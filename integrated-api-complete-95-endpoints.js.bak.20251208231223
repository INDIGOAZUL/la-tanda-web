const http = require('http');
const url = require('url');
const crypto = require('crypto');
const bcrypt = require('bcrypt');
// const formidable = require('formidable'); // Not needed - using manual parsing
const dns = require("dns").promises;
const nodemailer = require("nodemailer");

// Tesseract OCR for payment verification
const Tesseract = require("tesseract.js");

// Payment accounts for OCR verification
const PAYMENT_ACCOUNTS = {
    bank_transfer: {
        bank_name: "Banco Atlántida",
        account_number: "30613012837",
        account_variants: ["30613012837", "3061-301-2837", "3061 301 2837"],
        account_holder: "La Tanda Chain S.A.",
        holder_variants: ["LA TANDA", "TANDA CHAIN", "LA TANDA CHAIN"]
    },
    mobile_money: {
        phone: "+50494485859",
        phone_variants: ["94485859", "50494485859", "+50494485859", "9448-5859", "9448 5859"],
        name: "Narjell Ramon Ebanks Martinez",
        name_variants: ["NARJELL", "EBANKS", "MARTINEZ", "NARJELL RAMON", "EBANKS MARTINEZ"]
    },
    crypto: {
        address: "0x58EA31ceba1B3DeFacB06A5B7fc7408656b91bf7",
        address_short: "0x58EA31",
        address_end: "91bf7"
    }
};


// Email configuration - Gmail SMTP
const emailTransporter = nodemailer.createTransport({

    service: "gmail",
    auth: {
        user: "ebanksnigel@gmail.com",
        pass: "ptyy hugy ldji pbsw"
    }
});

// Email senders by type
const EMAIL_SENDERS = {
    // Seguridad y autenticación
    security: "La Tanda Security <security@latanda.online>",
    
    // Transacciones y pagos
    pagos: "La Tanda Pagos <pagos@latanda.online>",
    
    // Notificaciones automáticas
    notificaciones: "La Tanda <notificaciones@latanda.online>",
    noreply: "La Tanda <noreply@latanda.online>",
    
    // Comunicaciones del equipo
    team: "Equipo La Tanda <team@latanda.online>",
    admin: "Admin La Tanda <admin@latanda.online>",
    
    // Soporte y contacto
    soporte: "Soporte La Tanda <soporte@latanda.online>",
    info: "La Tanda <info@latanda.online>",
    hola: "La Tanda <hola@latanda.online>",
    
    // Beta testers
    beta: "La Tanda Beta <beta@latanda.online>"
};

// Send email function with sender type
async function sendEmail(to, subject, htmlContent, senderType) {
    try {
        const from = EMAIL_SENDERS[senderType] || EMAIL_SENDERS.security;
        const mailOptions = {
            from: from,
            to: to,
            subject: subject,
            html: htmlContent
        };
        const result = await emailTransporter.sendMail(mailOptions);
        console.log("Email sent to:", to, "from:", from);
        return { success: true, messageId: result.messageId };
    } catch (error) {
        console.error("Email error:", error.message);
        return { success: false, error: error.message };
    }
}

const hostname = '0.0.0.0';
const port = process.env.PORT || 3002;

// Create logs directory
const fs = require('fs');
const path = require('path');
// ============================================
// POSTGRESQL INTEGRATION - Phase 1: READ operations
// Date: 2025-11-14
// ============================================
const db = require('./db-unified.js');
const dbHelpers = require("./db-helpers-groups");
const dbPostgres = require('./db-postgres.js');
const exportUtils = require('./export-utils.js');
const notificationsUtils = require('./notifications-utils.js');

// Keep legacy database object for non-migrated collections

const logsDir = path.join(__dirname, 'logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

// Enhanced logging
const log = (level, message, data = {}) => {
  const timestamp = new Date().toISOString();
  const logEntry = { timestamp, level, message, ...data };
  console.log(`[${timestamp}] ${level.toUpperCase()}: ${message}`);
  
  const logFile = path.join(logsDir, 'api.log');
  fs.appendFileSync(logFile, JSON.stringify(logEntry) + '\n');
};

// Database persistence functions
const dbFile = path.join(__dirname, 'database.json');

const saveDatabase = () => {
  try {
    fs.writeFileSync(dbFile, JSON.stringify(database, null, 2));
    log('info', 'Database saved to disk');
  } catch (error) {
    log('error', 'Failed to save database', { error: error.message });
  }
};

const loadDatabase = () => {
  try {
    if (fs.existsSync(dbFile)) {
      const data = fs.readFileSync(dbFile, 'utf8');
      const loadedData = JSON.parse(data);
      
      // Merge with existing structure, preserving tanda fields in groups
      Object.keys(loadedData).forEach(key => {
        if (key === 'groups' && loadedData.groups && database.groups) {
          // Merge groups preserving tanda fields from hardcoded data
          loadedData.groups.forEach((loadedGroup, idx) => {
            const hardcodedGroup = database.groups.find(g => g.id === loadedGroup.id);
            if (hardcodedGroup && hardcodedGroup.is_tanda) {
              // Preserve tanda fields from hardcoded data
              loadedGroup.is_tanda = hardcodedGroup.is_tanda;
              loadedGroup.tanda_type = hardcodedGroup.tanda_type;
              loadedGroup.current_turn = hardcodedGroup.current_turn;
              loadedGroup.total_turns = hardcodedGroup.total_turns;
              loadedGroup.payment_frequency = hardcodedGroup.payment_frequency;
              loadedGroup.next_payment_date = hardcodedGroup.next_payment_date;
              loadedGroup.current_collector_id = hardcodedGroup.current_collector_id;
              loadedGroup.members = hardcodedGroup.members;
              loadedGroup.contribution_amount = hardcodedGroup.contribution_amount;
            }
          });
          database.groups = loadedData.groups;
        } else {
          database[key] = loadedData[key];
        }
      });
      
      log('info', 'Database loaded from disk', { 
        deposits: database.deposits?.length || 0,
        users: database.users?.length || 0,
        groups: database.groups?.length || 0,
        groups_with_tanda: database.groups?.filter(g => g.is_tanda)?.length || 0,
        first_group_is_tanda: database.groups?.[0]?.is_tanda
      });
    }
  } catch (error) {
    log('error', 'Failed to load database', { error: error.message });
  }
};

// Auto-save every 5 minutes and on process exit
setInterval(saveDatabase, 5 * 60 * 1000); // 5 minutes
process.on('SIGINT', () => {
  saveDatabase();
  process.exit(0);
});
process.on('SIGTERM', () => {
  saveDatabase();
  process.exit(0);
});

// Transaction State Management System
class TransactionStateManager {
    constructor() {
        this.states = {
            'pending': 'Esperando confirmación bancaria',
            'pending_transfer': 'Esperando que realices la transferencia',
            'processing': 'Comprobante recibido - En revisión administrativa',
            'confirmed': 'Confirmado y completado',
            'cancelled': 'Cancelado por el usuario',
            'failed': 'Falló la verificación',
            'expired': 'Expiró el tiempo límite'
        };
        
        this.validTransitions = {
            'pending': ['processing', 'cancelled', 'expired'],
            'pending_transfer': ['processing', 'cancelled', 'expired', 'confirmed', 'failed'], // Admin can confirm or reject directly
            'processing': ['confirmed', 'failed', 'cancelled'],
            'confirmed': [], // Final state
            'cancelled': [], // Final state
            'failed': ['pending', 'pending_transfer'], // Can retry
            'expired': ['pending', 'pending_transfer'] // Can retry
        };
    }
    
    isValidTransition(currentState, newState) {
        return this.validTransitions[currentState]?.includes(newState) || false;
    }
    
    getStateDescription(state) {
        return this.states[state] || 'Estado desconocido';
    }
    
    updateTransactionState(transactionId, newState, reason = '') {
        const transaction = database.deposits?.find(d => d.id === transactionId);
        if (!transaction) {
            return { success: false, error: 'Transacción no encontrada' };
        }
        
        if (!this.isValidTransition(transaction.status, newState)) {
            return { 
                success: false, 
                error: `Transición inválida de ${transaction.status} a ${newState}` 
            };
        }
        
        // Update transaction state
        transaction.status = newState;
        transaction.status_history = transaction.status_history || [];
        transaction.status_history.push({
            from: transaction.status,
            to: newState,
            reason: reason,
            timestamp: new Date().toISOString(),
            updated_by: 'system'
        });
        
        // Set expiration times based on state
        if (newState === 'pending') {
            transaction.expires_at = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(); // 24 hours
        } else if (newState === 'processing') {
            transaction.expires_at = new Date(Date.now() + 4 * 60 * 60 * 1000).toISOString(); // 4 hours
        }
        
        log('info', `Transaction ${transactionId} state updated`, {
            transactionId,
            oldState: transaction.status,
            newState,
            reason
        });
        
        return { 
            success: true, 
            newState: newState,
            description: this.getStateDescription(newState),
            expiresAt: transaction.expires_at
        };
    }
}

// Initialize transaction state manager
const transactionManager = new TransactionStateManager();

// Helper functions for transaction management
function getNextActionsForStatus(status) {
    const actions = {
        'pending': [
            'Realiza la transferencia bancaria según las instrucciones',
            'Conserva el comprobante de transferencia',
            'El sistema verificará automáticamente en 24 horas'
        ],
        'pending_transfer': [
            'Realiza la transferencia bancaria según las instrucciones proporcionadas',
            'Usa exactamente la referencia indicada: es obligatoria',
            'Guarda el comprobante - verificación automática en 2-4 horas'
        ],
        'processing': [
            'Tu transferencia está siendo verificada',
            'No se requiere acción adicional',
            'Recibirás notificación cuando se complete'
        ],
        'confirmed': [
            'Transacción completada exitosamente',
            'El saldo está disponible en tu cuenta'
        ],
        'cancelled': [
            'Transacción cancelada',
            'Puedes intentar un nuevo depósito si deseas'
        ],
        'failed': [
            'La verificación falló',
            'Verifica los datos bancarios',
            'Contacta soporte si persiste el problema'
        ],
        'expired': [
            'La transacción expiró',
            'Puedes crear un nuevo depósito',
            'Las instrucciones de transferencia ya no son válidas'
        ]
    };
    
    return actions[status] || ['Estado desconocido - contacta soporte'];
}

function getStatusSummary(transactions) {
    const summary = {
        pending: 0,
        pending_transfer: 0,
        processing: 0,
        confirmed: 0,
        cancelled: 0,
        failed: 0,
        expired: 0
    };
    
    transactions.forEach(t => {
        if (summary.hasOwnProperty(t.status)) {
            summary[t.status]++;
        }
    });
    
    return summary;
}

// Enhanced database with comprehensive mobile app data
const database = {
    // Groups data
    groups: [
        {
            id: 'group_001',
            name: 'Grupo Ahorro Familiar',
            contribution_amount: 2000,
            frequency: 'monthly',
            member_count: 6,
            max_members: 12,
            total_amount_collected: 3000.00,
            admin_name: 'Juan Pérez',
            admin_id: 'user_001',
            status: 'active',
            created_at: '2025-01-01T00:00:00Z',
            location: 'Tegucigalpa',
            description: 'Tanda familiar mensual',
            image_url: 'https://storage.latanda.online/groups/group_001.jpg',
            category: 'family',
            meeting_schedule: 'Sábados 2:00 PM',
            // TANDA fields
            is_tanda: true,
            tanda_type: 'mensual',
            current_turn: 2,
            total_turns: 6,
            payment_frequency: 'monthly',
            next_payment_date: '2025-12-05',
            current_collector_id: 'user_002',
            members: [
                { user_id: 'user_001', name: 'Juan Pérez', position: 1, payments_made: 2, total_paid: 4000, status: 'active' },
                { user_id: 'user_002', name: 'María González', position: 2, payments_made: 2, total_paid: 4000, status: 'active' },
                { user_id: 'user_003', name: 'Carlos López', position: 3, payments_made: 1, total_paid: 2000, status: 'active' },
                { user_id: 'user_004', name: 'Ana Martínez', position: 4, payments_made: 1, total_paid: 2000, status: 'active' },
                { user_id: 'user_005', name: 'Pedro Sánchez', position: 5, payments_made: 1, total_paid: 2000, status: 'active' },
                { user_id: 'user_006', name: 'Laura Torres', position: 6, payments_made: 1, total_paid: 2000, status: 'active' }
            ]
        },
        {
            id: 'group_002',
            name: 'Emprendedores Unidos',
            contribution_amount: 500.00,
            frequency: 'biweekly',
            member_count: 8,
            max_members: 15,
            total_amount_collected: 12000.00,
            admin_name: 'María González',
            admin_id: 'user_002',
            status: 'active',
            created_at: '2025-01-15T00:00:00Z',
            location: 'San Pedro Sula',
            description: 'Grupo de emprendedores para inversión',
            image_url: 'https://storage.latanda.online/groups/group_002.jpg',
            category: 'business',
            meeting_schedule: 'Jueves 6:00 PM'
        }
    ],

    // Users data with mobile app fields
    users: [
        {
            id: 'user_001',
            telegram_id: '123456789',
            name: 'Juan Pérez',
            email: 'juan@example.com',
            phone: '+50498765432',
            verification_level: 'advanced',
            registration_date: '2025-01-01T00:00:00Z',
            status: 'active',
            groups: ['group_001'],
            total_contributions: 1800.00,
            payment_methods: ['bank_transfer', 'tigo_money'],
            // Mobile app specific fields
            avatar_url: 'https://storage.latanda.online/avatars/user_001.jpg',
            push_token: 'fcm_token_123456',
            app_version: '1.0.0',
            device_type: 'android',
            last_app_access: '2025-07-24T14:30:00Z',
            notification_preferences: {
                payment_reminders: true,
                group_updates: true,
                marketing: false,
                push_enabled: true
            },
            app_settings: {
                theme: 'light',
                language: 'es',
                biometric_enabled: false,
                auto_backup: true
            }
        },
        {
            id: 'user_002',
            telegram_id: '987654321',
            name: 'María González',
            email: 'maria@example.com',
            phone: '+50487654321',
            verification_level: 'intermediate',
            registration_date: '2025-01-10T00:00:00Z',
            status: 'active',
            groups: ['group_002'],
            total_contributions: 4000.00,
            payment_methods: ['claro_money', 'cash'],
            avatar_url: 'https://storage.latanda.online/avatars/user_002.jpg',
            push_token: 'fcm_token_789012',
            app_version: '1.0.0',
            device_type: 'ios',
            last_app_access: '2025-07-24T13:15:00Z',
            notification_preferences: {
                payment_reminders: true,
                group_updates: true,
                marketing: true,
                push_enabled: true
            },
            app_settings: {
                theme: 'dark',
                language: 'es',
                biometric_enabled: true,
                auto_backup: true
            }
        }
    ],

    // Payments data with mobile receipts
    payments: [
        {
            id: 'payment_001',
            user_id: 'user_001',
            group_id: 'group_001',
            amount: 100.00,
            method: 'bank_transfer',
            status: 'completed',
            transaction_date: '2025-07-20T10:00:00Z',
            receipt_url: 'https://storage.latanda.online/receipts/payment_001.jpg',
            confirmation_code: 'CONF123456',
            processing_time: 1800, // seconds
            fees: 0.00,
            mobile_uploaded: true
        },
        {
            id: 'payment_002',
            user_id: 'user_002',
            group_id: 'group_002',
            amount: 500.00,
            method: 'tigo_money',
            status: 'pending',
            transaction_date: '2025-07-24T14:30:00Z',
            receipt_url: null,
            confirmation_code: null,
            processing_time: null,
            fees: 10.00,
            mobile_uploaded: false
        }
    ],

    // Verifications with mobile documents
    verifications: [
        {
            id: 'verify_001',
            user_id: 'user_001',
            type: 'identity',
            status: 'approved',
            documents: ['id_front.jpg', 'id_back.jpg', 'selfie.jpg'],
            verified_at: '2025-01-02T00:00:00Z',
            verification_level: 'advanced',
            mobile_captured: true,
            ai_confidence: 0.98
        }
    ],

    // Notifications with mobile push data
    notifications: [
        {
            id: 'notif_001',
            user_id: 'user_001',
            type: 'payment_reminder',
            title: 'Recordatorio de Pago',
            message: 'Tu contribución semanal vence mañana',
            sent_at: '2025-07-23T09:00:00Z',
            status: 'sent',
            channels: ['push', 'email'],
            push_delivered: true,
            opened: false,
            action_taken: false
        }
    ],

    // Mobile app sessions
    app_sessions: [
        {
            id: 'session_001',
            user_id: 'user_001',
            start_time: '2025-07-24T14:00:00Z',
            end_time: '2025-07-24T14:25:00Z',
            duration: 1500, // seconds
            screens_visited: ['Home', 'Groups', 'Payments'],
            actions_performed: 5,
            device_info: {
                os: 'Android 14',
                app_version: '1.0.0',
                device_model: 'Samsung Galaxy S23'
            }
        }
    ],

    // Offline sync data
    sync_data: [
        {
            id: 'sync_001',
            user_id: 'user_001',
            data_type: 'user_profile',
            last_sync: '2025-07-24T14:00:00Z',
            pending_changes: false,
            conflict_resolution: 'server_wins'
        }
    ],

    // MIA chat conversations
    mia_conversations: [
        {
            id: 'conv_001',
            user_id: 'user_001',
            messages: [
                {
                    id: 'msg_001',
                    sender: 'mia',
                    content: '¡Hola! Soy MIA, ¿en qué puedo ayudarte?',
                    timestamp: '2025-07-24T14:00:00Z'
                },
                {
                    id: 'msg_002',
                    sender: 'user',
                    content: '¿Cómo puedo unirme a un grupo?',
                    timestamp: '2025-07-24T14:01:00Z'
                }
            ],
            context: {
                current_screen: 'Groups',
                user_intent: 'group_registration'
            },
            status: 'active'
        }
    ]
};

// Utility functions
function generateId(prefix) {
    return `${prefix}_${crypto.randomBytes(8).toString('hex')}`;
}

function createResponse(success, data, meta = {}) {
    return {
        success,
        data,
        meta: {
            timestamp: new Date().toISOString(),
            version: '2.0.0',
            server: 'production-168.231.67.201',
            environment: 'production',
            ...meta
        }
    };
}

function sendResponse(res, statusCode, data) {
    res.statusCode = statusCode;
    res.setHeader('Content-Type', 'application/json');
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.end(JSON.stringify(data, null, 2));
}

function sendError(res, statusCode, message, details = null) {
    const error = createResponse(false, {
        error: {
            code: statusCode,
            message: message,
            details: details,
            timestamp: new Date().toISOString()
        }
    });
    sendResponse(res, statusCode, error);
}

function sendSuccess(res, data, meta = {}) {
    const response = createResponse(true, data, meta);
    sendResponse(res, 200, response);
}

// Parse request body
function parseBody(req) {
    return new Promise((resolve, reject) => {
        let body = "";
        req.on("data", chunk => {
            body += chunk.toString();
        });
        req.on("end", () => {
            try {
                if (!body || body.trim() === "") {
                    resolve({});
                    return;
                }
                const parsed = JSON.parse(body);
                resolve(parsed);
            } catch (error) {
                console.warn(`[WARNING] JSON parse failed: ${error.message}`);
                resolve({});
            }
        });
    });
}


// ============================================
// EMAIL MX RECORD VALIDATION
// Verifies that the email domain has valid mail servers
// ============================================
async function verifyEmailDomain(email) {
    try {
        const domain = email.split("@")[1];
        if (!domain) {
            return { valid: false, reason: "Formato de email inválido" };
        }
        
        // List of known disposable/temporary email domains to block
        const disposableDomains = [
            "tempmail.com", "throwaway.email", "guerrillamail.com", 
            "mailinator.com", "10minutemail.com", "temp-mail.org",
            "fakeinbox.com", "trashmail.com", "maildrop.cc"
        ];
        
        if (disposableDomains.includes(domain.toLowerCase())) {
            return { valid: false, reason: "No se permiten emails temporales" };
        }
        
        // Check MX records
        const mxRecords = await dns.resolveMx(domain);
        
        if (!mxRecords || mxRecords.length === 0) {
            return { valid: false, reason: "El dominio del email no tiene servidor de correo" };
        }
        
        return { valid: true, mxRecords: mxRecords.length };
    } catch (error) {
        // ENOTFOUND = domain doesnt exist
        // ENODATA = no MX records
        if (error.code === "ENOTFOUND" || error.code === "ENODATA") {
            return { valid: false, reason: "El dominio del email no existe o no puede recibir correos" };
        }
        // For other errors (network issues), allow registration but log warning
        console.warn("[MX CHECK] Warning - could not verify domain:", error.message);
        return { valid: true, warning: "No se pudo verificar el dominio" };
    }
}
let requestCount = 0;
const startTime = Date.now();

// Main server

// =============================================================================
// POSITION SELECTION & ASSIGNMENT - HELPER FUNCTIONS (10 ENDPOINTS)
// =============================================================================

// HELPER FUNCTIONS
// =============================================================================

/**
 * Genera ID único para solicitudes de posición
 */
function generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Verifica si una posición está disponible
 */
function isPositionAvailable(group, position) {
    if (!group.positions) {
        group.positions = [];
    }

    const existingPosition = group.positions.find(p => p.position === position);
    return !existingPosition || existingPosition.status !== 'confirmed';
}

/**
 * Obtiene posiciones sin asignar
 */
function getUnassignedPositions(group) {
    const assignedPositions = (group.positions || [])
        .filter(p => p.status === 'confirmed')
        .map(p => p.position);

    const allPositions = Array.from({ length: group.participant_count }, (_, i) => i + 1);
    return allPositions.filter(pos => !assignedPositions.includes(pos));
}

/**
 * Obtiene usuarios sin posición asignada
 */
function getUsersWithoutPosition(group) {
    if (!group.members || !group.positions) {
        return group.members || [];
    }

    const usersWithPosition = group.positions
        .filter(p => p.status === 'confirmed')
        .map(p => p.user_id);

    return group.members.filter(m => !usersWithPosition.includes(m.user_id));
}

// =============================================================================
// ENDPOINTS - PARA PARTICIPANTES (Tab Tandas)
// =============================================================================

// 1. GET /api/tandas/available-positions
// Obtener posiciones disponibles en un grupo
function handleGetAvailablePositions(req, res, query, database) {
    try {
        const { group_id } = query;

        if (!group_id) {
            sendError(res, 400, 'group_id es requerido');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        // Inicializar arrays si no existen
        if (!group.positions) group.positions = [];
        if (!group.position_requests) group.position_requests = [];

        // Construir array de posiciones con su estado
        const positions = [];
        for (let i = 1; i <= group.participant_count; i++) {
            const confirmedPosition = group.positions.find(p => p.position === i && p.status === 'confirmed');
            const pendingRequest = group.position_requests.find(r => r.requested_position === i && r.status === 'pending');

            let status = 'available';
            if (confirmedPosition) {
                status = 'confirmed';
            } else if (pendingRequest) {
                status = 'requested';
            }

            positions.push({
                position: i,
                status: status,
                isAvailable: status !== 'confirmed',
                hasRequest: status === 'requested'
            });
        }

        const positionsConfirmed = group.positions.filter(p => p.status === 'confirmed').length;
        const canActivate = positionsConfirmed === group.participant_count;

        sendSuccess(res, {
            group_id: group_id,
            participant_count: group.participant_count,
            positions: positions,
            positions_assigned: positionsConfirmed,
            can_activate: canActivate
        });

        log('info', 'Available positions retrieved', { group_id });
    } catch (error) {
        log('error', 'Error getting available positions', { error: error.message });
        sendError(res, 500, 'Error al obtener posiciones disponibles');
    }
}

// 2. POST /api/tandas/request-position
// Solicitar una posición específica
function handleRequestPosition(req, res, body, database) {
    try {
        const { group_id, user_id, user_name, position, reason } = body;

        if (!group_id || !user_id || !position) {
            sendError(res, 400, 'group_id, user_id y position son requeridos');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        // Inicializar arrays
        if (!group.positions) group.positions = [];
        if (!group.position_requests) group.position_requests = [];

        // Validar rango de posición
        if (position < 1 || position > group.participant_count) {
            sendError(res, 400, `Posición debe estar entre 1 y ${group.participant_count}`);
            return;
        }

        // Verificar si la posición está disponible
        if (!isPositionAvailable(group, position)) {
            sendError(res, 400, 'Esta posición ya está asignada');
            return;
        }

        // Verificar si el usuario ya tiene una solicitud pendiente
        const existingRequest = group.position_requests.find(r =>
            r.user_id === user_id && r.status === 'pending'
        );

        if (existingRequest) {
            sendError(res, 400, 'Ya tienes una solicitud pendiente. Cámbiala en lugar de crear una nueva.');
            return;
        }

        // Crear solicitud
        const request = {
            id: generateRequestId(),
            user_id: user_id,
            user_name: user_name || 'Usuario',
            requested_position: position,
            reason: reason || '',
            status: 'pending',
            created_at: new Date().toISOString(),
            approved_by: null,
            approved_at: null,
            rejected_by: null,
            rejected_at: null,
            rejection_reason: null
        };

        group.position_requests.push(request);

        // Crear posición temporal (pending)
        group.positions.push({
            position: position,
            user_id: null,
            user_name: null,
            assignment_type: null,
            requested_by: user_id,
            requested_at: new Date().toISOString(),
            approved_by: null,
            approved_at: null,
            status: 'pending',
            request_id: request.id
        });

        saveDatabase();

        sendSuccess(res, {
            message: 'Solicitud enviada exitosamente',
            request: request
        });

        log('info', 'Position request created', { group_id, user_id, position, request_id: request.id });
    } catch (error) {
        log('error', 'Error creating position request', { error: error.message });
        sendError(res, 500, 'Error al crear solicitud de posición');
    }
}

// 3. PUT /api/tandas/change-position-request
// Cambiar una solicitud de posición existente
function handleChangePositionRequest(req, res, body, database) {
    try {
        const { request_id, new_position, new_reason } = body;

        if (!request_id || !new_position) {
            sendError(res, 400, 'request_id y new_position son requeridos');
            return;
        }

        // Buscar la solicitud en todos los grupos
        let foundGroup = null;
        let foundRequest = null;

        for (const group of (database.groups || [])) {
            if (!group.position_requests) continue;

            const request = group.position_requests.find(r => r.id === request_id);
            if (request) {
                foundGroup = group;
                foundRequest = request;
                break;
            }
        }

        if (!foundRequest) {
            sendError(res, 404, 'Solicitud no encontrada');
            return;
        }

        if (foundRequest.status !== 'pending') {
            sendError(res, 400, 'Solo puedes cambiar solicitudes pendientes');
            return;
        }

        // Validar nueva posición
        if (new_position < 1 || new_position > foundGroup.participant_count) {
            sendError(res, 400, `Posición debe estar entre 1 y ${foundGroup.participant_count}`);
            return;
        }

        // Verificar si nueva posición está disponible
        if (!isPositionAvailable(foundGroup, new_position)) {
            sendError(res, 400, 'La nueva posición ya está asignada');
            return;
        }

        // Eliminar posición temporal anterior
        foundGroup.positions = foundGroup.positions.filter(p => p.request_id !== request_id);

        // Actualizar solicitud
        foundRequest.requested_position = new_position;
        if (new_reason !== undefined) {
            foundRequest.reason = new_reason;
        }
        foundRequest.updated_at = new Date().toISOString();

        // Crear nueva posición temporal
        foundGroup.positions.push({
            position: new_position,
            user_id: null,
            user_name: null,
            assignment_type: null,
            requested_by: foundRequest.user_id,
            requested_at: new Date().toISOString(),
            approved_by: null,
            approved_at: null,
            status: 'pending',
            request_id: request_id
        });

        saveDatabase();

        sendSuccess(res, {
            message: 'Solicitud actualizada exitosamente',
            request: {
                id: foundRequest.id,
                requested_position: foundRequest.requested_position,
                reason: foundRequest.reason,
                updated_at: foundRequest.updated_at
            }
        });

        log('info', 'Position request updated', { request_id, new_position });
    } catch (error) {
        log('error', 'Error updating position request', { error: error.message });
        sendError(res, 500, 'Error al actualizar solicitud de posición');
    }
}

// 4. GET /api/tandas/my-position-status
// Ver el estado de mi solicitud/posición
function handleGetMyPositionStatus(req, res, query, database) {
    try {
        const { group_id, user_id } = query;

        if (!group_id || !user_id) {
            sendError(res, 400, 'group_id y user_id son requeridos');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        // Inicializar arrays
        if (!group.positions) group.positions = [];
        if (!group.position_requests) group.position_requests = [];

        // Buscar solicitud del usuario
        const userRequest = group.position_requests.find(r => r.user_id === user_id);

        // Buscar posición confirmada
        const confirmedPosition = group.positions.find(p =>
            p.user_id === user_id && p.status === 'confirmed'
        );

        sendSuccess(res, {
            group_id: group_id,
            user_id: user_id,
            has_request: !!userRequest,
            request: userRequest ? {
                id: userRequest.id,
                requested_position: userRequest.requested_position,
                status: userRequest.status,
                reason: userRequest.reason,
                created_at: userRequest.created_at,
                rejection_reason: userRequest.rejection_reason
            } : null,
            has_confirmed_position: !!confirmedPosition,
            confirmed_position: confirmedPosition ? confirmedPosition.position : null,
            group_status: group.status
        });

        log('info', 'Position status retrieved', { group_id, user_id });
    } catch (error) {
        log('error', 'Error getting position status', { error: error.message });
        sendError(res, 500, 'Error al obtener estado de posición');
    }
}

// =============================================================================
// ENDPOINTS - PARA COORDINADORES (Tab My Groups)
// =============================================================================

// 5. GET /api/groups/position-requests
// Ver todas las solicitudes pendientes
function handleGetPositionRequests(req, res, query, database) {
    try {
        const { group_id } = query;

        if (!group_id) {
            sendError(res, 400, 'group_id es requerido');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        // Inicializar arrays
        if (!group.position_requests) group.position_requests = [];
        if (!group.positions) group.positions = [];

        const pendingRequests = group.position_requests.filter(r => r.status === 'pending');
        const assignedPositions = group.positions.filter(p => p.status === 'confirmed').length;

        sendSuccess(res, {
            group_id: group_id,
            group_name: group.name,
            requests: pendingRequests,
            total_positions: group.participant_count,
            assigned_positions: assignedPositions,
            pending_requests: pendingRequests.length
        });

        log('info', 'Position requests retrieved', { group_id, pending_count: pendingRequests.length });
    } catch (error) {
        log('error', 'Error getting position requests', { error: error.message });
        sendError(res, 500, 'Error al obtener solicitudes de posición');
    }
}

// 6. POST /api/groups/approve-position-request
// Aprobar una solicitud de posición
function handleApprovePositionRequest(req, res, body, database) {
    try {
        const { request_id, group_id, coordinator_id } = body;

        if (!request_id || !group_id) {
            sendError(res, 400, 'request_id y group_id son requeridos');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        if (!group.position_requests) group.position_requests = [];
        if (!group.positions) group.positions = [];

        const request = group.position_requests.find(r => r.id === request_id);
        if (!request) {
            sendError(res, 404, 'Solicitud no encontrada');
            return;
        }

        if (request.status !== 'pending') {
            sendError(res, 400, 'Solo se pueden aprobar solicitudes pendientes');
            return;
        }

        // Verificar que la posición aún esté disponible
        if (!isPositionAvailable(group, request.requested_position)) {
            sendError(res, 400, 'La posición solicitada ya no está disponible');
            return;
        }

        // Actualizar solicitud
        request.status = 'approved';
        request.approved_by = coordinator_id;
        request.approved_at = new Date().toISOString();

        // Actualizar o crear posición confirmada
        const existingPosition = group.positions.find(p => p.request_id === request_id);
        if (existingPosition) {
            existingPosition.user_id = request.user_id;
            existingPosition.user_name = request.user_name;
            existingPosition.assignment_type = 'approved';
            existingPosition.approved_by = coordinator_id;
            existingPosition.approved_at = new Date().toISOString();
            existingPosition.status = 'confirmed';
        } else {
            group.positions.push({
                position: request.requested_position,
                user_id: request.user_id,
                user_name: request.user_name,
                assignment_type: 'approved',
                requested_by: request.user_id,
                requested_at: request.created_at,
                approved_by: coordinator_id,
                approved_at: new Date().toISOString(),
                status: 'confirmed',
                request_id: request_id
            });
        }

        saveDatabase();

        sendSuccess(res, {
            message: 'Solicitud aprobada exitosamente',
            request: {
                id: request.id,
                status: request.status,
                approved_by: request.approved_by,
                approved_at: request.approved_at
            },
            position: {
                position: request.requested_position,
                user_id: request.user_id,
                user_name: request.user_name,
                status: 'confirmed',
                assignment_type: 'approved'
            }
        });

        log('info', 'Position request approved', { request_id, group_id, position: request.requested_position });
    } catch (error) {
        log('error', 'Error approving position request', { error: error.message });
        sendError(res, 500, 'Error al aprobar solicitud de posición');
    }
}

// 7. POST /api/groups/reject-position-request
// Rechazar una solicitud de posición
function handleRejectPositionRequest(req, res, body, database) {
    try {
        const { request_id, reason, coordinator_id } = body;

        if (!request_id) {
            sendError(res, 400, 'request_id es requerido');
            return;
        }

        // Buscar solicitud en todos los grupos
        let foundGroup = null;
        let foundRequest = null;

        for (const group of (database.groups || [])) {
            if (!group.position_requests) continue;

            const request = group.position_requests.find(r => r.id === request_id);
            if (request) {
                foundGroup = group;
                foundRequest = request;
                break;
            }
        }

        if (!foundRequest) {
            sendError(res, 404, 'Solicitud no encontrada');
            return;
        }

        if (foundRequest.status !== 'pending') {
            sendError(res, 400, 'Solo se pueden rechazar solicitudes pendientes');
            return;
        }

        // Actualizar solicitud
        foundRequest.status = 'rejected';
        foundRequest.rejected_by = coordinator_id;
        foundRequest.rejected_at = new Date().toISOString();
        foundRequest.rejection_reason = reason || 'No especificado';

        // Eliminar posición temporal
        foundGroup.positions = foundGroup.positions.filter(p => p.request_id !== request_id);

        saveDatabase();

        sendSuccess(res, {
            message: 'Solicitud rechazada',
            request: {
                id: foundRequest.id,
                status: foundRequest.status,
                rejected_by: foundRequest.rejected_by,
                rejected_at: foundRequest.rejected_at,
                rejection_reason: foundRequest.rejection_reason
            }
        });

        log('info', 'Position request rejected', { request_id, reason });
    } catch (error) {
        log('error', 'Error rejecting position request', { error: error.message });
        sendError(res, 500, 'Error al rechazar solicitud de posición');
    }
}

// 8. POST /api/groups/assign-position-manually
// Asignar posición manualmente (sin solicitud)
function handleAssignPositionManually(req, res, body, database) {
    try {
        const { group_id, user_id, user_name, position, coordinator_id } = body;

        if (!group_id || !user_id || !position) {
            sendError(res, 400, 'group_id, user_id y position son requeridos');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        if (!group.positions) group.positions = [];

        // Validar posición
        if (position < 1 || position > group.participant_count) {
            sendError(res, 400, `Posición debe estar entre 1 y ${group.participant_count}`);
            return;
        }

        // Verificar disponibilidad
        if (!isPositionAvailable(group, position)) {
            sendError(res, 400, 'Esta posición ya está asignada');
            return;
        }

        // Crear posición confirmada
        group.positions.push({
            position: position,
            user_id: user_id,
            user_name: user_name || 'Usuario',
            assignment_type: 'manual',
            requested_by: null,
            requested_at: null,
            approved_by: coordinator_id,
            approved_at: new Date().toISOString(),
            status: 'confirmed',
            request_id: null
        });

        saveDatabase();

        sendSuccess(res, {
            message: 'Posición asignada exitosamente',
            position: {
                position: position,
                user_id: user_id,
                user_name: user_name,
                assignment_type: 'manual',
                status: 'confirmed'
            }
        });

        log('info', 'Position assigned manually', { group_id, user_id, position });
    } catch (error) {
        log('error', 'Error assigning position manually', { error: error.message });
        sendError(res, 500, 'Error al asignar posición manualmente');
    }
}

// 9. POST /api/groups/auto-assign-positions
// Asignar automáticamente posiciones restantes
function handleAutoAssignPositions(req, res, body, database) {
    try {
        const { group_id, method, coordinator_id } = body;

        if (!group_id) {
            sendError(res, 400, 'group_id es requerido');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        if (!group.positions) group.positions = [];
        if (!group.members) group.members = [];

        const usersWithoutPosition = getUsersWithoutPosition(group);
        const unassignedPositions = getUnassignedPositions(group);

        if (usersWithoutPosition.length === 0) {
            sendError(res, 400, 'Todos los usuarios ya tienen posición asignada');
            return;
        }

        if (unassignedPositions.length < usersWithoutPosition.length) {
            sendError(res, 400, 'No hay suficientes posiciones disponibles');
            return;
        }

        let assignmentMethod = method || 'random';
        let positionsToAssign = [...unassignedPositions];
        let usersToAssign = [...usersWithoutPosition];

        // Método de asignación
        if (assignmentMethod === 'random') {
            // Shuffle positions
            positionsToAssign.sort(() => Math.random() - 0.5);
        } else if (assignmentMethod === 'order') {
            // Ordenar usuarios por fecha de unión
            usersToAssign.sort((a, b) => new Date(a.joined_at) - new Date(b.joined_at));
            positionsToAssign.sort((a, b) => a - b);
        }

        // Asignar posiciones
        let assignedCount = 0;
        for (let i = 0; i < usersToAssign.length && i < positionsToAssign.length; i++) {
            const user = usersToAssign[i];
            const position = positionsToAssign[i];

            group.positions.push({
                position: position,
                user_id: user.user_id,
                user_name: user.name || user.user_name || 'Usuario',
                assignment_type: assignmentMethod === 'random' ? 'random' : 'auto',
                requested_by: null,
                requested_at: null,
                approved_by: coordinator_id,
                approved_at: new Date().toISOString(),
                status: 'confirmed',
                request_id: null
            });

            assignedCount++;
        }

        saveDatabase();

        sendSuccess(res, {
            message: `${assignedCount} posiciones asignadas automáticamente`,
            method: assignmentMethod,
            assigned_count: assignedCount,
            assignments: group.positions
                .filter(p => p.assignment_type === assignmentMethod || p.assignment_type === 'auto')
                .slice(-assignedCount)
        });

        log('info', 'Positions auto-assigned', { group_id, method: assignmentMethod, count: assignedCount });
    } catch (error) {
        log('error', 'Error auto-assigning positions', { error: error.message });
        sendError(res, 500, 'Error al asignar posiciones automáticamente');
    }
}

// 10. POST /api/groups/activate-tanda
// Activar el grupo (requiere todas posiciones asignadas)
function handleActivateTanda(req, res, body, database) {
    try {
        const { group_id, coordinator_id } = body;

        if (!group_id) {
            sendError(res, 400, 'group_id es requerido');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        if (!group.positions) group.positions = [];

        // Verificar que todas las posiciones estén asignadas
        const confirmedPositions = group.positions.filter(p => p.status === 'confirmed').length;

        if (confirmedPositions < group.participant_count) {
            sendError(res, 400, `No se puede activar. Faltan ${group.participant_count - confirmedPositions} posiciones por asignar`);
            return;
        }

        // Cambiar estado del grupo
        group.status = 'active';
        group.activated_at = new Date().toISOString();
        group.activated_by = coordinator_id;
        group.current_round = 1;

        // Generar payment_schedule basado en posiciones
        if (!group.payment_schedule) {
            group.payment_schedule = [];
        }

        const sortedPositions = [...group.positions]
            .filter(p => p.status === 'confirmed')
            .sort((a, b) => a.position - b.position);

        for (let i = 0; i < sortedPositions.length; i++) {
            const pos = sortedPositions[i];
            group.payment_schedule.push({
                round: i + 1,
                position: pos.position,
                beneficiary_id: pos.user_id,
                beneficiary_name: pos.user_name,
                amount: group.contribution_amount,
                due_date: calculateDueDate(group, i + 1),
                status: i === 0 ? 'current' : 'pending'
            });
        }

        saveDatabase();

        sendSuccess(res, {
            message: 'Tanda activada exitosamente',
            group: {
                id: group.id,
                name: group.name,
                status: group.status,
                current_round: group.current_round,
                activated_at: group.activated_at,
                payment_schedule_generated: true
            }
        });

        log('info', 'Tanda activated', { group_id, coordinator_id });
    } catch (error) {
        log('error', 'Error activating tanda', { error: error.message });
        sendError(res, 500, 'Error al activar tanda');
    }
}

/**
 * Helper: Calcular fecha de vencimiento para una ronda
 */
function calculateDueDate(group, round) {
    const startDate = new Date(group.activated_at || Date.now());
    const frequency = group.frequency || 'monthly';

    let daysToAdd = 0;
    switch (frequency) {
        case 'weekly':
            daysToAdd = (round - 1) * 7;
            break;
        case 'biweekly':
            daysToAdd = (round - 1) * 14;
            break;
        case 'monthly':
        default:
            daysToAdd = (round - 1) * 30;
            break;
    }

    const dueDate = new Date(startDate);
    dueDate.setDate(dueDate.getDate() + daysToAdd);
    return dueDate.toISOString();
}

// =============================================================================

const server = http.createServer(async (req, res) => {
    requestCount++;
    const parsedUrl = url.parse(req.url, true);
    const pathname = parsedUrl.pathname;
    const query = parsedUrl.query;
    const method = req.method;

    log('info', 'Request received', { method, pathname });

    console.log("DEBUG: All requests - method:", method, "pathname:", pathname);
    if (method === "OPTIONS") {        res.statusCode = 204;        res.setHeader("Access-Control-Allow-Origin", "*");        res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");        res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");        res.end();        return;    }


    // Handle contribution proof upload BEFORE general parsing
    if (pathname.match(/^\/api\/contributions\/[^/]+\/upload-proof$/) && method === 'POST') {
        const contributionId = pathname.split('/')[3];
        
        try {
            let chunks = [];

            req.on('data', (chunk) => {
                chunks.push(chunk);
            });

            req.on('end', async () => {
                try {
                    const buffer = Buffer.concat(chunks);
                    const bodyString = buffer.toString();
                    
                    // Extract contribution ID and user ID from multipart
                    let userId = null;
                    let fileName = 'proof.jpg';
                    
                    // Parse user_id from form data
                    const userIdMatch = bodyString.match(/name="user_id"[\r\n]+([^\r\n-]+)/);
                    if (userIdMatch) userId = userIdMatch[1].trim();
                    
                    // Parse filename from Content-Disposition
                    const filenameMatch = bodyString.match(/filename="([^"]+)"/);
                    if (filenameMatch) fileName = filenameMatch[1];
                    
                    // Validate contribution exists
                    const contribResult = await dbPostgres.pool.query(
                        'SELECT id, user_id, status, reference_code FROM contributions WHERE id = $1',
                        [contributionId]
                    );
                    
                    if (contribResult.rows.length === 0) {
                        sendError(res, 404, 'Contribucion no encontrada');
                        return;
                    }
                    
                    const contribution = contribResult.rows[0];
                    
                    // Only allow proof upload for awaiting_payment or pending status
                    if (!['awaiting_payment', 'pending', 'pending_verification'].includes(contribution.status)) {
                        sendError(res, 400, 'Solo se puede subir comprobante para pagos pendientes');
                        return;
                    }
                    
                    // Extract image data from multipart (using raw buffer)
                    const boundaryMatch = bodyString.match(/--[^\r\n]+/);
                    if (!boundaryMatch) {
                        sendError(res, 400, 'Formato de multipart inválido');
                        return;
                    }
                    const boundary = boundaryMatch[0];
                    
                    // Find image content in raw buffer
                    let imageBuffer = null;
                    const boundaryBuffer = Buffer.from(boundary);
                    let start = 0;
                    
                    while (start < buffer.length) {
                        const boundaryPos = buffer.indexOf(boundaryBuffer, start);
                        if (boundaryPos === -1) break;
                        
                        // Find headers end (\r\n\r\n)
                        const headersEnd = buffer.indexOf(Buffer.from('\r\n\r\n'), boundaryPos);
                        if (headersEnd === -1) {
                            start = boundaryPos + boundaryBuffer.length;
                            continue;
                        }
                        
                        const headerSection = buffer.slice(boundaryPos, headersEnd + 4).toString('utf8');
                        
                        // Check if this part contains an image
                        if (headerSection.includes('Content-Type: image/')) {
                            const contentStart = headersEnd + 4;
                            const nextBoundary = buffer.indexOf(boundaryBuffer, contentStart);
                            
                            if (nextBoundary !== -1) {
                                // Remove trailing \r\n before boundary
                                let contentEnd = nextBoundary - 2;
                                if (contentEnd > contentStart) {
                                    imageBuffer = buffer.slice(contentStart, contentEnd);
                                }
                            }
                            break;
                        }
                        
                        start = boundaryPos + boundaryBuffer.length;
                    }
                    
                    if (!imageBuffer || imageBuffer.length < 100) {
                        sendError(res, 400, 'No se pudo extraer la imagen del formulario');
                        return;
                    }
                    
                    // Create proofs directory if it doesn't exist
                    const proofsDir = path.join(__dirname, 'proofs');
                    if (!fs.existsSync(proofsDir)) {
                        fs.mkdirSync(proofsDir, { recursive: true });
                    }
                    
                    // Generate unique filename
                    const timestamp = Date.now();
                    const fileExt = path.extname(fileName) || '.jpg';
                    const finalFileName = 'proof_' + contributionId.substring(0, 8) + '_' + timestamp + fileExt;
                    const filePath = path.join(proofsDir, finalFileName);
                    
                    // Save file
                    fs.writeFileSync(filePath, imageBuffer);
                    
                    // Update contribution with proof URL and status
                    const proofUrl = '/api/proof/' + finalFileName;
                    await dbPostgres.pool.query(
                        'UPDATE contributions SET proof_url = $1, status = $2, updated_at = NOW() WHERE id = $3',
                        [proofUrl, 'pending_verification', contributionId]
                    );
                    
                    log('info', 'Contribution proof uploaded', { 
                        contribution_id: contributionId, 
                        proof_url: proofUrl,
                        file_size: imageBuffer.length
                    });
                    
                    // ========== AUTOMATIC OCR VERIFICATION ==========
                    let ocrResult = null;
                    try {
                        log('info', 'Starting automatic OCR verification', { contribution_id: contributionId });
                        
                        // Get full contribution details for OCR
                        const fullContrib = await dbPostgres.pool.query(
                            `SELECT c.id, c.amount, c.payment_method, c.reference_code, c.status
                             FROM contributions c WHERE c.id = $1`,
                            [contributionId]
                        );
                        
                        if (fullContrib.rows.length > 0) {
                            const contrib = fullContrib.rows[0];
                            
                            // Perform OCR on the saved image
                            const { data: { text } } = await Tesseract.recognize(filePath, 'spa', {
                                logger: m => {} // Suppress logs
                            });
                            
                            const extractedText = text.toUpperCase();
                            log('info', 'OCR text extracted', { contribution_id: contributionId, text_length: extractedText.length });
                            
                            // Verification results
                            let verification = {
                                account_match: false,
                                name_match: false,
                                reference_match: false,
                                amount_match: false,
                                confidence: 0,
                                matches: [],
                                mismatches: []
                            };
                            
                            const paymentMethod = contrib.payment_method;
                            const expectedAmount = parseFloat(contrib.amount);
                            const referenceCode = contrib.reference_code;
                            
                            // Check based on payment method
                            if (paymentMethod === 'bank_transfer') {
                                for (const variant of PAYMENT_ACCOUNTS.bank_transfer.account_variants) {
                                    if (extractedText.includes(variant.replace(/-/g, '').replace(/ /g, ''))) {
                                        verification.account_match = true;
                                        verification.matches.push('Cuenta: ' + variant);
                                        break;
                                    }
                                }
                                for (const variant of PAYMENT_ACCOUNTS.bank_transfer.holder_variants) {
                                    if (extractedText.includes(variant)) {
                                        verification.name_match = true;
                                        verification.matches.push('Titular: ' + variant);
                                        break;
                                    }
                                }
                            } else if (paymentMethod === 'mobile_money') {
                                for (const variant of PAYMENT_ACCOUNTS.mobile_money.phone_variants) {
                                    const cleanVariant = variant.replace(/[^0-9]/g, '');
                                    if (extractedText.replace(/[^0-9]/g, '').includes(cleanVariant)) {
                                        verification.account_match = true;
                                        verification.matches.push('Teléfono: ' + variant);
                                        break;
                                    }
                                }
                                for (const variant of PAYMENT_ACCOUNTS.mobile_money.name_variants) {
                                    if (extractedText.includes(variant)) {
                                        verification.name_match = true;
                                        verification.matches.push('Nombre: ' + variant);
                                        break;
                                    }
                                }
                            } else if (paymentMethod === 'crypto') {
                                if (extractedText.includes(PAYMENT_ACCOUNTS.crypto.address_short.toUpperCase()) ||
                                    extractedText.includes(PAYMENT_ACCOUNTS.crypto.address_end.toUpperCase())) {
                                    verification.account_match = true;
                                    verification.name_match = true;
                                    verification.matches.push('Dirección crypto');
                                }
                            }
                            
                            // Check reference code
                            if (referenceCode) {
                                const refClean = referenceCode.replace(/-/g, '').toUpperCase();
                                if (extractedText.includes(refClean) || extractedText.includes(referenceCode.toUpperCase())) {
                                    verification.reference_match = true;
                                    verification.matches.push('Referencia: ' + referenceCode);
                                }
                            }
                            
                            // Check amount
                            const amountRegex = /L\.?\s*([0-9,]+\.?[0-9]*)|([0-9,]+\.?[0-9]*)\s*L/g;
                            let amountMatch;
                            while ((amountMatch = amountRegex.exec(extractedText)) !== null) {
                                const foundAmount = parseFloat((amountMatch[1] || amountMatch[2]).replace(/,/g, ''));
                                if (!isNaN(foundAmount)) {
                                    const tolerance = expectedAmount * 0.05;
                                    if (Math.abs(foundAmount - expectedAmount) <= tolerance) {
                                        verification.amount_match = true;
                                        verification.matches.push('Monto: L. ' + foundAmount.toFixed(2));
                                        break;
                                    }
                                }
                            }
                            
                            // Calculate confidence
                            let matchCount = 0;
                            if (verification.account_match) matchCount++;
                            if (verification.name_match) matchCount++;
                            if (verification.reference_match) matchCount++;
                            if (verification.amount_match) matchCount++;
                            verification.confidence = matchCount / 4;
                            
                            // Auto-approve if confidence >= 75%
                            if (verification.confidence >= 0.75) {
                                await dbPostgres.pool.query(`
                                    UPDATE contributions
                                    SET status = 'completed',
                                        verified_at = NOW(),
                                        verified_by = 'ocr_auto',
                                        notes = $1,
                                        updated_at = NOW()
                                    WHERE id = $2
                                `, ['Verificado automáticamente por OCR. Coincidencias: ' + verification.matches.join(', '), contributionId]);
                                
                                log('info', 'Contribution AUTO-APPROVED by OCR', { 
                                    contribution_id: contributionId, 
                                    confidence: verification.confidence,
                                    matches: verification.matches
                                });
                                
                                ocrResult = {
                                    auto_approved: true,
                                    confidence: verification.confidence,
                                    matches: verification.matches,
                                    status: 'completed'
                                };
                            } else {
                                log('info', 'OCR verification incomplete, requires manual review', { 
                                    contribution_id: contributionId, 
                                    confidence: verification.confidence,
                                    matches: verification.matches
                                });
                                
                                ocrResult = {
                                    auto_approved: false,
                                    confidence: verification.confidence,
                                    matches: verification.matches,
                                    status: 'pending_verification'
                                };
                            }
                        }
                    } catch (ocrError) {
                        log('error', 'OCR verification failed', { 
                            contribution_id: contributionId, 
                            error: ocrError.message 
                        });
                        ocrResult = { error: ocrError.message, auto_approved: false };
                    }
                    // ========== END OCR VERIFICATION ==========
                    
                    sendSuccess(res, {
                        success: true,
                        data: {
                            contribution_id: contributionId,
                            proof_url: proofUrl,
                            status: ocrResult?.auto_approved ? 'completed' : 'pending_verification',
                            message: ocrResult?.auto_approved 
                                ? 'Comprobante verificado automáticamente' 
                                : 'Comprobante subido, pendiente de verificación',
                            ocr_verification: ocrResult
                        }
                    });
                    
                } catch (error) {
                    console.error('Error processing proof upload:', error);
                    sendError(res, 500, 'Error al procesar comprobante');
                }
            });
            
        } catch (error) {
            console.error('Error in proof upload:', error);
            sendError(res, 500, 'Error al subir comprobante');
        }
        return;
    }

    // Handle upload-receipt endpoint BEFORE general parsing to avoid JSON parsing multipart data
    if (pathname === '/api/deposit/upload-receipt' && method === 'POST') {
        try {
            // For simplified functionality, we'll parse the body manually
            let body = '';
            let chunks = [];

            req.on('data', (chunk) => {
                chunks.push(chunk);
            });

            req.on('end', async () => {
                try {
                    const buffer = Buffer.concat(chunks);
                    const bodyString = buffer.toString();
                    
                    // Extract basic form data from multipart
                    let depositId = null;
                    let userId = null;
                    let fileName = 'receipt.jpg';
                    let notes = '';

                    // Simple extraction of form fields
                    if (bodyString.includes('name="deposit_id"')) {
                        const depositMatch = bodyString.match(/name="deposit_id"[\s\S]*?\r\n\r\n([^\r\n]+)/);
                        if (depositMatch) depositId = depositMatch[1].trim();
                    }
                    
                    if (bodyString.includes('name="user_id"')) {
                        const userMatch = bodyString.match(/name="user_id"[\s\S]*?\r\n\r\n([^\r\n]+)/);
                        if (userMatch) userId = userMatch[1].trim();
                    }

                    if (bodyString.includes('name="notes"')) {
                        const notesMatch = bodyString.match(/name="notes"[\s\S]*?\r\n\r\n([^\r\n]+)/);
                        if (notesMatch) notes = notesMatch[1].trim();
                    }

                    if (bodyString.includes('filename=')) {
                        const filenameMatch = bodyString.match(/filename="([^"]+)"/);
                        if (filenameMatch) fileName = filenameMatch[1];
                    }

                    // Basic file validation
                    if (!fileName || fileName === '') {
                        sendError(res, 400, 'Archivo no encontrado');
                        return;
                    }

                    // Validate file extension
                    const allowedExtensions = ['.jpg', '.jpeg', '.png', '.webp', '.pdf'];
                    const fileExt = path.extname(fileName).toLowerCase();
                    if (!allowedExtensions.includes(fileExt)) {
                        sendError(res, 400, 'Formato de archivo no válido. Use: JPG, PNG, WebP, PDF');
                        return;
                    }

                    // Validate file size (basic check from buffer)
                    if (buffer.length > 5 * 1024 * 1024) { // 5MB
                        sendError(res, 400, 'Archivo muy grande. Máximo 5MB');
                        return;
                    }

                    if (buffer.length < 1000) { // Very small file, likely not a real image
                        sendError(res, 400, 'Archivo muy pequeño. Asegúrese de subir una imagen válida');
                        return;
                    }

                    if (!depositId || !userId) {
                        sendError(res, 400, 'deposit_id y user_id son requeridos');
                        return;
                    }

                    const deposit = database.deposits?.find(d => d.id === depositId);
                    if (!deposit) {
                        sendError(res, 404, 'Depósito no encontrado');
                        return;
                    }
                    
                    if (deposit.user_id !== userId) {
                        sendError(res, 403, 'No autorizado para este depósito');
                        return;
                    }
                    
                    if (deposit.status !== 'pending_transfer') {
                        sendError(res, 400, 'Solo se pueden subir comprobantes para depósitos pendientes');
                        return;
                    }

                    // Advanced security checks
                    const securityFlags = [];
                    
                    // Check for suspicious patterns
                    if (fileName.includes('screenshot') || fileName.includes('screen')) {
                        securityFlags.push('SCREENSHOT_DETECTED');
                    }
                    
                    if (fileName.includes('fake') || fileName.includes('test')) {
                        securityFlags.push('SUSPICIOUS_FILENAME');
                    }

                    // Check if file content looks like image headers
                    const imageHeaders = {
                        'jpeg': [0xFF, 0xD8, 0xFF],
                        'png': [0x89, 0x50, 0x4E, 0x47],
                        'webp': [0x52, 0x49, 0x46, 0x46]
                    };

                    let validImageHeader = false;
                    for (const [format, header] of Object.entries(imageHeaders)) {
                        if (header.every((byte, i) => buffer[i] === byte)) {
                            validImageHeader = true;
                            break;
                        }
                    }

                    if (!validImageHeader && fileExt !== '.pdf') {
                        securityFlags.push('INVALID_IMAGE_HEADER');
                    }

                    // Mark as receipt uploaded with security metadata
                    const timestamp = Date.now();
                    const finalFileName = `receipt_${depositId}_${timestamp}${fileExt}`;
                    
                    // Create receipts directory if it doesn't exist
                    const receiptsDir = path.join(__dirname, 'receipts');
                    if (!fs.existsSync(receiptsDir)) {
                        fs.mkdirSync(receiptsDir, { recursive: true });
                    }
                    // Save the uploaded file physically

                    // Extract the actual file data from multipart buffer
                    let imageBuffer = null;
                    
                    // Parse multipart boundary
                    const boundaryMatch = bodyString.match(/------WebKitFormBoundary[A-Za-z0-9]+/);
                    if (boundaryMatch) {
                        const boundary = boundaryMatch[0];
                        
                        // Find the file part (Content-Type: image or application)
                        const filePartRegex = new RegExp(boundary + '[\s\S]*?Content-Type:\s*(image|application)[\s\S]*?\r\n\r\n([\s\S]*?)\r\n' + boundary);
                        const filePartMatch = buffer.toString('binary').match(filePartRegex);
                        
                        if (filePartMatch) {
                            // Extract binary data after headers
                            const headerEndIndex = buffer.indexOf('\r\n\r\n');
                            if (headerEndIndex !== -1) {
                                const dataStartIndex = headerEndIndex + 4;
                                const nextBoundaryIndex = buffer.indexOf(boundary, dataStartIndex);
                                if (nextBoundaryIndex !== -1) {
                                    // Extract only the image bytes (exclude boundary)
                                    const imageEndIndex = nextBoundaryIndex - 2; // Remove \r\n before boundary
                                    imageBuffer = buffer.slice(dataStartIndex, imageEndIndex);
                                    
                                    console.log('DEBUG: Extracted image buffer size:', imageBuffer.length);
                                    console.log('DEBUG: Original buffer size:', buffer.length);
                                }
                            }
                        }
                    }
                    
                    // Fallback: try to find image markers directly in buffer
                    if (!imageBuffer) {
                        // Find start of actual image data by looking for image headers
                        const imageHeaders = [
                            [0xFF, 0xD8, 0xFF], // JPEG
                            [0x89, 0x50, 0x4E, 0x47], // PNG  
                            [0x52, 0x49, 0x46, 0x46], // WEBP
                        ];
                        
                        for (let i = 0; i < buffer.length - 10; i++) {
                            for (const header of imageHeaders) {
                                if (header.every((byte, j) => buffer[i + j] === byte)) {
                                    // Found image start, now find end by looking for next boundary
                                    const remainingBuffer = buffer.slice(i);
                                    const boundaryBytes = Buffer.from('------WebKitFormBoundary', 'binary');
                                    const endIndex = remainingBuffer.indexOf(boundaryBytes);
                                    
                                    if (endIndex !== -1) {
                                        imageBuffer = remainingBuffer.slice(0, endIndex - 2); // Remove \r\n
                                    } else {
                                        imageBuffer = remainingBuffer.slice(0, -50); // Remove last 50 bytes (boundary + extra)
                                    }
                                    break;
                                }
                            }
                            if (imageBuffer) break;
                        }
                    }
                    
                    // Final validation - make sure we have valid image data
                    if (!imageBuffer || imageBuffer.length < 100) {
                        sendError(res, 400, 'No se pudo extraer los datos de la imagen del formulario multipart');
                        return;
                    }
                    
                    console.log('DEBUG: Final image buffer size:', imageBuffer.length, 'bytes');
                    
                    // Save the uploaded file physically (now with clean image data)
                    fs.writeFileSync(path.join(receiptsDir, finalFileName), imageBuffer);
                    
                    const depositIndex = database.deposits.findIndex(d => d.id === depositId);
                    database.deposits[depositIndex].receipt = {
                        filename: finalFileName,
                        original_name: fileName || 'receipt.jpg',
                        uploaded_at: new Date().toISOString(),
                        path: path.join(receiptsDir, finalFileName),
                        notes: notes || '',
                        security_flags: securityFlags,
                        file_size: buffer.length,
                        requires_manual_review: securityFlags.length > 0,
                        validation_status: securityFlags.length > 0 ? 'flagged' : 'pending'
                    };
                    
                    // Change status to 'processing'
                    const result = transactionManager.updateTransactionState(depositId, 'processing', 'receipt_uploaded');
                    
                    if (!result.success) {
                        sendError(res, 400, result.error);
                        return;
                    }
                    
                    database.deposits[depositIndex].status_updated_by = 'user_receipt_upload';
                    database.deposits[depositIndex].receipt_upload_notes = 'Usuario subió comprobante de pago';
                    
                    
                    log('info', 'Receipt uploaded successfully', {
                        depositId,
                        userId,
                        filename: finalFileName
                    });
                    
                    // Send notification to admin
                    sendDepositNotification({
                        type: 'receipt_uploaded',
                        deposit: database.deposits[depositIndex],
                        id: userId,  // Changed from user_id to id
                        receipt_filename: finalFileName
                    });
                    
                    sendSuccess(res, {
                        deposit_id: depositId,
                        old_status: 'pending_transfer',
                        new_status: 'processing',
                        status_description: securityFlags.length > 0 ? 
                            'Comprobante recibido - Requiere revisión adicional' : 
                            'Comprobante recibido - En revisión administrativa',
                        receipt: {
                            filename: finalFileName,
                            original_name: fileName,
                            uploaded_at: database.deposits[depositIndex].receipt.uploaded_at,
                            size: buffer.length,
                            notes: notes,
                            security_flags: securityFlags,
                            requires_manual_review: securityFlags.length > 0
                        },
                        message: 'Comprobante subido exitosamente. Su depósito está ahora en revisión.',
                        next_steps: [
                            'Su comprobante está siendo verificado por nuestro equipo',
                            'Recibirá una notificación cuando sea aprobado',
                            'El proceso de revisión toma entre 15-30 minutos'
                        ]
                    });
                    
                } catch (parseError) {
                    console.error('Parse error:', parseError);
                    sendError(res, 400, 'Error al procesar datos del formulario');
                }
            });
            
        } catch (error) {
            console.error('Upload error:', error);
            sendError(res, 500, 'Error interno del servidor');
        }
        return;
    }

    try {
        let body = {};
        if (method === 'POST' || method === 'PUT' || method === "PATCH") {
            body = await parseBody(req);
        }

        // ===== CORE SYSTEM ENDPOINTS (4) =====
        
        // 1. Root endpoint
        if (pathname === '/') {
            sendSuccess(res, {
                message: "La Tanda Complete Mobile API",
                deployment: "Production - Complete Mobile Integration (89 endpoints)",
                version: "2.0.0",
                environment: "production",
                mobile_optimized: true,
                features: [
                    "Mobile app integration",
                    "Push notifications",
                    "Offline sync",
                    "MIA AI assistant",
                    "Complete user journey"
                ]
            });
            return;
        }

        // 2. Health check
        if (pathname === '/health') {
            sendSuccess(res, {
                status: 'online',
                server: '168.231.67.201',
                endpoints_available: 85,
                mobile_integration: 'active',
                database_status: 'connected',
                uptime_seconds: Math.floor((Date.now() - startTime) / 1000),
                requests_served: requestCount,
                timestamp: new Date().toISOString(),
                features: {
                    push_notifications: true,
                    offline_sync: true,
                    mia_assistant: true,
                    real_time_updates: true
                }
            });
            return;
        }

        // 3. API Documentation
        if (pathname === '/docs' || path === '/api/docs') {
            sendSuccess(res, {
                title: 'La Tanda Complete Mobile API Documentation',
                version: '2.0.0',
                description: 'Complete API for La Tanda mobile ecosystem (89 endpoints)',
                endpoints: {
                    core_system: 4,
                    user_journey: 3,
                    registration_bot: 9,
                    payment_bot: 9,
                    verification_bot: 8,
                    notification_bot: 6,
                    business_intelligence: 8,
                    mobile_app_specific: 6,
                    user_authentication: 4,
                    push_notifications: 2,
                    offline_sync: 3,
                    mia_assistant: 5,
                    total: 85
                },
                mobile_features: [
                    'Real-time push notifications',
                    'Offline data synchronization',
                    'MIA AI assistant integration',
                    'Mobile-optimized user flows',
                    'Cross-platform compatibility'
                ],
                integration_status: 'complete'
            });
            return;
        }

        // 4. Complete system status
        if (pathname === '/api/system/status' && method === 'GET' || method === 'HEAD') {
            sendSuccess(res, {
                system: 'healthy',
                uptime: process.uptime(),
                memory: process.memoryUsage(),
                endpoints: 85,
                database: 'connected',
                mobile_services: {
                    push_notifications: 'active',
                    offline_sync: 'active',
                    mia_assistant: 'active',
                    real_time_updates: 'active'
                },
                performance: {
                    avg_response_time: '150ms',
                    requests_per_minute: 45,
                    error_rate: '0.1%'
                }
            });
            return;
        }

        // ===== MOBILE APP SPECIFIC ENDPOINTS (6) =====

        // 1. App initialization
        if (pathname === '/api/mobile/init' && method === 'POST') {
            const { user_id, device_info, app_version } = body;
            
            const user = database.users.find(u => u.id === user_id);
            if (user) {
                user.app_version = app_version;
                user.device_type = device_info.platform;
                user.last_app_access = new Date().toISOString();
            }

            sendSuccess(res, {
                welcome_message: '¡Bienvenido a La Tanda Ecosystem!',
                user_profile: user,
                app_config: {
                    features_enabled: ['groups', 'payments', 'mia_assistant', 'notifications'],
                    api_endpoints: 85,
                    theme_options: ['light', 'dark'],
                    supported_languages: ['es']
                },
                initial_data: {
                    groups: database.groups.filter(g => g.status === 'active').slice(0, 5),
                    notifications: database.notifications.filter(n => n.user_id === user_id).slice(0, 3)
                }
            });
            return;
        }

        // 2. App settings management
                if (pathname === '/api/mobile/settings' && method === 'POST') {
            const { user_id, settings } = body;
            
            // ============================================
            // DUAL-WRITE: PostgreSQL (Primary) + JSON (Backup)
            // Week 3 Day 2: User Settings Update
            // ============================================
            
            let pgWriteSuccess = false;
            let updatedUser = null;
            
            // Find user in JSON (for response)
            const user = database.users.find(u => u.id === user_id);
            if (!user) { // Usuario no encontrado - devolver balance 0 en lugar de error
                sendError(res, 404, 'User not found');
                return;
            }
            
            // Merge new settings
            const newSettings = { ...user.app_settings, ...settings };
            
            try {
                // PRIMARY WRITE: PostgreSQL
                const pgUpdateData = {
                    app_settings: newSettings
                };
                
                updatedUser = await db.updateUser(user_id, pgUpdateData);
                pgWriteSuccess = true;
                log('info', `✅ [DUAL-WRITE] User settings updated in PostgreSQL: ${user_id}`);
                
            } catch (pgError) {
                log('error', `❌ [DUAL-WRITE] PostgreSQL update failed for user settings: ${pgError.message}`, { user_id, error: pgError });
                // Continue to JSON write (graceful degradation)
            }
            
            // BACKUP WRITE: JSON (always write for backward compatibility)
            user.app_settings = newSettings;
            saveDatabase();  // CRITICAL: Save JSON to disk
            log('info', `✅ [DUAL-WRITE] User settings updated in JSON: ${user_id}`, { pgWriteSuccess });

            sendSuccess(res, {
                message: 'Configuración guardada exitosamente',
                settings: newSettings,
                sync_status: 'updated'
            });
            return;
        }


        // 3. User session tracking
        if (pathname === '/api/mobile/session/start' && method === 'POST') {
            const { user_id, device_info } = body;
            
            const sessionId = generateId('session');
            const session = {
                id: sessionId,
                user_id,
                start_time: new Date().toISOString(),
                device_info,
                screens_visited: [],
                actions_performed: 0
            };
            
            database.app_sessions.push(session);
            sendSuccess(res, { session_id: sessionId, message: 'Sesión iniciada' });
            return;
        }

        // 4. User session end
        if (pathname === '/api/mobile/session/end' && method === 'POST') {
            const { session_id, screens_visited, actions_performed } = body;
            
            const session = database.app_sessions.find(s => s.id === session_id);
            if (session) {
                session.end_time = new Date().toISOString();
                session.duration = new Date() - new Date(session.start_time);
                session.screens_visited = screens_visited;
                session.actions_performed = actions_performed;
            }

            sendSuccess(res, { message: 'Sesión finalizada', session_duration: session?.duration });
            return;
        }

        // 5. App feedback
        if (pathname === '/api/mobile/feedback' && method === 'POST') {
            const { user_id, rating, feedback_text, screen, feature } = body;
            
            const feedbackId = generateId('feedback');
            const feedback = {
                id: feedbackId,
                user_id,
                rating,
                feedback_text,
                screen,
                feature,
                submitted_at: new Date().toISOString(),
                status: 'received'
            };

            sendSuccess(res, {
                message: 'Gracias por tu feedback',
                feedback_id: feedbackId,
                status: 'received'
            });
            return;
        }

        // 6. App analytics
        if (pathname === '/api/mobile/analytics' && method === 'POST') {
            const { user_id, event_type, event_data } = body;
            
            sendSuccess(res, {
                message: 'Analytics data recorded',
                event_id: generateId('event'),
                processed_at: new Date().toISOString()
            });
            return;
        }

        // ===== USER AUTHENTICATION ENDPOINTS (4) =====

        // 1. User login
        if (pathname === '/api/auth/login' && method === 'POST') {
            const { email, password, device_info } = body;
            
            // ============================================
            // INPUT VALIDATION
            // ============================================
            if (!email || !password) {
                sendError(res, 400, 'Email y contraseña son requeridos');
                return;
            }
            
            // ============================================
            // FIND USER BY EMAIL (PostgreSQL)
            // ============================================
            let user;
            try {
                user = await db.getUserByEmail(email);
            } catch (dbError) {
                log('error', 'Error fetching user for login', { email, error: dbError.message });
                sendError(res, 500, 'Error interno del servidor');
                return;
            }
            
            if (!user) {
                // User not found - generic error for security
                sendError(res, 401, 'Credenciales inválidas');
                return;
            }
            
            // ============================================
            // CHECK IF USER HAS PASSWORD SET
            // ============================================
            if (!user.password_hash) {
                // User exists but has no password (legacy user)
                sendError(res, 403, 'Debes restablecer tu contraseña. Usa la opción Olvidé mi contraseña.', {
                    code: 'PASSWORD_RESET_REQUIRED',
                    email: email
                });
                return;
            }
            
            // ============================================
            // VERIFY PASSWORD
            // ============================================
            let validPassword;
            try {
                validPassword = await bcrypt.compare(password, user.password_hash);
            } catch (compareError) {
                log('error', 'Error comparing passwords', { email, error: compareError.message });
                sendError(res, 500, 'Error al verificar credenciales');
                return;
            }
            
            if (!validPassword) {
                sendError(res, 401, 'Credenciales inválidas');
                return;
            }
            
            // ============================================
            // GENERATE AUTH TOKEN AND RETURN SUCCESS
            // ============================================
            const authToken = generateId('auth');
            
            log('info', '✅ User logged in successfully', { userId: user.id, email });
            
            sendSuccess(res, {
                message: 'Inicio de sesión exitoso',
                user: {
                    id: user.id,
                    name: user.name,
                    email: user.email,
                    phone: user.phone,
                    verification_level: user.verification_level,
                    avatar_url: user.avatar_url,
                    status: user.status
                },
                auth_token: authToken,
                expires_in: 3600 // 1 hour
            });
            return;
        }

        // 2. User registration
        if (pathname === '/api/auth/register' && method === 'POST') {
            const { name, email, phone, password, device_info } = body;
            
            // ============================================
            // INPUT VALIDATION
            // ============================================
            if (!name || !email || !password) {
                sendError(res, 400, 'Nombre, email y contraseña son requeridos');
                return;
            }
            
            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                sendError(res, 400, 'Formato de email inválido');
                return;
            }
            
            // Validate email domain has MX records
            const mxCheck = await verifyEmailDomain(email);
            if (!mxCheck.valid) {
                sendError(res, 400, mxCheck.reason);
                return;
            }
            
            // Validate password strength
            if (password.length < 8) {
                sendError(res, 400, 'La contraseña debe tener al menos 8 caracteres');
                return;
            }
            
            // ============================================
            // CHECK FOR EXISTING USER
            // ============================================
            try {
                const existingUser = await db.getUserByEmail(email);
                if (existingUser) {
                    sendError(res, 409, 'Este email ya está registrado');
                    return;
                }
            } catch (checkError) {
                log('error', 'Error checking existing user', { email, error: checkError.message });
            }
            
            // ============================================
            // HASH PASSWORD
            // ============================================
            let password_hash;
            try {
                password_hash = await bcrypt.hash(password, 10);
            } catch (hashError) {
                log('error', 'Error hashing password', { error: hashError.message });
                sendError(res, 500, 'Error al procesar la contraseña');
                return;
            }
            
            const userId = generateId('user');
            const registrationDate = new Date().toISOString();
            
            // ============================================
            // CREATE USER IN POSTGRESQL (PRIMARY)
            // ============================================
            try {
                const pgUserData = {
                    id: userId,
                    name,
                    email: email,
                    phone: phone || null,
                    password_hash: password_hash,
                    verification_level: 'basic',
                    registration_date: registrationDate,
                    status: 'active',
                    total_contributions: 0,
                    avatar_url: 'https://storage.latanda.online/avatars/default.jpg',
                    notification_preferences: {
                        payment_reminders: true,
                        group_updates: true,
                        marketing: false,
                        push_enabled: true
                    },
                    app_settings: {
                        theme: 'light',
                        language: 'es',
                        biometric_enabled: false,
                        auto_backup: true
                    }
                };
                
                await db.createUser(pgUserData);
                log('info', '✅ User created in PostgreSQL', { userId, email });
                
            } catch (pgError) {
                // Handle specific PostgreSQL errors
                if (pgError.code === '23505') { // Unique violation
                    sendError(res, 409, 'Este email ya está registrado');
                    return;
                }
                log('error', '❌ PostgreSQL write failed', { userId, email, error: pgError.message });
                sendError(res, 500, 'Error al crear la cuenta. Intenta nuevamente.');
                return;
            }
            
            // Generate auth token
            const authToken = generateId('auth');
            
            // Return success (do NOT include password_hash in response)
            sendSuccess(res, {
                message: 'Registro exitoso',
                user: {
                    id: userId,
                    name,
                    email,
                    phone: phone || null,
                    verification_level: 'basic',
                    registration_date: registrationDate,
                    status: 'active',
                    avatar_url: 'https://storage.latanda.online/avatars/default.jpg'
                },
                auth_token: authToken,
                next_step: 'Verificar correo electrónico'
            });
            return;
        }

        // 3. Token refresh

        // ============================================
        // EMAIL VERIFICATION - Send Code
        // ============================================
        if (pathname === "/api/auth/send-verification" && method === "POST") {
            const { user_id, email } = body;
            
            if (!user_id && !email) {
                sendError(res, 400, "Se requiere user_id o email");
                return;
            }
            
            try {
                let user;
                if (user_id) {
                    // Get user by ID from PostgreSQL
                    const pgResult = await dbPostgres.pool.query(
                        "SELECT user_id, email, name FROM users WHERE user_id = $1",
                        [user_id]
                    );
                    user = pgResult.rows[0];
                } else {
                    user = await db.getUserByEmail(email);
                }
                
                if (!user) {
                    sendError(res, 404, "Usuario no encontrado");
                    return;
                }
                
                if (!user.email) {
                    sendError(res, 400, "El usuario no tiene email registrado");
                    return;
                }
                
                // Generate 6-digit code
                const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();
                
                // Code expires in 15 minutes
                const expiresAt = new Date(Date.now() + 5 * 60 * 1000);
                
                // Save to database
                await db.setEmailVerificationCode(user.user_id || user.id, verificationCode, expiresAt);
                
                // Log the code (in production, send email)
                console.log("📧 VERIFICATION CODE for", user.email, ":", verificationCode);
                
                // Send verification email
                const emailHtml = `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
                        <div style="text-align: center; margin-bottom: 30px;">
                            <h1 style="color: #22d55e;">La Tanda</h1>
                        </div>
                        <h2 style="color: #333;">Código de Verificación</h2>
                        <p>Tu código de verificación es:</p>
                        <div style="background: #f5f5f5; padding: 20px; text-align: center; font-size: 32px; font-weight: bold; letter-spacing: 8px; margin: 20px 0; border-radius: 8px;">
                            ${verificationCode}
                        </div>
                        <p style="color: #666;">Este código expira en 5 minutos.</p>
                        <p style="color: #999; font-size: 12px;">Si no solicitaste este código, ignora este mensaje.</p>
                    </div>
                `;
                await sendEmail(user.email, "Código de Verificación - La Tanda", emailHtml);
                // await notificationUtils.sendEmailNotification(user.email, "Código de verificación - La Tanda", `Tu código es: ${verificationCode}`);
                
                sendSuccess(res, {
                    message: "Código de verificación enviado",
                    email_sent_to: user.email.replace(/(.{2})(.*)(@.*)/, "$1***$3"),
                    expires_in_minutes: 5,
                    // DEV ONLY - Remove in production:
                    dev_code: verificationCode
                });
                return;
            } catch (error) {
                console.error("Error sending verification:", error);
                sendError(res, 500, "Error al enviar código de verificación");
                return;
            }
        }

        // ============================================
        // EMAIL VERIFICATION - Verify Code
        // ============================================
        if (pathname === "/api/auth/verify-email" && method === "POST") {
            const { user_id, email, code } = body;
            
            // Accept either user_id or email
            if ((!user_id && !email) || !code) {
                sendError(res, 400, "Se requiere user_id o email, y código de verificación");
                return;
            }
            
            try {
                let userId = user_id;
                
                // If email provided instead of user_id, look up the user
                if (!userId && email) {
                    const user = await db.getUserByEmail(email);
                    if (!user) {
                        sendError(res, 404, "Usuario no encontrado");
                        return;
                    }
                    userId = user.id;
                }
                
                const result = await db.verifyEmailCode(userId, code);
                
                if (!result.valid) {
                    sendError(res, 400, result.reason);
                    return;
                }
                
                // Get user data to return
                const user = await db.getUserById(userId);
                const authToken = "auth_" + Date.now().toString(36) + Math.random().toString(36).substr(2);
                
                sendSuccess(res, {
                    message: "Email verificado exitosamente",
                    email_verified: true,
                    user: user ? {
                        id: user.id,
                        name: user.name,
                        email: user.email,
                        phone: user.phone,
                        verification_level: user.verification_level,
                        avatar_url: user.avatar_url,
                        status: user.status
                    } : null,
                    auth_token: authToken
                });
                return;
            } catch (error) {
                console.error("Error verifying email:", error);
                sendError(res, 500, "Error al verificar código");
                return;
            }
        }

        // ============================================
        // PASSWORD RESET - Request Reset Link
        // ============================================

        // ============================================
        // PASSWORD RESET - Request Reset Code
        // ============================================
        if (pathname === "/api/auth/request-reset" && method === "POST") {
            const { email } = body;
            
            if (!email) {
                sendError(res, 400, "Email es requerido");
                return;
            }
            
            try {
                const user = await db.getUserByEmail(email);
                
                // Always return success for security (dont reveal if email exists)
                if (!user) {
                    sendSuccess(res, {
                        message: "Si el email existe, recibirás un código para restablecer tu contraseña."
                    });
                    return;
                }
                
                // Generate 6-digit reset code
                const resetCode = Math.floor(100000 + Math.random() * 900000).toString();
                const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes
                
                // Save code to database
                await db.setPasswordResetToken(user.id, resetCode, expiresAt);
                
                // Log the code (in production, send email)
                console.log("PASSWORD RESET CODE for", email, ":", resetCode);
                // Send email with reset code
                const resetEmailHtml = `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; border-radius: 10px 10px 0 0;">
                            <h1 style="color: white; margin: 0; text-align: center;">La Tanda</h1>
                            <p style="color: rgba(255,255,255,0.9); text-align: center; margin-top: 10px;">Restablecer Contrasena</p>
                        </div>
                        <div style="background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px;">
                            <p style="color: #333; font-size: 16px;">Has solicitado restablecer tu contrasena.</p>
                            <p style="color: #333; font-size: 16px;">Tu codigo de verificacion es:</p>
                            <div style="background: #667eea; color: white; font-size: 32px; font-weight: bold; padding: 20px; text-align: center; border-radius: 8px; letter-spacing: 8px; margin: 20px 0;">
                                ${resetCode}
                            </div>
                            <p style="color: #666; font-size: 14px;">Este codigo expirara en 5 minutos.</p>
                            <p style="color: #666; font-size: 14px;">Si no solicitaste restablecer tu contrasena, ignora este mensaje.</p>
                            <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;">
                            <p style="color: #999; font-size: 12px; text-align: center;">Este es un correo automatico de La Tanda. No responder.</p>
                        </div>
                    </div>
                `;
                
                const emailResult = await sendEmail(email, "Codigo de Restablecimiento - La Tanda", resetEmailHtml);
                if (emailResult.success) {
                    log("info", "Password reset email sent", { userId: user.id, email, messageId: emailResult.messageId });
                } else {
                    log("warn", "Failed to send password reset email", { userId: user.id, email, error: emailResult.error });
                }
                log("info", "Password reset code generated", { userId: user.id, email });
                
                sendSuccess(res, {
                    message: "Si el email existe, recibirás un código para restablecer tu contraseña.",
                    // DEV ONLY - Remove in production:
                    dev_code: resetCode
                });
                
            } catch (error) {
                log("error", "Error in request-reset", { email, error: error.message });
                sendError(res, 500, "Error al procesar la solicitud");
            }
            return;
        }

        // ============================================
        // PASSWORD RESET - Verify Reset Code
        // ============================================
        if (pathname === "/api/auth/verify-reset-token" && method === "POST") {
            const { email, code } = body;
            
            if (!email || !code) {
                sendError(res, 400, "Email y código son requeridos");
                return;
            }
            
            try {
                // Get user by email
                const user = await db.getUserByEmail(email);
                if (!user) {
                    sendError(res, 400, "Código inválido o expirado");
                    return;
                }
                
                // Verify the reset code
                const resetData = await db.getPasswordResetToken(user.id);
                
                if (!resetData || resetData.token !== code) {
                    sendError(res, 400, "Código inválido o expirado");
                    return;
                }
                
                // Check expiration
                if (new Date() > new Date(resetData.expires_at)) {
                    sendError(res, 400, "El código ha expirado. Solicita uno nuevo.");
                    return;
                }
                
                log("info", "Reset code verified", { userId: user.id, email });
                
                sendSuccess(res, {
                    message: "Código verificado correctamente",
                    verified: true
                });
                
            } catch (error) {
                log("error", "Error in verify-reset-token", { email, error: error.message });
                sendError(res, 500, "Error al verificar código");
            }
            return;
        }

        if (pathname === "/api/auth/reset-password" && method === "POST") {
            const { email, code, new_password } = body;
            
            if (!email || !code || !new_password) {
                sendError(res, 400, "Email, código y nueva contraseña son requeridos");
                return;
            }
            
            if (new_password.length < 8) {
                sendError(res, 400, "La contraseña debe tener al menos 8 caracteres");
                return;
            }
            
            try {
                // Find user by email
                const user = await db.getUserByEmail(email);
                
                if (!user) {
                    sendError(res, 400, "Código inválido o expirado");
                    return;
                }
                
                // Verify the reset code
                const resetData = await db.getPasswordResetToken(user.id);
                
                if (!resetData || resetData.token !== code) {
                    sendError(res, 400, "Código inválido o expirado");
                    return;
                }
                
                // Check if code is expired
                if (new Date() > new Date(resetData.expires_at)) {
                    sendError(res, 400, "El código ha expirado. Solicita uno nuevo.");
                    return;
                }
                
                // Hash new password
                const password_hash = await bcrypt.hash(new_password, 10);
                
                // Update password and clear reset token
                await db.updateUserPassword(user.id, password_hash);
                
                log("info", "Password reset successful", { userId: user.id, email: user.email });
                
                sendSuccess(res, {
                    message: "Contraseña actualizada exitosamente. Ya puedes iniciar sesión."
                });
                
            } catch (error) {
                log("error", "Error in reset-password", { error: error.message });
                sendError(res, 500, "Error al restablecer la contraseña");
            }
            return;
        }


        // ============================================
        // TEST ENDPOINT: Dual-Write Validation
        // ============================================
        if (pathname === '/api/test/register-dual-write' && method === 'POST') {
            const { name, email, phone, password } = body;

            const userId = generateId('user');
            const authToken = generateId('auth');
            const timestamp = new Date().toISOString();

            // Prepare user data
            const jsonUser = {
                id: userId,
                name,
                email,
                phone,
                verification_level: 'basic',
                registration_date: timestamp,
                status: 'active',
                groups: [],
                total_contributions: 0
            };

            try {
                // PRIMARY WRITE: PostgreSQL
                const pgUserData = {
                    id: userId,  // Changed from user_id to id
                    name,
                    email: email || null,
                    phone: phone || null,
                    verification_level: 'basic',
                    registration_date: timestamp,
                    status: 'active',
                    total_contributions: 0
                };

                const pgUser = await db.createUser(pgUserData);
                log('info', `✅ [TEST-DUAL-WRITE] User created in PostgreSQL: ${userId}`);

                sendSuccess(res, {
                    message: 'Test dual-write successful',
                    user: jsonUser,
                    auth_token: authToken,
                    _test_results: {
                        postgresql_write: 'SUCCESS',
                        id: userId,  // Changed from user_id to id
                        timestamp: timestamp,
                        pg_user: pgUser
                    }
                });

            } catch (pgError) {
                log('error', `❌ [TEST-DUAL-WRITE] PostgreSQL write failed: ${pgError.message}`);

                sendSuccess(res, {
                    message: 'Test dual-write failed (PostgreSQL error)',
                    user: jsonUser,
                    auth_token: authToken,
                    _test_results: {
                        postgresql_write: 'FAILED',
                        id: userId,  // Changed from user_id to id
                        pg_error: pgError.message
                    }
                });
            }

            return;
        }

        if (pathname === '/api/auth/refresh' && method === 'POST') {
            const { refresh_token } = body;
            
            const newAuthToken = generateId('auth');
            sendSuccess(res, {
                auth_token: newAuthToken,
                expires_in: 3600,
                refreshed_at: new Date().toISOString()
            });
            return;
        }

        // 4. Logout
        if (pathname === '/api/auth/logout' && method === 'POST') {
            const { auth_token, user_id } = body;
            
            sendSuccess(res, {
                message: 'Sesión cerrada exitosamente',
                logged_out_at: new Date().toISOString()
            });
            return;
        }

        // ===== PUSH NOTIFICATIONS ENDPOINTS (2) =====

        // 1. Register push token
        if (pathname === '/api/push/register' && method === 'POST') {
            const { user_id, push_token, device_type } = body;
            
            const user = database.users.find(u => u.id === user_id);
            if (user) {
                user.push_token = push_token;
                user.device_type = device_type;
            }

            sendSuccess(res, {
                message: 'Token de push registrado exitosamente',
                push_enabled: true,
                registered_at: new Date().toISOString()
            });
            return;
        }

        // 2. Send push notification
        if (pathname === '/api/push/send' && method === 'POST') {
            const { user_ids, title, message, data, priority } = body;
            
            const notificationId = generateId('push');
            const notification = {
                id: notificationId,
                user_ids,
                title,
                message,
                data,
                priority: priority || 'normal',
                sent_at: new Date().toISOString(),
                delivery_status: 'sent'
            };

            sendSuccess(res, {
                message: 'Push notification enviada',
                notification_id: notificationId,
                recipients: user_ids.length,
                estimated_delivery: '< 5 segundos'
            });
            return;
        }

        // ===== OFFLINE SYNC ENDPOINTS (3) =====

        // 1. Sync status
        if (pathname === '/api/sync/status' && method === 'POST') {
            const { user_id, data_types } = body;
            
            const syncStatus = data_types.map(type => ({
                data_type: type,
                last_sync: new Date(Date.now() - Math.random() * 3600000).toISOString(),
                pending_changes: Math.random() > 0.7,
                conflict_resolution: 'server_wins'
            }));

            sendSuccess(res, {
                user_id,
                sync_status: syncStatus,
                next_sync_window: '2025-07-24T20:00:00Z'
            });
            return;
        }

        // 2. Upload offline changes
        if (pathname === '/api/sync/upload' && method === 'POST') {
            const { user_id, changes, last_sync_timestamp } = body;
            
            const conflicts = changes.filter(() => Math.random() > 0.9);
            const accepted = changes.filter(c => !conflicts.includes(c));

            sendSuccess(res, {
                message: 'Cambios sincronizados',
                accepted_changes: accepted.length,
                conflicts: conflicts.length,
                conflict_details: conflicts,
                new_sync_timestamp: new Date().toISOString()
            });
            return;
        }

        // 3. Download server changes
        if (pathname === '/api/sync/download' && method === 'POST') {
            const { user_id, last_sync_timestamp } = body;
            
            const serverChanges = [
                {
                    data_type: 'user_profile',
                    action: 'update',
                    data: { verification_level: 'intermediate' },
                    timestamp: new Date().toISOString()
                }
            ];

            sendSuccess(res, {
                changes: serverChanges,
                total_changes: serverChanges.length,
                sync_timestamp: new Date().toISOString()
            });
            return;
        }

        // ===== MIA ASSISTANT ENDPOINTS (5) =====

        // 1. Start MIA conversation
        if (pathname === '/api/mia/conversation/start' && method === 'POST') {
            const { user_id, context } = body;
            
            const conversationId = generateId('conv');
            const conversation = {
                id: conversationId,
                user_id,
                messages: [
                    {
                        id: generateId('msg'),
                        sender: 'mia',
                        content: '¡Hola! Soy MIA, tu asistente inteligente de La Tanda. ¿En qué puedo ayudarte hoy?',
                        timestamp: new Date().toISOString()
                    }
                ],
                context: context || {},
                status: 'active',
                created_at: new Date().toISOString()
            };
            
            database.mia_conversations.push(conversation);
            
            sendSuccess(res, {
                conversation_id: conversationId,
                initial_message: conversation.messages[0],
                mia_capabilities: [
                    'Ayuda con grupos de ahorro',
                    'Información sobre pagos',
                    'Guía de verificación',
                    'Consejos financieros',
                    'Soporte de la aplicación'
                ]
            });
            return;
        }

        // 2. Send message to MIA
        if (pathname === '/api/mia/message/send' && method === 'POST') {
            const { conversation_id, message, context } = body;
            
            const conversation = database.mia_conversations.find(c => c.id === conversation_id);
            if (!conversation) {
                sendError(res, 404, 'Conversación no encontrada');
                return;
            }

            // Add user message
            const userMessage = {
                id: generateId('msg'),
                sender: 'user',
                content: message,
                timestamp: new Date().toISOString()
            };
            conversation.messages.push(userMessage);

            // Generate MIA response (simplified)
            const miaResponse = {
                id: generateId('msg'),
                sender: 'mia',
                content: generateMiaResponse(message, context),
                timestamp: new Date().toISOString()
            };
            conversation.messages.push(miaResponse);

            sendSuccess(res, {
                message_id: miaResponse.id,
                mia_response: miaResponse.content,
                conversation_updated: true,
                suggested_actions: getSuggestedActions(message)
            });
            return;
        }

        // 3. Get conversation history
        if (pathname.match(/^\/api\/mia\/conversation\/(.+)$/) && method === 'GET' || method === 'HEAD') {
            const conversationId = pathname.split('/').pop();
            const conversation = database.mia_conversations.find(c => c.id === conversationId);
            
            if (!conversation) {
                sendError(res, 404, 'Conversación no encontrada');
                return;
            }

            sendSuccess(res, {
                conversation,
                message_count: conversation.messages.length,
                last_activity: conversation.messages[conversation.messages.length - 1]?.timestamp
            });
            return;
        }

        // 4. MIA context update
        if (pathname === '/api/mia/context/update' && method === 'POST') {
            const { conversation_id, context } = body;
            
            const conversation = database.mia_conversations.find(c => c.id === conversation_id);
            if (conversation) {
                conversation.context = { ...conversation.context, ...context };
            }

            sendSuccess(res, {
                message: 'Contexto actualizado',
                updated_context: conversation?.context
            });
            return;
        }

        // 5. MIA capabilities
        if (pathname === '/api/mia/capabilities' && method === 'GET' || method === 'HEAD') {
            sendSuccess(res, {
                capabilities: [
                    {
                        category: 'Grupos de Ahorro',
                        features: ['Buscar grupos', 'Unirse a grupos', 'Información de grupos']
                    },
                    {
                        category: 'Pagos',
                        features: ['Métodos de pago', 'Historial de pagos', 'Ayuda con pagos']
                    },
                    {
                        category: 'Verificación',
                        features: ['Verificar identidad', 'Subir documentos', 'Estado de verificación']
                    },
                    {
                        category: 'Finanzas',
                        features: ['Consejos financieros', 'Calculadora de ahorros', 'Metas financieras']
                    },
                    {
                        category: 'Soporte',
                        features: ['Ayuda general', 'Reportar problemas', 'Guía de uso']
                    }
                ],
                supported_languages: ['es'],
                ai_model: 'MIA-v2.0',
                response_time: '< 2 segundos'
            });
            return;
        }

        // ===== ORIGINAL 73 ENDPOINTS (Groups, Payments, Verification, etc.) =====
        // [Previous endpoints from the 73-endpoint file would continue here...]
        
        // Groups management with PostgreSQL
        if (pathname === '/api/groups' && method === 'GET' || method === 'HEAD') {
            try {
                // Fetch groups from PostgreSQL
                const allGroups = await db.getGroups();
                const activeGroups = allGroups.filter(g => g.status === 'active');
                log("info", `GET /api/groups: ${activeGroups.length} active groups from PostgreSQL`);
                sendSuccess(res, activeGroups, {
                    total: activeGroups.length,
                    source: "postgresql"
                });
            } catch (error) {
                // Fallback to JSON database if PostgreSQL fails
                log("error", `PostgreSQL error in GET /api/groups: ${error.message}`);
                const activeGroups = database.groups.filter(g => g.status === 'active');
                log("warn", "Falling back to JSON database for GET /api/groups");
                sendSuccess(res, activeGroups, {
                    total: activeGroups.length,
                    source: "json_fallback"
                });
            }
            return;
        }


        // POST /api/groups - Create new group
        if (pathname === '/api/groups' && method === 'POST') {
            try {
                log("info", `POST /api/groups: Creating new group "${body.name}"`);

                // Validate required fields
                if (!body.name || !body.type || !body.createdBy) {
                    sendError(res, 400, "Missing required fields: name, type, createdBy");
                }                    return;

                // ============================================
                // USER ID RESOLUTION
                // Resolve JSON user IDs to PostgreSQL IDs
                // ============================================
                let resolvedAdminId = body.createdBy;
                
                try {
                    // First, try to get user from PostgreSQL by ID
                    let pgUser = await db.getUserById(body.createdBy);
                    
                    // If not found by ID, try to find in JSON database and sync
                    if (!pgUser) {
                        const jsonUser = database.users.find(u => u.id === body.createdBy || u.user_id === body.createdBy);
                        
                        if (jsonUser) {
                            log('info', `User ${body.createdBy} found in JSON, checking PostgreSQL by email...`);
                            
                            // Try to find by email in PostgreSQL
                            const allPgUsers = await db.getUsers();
                            pgUser = allPgUsers.find(u => u.email === jsonUser.email);
                            
                            if (pgUser) {
                                resolvedAdminId = pgUser.id;
                                log('info', `✅ Resolved user ID: ${body.createdBy} → ${pgUser.id} (by email: ${jsonUser.email})`);
                            } else {
                                // User doesn't exist in PostgreSQL, create it
                                log('info', `User ${jsonUser.email} not in PostgreSQL, creating...`);
                                const newPgUserId = await db.createUser({
                                    id: body.createdBy,
                                    name: jsonUser.name || body.creatorName || 'Unknown',
                                    email: jsonUser.email || null,
                                    phone: jsonUser.phone || null,
                                    verification_level: jsonUser.verified ? 'verified' : 'basic',
                                    status: 'active'
                                });
                                resolvedAdminId = newPgUserId;
                                log('info', `✅ Created user in PostgreSQL: ${newPgUserId}`);
                            }
                        } else {
                            log('warn', `User ${body.createdBy} not found in JSON or PostgreSQL, using as-is`);
                        }
                    } else {
                        log('info', `✅ User ${body.createdBy} found in PostgreSQL`);
                    }
                } catch (userResolveError) {
                    log('error', `Failed to resolve user ID: ${userResolveError.message}`);
                    // Continue with original ID
                }
                

                // Generate group ID
                const groupId = body.id || 'group_' + Date.now();

                // Create new group object
                const newGroup = {
                    id: groupId,
                    name: body.name,
                    description: body.description || "",
                    type: body.type,
                    maxMembers: body.maxMembers || 12,
                    currentMembers: 1,
                    contributionAmount: body.contributionAmount || 0,
                    frequency: body.frequency || "monthly",
                    paymentMethod: body.paymentMethod || "bank_transfer",
                    startDate: body.startDate || new Date().toISOString(),
                    endDate: body.endDate || null,
                    status: body.status || "recruiting",
                    privacy: body.privacy || "public",
                    autoAssignPositions: body.autoAssignPositions !== undefined ? body.autoAssignPositions : true,
                    requireApproval: body.requireApproval !== undefined ? body.requireApproval : false,
                    latePaymentPenalty: body.latePaymentPenalty || 0,
                    rules: body.rules || [],
                    admin_id: resolvedAdminId,
                    coordinators: body.coordinators || [],
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                    members: [{
                        userId: body.createdBy,
                        name: body.creatorName || "Admin",
                        role: "admin",
                        joinedAt: Date.now(),
                        status: "active"
                    }]
                };

                // ============================================
                // DUAL-WRITE: PostgreSQL (Primary) + JSON (Backup)
                // ============================================
                
                let pgWriteSuccess = false;
                
                try {
                    // PRIMARY WRITE: PostgreSQL
                    const pgGroupData = {
                        id: groupId,
                        name: body.name,
                        contribution_amount: parseFloat(body.contributionAmount || 0),
                        frequency: body.frequency || 'monthly',
                        max_members: parseInt(body.maxMembers || 12),
                        admin_id: resolvedAdminId,
                        status: 'active',
                        created_at: newGroup.created_at,
                        member_count: 1,
                        total_amount_collected: 0,
                        description: body.description || "",
                        location: 'Honduras',
                        category: body.type || 'general'
                    };
                    
                    await db.createGroup(pgGroupData);
                    pgWriteSuccess = true;
                    log('info', `✅ [DUAL-WRITE] Group created in PostgreSQL: ${groupId}`);

                // Add creator as member in PostgreSQL
                try {
                    await db.addGroupMember({
                        group_id: groupId,
                        user_id: resolvedAdminId,
                        role: "creator",
                        status: "active",
                        invited_by: resolvedAdminId,
                        notes: "Creador del grupo"
                    });
                    log("info", "Creator added as member in PostgreSQL: " + coordinator_id);

                // ✅ AUTO-CREATE TANDA for the new group
                try {
                    const tandaId = "tanda_" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
                    const tandaData = {
                        tanda_id: tandaId,
                        name: "Tanda - " + (body.name || newGroup.name),
                        contribution_amount: parseFloat(body.contributionAmount || body.contribution_amount || 100),
                        total_per_turn: parseFloat(body.contributionAmount || body.contribution_amount || 100) * parseInt(body.maxMembers || body.max_members || 10),
                        frequency: body.frequency || "monthly",
                        coordinator_id: resolvedAdminId,
                        group_id: groupId,
                        status: "recruiting",
                        current_turn: 0,
                        total_turns: parseInt(body.maxMembers || body.max_members || 10),
                        turns_order: [resolvedAdminId],
                        is_demo: false
                    };
                    await dbPostgres.createTanda(tandaData);
                    log("info", "✅ Tanda auto-creada para grupo: " + tandaId + " (group: " + groupId + ")");
                } catch (tandaError) {
                    log("warn", "⚠️ Error creando tanda automática: " + tandaError.message);
                }
                } catch (memberError) {
                    log("warn", "Failed to add creator as member: " + memberError.message);
                }

                    
                } catch (pgError) {
                    log('error', `❌ [DUAL-WRITE] PostgreSQL write failed for group: ${pgError.message}`, { groupId, error: pgError });
                    // Continue to JSON write (graceful degradation)
                }
                
                // BACKUP WRITE: JSON (always write for backward compatibility)
                // Add to database
                database.groups.push(newGroup);

                // Add creator to groupMembers if exists
                if (database.groupMembers) {
                    database.groupMembers.push({
                        id: 'member_' + Date.now(),
                        group_id: groupId,
                        user_id: body.createdBy,
                        role: 'creator',
                        position: body.preferredPosition || null,
                        joined_at: new Date().toISOString(),
                        status: 'active'
                    });
                }

                // Save to database file
                saveDatabase();

                log("info", `Group created successfully: ${groupId}`);
                sendSuccess(res, newGroup, {
                    message: "Group created successfully",
                    groupId: groupId
                });
            } catch (error) {
                log("error", `Error creating group: ${error.message}`);
                sendError(res, 500, "Error creating group: " + error.message);
            }
            return;
        }

        // ===== MY GROUPS ENHANCED ENDPOINT =====

        // GET /api/groups/my-groups - Enhanced endpoint with role, payment status, and alerts

        // NEW: Simple PostgreSQL-only endpoint for my groups
        // NEW: Public groups endpoint for Matching tab (PostgreSQL)

        // NEW: Join group using PostgreSQL

        // GET: User's pending group join requests
        if (pathname === "/api/groups/my-pending-requests" && method === "GET") {
            const userId = query.user_id;

            if (!userId) {
                sendError(res, 400, "user_id es requerido");
                return;
            }

            log("info", `Fetching pending requests for user ${userId}`);

            try {
                const result = await dbPostgres.pool.query(`
                    SELECT
                        gm.group_id,
                        gm.status,
                        gm.joined_at as requested_at,
                        gm.display_name,
                        g.name as group_name,
                        g.contribution_amount,
                        g.frequency,
                        g.member_count,
                        g.max_members,
                        g.location,
                        u.name as admin_name
                    FROM group_members gm
                    JOIN groups g ON gm.group_id = g.group_id
                    LEFT JOIN users u ON g.admin_id = u.user_id
                    WHERE gm.user_id = $1 AND gm.status = 'pending'
                    ORDER BY gm.joined_at DESC
                `, [userId]);

                sendSuccess(res, {
                    requests: result.rows,
                    total: result.rows.length
                });

            } catch (err) {
                log("error", `Error fetching pending requests: ${err.message}`);
                sendError(res, 500, "Error al obtener solicitudes: " + err.message);
            }
            return;
        }

        if (pathname.startsWith("/api/groups/") && pathname.endsWith("/join-pg") && method === "POST") {
            const groupId = pathname.split("/")[3];
            const { user_id, user_name } = body;

            log("info", `[PostgreSQL] User joining group: ${groupId}`, { user_id, user_name });

            if (!user_id) {
                sendError(res, 400, "user_id es requerido");
                return;
            }

            try {
                // 1. Verify group exists and has space
                const groupResult = await dbPostgres.pool.query(
                    "SELECT group_id, name, member_count, max_members, status FROM groups WHERE group_id = $1",
                    [groupId]
                );

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                const group = groupResult.rows[0];

                if (group.status !== "active") {
                    sendError(res, 400, "El grupo no está activo");
                    return;
                }

                if (group.member_count >= group.max_members) {
                    sendError(res, 400, "El grupo está lleno");
                    return;
                }

                // 2. Check if user already member
                const existingMember = await dbPostgres.pool.query(
                    "SELECT id, status FROM group_members WHERE group_id = $1 AND user_id = $2",
                    [groupId, user_id]
                );

                if (existingMember.rows.length > 0) {
                    const member = existingMember.rows[0];
                    if (member.status === "active") {
                        sendError(res, 400, "Ya eres miembro de este grupo");
                        return;
                    } else if (member.status === "pending") {
                        sendError(res, 400, "Ya tienes una solicitud pendiente para este grupo");
                        return;
                    } else if (member.status === "left") {
                        // Re-activate membership
                        await dbPostgres.pool.query(
                            "UPDATE group_members SET status = 'pending', left_at = NULL, updated_at = NOW() WHERE group_id = $1 AND user_id = $2",
                            [groupId, user_id]
                        );
                        log("info", `User ${user_id} re-requested to join group ${groupId}`);
                        sendSuccess(res, {
                            message: "Solicitud enviada. El administrador revisará tu solicitud.",
                            group_id: groupId,
                            status: "pending"
                        });
                        return;
                    }
                }

                // 3. Get user info
                const userResult = await dbPostgres.pool.query(
                    "SELECT user_id, name FROM users WHERE user_id = $1",
                    [user_id]
                );

                const displayName = userResult.rows.length > 0 ? userResult.rows[0].name : (user_name || "Usuario");

                // 4. Add as pending member (requires admin approval)
                await dbPostgres.pool.query(
                    `INSERT INTO group_members (group_id, user_id, role, status, display_name, joined_at)
                     VALUES ($1, $2, 'member', 'pending', $3, NOW())`,
                    [groupId, user_id, displayName]
                );

                log("info", `User ${user_id} requested to join group ${groupId} (pending approval)`);

                sendSuccess(res, {
                    message: "Solicitud enviada. El administrador del grupo revisará tu solicitud.",
                    group_id: groupId,
                    group_name: group.name,
                    status: "pending"
                });

            } catch (err) {
                log("error", `Error joining group: ${err.message}`);
                sendError(res, 500, "Error al procesar solicitud: " + err.message);
            }
            return;
        }

        if (pathname === "/api/groups/public-pg" && method === "GET") {
            const userId = query.user_id || query.exclude_user;
            log("info", "Fetching public groups from PostgreSQL", { excludeUserId: userId });
            
            try {
                const groups = await dbHelpers.getPublicGroups(userId);
                sendSuccess(res, {
                    groups: groups,
                    total: groups.length,
                    source: "postgresql"
                });
            } catch (err) {
                log("error", "Error fetching public groups", { error: err.message });
                sendError(res, 500, "Error al cargar grupos públicos: " + err.message);
            }
            return;
        }

        if (pathname === "/api/groups/my-groups-pg" && method === "GET") {
            const rawUserId = query.user_id; const userId = rawUserId ? rawUserId.split("?")[0] : null; console.log("DEBUG: rawUserId=", rawUserId, "cleaned userId=", userId);
            if (!userId) {
                sendError(res, 400, "user_id required");
                return;
            }

            let groups = [];
            let source = "postgresql";

            // 1. Intentar PostgreSQL primero
            try {
                groups = await dbHelpers.getEnrichedGroupsByUser(userId);
                log("info", `Loaded ${groups.length} groups from PostgreSQL for user ${userId}`);
            } catch (pgError) {
                log("warn", `PostgreSQL failed for user ${userId}: ${pgError.message}`);
                source = "json_fallback";

                // 2. Fallback a JSON (database.groups)
                try {
                    const userMemberships = (database.groupMembers || []).filter(
                        m => m.user_id === userId
                    );
                    const memberGroupIds = userMemberships.map(m => m.group_id);

                    // También incluir grupos donde el usuario es admin/coordinator
                    groups = (database.groups || []).filter(g =>
                        memberGroupIds.includes(g.id) ||
                        g.admin_id === userId ||
                        g.coordinator_id === userId
                    );

                    log("info", `Loaded ${groups.length} groups from JSON fallback for user ${userId}`);
                } catch (jsonError) {
                    log("error", `JSON fallback also failed: ${jsonError.message}`);
                }
            }

            sendSuccess(res, {
                groups,
                total: groups.length,
                source: source
            });
            return;
        }

        if (pathname === "/api/groups/my-groups" && method === "GET") {
            const rawUserId = query.user_id; const userId = rawUserId ? rawUserId.split("?")[0] : null; console.log("DEBUG: rawUserId=", rawUserId, "cleaned userId=", userId);

            log("info", `Fetching enhanced groups for user ${userId}`);

            if (!userId) {
                sendError(res, 400, "user_id requerido");
                return;
            }

            // Get all groups where user is a member
            const userMemberships = (database.groupMembers || []).filter(
                m => m.user_id === userId
            );

            const enhancedGroups = [];

            for (const membership of userMemberships) {
                const group = (database.groups || []).find(g => g.id === membership.group_id);

                if (!group) continue;

                // 1. DETERMINE USER ROLE
                let userRole = "member"; // default
                let userPermissions = ["view", "register_payment"];

                if (group.admin_id === userId) {
                    userRole = "creator";
                    userPermissions = [
                        "view", "edit", "delete", "manage_coordinators",
                        "approve_payments", "invite_members", "remove_members",
                        "pause_group", "close_group", "view_reports"
                    ];
                } else if (group.coordinators && group.coordinators.includes(userId)) {
                    userRole = "coordinator";
                    userPermissions = [
                        "view", "approve_payments", "invite_members",
                        "manage_turns", "send_reminders", "view_reports"
                    ];
                }

                // 2. GET USER PAYMENT STATUS
                const userPayments = (database.payments || []).filter(
                    p => p.group_id === group.id && p.user_id === userId
                );

                // Find latest payment
                const latestPayment = userPayments.sort((a, b) =>
                    new Date(b.payment_date || b.created_at) - new Date(a.payment_date || a.created_at)
                )[0];

                // Calculate next payment due date
                let nextPaymentDue = null;
                let paymentStatus = "up_to_date";
                let daysLate = 0;

                if (group.frequency) {
                    const today = new Date();
                    const lastPaymentDate = latestPayment ? new Date(latestPayment.payment_date || latestPayment.created_at) : new Date(group.created_at);

                    let daysBetweenPayments = 30; // default monthly
                    if (group.frequency === "weekly") daysBetweenPayments = 7;
                    else if (group.frequency === "biweekly") daysBetweenPayments = 14;

                    nextPaymentDue = new Date(lastPaymentDate);
                    nextPaymentDue.setDate(nextPaymentDue.getDate() + daysBetweenPayments);

                    // Check if payment is late
                    const gracePeriod = 3; // 3 days grace period
                    const dueWithGrace = new Date(nextPaymentDue);
                    dueWithGrace.setDate(dueWithGrace.getDate() + gracePeriod);

                    if (today > dueWithGrace) {
                        paymentStatus = "late";
                        daysLate = Math.floor((today - dueWithGrace) / (1000 * 60 * 60 * 24));
                    } else if (today > nextPaymentDue) {
                        paymentStatus = "pending";
                        daysLate = Math.floor((today - nextPaymentDue) / (1000 * 60 * 60 * 24));
                    }

                    // Check if suspended
                    if (membership.status === "suspended") {
                        paymentStatus = "suspended";
                    }
                }

                // 3. GET ACTIVE TANDA INFO (if exists)
                const activeTanda = (database.tandas || []).find(
                    t => t.group_id === group.id && t.status === "active"
                );

                let myTurnNumber = null;
                let currentTurnNumber = null;
                let currentTurnRecipient = null;
                let turnsUntilMine = null;

                if (activeTanda) {
                    currentTurnNumber = activeTanda.current_turn;

                    // Find user's turn number
                    if (activeTanda.turns_order && activeTanda.turns_order.length > 0) {
                        myTurnNumber = activeTanda.turns_order.indexOf(userId) + 1;

                        if (myTurnNumber > 0) {
                            turnsUntilMine = myTurnNumber - currentTurnNumber;
                        }
                    }

                    // Get current recipient
                    if (activeTanda.current_turn_payments) {
                        currentTurnRecipient = activeTanda.current_turn_payments.recipient_user_id;
                    }
                }

                // 4. CALCULATE TOTAL MEMBERS
                const groupMembers = (database.groupMembers || []).filter(
                    m => m.group_id === group.id
                );

                // 5. GENERATE ALERTS FOR THIS USER
                const alerts = [];

                // Alert: Payment due soon
                if (paymentStatus === "up_to_date" && nextPaymentDue) {
                    const today = new Date();
                    const daysUntilDue = Math.floor((new Date(nextPaymentDue) - today) / (1000 * 60 * 60 * 24));

                    if (daysUntilDue <= 3 && daysUntilDue > 0) {
                        alerts.push({
                            type: "payment_due",
                            severity: "warning",
                            message: `Tu pago vence en ${daysUntilDue} día${daysUntilDue !== 1 ? 's' : ''}`,
                            action_url: "/register-payment",
                            metadata: {
                                days_until: daysUntilDue,
                                amount: group.contribution_amount
                            }
                        });
                    }
                }

                // Alert: Payment overdue
                if (paymentStatus === "late") {
                    alerts.push({
                        type: "payment_overdue",
                        severity: "danger",
                        message: `Tienes un pago atrasado (${daysLate} día${daysLate !== 1 ? 's' : ''})`,
                        action_url: "/pay-debt",
                        metadata: {
                            days_late: daysLate,
                            amount: group.contribution_amount
                        }
                    });
                }

                // Alert: Your turn is coming soon
                if (turnsUntilMine !== null && turnsUntilMine > 0 && turnsUntilMine <= 2) {
                    const message = turnsUntilMine === 1
                        ? "¡Tu turno es el próximo!"
                        : `Faltan ${turnsUntilMine} turnos para el tuyo`;

                    alerts.push({
                        type: "turn_upcoming",
                        severity: "info",
                        message: message,
                        action_url: "/view-schedule",
                        metadata: {
                            turns_until: turnsUntilMine,
                            estimated_amount: group.contribution_amount * groupMembers.length
                        }
                    });
                }

                // Alert: It's your turn now
                if (currentTurnRecipient === userId) {
                    alerts.push({
                        type: "your_turn_now",
                        severity: "success",
                        message: "¡Es tu turno! Recibirás cuando todos paguen",
                        action_url: "/view-turn-status",
                        metadata: {
                            amount: group.contribution_amount * (groupMembers.length - 1)
                        }
                    });
                }

                // COORDINATOR ALERTS
                if (userRole === "coordinator" || userRole === "creator") {
                    // Alert: Pending payment approvals
                    const pendingPayments = (database.payments || []).filter(
                        p => p.group_id === group.id && p.status === "pending"
                    );

                    if (pendingPayments.length > 0) {
                        alerts.push({
                            type: "pending_approvals",
                            severity: "info",
                            message: `${pendingPayments.length} pago${pendingPayments.length !== 1 ? 's' : ''} pendiente${pendingPayments.length !== 1 ? 's' : ''} de aprobación`,
                            action_url: "/approve-payments",
                            metadata: {
                                count: pendingPayments.length
                            }
                        });
                    }

                    // Alert: Can advance turn
                    if (activeTanda && activeTanda.current_turn_payments) {
                        const pendingFrom = activeTanda.current_turn_payments.pending_from || [];

                        if (pendingFrom.length === 0 && activeTanda.status === "active") {
                            alerts.push({
                                type: "can_advance_turn",
                                severity: "success",
                                message: "Todos pagaron - Puedes avanzar el turno",
                                action_url: "/advance-turn",
                                metadata: {
                                    current_turn: activeTanda.current_turn
                                }
                            });
                        }
                    }

                    // Alert: Members with late payments
                    const lateMembers = groupMembers.filter(m => {
                        const memberPayments = (database.payments || []).filter(
                            p => p.group_id === group.id && p.user_id === m.user_id && p.status === "approved"
                        );

                        // Simple check - if no payments or last payment is old
                        if (memberPayments.length === 0) return false;

                        const lastPayment = memberPayments.sort((a, b) =>
                            new Date(b.payment_date || b.created_at) - new Date(a.payment_date || a.created_at)
                        )[0];

                        const daysSinceLastPayment = Math.floor(
                            (new Date() - new Date(lastPayment.payment_date || lastPayment.created_at)) / (1000 * 60 * 60 * 24)
                        );

                        let maxDays = 30; // monthly
                        if (group.frequency === "weekly") maxDays = 7;
                        else if (group.frequency === "biweekly") maxDays = 14;

                        return daysSinceLastPayment > maxDays + 3; // with grace period
                    });

                    if (lateMembers.length > 0) {
                        alerts.push({
                            type: "late_members",
                            severity: "warning",
                            message: `${lateMembers.length} miembro${lateMembers.length !== 1 ? 's' : ''} con pagos atrasados`,
                            action_url: "/view-delinquent",
                            metadata: {
                                count: lateMembers.length
                            }
                        });
                    }
                }

                // 6. BUILD ENHANCED GROUP OBJECT
                const enhancedGroup = {
                    // Basic group info
                    id: group.id,
                    name: group.name,
                    description: group.description || "",
                    category: group.category || "general",
                    location: group.location || "",

                    // Group settings
                    contribution_amount: group.contribution_amount,
                    frequency: group.frequency,
                    max_members: group.max_members,
                    members_count: groupMembers.length,
                    status: group.status || "active",

                    // Group admin
                    admin_id: group.admin_id,
                    coordinators: group.coordinators || [],

                    // Dates
                    created_at: group.created_at,

                    // MY ROLE (NEW)
                    my_role: userRole,
                    my_permissions: userPermissions,

                    // MY PAYMENT STATUS (NEW)
                    my_payment_status: paymentStatus,
                    my_next_payment_due: nextPaymentDue ? nextPaymentDue.toISOString().split('T')[0] : null,
                    my_days_late: daysLate,
                    my_total_paid: userPayments.filter(p => p.status === "approved")
                        .reduce((sum, p) => sum + (p.amount || 0), 0),

                    // MY TANDA INFO (NEW)
                    my_turn_number: myTurnNumber,
                    turns_until_mine: turnsUntilMine,

                    // CURRENT GROUP STATE (NEW)
                    current_turn_number: currentTurnNumber,
                    current_turn_recipient: currentTurnRecipient,
                    has_active_tanda: activeTanda !== undefined,

                    // ALERTS (NEW)
                    my_alerts: alerts,

                    // POSITION ASSIGNMENT (NEW)
                    positions: group.positions || [],
                    position_requests: group.position_requests || []
                };

                enhancedGroups.push(enhancedGroup);
            }

            // Sort groups by most recent first
            enhancedGroups.sort((a, b) =>
                new Date(b.created_at) - new Date(a.created_at)
            );

            log("info", `Returning ${enhancedGroups.length} enhanced groups for user ${userId}`);

            sendSuccess(res, {
                groups: enhancedGroups,
                total: enhancedGroups.length
            });
            return;
        }

        // Registration endpoints
        if (pathname === '/api/registration/groups/list' && method === 'POST') {
            const availableGroups = database.groups.filter(g => 
                g.status === 'active' && g.member_count < g.max_members
            );
            sendSuccess(res, { groups: availableGroups, total_count: availableGroups.length });
            return;
        }        if (pathname === '/api/registration/groups/create' && method === 'POST') {
            const { name, contribution_amount, frequency, max_members, coordinator_id, grace_period, start_date, latePaymentPenalty } = body;
            const groupId = generateId('group');
            const newGroup = {
                id: groupId,
                name,
                contribution_amount,
                frequency,
                member_count: 1,
                max_members,
                total_amount_collected: 0,
                admin_id: coordinator_id,
                admin_name: database.users.find(u => u.id === coordinator_id)?.name || 'Unknown',
                status: 'active',
                created_at: new Date().toISOString(),
                location: 'Honduras',
                description: `Grupo ${name} - ${frequency}`,
                image_url: 'https://storage.latanda.online/groups/default.jpg',
                category: 'general',
                meeting_schedule: 'Por definir'
            };
            
            // ============================================
            // DUAL-WRITE: PostgreSQL (Primary) + JSON (Backup)
            // Week 3-4: Group Creation Implementation
            // ============================================
            
            let pgWriteSuccess = false;
            
            try {
                // PRIMARY WRITE: PostgreSQL
                const pgGroupData = {
                    id: groupId,
                    name,
                    contribution_amount: parseFloat(contribution_amount),
                    frequency,
                    max_members: parseInt(max_members),
                    admin_id: coordinator_id,
                    status: 'active',
                    created_at: newGroup.created_at,
                    member_count: 1,
                    total_amount_collected: 0,
                    description: newGroup.description,
                    location: 'Honduras',
                    category: 'general',
                    start_date: start_date || null,
                    grace_period: parseInt(grace_period) || 3,
                    penalty_amount: parseFloat(latePaymentPenalty) || 50
                };
                
                await db.createGroup(pgGroupData);
                pgWriteSuccess = true;
                log('info', `✅ [DUAL-WRITE] Group created in PostgreSQL: ${groupId}`);

                // ✅ Add creator as member in PostgreSQL
                try {
                    await db.addGroupMember({
                        group_id: groupId,
                        user_id: coordinator_id,
                        role: "creator",
                        status: "active",
                        invited_by: coordinator_id,
                        notes: "Creador del grupo"
                    });
                    log("info", "✅ Creator added as member in PostgreSQL: " + coordinator_id);

                // ✅ AUTO-CREATE TANDA for the new group
                try {
                    const tandaId = "tanda_" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
                    const tandaData = {
                        tanda_id: tandaId,
                        name: "Tanda - " + name,
                        contribution_amount: parseFloat(contribution_amount || 100),
                        total_per_turn: parseFloat(contribution_amount || 100) * parseInt(max_members || 10),
                        frequency: frequency || "monthly",
                        coordinator_id: coordinator_id,
                        group_id: groupId,
                        status: "recruiting",
                        current_turn: 0,
                        total_turns: parseInt(max_members || 10),
                        turns_order: [coordinator_id],
                        is_demo: false
                    };
                    await dbPostgres.createTanda(tandaData);
                    log("info", "✅ Tanda auto-creada para grupo: " + tandaId + " (group: " + groupId + ")");
                } catch (tandaError) {
                    log("warn", "⚠️ Error creando tanda automática: " + tandaError.message);
                }
                } catch (memberError) {
                    log("warn", "⚠️ Failed to add creator as member: " + memberError.message);
                }
                
            } catch (pgError) {
                log('error', `❌ [DUAL-WRITE] PostgreSQL write failed for group: ${pgError.message}`, { groupId, error: pgError });
                // Continue to JSON write (graceful degradation)
            }
            
            // BACKUP WRITE: JSON (always write for backward compatibility)
            database.groups.push(newGroup);
            saveDatabase();  // CRITICAL: Save JSON to disk
            log('info', `✅ [DUAL-WRITE] Group created in JSON: ${groupId}`, { pgWriteSuccess });
            
            sendSuccess(res, { group: newGroup, message: 'Grupo creado exitosamente' });
            return;
        }


        // Group update endpoint (NUEVO - Agregado para persistencia)
                if (pathname.startsWith('/api/groups/') && pathname.endsWith('/update') && method === 'PUT') {
            const groupId = pathname.split('/')[3]; // Extract ID from /api/groups/GROUP_ID/update
            const { name, description, contribution_amount, max_members } = body;
            
            log('info', `Updating group: ${groupId}`, { name, contribution_amount });
            
            // ============================================
            // DUAL-WRITE: PostgreSQL (Primary) + JSON (Backup)
            // Week 3 Day 2: Group Update
            // ============================================
            
            let pgWriteSuccess = false;
            
            // Check PostgreSQL first, then JSON
            let groupExists = false;
            try {
                const pgGroup = await db.getGroupById(groupId);
                if (pgGroup) groupExists = true;
            } catch (e) {}

            const groupIndex = database.groups.findIndex(g => g.id === groupId);
            if (!groupExists && groupIndex === -1) {
                sendError(res, 404, 'Grupo no encontrado');
                return;
            }
            
            try {
                // PRIMARY WRITE: PostgreSQL
                const pgUpdateData = {};
                if (name) pgUpdateData.name = name;
                if (description !== undefined) pgUpdateData.description = description;
                if (contribution_amount) pgUpdateData.contribution_amount = parseFloat(contribution_amount);
                if (max_members) pgUpdateData.max_members = parseInt(max_members);
                
                await db.updateGroup(groupId, pgUpdateData);
                pgWriteSuccess = true;
                log('info', `✅ [DUAL-WRITE] Group updated in PostgreSQL: ${groupId}`);
                
            } catch (pgError) {
                log('error', `❌ [DUAL-WRITE] PostgreSQL update failed for group: ${pgError.message}`, { groupId, error: pgError });
                // Continue to JSON write (graceful degradation)
            }
            
            // BACKUP WRITE: JSON (always write for backward compatibility)
            const group = database.groups[groupIndex];
            if (name) group.name = name;
            if (description !== undefined) group.description = description;
            if (contribution_amount) group.contribution_amount = parseFloat(contribution_amount);
            if (max_members) group.max_members = parseInt(max_members);
            group.updated_at = new Date().toISOString();
            
            database.groups[groupIndex] = group;
            saveDatabase();  // CRITICAL: Save JSON to disk
            log('info', `✅ [DUAL-WRITE] Group updated in JSON: ${groupId}`, { pgWriteSuccess });
            
            sendSuccess(res, { group, message: 'Group updated successfully' });
            return;
        }


        // Get individual group details (for invitation page)
        
        // ========== CYCLE DISTRIBUTION ENDPOINTS ==========

        // Calculate and preview cycle distribution
        if (pathname.match(/^\/api\/groups\/[^/]+\/distribution\/preview$/) && (method === 'GET' || method === 'HEAD')) {
            const groupId = pathname.split('/')[3];

            try {
                // Get group info
                const groupResult = await dbPostgres.pool.query(`
                    SELECT g.*,
                           (SELECT COUNT(*) FROM group_members WHERE group_id = g.group_id AND status = 'active') as member_count
                    FROM groups g WHERE g.group_id = $1
                `, [groupId]);

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                const group = groupResult.rows[0];
                const memberCount = parseInt(group.member_count) || 0;
                const contributionAmount = parseFloat(group.contribution_amount) || 0;

                // Get completed contributions for current cycle
                const contribResult = await dbPostgres.pool.query(`
                    SELECT
                        COUNT(*) as total_contributions,
                        SUM(amount) as total_collected,
                        SUM(CASE WHEN payment_method = 'cash' THEN amount ELSE 0 END) as cash_collected,
                        SUM(CASE WHEN payment_method != 'cash' THEN amount ELSE 0 END) as transfer_collected
                    FROM contributions
                    WHERE group_id = $1 AND status = 'completed'
                `, [groupId]);

                const contrib = contribResult.rows[0];
                const totalCollected = parseFloat(contrib.total_collected) || 0;
                const cashCollected = parseFloat(contrib.cash_collected) || 0;
                const transferCollected = parseFloat(contrib.transfer_collected) || 0;
                const totalContributions = parseInt(contrib.total_contributions) || 0;

                // Calculate fees - Commission rate based on pool size
                // Rates: <50k = 3%, 50k-100k = 2%, >100k = 1%
                let commissionRate = 0.03;
                if (totalCollected >= 100000) commissionRate = 0.01;
                else if (totalCollected >= 50000) commissionRate = 0.02;
                
                const coordinatorFee = totalCollected * commissionRate;
                const platformFee = coordinatorFee * 0.10;  // Platform gets 10% of coordinator fee
                const coordinatorNetFee = coordinatorFee - platformFee;
                
                // Get current beneficiary (next in turn) - MUST query before using beneficiary
                const beneficiaryResult = await dbPostgres.pool.query(`
                    SELECT gm.*, u.name as user_name, u.email
                    FROM group_members gm
                    LEFT JOIN users u ON gm.user_id = u.user_id
                    WHERE gm.group_id = $1 AND gm.status = 'active'
                    ORDER BY gm.turn_position ASC
                    LIMIT 1
                `, [groupId]);

                const beneficiary = beneficiaryResult.rows[0];
                
                // Check if coordinator is the beneficiary (turn #1)
                const isCoordinatorTurn = beneficiary?.turn_position === 1;
                
                // Calculate what each party receives
                let beneficiaryReceives, coordinatorReceives;
                if (isCoordinatorTurn) {
                    // Coordinator is beneficiary - only platform fee applies
                    beneficiaryReceives = totalCollected - platformFee;
                    coordinatorReceives = 0;  // Coordinator IS the beneficiary
                } else {
                    // Normal case - coordinator takes commission, platform takes 10% of that
                    beneficiaryReceives = totalCollected - coordinatorFee;
                    coordinatorReceives = coordinatorNetFee;
                }

                sendSuccess(res, {
                    group_id: groupId,
                    group_name: group.name,
                    cycle_number: group.current_cycle || 1,
                    collection: {
                        total_contributions: totalContributions,
                        expected_contributions: memberCount,
                        total_collected: totalCollected,
                        cash_collected: cashCollected,
                        transfer_collected: transferCollected,
                        is_complete: totalContributions >= memberCount
                    },
                    fees: {
                        coordinator_fee: isCoordinatorTurn ? 0 : coordinatorFee,
                        coordinator_rate: commissionRate * 100,
                        platform_fee: platformFee,
                        platform_rate: 10,
                        coordinator_net: isCoordinatorTurn ? 0 : coordinatorNetFee,
                        is_coordinator_turn: isCoordinatorTurn
                    },
                    distribution: {
                        coordinator_receives: {
                            gross_commission: isCoordinatorTurn ? 0 : coordinatorFee,
                            platform_fee_paid: isCoordinatorTurn ? 0 : platformFee,
                            net_commission: coordinatorReceives,
                            method: 'Comision + efectivo en mano'
                        },
                        beneficiary_receives: {
                            amount: beneficiaryReceives,
                            user_id: beneficiary?.user_id,
                            user_name: beneficiary?.user_name || 'Por asignar',
                            method: 'Transferencia bancaria',
                            is_coordinator: isCoordinatorTurn
                        }
                    },
                    can_distribute: totalContributions >= memberCount && totalCollected > 0
                });
            } catch (error) {
                console.error('Error calculating distribution preview:', error);
                sendError(res, 500, 'Error al calcular distribucion');
            }
            return;
        }

        // Execute cycle distribution
        if (pathname.match(/^\/api\/groups\/[^/]+\/distribution\/execute$/) && method === 'POST') {
            const groupId = pathname.split('/')[3];
            const { beneficiary_user_id, transfer_reference, executed_by } = body;

            try {
                // Get group and verify
                const groupResult = await dbPostgres.pool.query(`
                    SELECT g.*,
                           (SELECT COUNT(*) FROM group_members WHERE group_id = g.group_id AND status = 'active') as member_count
                    FROM groups g WHERE g.group_id = $1
                `, [groupId]);

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                const group = groupResult.rows[0];
                const memberCount = parseInt(group.member_count) || 0;
                const cycleNumber = group.current_cycle || 1;

                // Get contributions summary
                const contribResult = await dbPostgres.pool.query(`
                    SELECT
                        COUNT(*) as total_contributions,
                        SUM(amount) as total_collected,
                        SUM(CASE WHEN payment_method = 'cash' THEN amount ELSE 0 END) as cash_collected,
                        SUM(CASE WHEN payment_method != 'cash' THEN amount ELSE 0 END) as transfer_collected
                    FROM contributions
                    WHERE group_id = $1 AND status = 'completed'
                `, [groupId]);

                const contrib = contribResult.rows[0];
                const totalCollected = parseFloat(contrib.total_collected) || 0;
                const cashCollected = parseFloat(contrib.cash_collected) || 0;
                const transferCollected = parseFloat(contrib.transfer_collected) || 0;
                const totalContributions = parseInt(contrib.total_contributions) || 0;

                if (totalContributions < memberCount) {
                    sendError(res, 400, 'No todas las contribuciones han sido completadas');
                    return;
                }

                // Determine beneficiary first - need this for fee calculation
                let finalBeneficiary = beneficiary_user_id;
                let beneficiaryTurnPosition = null;
                if (!finalBeneficiary) {
                    const beneficiaryResult = await dbPostgres.pool.query(`
                        SELECT user_id, turn_position FROM group_members
                        WHERE group_id = $1 AND status = 'active'
                        ORDER BY turn_position ASC LIMIT 1
                    `, [groupId]);
                    finalBeneficiary = beneficiaryResult.rows[0]?.user_id;
                    beneficiaryTurnPosition = beneficiaryResult.rows[0]?.turn_position;
                } else {
                    // Get turn position for provided beneficiary
                    const posResult = await dbPostgres.pool.query(`
                        SELECT turn_position FROM group_members
                        WHERE group_id = $1 AND user_id = $2
                    `, [groupId, finalBeneficiary]);
                    beneficiaryTurnPosition = posResult.rows[0]?.turn_position;
                }
                
                // Calculate fees - Rate based on pool size
                let commissionRate = 0.03;
                if (totalCollected >= 100000) commissionRate = 0.01;
                else if (totalCollected >= 50000) commissionRate = 0.02;
                
                const coordinatorFee = totalCollected * commissionRate;
                const platformFee = coordinatorFee * 0.10;
                const isCoordinatorTurn = beneficiaryTurnPosition === 1;
                const coordinatorNet = isCoordinatorTurn ? 0 : (coordinatorFee - platformFee);
                const beneficiaryNet = isCoordinatorTurn ? (totalCollected - platformFee) : (totalCollected - coordinatorFee);

                if (!finalBeneficiary) {
                    sendError(res, 400, 'No se pudo determinar el beneficiario');
                    return;
                }

                // Create distribution record
                const distributionResult = await dbPostgres.pool.query(`
                    INSERT INTO cycle_distributions (
                        group_id, cycle_number, beneficiary_user_id,
                        total_collected, platform_fee, coordinator_fee, coordinator_net,
                        net_amount, cash_amount, transfer_amount,
                        member_count, contribution_amount,
                        status, transfer_reference, distributed_at
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 'completed', $13, NOW())
                    RETURNING *
                `, [
                    groupId, cycleNumber, finalBeneficiary,
                    totalCollected, platformFee, coordinatorFee, coordinatorNet,
                    beneficiaryNet, cashCollected, transferCollected,
                    memberCount, group.contribution_amount || 0,
                    transfer_reference || null
                ]);

                // Archive current contributions and increment cycle
                await dbPostgres.pool.query(`
                    UPDATE contributions
                    SET status = 'archived', notes = COALESCE(notes, '') || ' [Ciclo ' || $2 || ' completado]'
                    WHERE group_id = $1 AND status = 'completed'
                `, [groupId, cycleNumber]);

                await dbPostgres.pool.query(`
                    UPDATE groups SET current_cycle = $1 WHERE group_id = $2
                `, [cycleNumber + 1, groupId]);

                log('info', 'Cycle distribution executed', {
                    group_id: groupId,
                    cycle_number: cycleNumber,
                    beneficiary: finalBeneficiary,
                    total_collected: totalCollected,
                    executed_by
                });

                sendSuccess(res, {
                    distribution_id: distributionResult.rows[0].id,
                    cycle_number: cycleNumber,
                    beneficiary_user_id: finalBeneficiary,
                    total_collected: totalCollected,
                    coordinator_net: coordinatorNet,
                    beneficiary_net: beneficiaryNet,
                    next_cycle: cycleNumber + 1,
                    status: 'completed',
                    message: 'Distribucion ejecutada exitosamente'
                });
            } catch (error) {
                console.error('Error executing distribution:', error);
                sendError(res, 500, 'Error al ejecutar distribucion');
            }
            return;
        }

        // Get distribution history for a group
        if (pathname.match(/^\/api\/groups\/[^/]+\/distributions$/) && (method === 'GET' || method === 'HEAD')) {
            const groupId = pathname.split('/')[3];

            try {
                const result = await dbPostgres.pool.query(`
                    SELECT cd.*, u.name as beneficiary_name
                    FROM cycle_distributions cd
                    LEFT JOIN users u ON cd.beneficiary_user_id = u.user_id
                    WHERE cd.group_id = $1
                    ORDER BY cd.cycle_number DESC
                `, [groupId]);

                sendSuccess(res, {
                    distributions: result.rows,
                    total: result.rows.length
                });
            } catch (error) {
                console.error('Error fetching distributions:', error);
                sendError(res, 500, 'Error al obtener historial de distribuciones');
            }
            return;
        }

        // ========== END CYCLE DISTRIBUTION ENDPOINTS ==========

        if (pathname.startsWith("/api/groups/") && !pathname.includes("/update") && !pathname.includes("/members") && !pathname.includes("/notifications") && !pathname.includes("/finances") && !pathname.includes("/join") && !pathname.includes("/my-groups") && !pathname.includes("/position-requests") && !pathname.includes("/approve-position-request") && !pathname.includes("/reject-position-request") && !pathname.includes("/assign-position-manually") && !pathname.includes("/auto-assign-positions") && !pathname.includes("/activate-tanda") && !pathname.includes("/contributions") && !pathname.includes("/export") && !pathname.includes("/stats") && !pathname.includes("/calendar") && !pathname.includes("/pending-members") && method === "GET") {
            const groupId = pathname.split("/")[3];
            
            log("info", `Fetching group details: ${groupId}`);
            
            // Check PostgreSQL first, then JSON
            let group = null;
            try {
                group = await db.getGroupById(groupId);
            } catch (e) {
                log("warn", "PostgreSQL fetch failed, falling back to JSON", { error: e.message });
            }
            
            if (!group) {
                group = database.groups.find(g => g.id === groupId);
            }
            
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            
            sendSuccess(res, { data: group });
            return;
        }

        // Join a group (for invitation acceptance)
        if (pathname.startsWith("/api/groups/") && pathname.endsWith("/join") && method === "POST") {
            const groupId = pathname.split("/")[3];
            const { userId, userName, userEmail } = body;
            
            log("info", `User joining group: ${groupId}`, { userId, userName });
            
            // Validate group exists
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            
            // Check if group is full
            if (group.member_count >= group.max_members) {
                sendError(res, 400, "El grupo está lleno");
                return;
            }
            
            // Check if group is active
            if (group.status !== "active") {
                sendError(res, 400, "El grupo no está activo");
                return;
            }
            
            // Initialize members array if it does not exist
            if (!database.groupMembers) {
                database.groupMembers = [];
            }
            
            // Check if user is already a member
            const existingMember = database.groupMembers.find(
                m => m.group_id === groupId && m.user_id === userId
            );
            
            if (existingMember) {
                sendError(res, 400, "Ya eres miembro de este grupo");
                return;
            }
            
            // Add user to group
            const newMember = {
                id: generateId("member"),
                group_id: groupId,
                id: userId,  // Changed from user_id to id
                user_name: userName,
                user_email: userEmail,
                joined_at: new Date().toISOString(),
                status: "active",
                payment_status: "pending",
                total_paid: 0
            };
            
            database.groupMembers.push(newMember);
            
            // Update group member count
            group.member_count = (group.member_count || 1) + 1;
            
            // Save database
            saveDatabase();
            
            log("info", `User ${userId} successfully joined group ${groupId}`);
            
            sendSuccess(res, {
                message: "Te has unido al grupo exitosamente",
                data: {
                    membership: newMember,
                    group: {
                        id: group.id,
                        name: group.name,
                        member_count: group.member_count,
                        max_members: group.max_members
                    }
                }
            });
            return;
        }

        // Group members management endpoints (NUEVOS)
                if (pathname.startsWith('/api/groups/') && pathname.includes('/members/invite') && method === 'POST') {
            const groupId = pathname.split('/')[3];
            const {
                email,
                phone,
                name,
                message = 'Te invitan a unirte a nuestro grupo de ahorro',
                inviter_id = 'system'
            } = body;

            log('info', `Inviting member to group: ${groupId}`, { email, phone });

            try {
                // Verify group exists
                const group = await db.getGroupById(groupId);
                if (!group) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                // Create invitation in database
                const invitation = await db.createGroupInvitation({
                    group_id: groupId,
                    inviter_id: inviter_id,
                    invitee_email: email || null,
                    invitee_phone: phone || null,
                    invitee_name: name || null,
                    message: message
                });

                // Generate invitation link
                const inviteLink = `https://latanda.online/invite/${invitation.token}`;

                sendSuccess(res, {
                    message: `Invitación creada exitosamente`,
                    invitation_id: invitation.id,
                    token: invitation.token,
                    invite_link: inviteLink,
                    status: 'pending',
                    expires_at: invitation.expires_at
                });
            } catch (error) {
                log('error', 'Error creating invitation', { groupId, error: error.message });
                sendError(res, 500, 'Error al crear invitación');
            }
            return;
        }

        // GET /api/groups/:groupId/export/members - Export members as PDF or CSV
        if (pathname.match(/^\/api\/groups\/[^\/]+\/export\/members$/) && method === 'GET') {
            const groupId = pathname.split('/')[3];
            const urlParts = url.parse(req.url, true);
            const format = urlParts.query.format || 'pdf';
            
            log('info', 'Exporting members', { groupId, format });
            
            try {
                const groupResult = await dbPostgres.pool.query(
                    'SELECT * FROM groups WHERE group_id = $1',
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                
                const groupData = groupResult.rows[0];
                
                const membersResult = await dbPostgres.pool.query(
                    `SELECT gm.*, u.name, u.email, u.phone
                     FROM group_members gm
                     LEFT JOIN users u ON gm.user_id = u.user_id
                     WHERE gm.group_id = $1 AND gm.status != 'left'
                     ORDER BY gm.role DESC, gm.joined_at ASC`,
                    [groupId]
                );
                
                const members = membersResult.rows;
                
                let result;
                if (format === 'csv') {
                    result = await exportUtils.generateMembersCSV(groupData, members);
                } else {
                    result = await exportUtils.generateMembersPDF(groupData, members);
                }
                
                const fileContent = fs.readFileSync(result.filepath);
                const contentType = format === 'csv' ? 'text/csv' : 'application/pdf';
                
                res.writeHead(200, {
                    'Content-Type': contentType,
                    'Content-Disposition': 'attachment; filename="' + result.filename + '"',
                    'Content-Length': fileContent.length,
                    'Access-Control-Allow-Origin': '*'
                });
                res.end(fileContent);
                
                setTimeout(function() {
                    try { fs.unlinkSync(result.filepath); } catch(e) {}
                }, 5000);
                
                return;
            } catch (error) {
                log('error', 'Export members failed', { error: error.message, groupId });
                sendError(res, 500, 'Error al exportar miembros');
                return;
            }
        }

        // Get group members list (PostgreSQL)

        if (pathname.startsWith("/api/groups/") && pathname.endsWith("/members") && method === "GET") {
            const groupId = pathname.split("/")[3];
            log("info", "Fetching members for group: " + groupId);
            
            try {
                // Get group info from PostgreSQL
                const group = await db.getGroupById(groupId);
                if (!group) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }
                
                // Get the tanda to calculate real turn positions from turns_order
                const tandaResult = await dbPostgres.pool.query(
                    "SELECT tanda_id, turns_order FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1",
                    [groupId]
                );
                const tanda = tandaResult.rows[0];
                const turnsOrder = tanda && tanda.turns_order ? tanda.turns_order : [];
                
                // Create position map from turns_order
                const positionMap = {};
                turnsOrder.forEach(function(userId, index) {
                    positionMap[userId] = index + 1;
                });
                
                // Get members from PostgreSQL with user details
                const membersResult = await dbPostgres.pool.query(
                    `SELECT 
                        gm.id,
                        gm.user_id,
                        gm.role,
                        gm.status,
                        gm.joined_at,
                        gm.invited_by,
                        gm.turn_position,
                        gm.turn_locked,
                        gm.turn_locked_by,
                        gm.turn_locked_at,
                        gm.is_anonymous,
                        COALESCE(u.name, 'Usuario') as name,
                        u.email,
                        u.phone,
                        u.telegram_id,
                        u.avatar_url
                    FROM group_members gm
                    LEFT JOIN users u ON gm.user_id = u.user_id
                    WHERE gm.group_id = $1 AND gm.status != $2
                    ORDER BY COALESCE(gm.turn_position, 999), gm.joined_at`,
                    [groupId, "left"]
                );
                const members = membersResult.rows;
                
                sendSuccess(res, {
                    group_id: groupId,
                    group_name: group.name || group.group_name,
                    members: members.map(m => ({
                        id: m.id,
                        user_id: m.user_id,
                        name: m.name || 'Usuario',
                        email: m.email,
                        phone: m.phone,
                        telegram_id: m.telegram_id,
                        avatar_url: m.avatar_url,
                        role: m.role,
                        status: m.status,
                        joined_at: m.joined_at,
                        invited_by: m.invited_by,
                        turn_position: positionMap[m.user_id] || null,
                        has_turn_assigned: !!positionMap[m.user_id],
                        is_anonymous: m.is_anonymous || false,
                        turn_locked: m.turn_locked || false,
                        turn_locked_by: m.turn_locked_by,
                        turn_locked_at: m.turn_locked_at
                    })),
                    total_members: members.length,
                    turns_assigned: turnsOrder.length
                });
            } catch (error) {
                log("error", "Error fetching group members", { groupId, error: error.message });
                sendError(res, 500, "Error al obtener miembros del grupo");
            }
            return;
        }
        // ============================================
        // MEMBER ADMIN ACTIONS (Nov 25, 2025)
        // ============================================

        // Change member role (PATCH /api/groups/:groupId/members/:userId/role)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/role$/) && method === "PATCH") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const userId = parts[5];
            const { role, changed_by } = body;

            log("info", "Changing member role", { groupId, userId, newRole: role });

            try {
                // Validate role
                if (!["coordinator", "member"].includes(role)) {
                    sendError(res, 400, "Rol invalido. Use: coordinator o member");
                    return;
                }

                // Get current member to check if they are creator
                // Get ALL members including suspended (for admin actions)
                const membersResult = await dbPostgres.pool.query(
                    "SELECT user_id, role, status FROM group_members WHERE group_id = $1 AND status != $2",
                    [groupId, "left"]
                );
                const members = membersResult.rows;
                const targetMember = members.find(m => m.user_id === userId);
                
                if (!targetMember) {
                    sendError(res, 404, "Miembro no encontrado");
                    return;
                }

                if (targetMember.role === "creator") {
                    sendError(res, 403, "No se puede cambiar el rol del creador del grupo");
                    return;
                }

                // Update member role
                await db.updateGroupMember(groupId, userId, { role });

                sendSuccess(res, {
                    message: "Rol actualizado exitosamente",
                    member: {
                        user_id: userId,
                        new_role: role
                    }
                });
            } catch (error) {
                log("error", "Error changing member role", { error: error.message });
                sendError(res, 500, "Error al cambiar rol del miembro");
            }
            return;
        }

        // Change member status - suspend/activate (PATCH /api/groups/:groupId/members/:userId/status)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/status$/) && method === "PATCH") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const userId = parts[5];
            const { status, changed_by } = body;

            log("info", "Changing member status", { groupId, userId, newStatus: status });

            try {
                // Validate status
                if (!["active", "suspended"].includes(status)) {
                    sendError(res, 400, "Estado invalido. Use: active o suspended");
                    return;
                }

                // Get current member to check if they are creator
                // Get ALL members including suspended (for admin actions)
                const membersResult = await dbPostgres.pool.query(
                    "SELECT user_id, role, status FROM group_members WHERE group_id = $1 AND status != $2",
                    [groupId, "left"]
                );
                const members = membersResult.rows;
                const targetMember = members.find(m => m.user_id === userId);
                
                if (!targetMember) {
                    sendError(res, 404, "Miembro no encontrado");
                    return;
                }

                if (targetMember.role === "creator") {
                    sendError(res, 403, "No se puede suspender al creador del grupo");
                    return;
                }

                // Update member status
                await db.updateGroupMember(groupId, userId, { status });

                sendSuccess(res, {
                    message: status === "suspended" ? "Miembro suspendido" : "Miembro activado",
                    member: {
                        user_id: userId,
                        new_status: status
                    }
                });
            } catch (error) {
                log("error", "Error changing member status", { error: error.message });
                sendError(res, 500, "Error al cambiar estado del miembro");
            }
            return;
        }

        // Remove member from group (DELETE /api/groups/:groupId/members/:userId)
        // Delete group (DELETE /api/groups/:groupId)
        if (pathname.match(/^\/api\/groups\/[^\/]+$/) && method === "DELETE") {
            const groupId = pathname.split("/").pop();
            const userId = query.user_id;
            
            log("info", "Delete group request", { groupId, userId });
            
            try {
                // 1. Verificar que el usuario es admin del grupo
                const groupResult = await dbPostgres.pool.query(
                    "SELECT * FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }
                
                const group = groupResult.rows[0];
                
                if (group.admin_id !== userId) {
                    sendError(res, 403, "Solo el administrador puede eliminar el grupo");
                    return;
                }
                
                // 2. Verificar si hay contribuciones (skip if force=true)
                const forceDelete = query.force === 'true';
                
                const contributionsResult = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count FROM contributions WHERE group_id = $1",
                    [groupId]
                );
                
                const hasContributions = parseInt(contributionsResult.rows[0].count) > 0;
                
                if (hasContributions && !forceDelete) {
                    sendError(res, 400, "No se puede eliminar un grupo con contribuciones. Use force=true para eliminar grupos de prueba.");
                    return;
                }
                
                // If force delete, remove contributions first
                if (hasContributions && forceDelete) {
                    log("warn", "Force deleting group with contributions", { groupId, contributionCount: contributionsResult.rows[0].count });
                    await dbPostgres.pool.query("DELETE FROM contributions WHERE group_id = $1", [groupId]);
                }
                
                // 3. Eliminar tandas asociadas
                await dbPostgres.pool.query(
                    "DELETE FROM tandas WHERE group_id = $1",
                    [groupId]
                );
                
                // 4. Eliminar miembros del grupo
                await dbPostgres.pool.query(
                    "DELETE FROM group_members WHERE group_id = $1",
                    [groupId]
                );
                
                // 5. Eliminar el grupo
                await dbPostgres.pool.query(
                    "DELETE FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                // 6. Eliminar de JSON backup
                const jsonIndex = database.groups.findIndex(g => g.id === groupId);
                if (jsonIndex > -1) {
                    database.groups.splice(jsonIndex, 1);
                    saveDatabase();
                }
                
                log("info", "Group deleted successfully", { groupId });
                sendSuccess(res, { message: "Grupo eliminado exitosamente", group_id: groupId });
                return;
                
            } catch (error) {
                log("error", "Error deleting group", { groupId, error: error.message });
                sendError(res, "Error al eliminar el grupo: " + error.message, 500);
                return;
            }
        }


        


        // ============================================

        // ============================================

        // ============================================

        // GET /api/groups/:groupId/payouts - Get group payouts (Coordinator sees all, member sees own)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/payouts$/) && method === "GET") {
            const groupId = pathname.split("/")[3];
            const requesterId = query.user_id;

            log("info", "Fetching group payouts", { groupId, requesterId });

            try {
                // Check if requester is coordinator
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id,  name FROM groups WHERE group_id = $1",
                    [groupId]
                );

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                const group = groupResult.rows[0];
                const isCoordinator = group.admin_id === requesterId || false;

                // Also check role in group_members
                let hasCoordinatorRole = false;
                const roleCheck = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = 'active'",
                    [groupId, requesterId]
                );
                if (roleCheck.rows.length > 0 && ['admin', 'coordinator', 'creator'].includes(roleCheck.rows[0].role)) {
                    hasCoordinatorRole = true;
                }

                const canSeeAll = isCoordinator || hasCoordinatorRole;

                // Build query based on role
                let queryStr = `
                    SELECT
                        pr.*,
                        u.name as user_name,
                        u.email as user_email,
                        upm.method_type,
                        upm.account_number,
                        upm.bank_name
                    FROM payout_requests pr
                    LEFT JOIN users u ON pr.user_id = u.user_id
                    LEFT JOIN user_payout_methods upm ON pr.payout_method_id = upm.id
                    WHERE pr.group_id = $1
                `;
                const params = [groupId];

                // If not coordinator, only show own payouts
                if (!canSeeAll) {
                    queryStr += " AND pr.user_id = $2";
                    params.push(requesterId);
                }

                queryStr += " ORDER BY pr.created_at DESC LIMIT 50";

                const result = await dbPostgres.pool.query(queryStr, params);

                // Calculate stats
                const payouts = result.rows;
                const stats = {
                    total: payouts.length,
                    pending: payouts.filter(p => p.status === 'pending').length,
                    approved: payouts.filter(p => p.status === 'approved').length,
                    processed: payouts.filter(p => p.status === 'processed').length,
                    completed: payouts.filter(p => p.status === 'completed').length,
                    rejected: payouts.filter(p => p.status === 'rejected').length,
                    total_amount: payouts.filter(p => ['approved', 'processed', 'completed'].includes(p.status))
                        .reduce((sum, p) => sum + parseFloat(p.net_amount || 0), 0)
                };

                sendSuccess(res, {
                    payouts: payouts,
                    stats: stats,
                    is_coordinator: canSeeAll,
                    group_name: group.name
                });

            } catch (err) {
                log("error", "Error fetching group payouts", { error: err.message });
                sendError(res, 500, "Error al obtener payouts: " + err.message);
            }
            return;
        }


                // DISPUTES SYSTEM ENDPOINTS
        // ============================================

        // POST /api/disputes - Create a new dispute (Member)
        if (pathname === "/api/disputes" && method === "POST") {
            const { user_id, group_id, payment_id, payout_request_id, type, description, evidence_url } = body;

            log("info", "Creating dispute", { user_id, group_id, type });

            if (!user_id || !group_id || !type || !description) {
                sendError(res, 400, "user_id, group_id, type y description son requeridos");
                return;
            }

            try {
                // Verify user is member of the group
                const memberCheck = await dbPostgres.pool.query(
                    "SELECT id FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = 'active'",
                    [group_id, user_id]
                );

                if (memberCheck.rows.length === 0) {
                    sendError(res, 403, "No eres miembro activo de este grupo");
                    return;
                }

                // Check for existing pending dispute on same payment
                if (payment_id || payout_request_id) {
                    const existingDispute = await dbPostgres.pool.query(
                        "SELECT id FROM disputes WHERE user_id = $1 AND (payment_id = $2 OR payout_request_id = $3) AND status IN ('pending', 'in_review')",
                        [user_id, payment_id, payout_request_id]
                    );

                    if (existingDispute.rows.length > 0) {
                        sendError(res, 400, "Ya tienes una disputa pendiente para este pago");
                        return;
                    }
                }

                // Create dispute
                const result = await dbPostgres.pool.query(
                    `INSERT INTO disputes (group_id, user_id, payment_id, payout_request_id, type, description, evidence_url, status)
                     VALUES ($1, $2, $3, $4, $5, $6, $7, 'pending')
                     RETURNING *`,
                    [group_id, user_id, payment_id || null, payout_request_id || null, type, description, evidence_url || null]
                );

                const dispute = result.rows[0];

                // Notify coordinator
                try {
                    const groupResult = await dbPostgres.pool.query(
                        "SELECT admin_id, name FROM groups WHERE group_id = $1",
                        [group_id]
                    );

                    if (groupResult.rows.length > 0) {
                        const group = groupResult.rows[0];
                        await notificationsUtils.createNotification(
                            dbPostgres.pool,
                            group.admin_id,
                            'dispute_created',
                            'Nueva disputa reportada',
                            'Un miembro ha reportado un problema en el grupo "' + group.name + '". Tipo: ' + type,
                            { dispute_id: dispute.id, group_id, type }
                        );
                    }
                } catch (notifErr) {
                    console.error('Error notifying coordinator:', notifErr);
                }

                log("info", "Dispute created", { dispute_id: dispute.id });
                sendSuccess(res, { dispute, message: "Disputa creada exitosamente" });

            } catch (err) {
                log("error", "Error creating dispute", { error: err.message });
                sendError(res, 500, "Error al crear disputa: " + err.message);
            }
            return;
        }

        // GET /api/disputes - Get user's disputes
        if (pathname === "/api/disputes" && method === "GET") {
            const userId = query.user_id;
            const status = query.status;

            if (!userId) {
                sendError(res, 400, "user_id es requerido");
                return;
            }

            try {
                let queryStr = `
                    SELECT d.*, g.name as group_name
                    FROM disputes d
                    LEFT JOIN groups g ON d.group_id = g.group_id
                    WHERE d.user_id = $1
                `;
                const params = [userId];

                if (status && status !== 'all') {
                    queryStr += " AND d.status = $2";
                    params.push(status);
                }

                queryStr += " ORDER BY d.created_at DESC";

                const result = await dbPostgres.pool.query(queryStr, params);

                sendSuccess(res, {
                    disputes: result.rows,
                    total: result.rows.length
                });

            } catch (err) {
                log("error", "Error fetching disputes", { error: err.message });
                sendError(res, 500, "Error al obtener disputas: " + err.message);
            }
            return;
        }

        // GET /api/groups/:groupId/disputes - Get group disputes (Coordinator only)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/disputes$/) && method === "GET") {
            const groupId = pathname.split("/")[3];
            const requesterId = query.user_id;

            log("info", "Fetching group disputes", { groupId, requesterId });

            try {
                // Verify requester is coordinator
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id FROM groups WHERE group_id = $1",
                    [groupId]
                );

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                const group = groupResult.rows[0];
                const isCoordinator = group.admin_id === requesterId || false;

                if (!isCoordinator) {
                    // Check role in group_members
                    const roleCheck = await dbPostgres.pool.query(
                        "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = 'active'",
                        [groupId, requesterId]
                    );

                    if (roleCheck.rows.length === 0 || !['admin', 'coordinator', 'creator'].includes(roleCheck.rows[0].role)) {
                        sendError(res, 403, "Solo el coordinador puede ver las disputas del grupo");
                        return;
                    }
                }

                // Fetch disputes with user info
                const result = await dbPostgres.pool.query(`
                    SELECT d.*, u.name as user_name, u.email as user_email
                    FROM disputes d
                    LEFT JOIN users u ON d.user_id = u.user_id
                    WHERE d.group_id = $1
                    ORDER BY
                        CASE d.status
                            WHEN 'pending' THEN 1
                            WHEN 'in_review' THEN 2
                            ELSE 3
                        END,
                        d.created_at DESC
                `, [groupId]);

                const pending = result.rows.filter(d => d.status === 'pending').length;
                const inReview = result.rows.filter(d => d.status === 'in_review').length;

                sendSuccess(res, {
                    disputes: result.rows,
                    total: result.rows.length,
                    pending_count: pending,
                    in_review_count: inReview
                });

            } catch (err) {
                log("error", "Error fetching group disputes", { error: err.message });
                sendError(res, 500, "Error al obtener disputas: " + err.message);
            }
            return;
        }

        // PUT /api/disputes/:id/resolve - Resolve a dispute (Coordinator)
        if (pathname.match(/^\/api\/disputes\/[^\/]+\/resolve$/) && method === "PUT") {
            const disputeId = pathname.split("/")[3];
            const { coordinator_id, status, resolution } = body;

            log("info", "Resolving dispute", { disputeId, coordinator_id, status });

            if (!coordinator_id || !status || !resolution) {
                sendError(res, 400, "coordinator_id, status y resolution son requeridos");
                return;
            }

            if (!['resolved', 'rejected'].includes(status)) {
                sendError(res, 400, "Status debe ser 'resolved' o 'rejected'");
                return;
            }

            try {
                // Get dispute and verify coordinator
                const disputeResult = await dbPostgres.pool.query(
                    "SELECT d.*, g.admin_id, g. g.name as group_name FROM disputes d JOIN groups g ON d.group_id = g.group_id WHERE d.id = $1",
                    [disputeId]
                );

                if (disputeResult.rows.length === 0) {
                    sendError(res, 404, "Disputa no encontrada");
                    return;
                }

                const dispute = disputeResult.rows[0];
                const isCoordinator = dispute.admin_id === coordinator_id ;

                if (!isCoordinator) {
                    sendError(res, 403, "Solo el coordinador puede resolver disputas");
                    return;
                }

                if (['resolved', 'rejected'].includes(dispute.status)) {
                    sendError(res, 400, "Esta disputa ya fue resuelta");
                    return;
                }

                // Update dispute
                const updateResult = await dbPostgres.pool.query(`
                    UPDATE disputes
                    SET status = $1, resolution = $2, resolved_by = $3, resolved_at = NOW(), updated_at = NOW()
                    WHERE id = $4
                    RETURNING *
                `, [status, resolution, coordinator_id, disputeId]);

                // Notify user
                try {
                    await notificationsUtils.createNotification(
                        dbPostgres.pool,
                        dispute.user_id,
                        'dispute_resolved',
                        status === 'resolved' ? 'Disputa resuelta' : 'Disputa rechazada',
                        'Tu disputa en "' + dispute.group_name + '" ha sido ' + (status === 'resolved' ? 'resuelta' : 'rechazada') + '. ' + resolution,
                        { dispute_id: disputeId, status, resolution }
                    );
                } catch (notifErr) {
                    console.error('Error notifying user:', notifErr);
                }

                log("info", "Dispute resolved", { disputeId, status });
                sendSuccess(res, {
                    dispute: updateResult.rows[0],
                    message: "Disputa " + (status === 'resolved' ? 'resuelta' : 'rechazada')
                });

            } catch (err) {
                log("error", "Error resolving dispute", { error: err.message });
                sendError(res, 500, "Error al resolver disputa: " + err.message);
            }
            return;
        }

        // PUT /api/disputes/:id/status - Update dispute status (Coordinator)
        if (pathname.match(/^\/api\/disputes\/[^\/]+\/status$/) && method === "PUT") {
            const disputeId = pathname.split("/")[3];
            const { coordinator_id, status } = body;

            if (!coordinator_id || !status) {
                sendError(res, 400, "coordinator_id y status son requeridos");
                return;
            }

            try {
                // Get dispute
                const disputeResult = await dbPostgres.pool.query(
                    "SELECT d.*, g.admin_id, g.admin_id as created_by FROM disputes d JOIN groups g ON d.group_id = g.group_id WHERE d.id = $1",
                    [disputeId]
                );

                if (disputeResult.rows.length === 0) {
                    sendError(res, 404, "Disputa no encontrada");
                    return;
                }

                const dispute = disputeResult.rows[0];
                const isCoordinator = dispute.admin_id === coordinator_id ;

                if (!isCoordinator) {
                    sendError(res, 403, "Solo el coordinador puede actualizar disputas");
                    return;
                }

                // Update status
                const updateResult = await dbPostgres.pool.query(
                    "UPDATE disputes SET status = $1, updated_at = NOW() WHERE id = $2 RETURNING *",
                    [status, disputeId]
                );

                sendSuccess(res, { dispute: updateResult.rows[0] });

            } catch (err) {
                log("error", "Error updating dispute status", { error: err.message });
                sendError(res, 500, "Error al actualizar disputa: " + err.message);
            }
            return;
        }


                // COORDINATOR MEMBER MANAGEMENT ENDPOINTS
        // ============================================

        // GET /api/groups/:groupId/pending-members - Get pending member requests (Coordinator only)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/pending-members$/) && method === "GET") {
            const groupId = pathname.split("/")[3];
            const requesterId = query.user_id;

            log("info", "Fetching pending members for group", { groupId, requesterId });

            try {
                // 1. Verify requester is coordinator/admin of this group
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id FROM groups WHERE group_id = $1",
                    [groupId]
                );

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                const group = groupResult.rows[0];
                const isCoordinator = group.admin_id === requesterId || false;

                // Also check if user has coordinator role in group_members
                const roleCheck = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = 'active'",
                    [groupId, requesterId]
                );

                const hasCoordinatorRole = roleCheck.rows.length > 0 &&
                    ['admin', 'coordinator', 'creator'].includes(roleCheck.rows[0].role);

                if (!isCoordinator && !hasCoordinatorRole) {
                    sendError(res, 403, "Solo el coordinador puede ver solicitudes pendientes");
                    return;
                }

                // 2. Fetch pending members
                const pendingResult = await dbPostgres.pool.query(`
                    SELECT
                        gm.id,
                        gm.user_id,
                        gm.display_name,
                        gm.joined_at as requested_at,
                        gm.notes,
                        u.name as user_name,
                        u.email as user_email,
                        u.phone as user_phone,
                        u.avatar_url as profile_image_url
                    FROM group_members gm
                    LEFT JOIN users u ON gm.user_id = u.user_id
                    WHERE gm.group_id = $1 AND gm.status = 'pending'
                    ORDER BY gm.joined_at ASC
                `, [groupId]);

                sendSuccess(res, {
                    pending_members: pendingResult.rows,
                    total: pendingResult.rows.length,
                    group_id: groupId
                });

            } catch (err) {
                log("error", "Error fetching pending members", { groupId, error: err.message });
                sendError(res, 500, "Error al obtener solicitudes: " + err.message);
            }
            return;
        }

        // POST /api/groups/:groupId/members/:memberId/approve - Approve member request (Coordinator only)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/approve$/) && method === "POST") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const memberId = parts[5];
            const { coordinator_id, position } = body;

            log("info", "Approving member request", { groupId, memberId, coordinator_id });

            try {
                // 1. Verify requester is coordinator
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id,  name, max_members FROM groups WHERE group_id = $1",
                    [groupId]
                );

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                const group = groupResult.rows[0];
                const isCoordinator = group.admin_id === coordinator_id ;

                const roleCheck = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = 'active'",
                    [groupId, coordinator_id]
                );

                const hasCoordinatorRole = roleCheck.rows.length > 0 &&
                    ['admin', 'coordinator', 'creator'].includes(roleCheck.rows[0].role);

                if (!isCoordinator && !hasCoordinatorRole) {
                    sendError(res, 403, "Solo el coordinador puede aprobar solicitudes");
                    return;
                }

                // 2. Check member exists and is pending
                const memberResult = await dbPostgres.pool.query(
                    "SELECT * FROM group_members WHERE group_id = $1 AND user_id = $2",
                    [groupId, memberId]
                );

                if (memberResult.rows.length === 0) {
                    sendError(res, 404, "Solicitud no encontrada");
                    return;
                }

                if (memberResult.rows[0].status !== 'pending') {
                    sendError(res, 400, "Esta solicitud ya fue procesada");
                    return;
                }

                // 3. Check group capacity
                const activeCount = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count FROM group_members WHERE group_id = $1 AND status = 'active'",
                    [groupId]
                );

                if (parseInt(activeCount.rows[0].count) >= group.max_members) {
                    sendError(res, 400, "El grupo ha alcanzado su capacidad maxima");
                    return;
                }

                // 4. Approve the member
                const approveResult = await dbPostgres.pool.query(`
                    UPDATE group_members
                    SET status = 'active',
                        approved_by = $1,
                        approved_at = NOW(),
                        position = $2,
                        updated_at = NOW()
                    WHERE group_id = $3 AND user_id = $4
                    RETURNING *
                `, [coordinator_id, position || null, groupId, memberId]);

                // 5. Update group member count
                await dbPostgres.pool.query(`
                    UPDATE groups
                    SET member_count = (SELECT COUNT(*) FROM group_members WHERE group_id = $1 AND status = 'active'),
                        updated_at = NOW()
                    WHERE group_id = $1
                `, [groupId]);

                // 6. Send notification to approved user
                try {
                    await notificationsUtils.createNotification(
                        dbPostgres.pool,
                        memberId,
                        'member_approved',
                        'Bienvenido al grupo!',
                        'Tu solicitud para unirte a "' + group.name + '" ha sido aprobada.',
                        { group_id: groupId, group_name: group.name }
                    );

                    // Send email notification
                    const userResult = await dbPostgres.pool.query(
                        'SELECT email, name FROM users WHERE user_id = $1',
                        [memberId]
                    );
                    if (userResult.rows.length > 0 && userResult.rows[0].email) {
                        await sendEmail(
                            userResult.rows[0].email,
                            'Tu solicitud fue aprobada! - La Tanda',
                            '<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">' +
                                '<h2 style="color: #16a34a;">Bienvenido a ' + group.name + '!</h2>' +
                                '<p>Hola ' + (userResult.rows[0].name || 'Usuario') + ',</p>' +
                                '<p>Tu solicitud para unirte al grupo <strong>' + group.name + '</strong> ha sido aprobada.</p>' +
                                '<p>Ya puedes participar en las tandas del grupo.</p>' +
                                '<a href="https://latanda.online" style="display: inline-block; background: #16a34a; color: white; padding: 12px 24px; border-radius: 8px; text-decoration: none; margin-top: 16px;">Ir a La Tanda</a>' +
                            '</div>',
                            'notificaciones'
                        );
                    }
                } catch (notifError) {
                    console.error('Error sending approval notification:', notifError);
                }

                log("info", "Member approved successfully", { groupId, memberId });
                sendSuccess(res, {
                    member: approveResult.rows[0],
                    message: "Miembro aprobado exitosamente"
                });

            } catch (err) {
                log("error", "Error approving member", { groupId, memberId, error: err.message });
                sendError(res, 500, "Error al aprobar miembro: " + err.message);
            }
            return;
        }

        // POST /api/groups/:groupId/members/:memberId/reject - Reject member request (Coordinator only)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/reject$/) && method === "POST") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const memberId = parts[5];
            const { coordinator_id, reason } = body;

            log("info", "Rejecting member request", { groupId, memberId, coordinator_id, reason });

            try {
                // 1. Verify requester is coordinator
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id,  name FROM groups WHERE group_id = $1",
                    [groupId]
                );

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                const group = groupResult.rows[0];
                const isCoordinator = group.admin_id === coordinator_id ;

                const roleCheck = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = 'active'",
                    [groupId, coordinator_id]
                );

                const hasCoordinatorRole = roleCheck.rows.length > 0 &&
                    ['admin', 'coordinator', 'creator'].includes(roleCheck.rows[0].role);

                if (!isCoordinator && !hasCoordinatorRole) {
                    sendError(res, 403, "Solo el coordinador puede rechazar solicitudes");
                    return;
                }

                // 2. Check member exists and is pending
                const memberResult = await dbPostgres.pool.query(
                    "SELECT * FROM group_members WHERE group_id = $1 AND user_id = $2",
                    [groupId, memberId]
                );

                if (memberResult.rows.length === 0) {
                    sendError(res, 404, "Solicitud no encontrada");
                    return;
                }

                if (memberResult.rows[0].status !== 'pending') {
                    sendError(res, 400, "Esta solicitud ya fue procesada");
                    return;
                }

                // 3. Reject the member (delete or mark as rejected)
                await dbPostgres.pool.query(`
                    DELETE FROM group_members
                    WHERE group_id = $1 AND user_id = $2 AND status = 'pending'
                `, [groupId, memberId]);

                // 4. Send notification to rejected user
                try {
                    await notificationsUtils.createNotification(
                        dbPostgres.pool,
                        memberId,
                        'member_rejected',
                        'Solicitud no aprobada',
                        'Tu solicitud para unirte a "' + group.name + '" no fue aprobada.' + (reason ? ' Razon: ' + reason : ''),
                        { group_id: groupId, group_name: group.name, reason: reason }
                    );
                } catch (notifError) {
                    console.error('Error sending rejection notification:', notifError);
                }

                log("info", "Member rejected successfully", { groupId, memberId, reason });
                sendSuccess(res, {
                    message: "Solicitud rechazada",
                    user_id: memberId,
                    group_id: groupId
                });

            } catch (err) {
                log("error", "Error rejecting member", { groupId, memberId, error: err.message });
                sendError(res, 500, "Error al rechazar solicitud: " + err.message);
            }
            return;
        }

        // DELETE /api/groups/:groupId/members/:memberId/remove - Remove active member (Coordinator only)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/remove$/) && method === "DELETE") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const memberId = parts[5];
            const coordinator_id = query.coordinator_id || query.user_id;
            const reason = query.reason || body?.reason;

            log("info", "Removing member from group", { groupId, memberId, coordinator_id });

            try {
                // 1. Verify requester is coordinator
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id,  name FROM groups WHERE group_id = $1",
                    [groupId]
                );

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                const group = groupResult.rows[0];

                // Cannot remove yourself if you are the admin
                if (memberId === group.admin_id ) {
                    sendError(res, 400, "No puedes remover al administrador del grupo");
                    return;
                }

                const isCoordinator = group.admin_id === coordinator_id ;

                const roleCheck = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = 'active'",
                    [groupId, coordinator_id]
                );

                const hasCoordinatorRole = roleCheck.rows.length > 0 &&
                    ['admin', 'coordinator', 'creator'].includes(roleCheck.rows[0].role);

                if (!isCoordinator && !hasCoordinatorRole) {
                    sendError(res, 403, "Solo el coordinador puede remover miembros");
                    return;
                }

                // 2. Check member exists
                const memberResult = await dbPostgres.pool.query(
                    "SELECT * FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = 'active'",
                    [groupId, memberId]
                );

                if (memberResult.rows.length === 0) {
                    sendError(res, 404, "Miembro no encontrado en el grupo");
                    return;
                }

                // 3. Check for pending contributions
                const pendingContribs = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count FROM contributions WHERE group_id = $1 AND user_id = $2 AND status IN ('pending', 'processing')",
                    [groupId, memberId]
                );

                if (parseInt(pendingContribs.rows[0].count) > 0) {
                    sendError(res, 400, "El miembro tiene contribuciones pendientes. Debe resolverlas primero.");
                    return;
                }

                // 4. Mark member as removed (soft delete)
                await dbPostgres.pool.query(`
                    UPDATE group_members
                    SET status = 'removed',
                        removed_by = $1,
                        removed_at = NOW(),
                        removal_reason = $2,
                        updated_at = NOW()
                    WHERE group_id = $3 AND user_id = $4
                `, [coordinator_id, reason || 'Removido por coordinador', groupId, memberId]);

                // 5. Update group member count
                await dbPostgres.pool.query(`
                    UPDATE groups
                    SET member_count = (SELECT COUNT(*) FROM group_members WHERE group_id = $1 AND status = 'active'),
                        updated_at = NOW()
                    WHERE group_id = $1
                `, [groupId]);

                // 6. Send notification to removed user
                try {
                    await notificationsUtils.createNotification(
                        dbPostgres.pool,
                        memberId,
                        'member_removed',
                        'Has sido removido del grupo',
                        'Has sido removido del grupo "' + group.name + '".' + (reason ? ' Razon: ' + reason : ''),
                        { group_id: groupId, group_name: group.name, reason: reason }
                    );

                    // Send email notification
                    const userResult = await dbPostgres.pool.query(
                        'SELECT email, name FROM users WHERE user_id = $1',
                        [memberId]
                    );
                    if (userResult.rows.length > 0 && userResult.rows[0].email) {
                        await sendEmail(
                            userResult.rows[0].email,
                            'Notificacion de La Tanda',
                            '<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">' +
                                '<h2 style="color: #dc2626;">Actualizacion de membresia</h2>' +
                                '<p>Hola ' + (userResult.rows[0].name || 'Usuario') + ',</p>' +
                                '<p>Te informamos que has sido removido del grupo <strong>' + group.name + '</strong>.</p>' +
                                (reason ? '<p><strong>Razon:</strong> ' + reason + '</p>' : '') +
                                '<p>Si crees que esto fue un error, contacta al coordinador del grupo.</p>' +
                            '</div>',
                            'notificaciones'
                        );
                    }
                } catch (notifError) {
                    console.error('Error sending removal notification:', notifError);
                }

                log("info", "Member removed successfully", { groupId, memberId, reason });
                sendSuccess(res, {
                    message: "Miembro removido exitosamente",
                    user_id: memberId,
                    group_id: groupId
                });

            } catch (err) {
                log("error", "Error removing member", { groupId, memberId, error: err.message });
                sendError(res, 500, "Error al remover miembro: " + err.message);
            }
            return;
        }


                // MEMBER ACTION ENDPOINTS
        // ============================================
        
        // Toggle anonymous mode (PUT /api/groups/:groupId/members/:userId/anonymous)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/anonymous$/) && method === "PUT") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const userId = parts[5];
            
            log("info", "Toggle anonymous request", { groupId, userId });
            
            try {
                const { is_anonymous } = body;
                
                await dbPostgres.pool.query(
                    "UPDATE group_members SET is_anonymous = $1 WHERE group_id = $2 AND user_id = $3",
                    [is_anonymous, groupId, userId]
                );
                
                sendSuccess(res, { 
                    message: is_anonymous ? "Nombre oculto" : "Nombre visible",
                    is_anonymous: is_anonymous
                });
                return;
                
            } catch (error) {
                log("error", "Error toggling anonymous", { error: error.message });
                sendError(res, "Error al cambiar modo anonimo", 500);
                return;
            }
        }
        
        // Check if member can leave (GET /api/groups/:groupId/members/:userId/can-leave)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/can-leave$/) && method === "GET") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const userId = parts[5];
            
            log("info", "Check can leave request", { groupId, userId });
            
            try {
                // Check for pending payments/contributions
                const pendingResult = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count FROM contributions WHERE group_id = $1 AND user_id = $2 AND status = 'pending'",
                    [groupId, userId]
                );
                
                const hasPending = parseInt(pendingResult.rows[0].count) > 0;
                
                if (hasPending) {
                    sendSuccess(res, { 
                        can_leave: false, 
                        reason: "Tienes pagos pendientes en este grupo" 
                    });
                    return;
                }
                
                // Check if user is creator
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                if (groupResult.rows.length > 0 && groupResult.rows[0].admin_id === userId) {
                    sendSuccess(res, { 
                        can_leave: false, 
                        reason: "Eres el creador. Debes transferir la propiedad primero." 
                    });
                    return;
                }
                
                sendSuccess(res, { can_leave: true });
                return;
                
            } catch (error) {
                log("error", "Error checking can leave", { error: error.message });
                sendError(res, "Error al verificar", 500);
                return;
            }
        }
        
        // Leave group (DELETE /api/groups/:groupId/members/:userId)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+$/) && method === "DELETE") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const userId = parts[5];
            
            log("info", "Leave group request", { groupId, userId });
            
            try {
                // Check for pending payments first
                const pendingResult = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count FROM contributions WHERE group_id = $1 AND user_id = $2 AND status = 'pending'",
                    [groupId, userId]
                );
                
                if (parseInt(pendingResult.rows[0].count) > 0) {
                    sendError(res, "No puedes salir: tienes pagos pendientes", 400);
                    return;
                }
                
                // Check if user is creator
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                if (groupResult.rows.length > 0 && groupResult.rows[0].admin_id === userId) {
                    sendError(res, "Eres el creador. Debes transferir la propiedad primero.", 400);
                    return;
                }
                
                // Update member status to 'left'
                await dbPostgres.pool.query(
                    "UPDATE group_members SET status = 'left', left_at = NOW() WHERE group_id = $1 AND user_id = $2",
                    [groupId, userId]
                );
                
                log("info", "Member left group", { groupId, userId });
                sendSuccess(res, { message: "Has salido del grupo exitosamente" });
                return;
                
            } catch (error) {
                log("error", "Error leaving group", { error: error.message });
                sendError(res, "Error al salir del grupo", 500);
                return;
            }
        }
        
        // Create role request (POST /api/groups/:groupId/role-requests)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/role-requests$/) && method === "POST") {
            const groupId = pathname.split("/")[3];
            
            log("info", "Role request", { groupId, body });
            
            try {
                const { user_id, requested_role, reason } = body;
                
                // Check if already has pending request
                const existingResult = await dbPostgres.pool.query(
                    "SELECT id FROM role_requests WHERE group_id = $1 AND user_id = $2 AND status = 'pending'",
                    [groupId, user_id]
                );
                
                if (existingResult.rows.length > 0) {
                    sendError(res, "Ya tienes una solicitud pendiente", 400);
                    return;
                }
                
                // Create request
                await dbPostgres.pool.query(
                    "INSERT INTO role_requests (group_id, user_id, requested_role, reason, status) VALUES ($1, $2, $3, $4, 'pending')",
                    [groupId, user_id, requested_role, reason || '']
                );
                
                log("info", "Role request created", { groupId, user_id, requested_role });
                sendSuccess(res, { message: "Solicitud enviada exitosamente" });
                return;
                
            } catch (error) {
                log("error", "Error creating role request", { error: error.message });
                sendError(res, "Error al enviar solicitud", 500);
                return;
            }
        }
        
        // Transfer ownership (POST /api/groups/:groupId/transfer-ownership)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/transfer-ownership$/) && method === "POST") {
            const groupId = pathname.split("/")[3];
            
            log("info", "Transfer ownership request", { groupId, body });
            
            try {
                const { new_owner_id } = body;
                
                // Get current owner
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }
                
                const oldOwnerId = groupResult.rows[0].admin_id;
                
                // Verify new owner is a member
                const memberResult = await dbPostgres.pool.query(
                    "SELECT id FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = 'active'",
                    [groupId, new_owner_id]
                );
                
                if (memberResult.rows.length === 0) {
                    sendError(res, "El usuario seleccionado no es miembro activo del grupo", 400);
                    return;
                }
                
                // Update group admin
                await dbPostgres.pool.query(
                    "UPDATE groups SET admin_id = $1 WHERE group_id = $2",
                    [new_owner_id, groupId]
                );
                
                // Update old owner role to 'member'
                await dbPostgres.pool.query(
                    "UPDATE group_members SET role = 'member' WHERE group_id = $1 AND user_id = $2",
                    [groupId, oldOwnerId]
                );
                
                // Update new owner role to 'creator'
                await dbPostgres.pool.query(
                    "UPDATE group_members SET role = 'creator' WHERE group_id = $1 AND user_id = $2",
                    [groupId, new_owner_id]
                );
                
                log("info", "Ownership transferred", { groupId, oldOwnerId, new_owner_id });
                sendSuccess(res, { message: "Propiedad transferida exitosamente" });
                return;
                
            } catch (error) {
                log("error", "Error transferring ownership", { error: error.message });
                sendError(res, "Error al transferir propiedad", 500);
                return;
            }
        }

        // Reorder turns (PUT /api/groups/:groupId/reorder-turns)
        // Supports is_locked flag for lottery-protected positions
        if (pathname.match(/^\/api\/groups\/[^\/]+\/reorder-turns$/) && method === "PUT") {
            const groupId = pathname.split("/")[3];
            const coordinatorId = query.user_id || body.coordinator_id;
            
            log("info", "Reorder turns request", { groupId, coordinatorId });
            
            try {
                const { member_turns } = body;
                
                if (!member_turns || !Array.isArray(member_turns)) {
                    sendError(res, 400, "member_turns debe ser un array");
                    return;
                }
                
                // Update each member turn position with lock status
                for (const turn of member_turns) {
                    const isLocked = turn.is_locked === true;
                    const lockedBy = isLocked ? coordinatorId : null;
                    const lockedAt = isLocked ? new Date() : null;
                    
                    await dbPostgres.pool.query(
                        `UPDATE group_members 
                         SET turn_position = $1, 
                             turn_locked = $2,
                             turn_locked_by = $3,
                             turn_locked_at = $4,
                             updated_at = NOW()
                         WHERE group_id = $5 AND user_id = $6`,
                        [turn.new_position, isLocked, lockedBy, lockedAt, groupId, turn.user_id]
                    );
                }
                
                // Also update turns_order in tandas table if exists
                try {
                    const tandaResult = await dbPostgres.pool.query(
                        "SELECT tanda_id FROM tandas WHERE group_id = $1",
                        [groupId]
                    );
                    
                    if (tandaResult.rows.length > 0) {
                        const tandaId = tandaResult.rows[0].tanda_id;
                        
                        // Build turns_order array from sorted positions
                        const sortedTurns = [...member_turns].sort((a, b) => a.new_position - b.new_position);
                        const turnsOrder = sortedTurns.map(t => t.user_id);
                        
                        await dbPostgres.pool.query(
                            "UPDATE tandas SET turns_order = $1, updated_at = NOW() WHERE tanda_id = $2",
                            [turnsOrder, tandaId]
                        );
                    }
                } catch (tandaError) {
                    log("warn", "Could not update tanda turns_order", { error: tandaError.message });
                }
                
                log("info", "Turns reordered successfully", { groupId, count: member_turns.length });
                sendSuccess(res, { 
                    message: "Turnos actualizados exitosamente", 
                    updated: member_turns.length,
                    locked_count: member_turns.filter(t => t.is_locked).length
                });
                return;
                
            } catch (error) {
                log("error", "Error reordering turns", { groupId, error: error.message });
                sendError(res, 500, "Error al reordenar turnos: " + error.message);
                return;
            }
        }

        // Lottery assign positions (POST /api/groups/:groupId/lottery-assign)
        // Only assigns to members without locked positions
        if (pathname.match(/^\/api\/groups\/[^\/]+\/lottery-assign$/) && method === "POST") {
            const groupId = pathname.split("/")[3];
            const coordinatorId = query.user_id || body.coordinator_id;
            
            log("info", "Lottery assign request", { groupId, coordinatorId });
            
            try {
                // 1. Verify coordinator permission
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }
                
                if (groupResult.rows[0].admin_id !== coordinatorId) {
                    sendError(res, 403, "Solo el coordinador puede ejecutar la tombola");
                    return;
                }
                
                // 2. Get all active members
                const membersResult = await dbPostgres.pool.query(
                    "SELECT user_id, turn_position, turn_locked, display_name FROM group_members WHERE group_id = $1 AND status = 'active' ORDER BY turn_position ASC NULLS LAST",
                    [groupId]
                );
                
                const allMembers = membersResult.rows;
                const lockedMembers = allMembers.filter(m => m.turn_locked === true);
                const unlockedMembers = allMembers.filter(m => m.turn_locked !== true);
                
                if (unlockedMembers.length === 0) {
                    sendError(res, 400, "No hay miembros sin posicion bloqueada para sortear");
                    return;
                }
                
                // 3. Get locked positions
                const lockedPositions = new Set(lockedMembers.map(m => m.turn_position).filter(p => p !== null));
                
                // 4. Calculate available positions (1 to total members, excluding locked)
                const totalPositions = allMembers.length;
                const availablePositions = [];
                for (let i = 1; i <= totalPositions; i++) {
                    if (!lockedPositions.has(i)) {
                        availablePositions.push(i);
                    }
                }
                
                // 5. Shuffle available positions (Fisher-Yates)
                for (let i = availablePositions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availablePositions[i], availablePositions[j]] = [availablePositions[j], availablePositions[i]];
                }
                
                // 6. Assign shuffled positions to unlocked members
                const assignments = [];
                for (let i = 0; i < unlockedMembers.length && i < availablePositions.length; i++) {
                    const member = unlockedMembers[i];
                    const newPosition = availablePositions[i];
                    
                    await dbPostgres.pool.query(
                        "UPDATE group_members SET turn_position = $1, updated_at = NOW() WHERE group_id = $2 AND user_id = $3",
                        [newPosition, groupId, member.user_id]
                    );
                    
                    assignments.push({
                        user_id: member.user_id,
                        display_name: member.display_name,
                        new_position: newPosition
                    });
                }
                
                // 7. Update turns_order in tandas table
                try {
                    const allUpdatedMembers = await dbPostgres.pool.query(
                        "SELECT user_id FROM group_members WHERE group_id = $1 AND status = 'active' ORDER BY turn_position ASC",
                        [groupId]
                    );
                    const turnsOrder = allUpdatedMembers.rows.map(m => m.user_id);
                    
                    await dbPostgres.pool.query(
                        "UPDATE tandas SET turns_order = $1, updated_at = NOW() WHERE group_id = $2",
                        [turnsOrder, groupId]
                    );
                } catch (tandaError) {
                    log("warn", "Could not update tanda turns_order after lottery", { error: tandaError.message });
                }
                
                log("info", "Lottery completed", { groupId, assigned: assignments.length, locked: lockedMembers.length });
                
                sendSuccess(res, {
                    message: "Tombola completada exitosamente",
                    assignments: assignments.sort((a, b) => a.new_position - b.new_position),
                    locked_count: lockedMembers.length,
                    assigned_count: assignments.length
                });
                return;
                
            } catch (error) {
                log("error", "Error in lottery assign", { groupId, error: error.message });
                sendError(res, 500, "Error en la tombola: " + error.message);
                return;
            }
        }

        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+$/) && method === "DELETE") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const userId = parts[5];

            log("info", "Removing member from group", { groupId, userId });

            try {
                // Get current member to check if they are creator
                // Get ALL members including suspended (for admin actions)
                const membersResult = await dbPostgres.pool.query(
                    "SELECT user_id, role, status FROM group_members WHERE group_id = $1 AND status != $2",
                    [groupId, "left"]
                );
                const members = membersResult.rows;
                const targetMember = members.find(m => m.user_id === userId);
                
                if (!targetMember) {
                    sendError(res, 404, "Miembro no encontrado");
                    return;
                }

                if (targetMember.role === "creator") {
                    sendError(res, 403, "No se puede remover al creador del grupo");
                    return;
                }

                // Remove member (soft delete)
                await db.removeGroupMember(groupId, userId);

                sendSuccess(res, {
                    message: "Miembro removido del grupo exitosamente",
                    removed_user_id: userId
                });
            } catch (error) {
                log("error", "Error removing member", { error: error.message });
                sendError(res, 500, "Error al remover miembro del grupo");
            }
            return;
        }


        // =============================================
        // EXPORT ENDPOINTS - PDF & CSV
        // Added: 2025-11-25
        // =============================================
        
        // GET /api/groups/:groupId/export/payments - Export payments as PDF or CSV
        if (pathname.match(/^\/api\/groups\/[^\/]+\/export\/payments$/) && method === 'GET') {
            const groupId = pathname.split('/')[3];
            const urlParts = url.parse(req.url, true);
            const format = urlParts.query.format || 'pdf';
            
            log('info', 'Exporting payments', { groupId, format });
            
            try {
                const groupResult = await dbPostgres.pool.query(
                    'SELECT * FROM groups WHERE group_id = $1',
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                
                const groupData = groupResult.rows[0];
                
                const paymentsResult = await dbPostgres.pool.query(
                    `SELECT c.*, u.name as member_name, u.email as member_email
                     FROM contributions c
                     LEFT JOIN users u ON c.user_id = u.user_id
                     WHERE c.group_id = $1
                     ORDER BY c.created_at DESC`,
                    [groupId]
                );
                
                const payments = paymentsResult.rows;
                
                let result;
                if (format === 'csv') {
                    result = await exportUtils.generatePaymentsCSV(groupData, payments);
                } else {
                    result = await exportUtils.generatePaymentsPDF(groupData, payments);
                }
                
                const fileContent = fs.readFileSync(result.filepath);
                const contentType = format === 'csv' ? 'text/csv' : 'application/pdf';
                
                res.writeHead(200, {
                    'Content-Type': contentType,
                    'Content-Disposition': 'attachment; filename="' + result.filename + '"',
                    'Content-Length': fileContent.length,
                    'Access-Control-Allow-Origin': '*'
                });
                res.end(fileContent);
                
                setTimeout(function() {
                    try { fs.unlinkSync(result.filepath); } catch(e) {}
                }, 5000);
                
                return;
            } catch (error) {
                log('error', 'Export payments failed', { error: error.message, groupId });
                sendError(res, 500, 'Error al exportar pagos');
                return;
            }
        }
        

        
        // GET /api/groups/:groupId/export/summary - Export group summary as PDF
        if (pathname.match(/^\/api\/groups\/[^\/]+\/export\/summary$/) && method === 'GET') {
            const groupId = pathname.split('/')[3];
            
            log('info', 'Exporting group summary', { groupId });
            
            try {
                const groupResult = await dbPostgres.pool.query(
                    'SELECT * FROM groups WHERE group_id = $1',
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                
                const groupData = groupResult.rows[0];
                
                const membersCount = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count FROM group_members WHERE group_id = $1 AND status = 'active'",
                    [groupId]
                );
                
                const paymentsStats = await dbPostgres.pool.query(
                    `SELECT 
                        COUNT(*) as total_payments,
                        COALESCE(SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END), 0) as total_collected,
                        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_count
                     FROM contributions WHERE group_id = $1`,
                    [groupId]
                );
                
                const ps = paymentsStats.rows[0];
                const totalPayments = parseInt(ps.total_payments) || 0;
                const completedCount = parseInt(ps.completed_count) || 0;
                
                const stats = {
                    memberCount: parseInt(membersCount.rows[0].count) || 0,
                    totalCollected: parseFloat(ps.total_collected) || 0,
                    paymentCount: totalPayments,
                    completionRate: totalPayments > 0 ? Math.round((completedCount / totalPayments) * 100) : 100
                };
                
                const result = await exportUtils.generateSummaryPDF(groupData, stats);
                
                const fileContent = fs.readFileSync(result.filepath);
                
                res.writeHead(200, {
                    'Content-Type': 'application/pdf',
                    'Content-Disposition': 'attachment; filename="' + result.filename + '"',
                    'Content-Length': fileContent.length,
                    'Access-Control-Allow-Origin': '*'
                });
                res.end(fileContent);
                
                setTimeout(function() {
                    try { fs.unlinkSync(result.filepath); } catch(e) {}
                }, 5000);
                
                return;
            } catch (error) {
                log('error', 'Export summary failed', { error: error.message, groupId });
                sendError(res, 500, 'Error al exportar resumen');
                return;
            }
        }


        // =============================================
        // NOTIFICATIONS ENDPOINTS
        // Added: 2025-11-25
        // =============================================
        
        // GET /api/notifications - Get user notifications
        if (pathname === '/api/notifications' && method === 'GET') {
            const urlParts = url.parse(req.url, true);
            const userId = urlParts.query.user_id;
            const unreadOnly = urlParts.query.unread === 'true';
            const limit = parseInt(urlParts.query.limit) || 50;
            const offset = parseInt(urlParts.query.offset) || 0;
            
            if (!userId) {
                sendError(res, 400, 'user_id requerido');
                return;
            }
            
            log('info', 'Getting notifications', { userId, unreadOnly, limit });
            
            try {
                const result = await notificationsUtils.getNotifications(dbPostgres.pool, userId, {
                    unreadOnly: unreadOnly,
                    limit: limit,
                    offset: offset
                });
                
                sendSuccess(res, result);
            } catch (error) {
                log('error', 'Error getting notifications', { error: error.message });
                sendError(res, 500, 'Error al obtener notificaciones');
            }
            return;
        }
        
        // POST /api/notifications/read/:id - Mark single notification as read
        if (pathname.match(/^\/api\/notifications\/read\/[^\/]+$/) && method === 'POST') {
            const notificationId = pathname.split('/')[4];
            
            try {
                const userId = body.user_id;
                    
                    if (!userId) {
                        sendError(res, 400, 'user_id requerido');
                        return;
                    }
                    
                    log('info', 'Marking notification as read', { notificationId, userId });
                    
                    const result = await notificationsUtils.markAsRead(dbPostgres.pool, notificationId, userId);
                    
                    if (!result) {
                        sendError(res, 404, 'Notificacion no encontrada');
                        return;
                    }
                    
                sendSuccess(res, { message: 'Notificacion marcada como leida', notification: result });
            } catch (error) {
                log('error', 'Error marking as read', { error: error.message });
                sendError(res, 500, 'Error al marcar notificacion');
            }
            return;
        }
        
        // POST /api/notifications/read-all - Mark all notifications as read
        if (pathname === '/api/notifications/read-all' && method === 'POST') {
            try {
                const userId = body.user_id;
                    
                    if (!userId) {
                        sendError(res, 400, 'user_id requerido');
                        return;
                    }
                    
                    log('info', 'Marking all notifications as read', { userId });
                    
                    const result = await notificationsUtils.markAllAsRead(dbPostgres.pool, userId);
                    
                sendSuccess(res, { message: 'Todas las notificaciones marcadas como leidas', ...result });
            } catch (error) {
                log('error', 'Error marking all as read', { error: error.message });
                sendError(res, 500, 'Error al marcar notificaciones');
            }
            return;
        }
        
        // GET /api/notifications/preferences - Get notification preferences
        if (pathname === '/api/notifications/preferences' && method === 'GET') {
            const urlParts = url.parse(req.url, true);
            const userId = urlParts.query.user_id;
            
            if (!userId) {
                sendError(res, 400, 'user_id requerido');
                return;
            }
            
            log('info', 'Getting notification preferences', { userId });
            
            try {
                const result = await notificationsUtils.getPreferences(dbPostgres.pool, userId);
                sendSuccess(res, result);
            } catch (error) {
                log('error', 'Error getting preferences', { error: error.message });
                sendError(res, 500, 'Error al obtener preferencias');
            }
            return;
        }
        
        // PUT /api/notifications/preferences - Update notification preferences
        if (pathname === '/api/notifications/preferences' && method === 'PUT') {
            try {
                const userId = body.user_id;
                    
                    if (!userId) {
                        sendError(res, 400, 'user_id requerido');
                        return;
                    }
                    
                    log('info', 'Updating notification preferences', { userId });
                    
                const result = await notificationsUtils.updatePreferences(dbPostgres.pool, userId, body);
                
                sendSuccess(res, { message: 'Preferencias actualizadas', preferences: result });
            } catch (error) {
                log('error', 'Error updating preferences', { error: error.message });
                sendError(res, 500, 'Error al actualizar preferencias');
            }
            return;
        }
        
        // POST /api/notifications/create - Create notification (internal/admin)
        if (pathname === '/api/notifications/create' && method === 'POST') {
            try {
                const { user_id, type, title, message, notification_data } = body;
                    
                    if (!user_id || !type || !title) {
                        sendError(res, 400, 'user_id, type y title son requeridos');
                        return;
                    }
                    
                    log('info', 'Creating notification', { user_id, type, title });
                    
                    const result = await notificationsUtils.createNotification(
                        dbPostgres.pool, 
                        user_id, 
                        type, 
                        title, 
                        message || '', 
                        notification_data || {}
                    );
                    
                sendSuccess(res, { message: 'Notificacion creada', notification: result });
            } catch (error) {
                log('error', 'Error creating notification', { error: error.message });
                sendError(res, 500, 'Error al crear notificacion');
            }
            return;
        }


        // =============================================
        // STATISTICS/DASHBOARD ENDPOINTS
        // Added: 2025-11-25
        // =============================================
        

        // =============================================
        // CALENDAR/SCHEDULE ENDPOINTS
        // Added: 2025-11-25
        // =============================================
        
        // GET /api/groups/:groupId/calendar - Get payment calendar/schedule
        if (pathname.match(/^\/api\/groups\/[^\/]+\/calendar$/) && method === 'GET') {
            const groupId = pathname.split('/')[3];
            const urlParts = url.parse(req.url, true);
            const month = urlParts.query.month; // Format: YYYY-MM
            
            log('info', 'Getting payment calendar', { groupId, month });
            
            try {
                // Get group info
                const groupResult = await dbPostgres.pool.query(
                    'SELECT * FROM groups WHERE group_id = $1',
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                
                const groupData = groupResult.rows[0];
                
                // Get the tanda associated with this group to use real turns_order
                const tandaResult = await dbPostgres.pool.query(
                    'SELECT tanda_id, name, status, turns_order, total_per_turn, contribution_amount, frequency, total_turns, current_turn FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1',
                    [groupId]
                );
                
                const tanda = tandaResult.rows[0];
                const turnsOrder = tanda && tanda.turns_order ? tanda.turns_order : [];
                const totalPerTurn = tanda ? parseFloat(tanda.total_per_turn) || 0 : 0;
                const contributionAmount = tanda ? parseFloat(tanda.contribution_amount) || parseFloat(groupData.contribution_amount) || 0 : parseFloat(groupData.contribution_amount) || 0;
                const frequency = tanda ? tanda.frequency || groupData.frequency || 'monthly' : groupData.frequency || 'monthly';
                const totalTurns = tanda ? tanda.total_turns || 8 : 8;
                const currentTurn = tanda ? tanda.current_turn || 0 : 0;
                
                // Get user names for users in turns_order
                let membersInOrder = [];
                if (turnsOrder.length > 0) {
                    const usersResult = await dbPostgres.pool.query(
                        'SELECT user_id, name FROM users WHERE user_id = ANY($1)',
                        [turnsOrder]
                    );
                    
                    // Create a map for quick lookup
                    const userMap = {};
                    usersResult.rows.forEach(function(u) {
                        userMap[u.user_id] = u.name;
                    });
                    
                    // Maintain the order from turns_order
                    membersInOrder = turnsOrder.map(function(userId, index) {
                        return {
                            user_id: userId,
                            name: userMap[userId] || 'Miembro ' + (index + 1),
                            position: index + 1
                        };
                    });
                }
                
                // Generate schedule based on turns_order
                const upcomingDates = [];
                const today = new Date();
                
                // Generate dates for each turn
                const turnsToShow = Math.max(membersInOrder.length, totalTurns);
                for (let i = 0; i < turnsToShow; i++) {
                    const nextDate = new Date(today);
                    switch (frequency) {
                        case 'weekly':
                            nextDate.setDate(today.getDate() + (i * 7));
                            break;
                        case 'biweekly':
                            nextDate.setDate(today.getDate() + (i * 14));
                            break;
                        case 'monthly':
                        default:
                            nextDate.setMonth(today.getMonth() + i);
                            break;
                    }
                    
                    const member = membersInOrder[i] || null;
                    upcomingDates.push({
                        date: nextDate.toISOString().split('T')[0],
                        position: i + 1,
                        beneficiary: member ? {
                            user_id: member.user_id,
                            name: member.name
                        } : null,
                        amount: totalPerTurn,
                        status: i === currentTurn ? 'current' : (i < currentTurn ? 'completed' : 'upcoming')
                    });
                }
                
                // Translate frequency to Spanish
                const frequencyMap = {
                    'weekly': 'Semanal',
                    'biweekly': 'Quincenal',
                    'monthly': 'Mensual'
                };
                
                const calendar = {
                    group: {
                        id: groupData.group_id,
                        name: groupData.name,
                        frequency: frequencyMap[frequency] || frequency,
                        contribution_amount: contributionAmount
                    },
                    tanda: tanda ? {
                        id: tanda.tanda_id,
                        name: tanda.name,
                        status: tanda.status,
                        total_per_turn: totalPerTurn,
                        total_turns: totalTurns,
                        current_turn: currentTurn,
                        turns_assigned: turnsOrder.length
                    } : null,
                    schedule: upcomingDates,
                    total_members: membersInOrder.length,
                    currency: 'L.'
                };
                
                sendSuccess(res, calendar);
            } catch (error) {
                console.error('Calendar ERROR:', error); log('error', 'Error getting calendar', { error: error.message, stack: error.stack, groupId });
                sendError(res, 500, 'Error al obtener calendario');
            }
            return;
        }
        // GET /api/groups/:groupId/stats - Get group statistics dashboard
        if (pathname.match(/^\/api\/groups\/[^\/]+\/stats$/) && method === 'GET') {
            const groupId = pathname.split('/')[3];
            
            log('info', 'Getting group statistics', { groupId });
            
            try {
                // Get group info
                const groupResult = await dbPostgres.pool.query(
                    'SELECT * FROM groups WHERE group_id = $1',
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                
                const groupData = groupResult.rows[0];
                
                // Get member statistics
                const memberStats = await dbPostgres.pool.query(`
                    SELECT 
                        COUNT(*) as total_members,
                        COUNT(CASE WHEN status = 'active' THEN 1 END) as active_members,
                        COUNT(CASE WHEN role = 'admin' THEN 1 END) as admins
                    FROM group_members 
                    WHERE group_id = $1 AND status != 'left'
                `, [groupId]);
                
                // Get payment statistics
                const paymentStats = await dbPostgres.pool.query(`
                    SELECT 
                        COUNT(*) as total_payments,
                        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_payments,
                        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_payments,
                        COALESCE(SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END), 0) as total_collected,
                        COALESCE(SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END), 0) as pending_amount,
                        COALESCE(AVG(CASE WHEN status = 'completed' THEN amount END), 0) as avg_payment
                    FROM contributions 
                    WHERE group_id = $1
                `, [groupId]);
                
                // Get payments by month (last 6 months)
                const monthlyStats = await dbPostgres.pool.query(`
                    SELECT 
                        TO_CHAR(created_at, 'YYYY-MM') as month,
                        COUNT(*) as payments,
                        COALESCE(SUM(amount), 0) as amount
                    FROM contributions 
                    WHERE group_id = $1 
                        AND status = 'completed'
                        AND created_at >= NOW() - INTERVAL '6 months'
                    GROUP BY TO_CHAR(created_at, 'YYYY-MM')
                    ORDER BY month DESC
                `, [groupId]);
                
                // Get top contributors
                const topContributors = await dbPostgres.pool.query(`
                    SELECT 
                        c.user_id,
                        u.name,
                        COUNT(*) as payment_count,
                        COALESCE(SUM(c.amount), 0) as total_contributed
                    FROM contributions c
                    LEFT JOIN users u ON c.user_id = u.user_id
                    WHERE c.group_id = $1 AND c.status = 'completed'
                    GROUP BY c.user_id, u.name
                    ORDER BY total_contributed DESC
                    LIMIT 5
                `, [groupId]);
                
                const ms = memberStats.rows[0];
                const ps = paymentStats.rows[0];
                const expectedTotal = parseFloat(groupData.contribution_amount || 0) * parseInt(groupData.total_members || ms.total_members);
                const collectedTotal = parseFloat(ps.total_collected) || 0;
                const completionRate = expectedTotal > 0 ? Math.round((collectedTotal / expectedTotal) * 100) : 0;
                
                const stats = {
                    group: {
                        id: groupData.group_id,
                        name: groupData.name,
                        contribution_amount: parseFloat(groupData.contribution_amount) || 0,
                        frequency: groupData.frequency,
                        status: groupData.status
                    },
                    members: {
                        total: parseInt(ms.total_members) || 0,
                        active: parseInt(ms.active_members) || 0,
                        admins: parseInt(ms.admins) || 0
                    },
                    payments: {
                        total: parseInt(ps.total_payments) || 0,
                        completed: parseInt(ps.completed_payments) || 0,
                        pending: parseInt(ps.pending_payments) || 0,
                        total_collected: collectedTotal,
                        pending_amount: parseFloat(ps.pending_amount) || 0,
                        average: parseFloat(ps.avg_payment) || 0,
                        completion_rate: completionRate
                    },
                    monthly: monthlyStats.rows.map(function(m) {
                        return {
                            month: m.month,
                            payments: parseInt(m.payments),
                            amount: parseFloat(m.amount)
                        };
                    }),
                    top_contributors: topContributors.rows.map(function(c) {
                        return {
                            user_id: c.user_id,
                            name: c.name || 'Usuario',
                            payment_count: parseInt(c.payment_count),
                            total: parseFloat(c.total_contributed)
                        };
                    })
                };
                
                sendSuccess(res, stats);
            } catch (error) {
                log('error', 'Error getting group stats', { error: error.message, groupId });
                sendError(res, 500, 'Error al obtener estadisticas');
            }
            return;
        }
        
        // GET /api/user/:userId/stats - Get user statistics across all groups
        if (pathname.match(/^\/api\/user\/[^\/]+\/stats$/) && method === 'GET') {
            const userId = pathname.split('/')[3];
            
            log('info', 'Getting user statistics', { userId });
            
            try {
                // Get user groups count
                const groupStats = await dbPostgres.pool.query(`
                    SELECT 
                        COUNT(*) as total_groups,
                        COUNT(CASE WHEN role = 'admin' THEN 1 END) as admin_groups
                    FROM group_members 
                    WHERE user_id = $1 AND status = 'active'
                `, [userId]);
                
                // Get user payment statistics
                const paymentStats = await dbPostgres.pool.query(`
                    SELECT 
                        COUNT(*) as total_payments,
                        COALESCE(SUM(amount), 0) as total_paid,
                        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed,
                        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending
                    FROM contributions 
                    WHERE user_id = $1
                `, [userId]);
                
                // Get recent activity
                const recentActivity = await dbPostgres.pool.query(`
                    SELECT 
                        c.id,
                        c.amount,
                        c.status,
                        c.created_at,
                        g.name as group_name
                    FROM contributions c
                    LEFT JOIN groups g ON c.group_id = g.group_id
                    WHERE c.user_id = $1
                    ORDER BY c.created_at DESC
                    LIMIT 10
                `, [userId]);
                
                const gs = groupStats.rows[0];
                const ps = paymentStats.rows[0];
                
                const stats = {
                    groups: {
                        total: parseInt(gs.total_groups) || 0,
                        as_admin: parseInt(gs.admin_groups) || 0
                    },
                    payments: {
                        total: parseInt(ps.total_payments) || 0,
                        completed: parseInt(ps.completed) || 0,
                        pending: parseInt(ps.pending) || 0,
                        total_paid: parseFloat(ps.total_paid) || 0
                    },
                    recent_activity: recentActivity.rows.map(function(a) {
                        return {
                            id: a.id,
                            amount: parseFloat(a.amount),
                            status: a.status,
                            group_name: a.group_name,
                            date: a.created_at
                        };
                    })
                };
                
                sendSuccess(res, stats);
            } catch (error) {
                log('error', 'Error getting user stats', { error: error.message, userId });
                sendError(res, 500, 'Error al obtener estadisticas del usuario');
            }
            return;
        }

        // Get group contributions/payments (PostgreSQL)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/contributions$/) && method === "GET") {
            const groupId = pathname.split("/")[3];
            log("info", "Fetching contributions for group: " + groupId);

            try {
                // Get group info first
                const group = await db.getGroupById(groupId);
                if (!group) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                // Parse query params for filtering
                const urlParts = url.parse(req.url, true);
                const options = {
                    status: urlParts.query.status || null,
                    limit: parseInt(urlParts.query.limit) || 50,
                    offset: parseInt(urlParts.query.offset) || 0
                };

                // Get contributions from PostgreSQL
                const result = await db.getGroupContributions(groupId, options);

                sendSuccess(res, {
                    group_id: groupId,
                    group_name: group.name || group.group_name,
                    contributions: result.contributions.map(c => ({
                        id: c.id,
                        user_id: c.user_id,
                        user_name: c.user_name,
                        user_email: c.user_email,
                        user_avatar: c.user_avatar,
                        amount: parseFloat(c.amount),
                        payment_method: c.payment_method,
                        status: c.status,
                        transaction_id: c.transaction_id,
                        confirmation_code: c.confirmation_code,
                        notes: c.notes,
                        due_date: c.due_date,
                        paid_date: c.paid_date,
                        cycle_number: c.cycle_number,
                        created_at: c.created_at
                    })),
                    totals: {
                        total_count: parseInt(result.totals.total_count),
                        total_completed: parseFloat(result.totals.total_completed),
                        total_pending: parseFloat(result.totals.total_pending),
                        completed_count: parseInt(result.totals.completed_count),
                        pending_count: parseInt(result.totals.pending_count)
                    }
                });
            } catch (error) {
                log("error", "Error fetching group contributions", { groupId, error: error.message });
                sendError(res, 500, "Error al obtener historial de pagos");
            }
            return;
        }

        // // Update group (PostgreSQL-only)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/update-pg$/) && method === 'PATCH') {
            const groupId = pathname.split('/')[3];
            const { name, description, contribution_amount, max_members, frequency, location, status } = body;

            log('info', 'Updating group (PostgreSQL)', { groupId, name });

            try {
                // Build update data
                const updateData = {};
                if (name) updateData.name = name;
                if (description !== undefined) updateData.description = description;
                if (contribution_amount) updateData.contribution_amount = parseFloat(contribution_amount);
                if (max_members) updateData.max_members = parseInt(max_members);
                if (frequency) updateData.frequency = frequency;
                if (location) updateData.location = location;
                if (status) updateData.status = status;
                updateData.updated_at = new Date().toISOString();

                // Update in PostgreSQL
                const updated = await db.updateGroup(groupId, updateData);

                if (!updated) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                sendSuccess(res, {
                    message: 'Grupo actualizado exitosamente',
                    group: updated
                });

            } catch (error) {
                log('error', 'Error updating group', { error: error.message });
                sendError(res, 500, 'Error al actualizar el grupo');
            }
            return;
        }


        // ========== CONTRIBUTION REQUEST - Generate payment code and instructions ==========
        if (pathname === '/api/contributions/request' && method === 'POST') {
            const { user_id, group_id, amount, payment_method } = body;
            console.log('DEBUG contributions/request:', body);

            // Validate required fields
            if (!user_id || !group_id || !amount || !payment_method) {
                sendError(res, 400, 'Campos requeridos: user_id, group_id, amount, payment_method');
                return;
            }

            // Validate payment method
            const validMethods = ['cash', 'bank_transfer', 'mobile_money', 'card', 'crypto', 'wallet'];
            if (!validMethods.includes(payment_method)) {
                sendError(res, 400, 'Método de pago no válido');
                return;
            }

            try {
                // Generate unique reference code
                const timestamp = Date.now();
                const groupShort = group_id.substring(0, 8).toUpperCase();
                const userShort = user_id.substring(user_id.length - 4).toUpperCase();
                const referenceCode = `LT-CNT-${groupShort}-${userShort}-${timestamp}`;

                // Calculate expiration (48 hours)
                const expiresAt = new Date(timestamp + 48 * 60 * 60 * 1000);

                // Get group info for instructions
                const groupResult = await dbPostgres.pool.query(
                    'SELECT name, admin_id FROM groups WHERE group_id = $1',
                    [group_id]
                );
                const group = groupResult.rows[0];

                // Get coordinator info
                let coordinatorInfo = null;
                if (group && group.admin_id) {
                    const coordResult = await dbPostgres.pool.query(
                        'SELECT name, phone FROM users WHERE user_id = $1',
                        [group.admin_id]
                    );
                    coordinatorInfo = coordResult.rows[0];
                }

                // Generate instructions based on payment method
                let instructions = {};
                
                if (payment_method === 'bank_transfer') {
                    instructions = {
                        title: 'Transferencia Bancaria',
                        steps: [
                            'Accede a tu banca en línea o app móvil',
                            'Realiza transferencia a: La Tanda Chain S.A.',
                            'Banco: Banco Atlántida',
                            'Cuenta: 30613012837 (Corriente)',
                            `Monto exacto: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            `IMPORTANTE - En descripción/referencia incluir: ${referenceCode}`,
                            'Guarda tu comprobante y súbelo aquí'
                        ],
                        bank_details: {
                            bank_name: 'Banco Atlántida',
                            account_number: '30613012837',
                            account_holder: 'La Tanda Chain S.A.',
                            account_type: 'Cuenta Corriente'
                        },
                        verification_time: '2-4 horas',
                        proof_required: true
                    };
                } else if (payment_method === 'mobile_money') {
                    const fee = parseFloat(amount) * 0.025;
                    instructions = {
                        title: 'Tigo Money',
                        steps: [
                            'Abre tu app Tigo Money',
                            'Selecciona "Enviar Dinero"',
                            'Enviar a: +50494485859',
                            'Nombre destinatario: Narjell Ramon Ebanks Martinez',
                            `Monto exacto: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            `Comisión aproximada: L. ${fee.toLocaleString('es-HN', {minimumFractionDigits: 2})} (2.5%)`,
                            `IMPORTANTE - En mensaje/nota incluir: ${referenceCode}`,
                            'Captura pantalla del comprobante y súbelo aquí'
                        ],
                        recipient_phone: '+50494485859',
                        recipient_name: 'Narjell Ramon Ebanks Martinez',
                        recipient_email: 'ebanksnigel@gmail.com',
                        fee_rate: 0.025,
                        verification_time: 'Inmediata',
                        proof_required: true
                    };
                } else if (payment_method === 'cash') {
                    instructions = {
                        title: 'Pago en Efectivo',
                        steps: [
                            'PASO 1: Toma una foto del efectivo que vas a entregar',
                            'PASO 2: Sube la foto aquí para generar tu código',
                            `PASO 3: Tu código de pago: ${referenceCode}`,
                            coordinatorInfo ? `PASO 4: Contacta al coordinador: ${coordinatorInfo.name} - ${coordinatorInfo.phone || 'Sin teléfono'}` : 'PASO 4: Contacta al coordinador del grupo',
                            `PASO 5: Entrega el monto exacto: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            'PASO 6: Muestra tu código al coordinador para que confirme'
                        ],
                        coordinator: coordinatorInfo,
                        verification_time: 'Cuando coordinador confirme',
                        proof_required: true,
                        proof_before_delivery: true
                    };
                } else if (payment_method === 'crypto') {
                    instructions = {
                        title: 'Criptomoneda (Ethereum/USDT)',
                        steps: [
                            'Envía USDT, ETH o stablecoins a la siguiente dirección:',
                            'Dirección: 0x58EA31ceba1B3DeFacB06A5B7fc7408656b91bf7',
                            'Redes soportadas: Ethereum (ERC-20) o Polygon',
                            `Monto equivalente en HNL: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            `IMPORTANTE - En memo incluir: ${referenceCode}`,
                            'Copia el hash/TXID de la transacción como comprobante'
                        ],
                        wallet_address: '0x58EA31ceba1B3DeFacB06A5B7fc7408656b91bf7',
                        networks: ['Ethereum', 'Polygon'],
                        verification_time: 'Variable según red (5-30 min)',
                        proof_required: true
                    };
                } else if (payment_method === 'card') {
                    instructions = {
                        title: 'Tarjeta de Crédito/Débito',
                        steps: [
                            'El pago será procesado automáticamente',
                            `Monto: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            'Recibirás confirmación por email',
                            'Guarda el comprobante de la transacción'
                        ],
                        verification_time: 'Inmediata',
                        proof_required: true
                    };
                } else if (payment_method === 'wallet') {
                    instructions = {
                        title: 'Wallet La Tanda',
                        steps: [
                            'El monto será descontado de tu wallet',
                            `Monto: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            'Verificación automática'
                        ],
                        verification_time: 'Inmediata',
                        proof_required: false
                    };
                }

                // Insert contribution request to database
                const insertResult = await dbPostgres.pool.query(`
                    INSERT INTO contributions (
                        user_id, group_id, amount, payment_method, status,
                        reference_code, expires_at, created_at
                    ) VALUES ($1, $2, $3, $4, 'awaiting_payment', $5, $6, NOW())
                    RETURNING id, reference_code, status, created_at
                `, [user_id, group_id, amount, payment_method, referenceCode, expiresAt]);

                const contribution = insertResult.rows[0];

                log('info', 'Contribution request created', { 
                    contribution_id: contribution.id, 
                    reference_code: referenceCode,
                    payment_method,
                    amount
                });

                sendSuccess(res, {
                    contribution_id: contribution.id,
                    reference_code: referenceCode,
                    amount: parseFloat(amount),
                    payment_method,
                    instructions,
                    expires_at: expiresAt.toISOString(),
                    status: 'awaiting_payment',
                    group_name: group?.name || 'Grupo'
                });
            } catch (error) {
                console.error('FULL ERROR:', error); log('error', 'Error creating contribution request', { error: error.message, stack: error.stack });
                sendError(res, 500, 'Error al crear solicitud de pago');
            }
            return;
        }

        // Get pending contributions for a group (coordinator verification)
        if (pathname.match(/^\/api\/groups\/[^/]+\/contributions\/pending$/) && (method === 'GET' || method === 'HEAD')) {
            const groupId = pathname.split('/')[3];

            try {
                const result = await dbPostgres.pool.query(`
                    SELECT
                        c.id,
                        c.user_id,
                        c.amount,
                        c.payment_method,
                        c.status,
                        c.reference_code,
                        c.proof_url,
                        c.created_at,
                        c.verified_at,
                        c.verified_by,
                        u.name as user_name,
                        u.email as user_email,
                        u.phone as user_phone
                    FROM contributions c
                    LEFT JOIN users u ON c.user_id = u.user_id
                    WHERE c.group_id = $1
                    AND c.status IN ('pending_verification', 'awaiting_payment')
                    ORDER BY c.created_at DESC
                `, [groupId]);

                sendSuccess(res, {
                    contributions: result.rows,
                    total: result.rows.length
                });
            } catch (error) {
                console.error('Error fetching pending contributions:', error);
                sendError(res, 500, 'Error al obtener contribuciones pendientes');
            }
            return;
        }

        // Verify a contribution (coordinator action)
        if (pathname.match(/^\/api\/contributions\/[^/]+\/verify$/) && method === 'POST') {
            const contributionId = pathname.split('/')[3];
            const { action, verified_by, rejection_reason } = body;

            if (!action || !['approve', 'reject'].includes(action)) {
                sendError(res, 400, 'Accion requerida: approve o reject');
                return;
            }

            try {
                const checkResult = await dbPostgres.pool.query(
                    'SELECT id, status, amount, user_id, group_id FROM contributions WHERE id = $1',
                    [contributionId]
                );

                if (checkResult.rows.length === 0) {
                    sendError(res, 404, 'Contribucion no encontrada');
                    return;
                }

                const contribution = checkResult.rows[0];

                if (contribution.status !== 'pending_verification') {
                    sendError(res, 400, 'Solo se pueden verificar contribuciones pendientes de verificacion');
                    return;
                }

                if (action === 'approve') {
                    await dbPostgres.pool.query(`
                        UPDATE contributions
                        SET status = 'completed',
                            verified_at = NOW(),
                            verified_by = $1,
                            updated_at = NOW()
                        WHERE id = $2
                    `, [verified_by || 'coordinator', contributionId]);

                    log('info', 'Contribution approved', { contribution_id: contributionId, verified_by });

                    sendSuccess(res, {
                        contribution_id: contributionId,
                        status: 'completed',
                        message: 'Pago verificado exitosamente'
                    });
                } else {
                    await dbPostgres.pool.query(`
                        UPDATE contributions
                        SET status = 'rejected',
                            verified_at = NOW(),
                            verified_by = $1,
                            notes = $2,
                            updated_at = NOW()
                        WHERE id = $3
                    `, [verified_by || 'coordinator', rejection_reason || 'Rechazado por coordinador', contributionId]);

                    log('info', 'Contribution rejected', { contribution_id: contributionId, verified_by, reason: rejection_reason });

                    sendSuccess(res, {
                        contribution_id: contributionId,
                        status: 'rejected',
                        message: 'Pago rechazado'
                    });
                }
            } catch (error) {
                console.error('Error verifying contribution:', error);
                sendError(res, 500, 'Error al verificar contribucion');
            }
            return;
        }

        // OCR Verification endpoint - auto-verify payment proof
        if (pathname.match(/^\/api\/contributions\/[^/]+\/verify-ocr$/) && method === 'POST') {
            const contributionId = pathname.split('/')[3];
            
            try {
                // Get contribution details
                const contribResult = await dbPostgres.pool.query(
                    `SELECT c.id, c.amount, c.payment_method, c.reference_code, c.status, c.proof_image_url,
                            c.user_id, c.group_id
                     FROM contributions c
                     WHERE c.id = $1`,
                    [contributionId]
                );
                
                if (contribResult.rows.length === 0) {
                    sendError(res, 404, 'Contribucion no encontrada');
                    return;
                }
                
                const contribution = contribResult.rows[0];
                
                if (!contribution.proof_image_url) {
                    sendError(res, 400, 'No hay comprobante subido para verificar');
                    return;
                }
                
                // Read the image file
                const imagePath = contribution.proof_image_url.startsWith('/uploads/')
                    ? path.join(__dirname, contribution.proof_image_url)
                    : contribution.proof_image_url;
                
                if (!fs.existsSync(imagePath)) {
                    sendError(res, 404, 'Archivo de comprobante no encontrado');
                    return;
                }
                
                log('info', 'Starting OCR verification', { contribution_id: contributionId, image_path: imagePath });
                
                // Perform OCR
                const { data: { text } } = await Tesseract.recognize(imagePath, 'spa', {
                    logger: m => console.log(m)
                });
                
                const extractedText = text.toUpperCase();
                log('info', 'OCR extracted text', { contribution_id: contributionId, text_length: extractedText.length });
                
                // Verification results
                let verification = {
                    account_match: false,
                    name_match: false,
                    reference_match: false,
                    amount_match: false,
                    extracted_text: extractedText.substring(0, 500), // Limit for response
                    confidence: 0,
                    matches: [],
                    mismatches: []
                };
                
                const paymentMethod = contribution.payment_method;
                const expectedAmount = parseFloat(contribution.amount);
                const referenceCode = contribution.reference_code;
                
                // Check based on payment method
                if (paymentMethod === 'bank_transfer') {
                    // Check account number
                    for (const variant of PAYMENT_ACCOUNTS.bank_transfer.account_variants) {
                        if (extractedText.includes(variant.replace(/-/g, '').replace(/ /g, ''))) {
                            verification.account_match = true;
                            verification.matches.push('Cuenta bancaria: ' + variant);
                            break;
                        }
                    }
                    if (!verification.account_match) verification.mismatches.push('Cuenta bancaria no encontrada');
                    
                    // Check holder name
                    for (const variant of PAYMENT_ACCOUNTS.bank_transfer.holder_variants) {
                        if (extractedText.includes(variant)) {
                            verification.name_match = true;
                            verification.matches.push('Titular: ' + variant);
                            break;
                        }
                    }
                    if (!verification.name_match) verification.mismatches.push('Nombre de titular no encontrado');
                    
                } else if (paymentMethod === 'mobile_money') {
                    // Check phone number
                    for (const variant of PAYMENT_ACCOUNTS.mobile_money.phone_variants) {
                        const cleanVariant = variant.replace(/[^0-9]/g, '');
                        if (extractedText.replace(/[^0-9]/g, '').includes(cleanVariant)) {
                            verification.account_match = true;
                            verification.matches.push('Teléfono: ' + variant);
                            break;
                        }
                    }
                    if (!verification.account_match) verification.mismatches.push('Número de teléfono no encontrado');
                    
                    // Check recipient name
                    for (const variant of PAYMENT_ACCOUNTS.mobile_money.name_variants) {
                        if (extractedText.includes(variant)) {
                            verification.name_match = true;
                            verification.matches.push('Nombre: ' + variant);
                            break;
                        }
                    }
                    if (!verification.name_match) verification.mismatches.push('Nombre de destinatario no encontrado');
                    
                } else if (paymentMethod === 'crypto') {
                    // Check wallet address (partial match)
                    if (extractedText.includes(PAYMENT_ACCOUNTS.crypto.address_short) ||
                        extractedText.includes(PAYMENT_ACCOUNTS.crypto.address_end) ||
                        extractedText.includes(PAYMENT_ACCOUNTS.crypto.address)) {
                        verification.account_match = true;
                        verification.name_match = true;
                        verification.matches.push('Dirección crypto verificada');
                    } else {
                        verification.mismatches.push('Dirección de wallet no encontrada');
                    }
                }
                
                // Check reference code
                if (referenceCode && extractedText.includes(referenceCode.replace(/-/g, '').toUpperCase())) {
                    verification.reference_match = true;
                    verification.matches.push('Referencia: ' + referenceCode);
                } else if (referenceCode) {
                    // Try partial match
                    const refParts = referenceCode.split('-');
                    const lastPart = refParts[refParts.length - 1];
                    if (extractedText.includes(lastPart)) {
                        verification.reference_match = true;
                        verification.matches.push('Referencia parcial: ' + lastPart);
                    } else {
                        verification.mismatches.push('Código de referencia no encontrado');
                    }
                }
                
                // Check amount (with 5% tolerance)
                const amountRegex = /L\.?\s*([0-9,]+\.?[0-9]*)|([0-9,]+\.?[0-9]*)\s*L/g;
                let amountMatch;
                while ((amountMatch = amountRegex.exec(extractedText)) !== null) {
                    const foundAmount = parseFloat((amountMatch[1] || amountMatch[2]).replace(/,/g, ''));
                    if (!isNaN(foundAmount)) {
                        const tolerance = expectedAmount * 0.05;
                        if (Math.abs(foundAmount - expectedAmount) <= tolerance) {
                            verification.amount_match = true;
                            verification.matches.push('Monto: L. ' + foundAmount.toFixed(2));
                            break;
                        }
                    }
                }
                if (!verification.amount_match) verification.mismatches.push('Monto exacto no encontrado');
                
                // Calculate confidence score
                let matchCount = 0;
                if (verification.account_match) matchCount++;
                if (verification.name_match) matchCount++;
                if (verification.reference_match) matchCount++;
                if (verification.amount_match) matchCount++;
                verification.confidence = matchCount / 4;
                
                // Determine if auto-approve
                verification.auto_approved = verification.confidence >= 0.75;
                
                // If high confidence, auto-approve
                if (verification.auto_approved) {
                    await dbPostgres.pool.query(`
                        UPDATE contributions
                        SET status = 'completed',
                            verified_at = NOW(),
                            verified_by = 'ocr_auto',
                            notes = $1,
                            updated_at = NOW()
                        WHERE id = $2
                    `, ['Verificado automáticamente por OCR. Confianza: ' + (verification.confidence * 100).toFixed(0) + '%', contributionId]);
                    
                    log('info', 'Contribution auto-approved by OCR', { contribution_id: contributionId, confidence: verification.confidence });
                }
                
                sendSuccess(res, {
                    contribution_id: contributionId,
                    verification,
                    message: verification.auto_approved 
                        ? 'Pago verificado automáticamente' 
                        : 'Verificación requiere revisión manual'
                });
                
            } catch (error) {
                console.error('Error in OCR verification:', error);
                sendError(res, 500, 'Error en verificación OCR: ' + error.message);
            }
            return;
        }

        






// ============================================
// PAYOUT SYSTEM ENDPOINTS
// Sistema de Cobro de Tandas para Beneficiarios
// ============================================

// ========== USER PAYOUT METHODS ==========

// GET /api/users/payout-methods - List user's payout methods
if (pathname === '/api/users/payout-methods' && method === 'GET') {
    const user_id = url.parse(req.url, true).query.user_id;
    
    if (!user_id) {
        sendError(res, 400, 'user_id es requerido');
        return;
    }
    
    try {
        const result = await dbPostgres.pool.query(
            `SELECT * FROM user_payout_methods 
             WHERE user_id = $1 
             ORDER BY is_default DESC, created_at DESC`,
            [user_id]
        );
        
        sendSuccess(res, {
            payout_methods: result.rows,
            count: result.rows.length
        });
    } catch (error) {
        console.error('Error fetching payout methods:', error);
        sendError(res, 500, 'Error al obtener métodos de pago');
    }
    return;
}

// POST /api/users/payout-methods - Add new payout method
if (pathname === '/api/users/payout-methods' && method === 'POST') {
    const {
        user_id,
        method_type,
        is_default,
        bank_name,
        bank_account_number,
        bank_account_type,
        bank_account_holder,
        tigo_phone,
        tigo_name,
        crypto_address,
        crypto_network
    } = body;
    
    if (!user_id || !method_type) {
        sendError(res, 400, 'user_id y method_type son requeridos');
        return;
    }
    
    if (!['bank_transfer', 'mobile_money', 'crypto'].includes(method_type)) {
        sendError(res, 400, 'method_type debe ser: bank_transfer, mobile_money, o crypto');
        return;
    }
    
    try {
        if (is_default) {
            await dbPostgres.pool.query(
                'UPDATE user_payout_methods SET is_default = false WHERE user_id = $1',
                [user_id]
            );
        }
        
        const result = await dbPostgres.pool.query(
            `INSERT INTO user_payout_methods (
                user_id, method_type, is_default,
                bank_name, bank_account_number, bank_account_type, bank_account_holder,
                tigo_phone, tigo_name, crypto_address, crypto_network
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
            RETURNING *`,
            [user_id, method_type, is_default || false,
             bank_name, bank_account_number, bank_account_type, bank_account_holder,
             tigo_phone, tigo_name, crypto_address, crypto_network]
        );
        
        log('info', 'Payout method added', { user_id, method_type });
        sendSuccess(res, { payout_method: result.rows[0], message: 'Método de cobro agregado' });
    } catch (error) {
        console.error('Error adding payout method:', error);
        sendError(res, 500, 'Error al agregar método de pago');
    }
    return;
}

// PUT /api/users/payout-methods/:id - Update payout method
if (pathname.match(/^\/api\/users\/payout-methods\/[^/]+$/) && method === 'PUT' && !pathname.includes('/default')) {
    const methodId = pathname.split('/')[4];
    const { bank_name, bank_account_number, bank_account_type, bank_account_holder,
            tigo_phone, tigo_name, crypto_address, crypto_network } = body;
    
    try {
        const result = await dbPostgres.pool.query(
            `UPDATE user_payout_methods SET
                bank_name = COALESCE($1, bank_name),
                bank_account_number = COALESCE($2, bank_account_number),
                bank_account_type = COALESCE($3, bank_account_type),
                bank_account_holder = COALESCE($4, bank_account_holder),
                tigo_phone = COALESCE($5, tigo_phone),
                tigo_name = COALESCE($6, tigo_name),
                crypto_address = COALESCE($7, crypto_address),
                crypto_network = COALESCE($8, crypto_network),
                updated_at = NOW()
            WHERE id = $9 RETURNING *`,
            [bank_name, bank_account_number, bank_account_type, bank_account_holder,
             tigo_phone, tigo_name, crypto_address, crypto_network, methodId]
        );
        
        if (result.rows.length === 0) {
            sendError(res, 404, 'Método de pago no encontrado');
            return;
        }
        sendSuccess(res, { payout_method: result.rows[0], message: 'Método actualizado' });
    } catch (error) {
        console.error('Error updating payout method:', error);
        sendError(res, 500, 'Error al actualizar método');
    }
    return;
}

// PUT /api/users/payout-methods/:id/default - Set as default
if (pathname.match(/^\/api\/users\/payout-methods\/[^/]+\/default$/) && method === 'PUT') {
    const methodId = pathname.split('/')[4];
    
    try {
        const methodResult = await dbPostgres.pool.query(
            'SELECT user_id FROM user_payout_methods WHERE id = $1', [methodId]
        );
        
        if (methodResult.rows.length === 0) {
            sendError(res, 404, 'Método no encontrado');
            return;
        }
        
        const user_id = methodResult.rows[0].user_id;
        await dbPostgres.pool.query(
            'UPDATE user_payout_methods SET is_default = false WHERE user_id = $1', [user_id]
        );
        
        const result = await dbPostgres.pool.query(
            'UPDATE user_payout_methods SET is_default = true, updated_at = NOW() WHERE id = $1 RETURNING *',
            [methodId]
        );
        
        sendSuccess(res, { payout_method: result.rows[0], message: 'Método predeterminado actualizado' });
    } catch (error) {
        console.error('Error setting default:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// DELETE /api/users/payout-methods/:id
if (pathname.match(/^\/api\/users\/payout-methods\/[^/]+$/) && method === 'DELETE') {
    const methodId = pathname.split('/')[4];
    
    try {
        const result = await dbPostgres.pool.query(
            'DELETE FROM user_payout_methods WHERE id = $1 RETURNING id', [methodId]
        );
        
        if (result.rows.length === 0) {
            sendError(res, 404, 'Método no encontrado');
            return;
        }
        sendSuccess(res, { message: 'Método eliminado' });
    } catch (error) {
        console.error('Error deleting:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// ========== PAYOUT REQUESTS ==========

// GET /api/groups/:id/payout/eligibility
if (pathname.match(/^\/api\/groups\/[^/]+\/payout\/eligibility$/) && method === 'GET') {
    const groupId = pathname.split('/')[3];
    const user_id = url.parse(req.url, true).query.user_id;
    
    if (!user_id) {
        sendError(res, 400, 'user_id es requerido');
        return;
    }
    
    try {
        const groupResult = await dbPostgres.pool.query(
            'SELECT * FROM groups WHERE group_id = $1', [groupId]
        );
        
        if (groupResult.rows.length === 0) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }
        
        const group = groupResult.rows[0];
        const currentCycle = group.current_cycle || 1;
        
        // Check member and turn
        const memberResult = await dbPostgres.pool.query(
            'SELECT * FROM group_members WHERE group_id = $1 AND user_id = $2',
            [groupId, user_id]
        );
        
        if (memberResult.rows.length === 0) {
            sendError(res, 403, 'No eres miembro de este grupo');
            return;
        }
        
        const member = memberResult.rows[0];
        const isBeneficiary = (member.turn_order === currentCycle) || 
                              (group.current_beneficiary_id === user_id);
        
        // Check cycle completion
        const contribResult = await dbPostgres.pool.query(
            `SELECT COUNT(*) as count, COALESCE(SUM(amount), 0) as total 
             FROM contributions 
             WHERE group_id = $1 AND cycle_number = $2 AND status = 'completed'`,
            [groupId, currentCycle]
        );
        
        const memberCountResult = await dbPostgres.pool.query(
            'SELECT COUNT(*) as count FROM group_members WHERE group_id = $1', [groupId]
        );
        
        const contributionsCount = parseInt(contribResult.rows[0].count);
        const memberCount = parseInt(memberCountResult.rows[0].count);
        const cycleComplete = contributionsCount >= memberCount;
        
        // Check existing payout request
        const existingPayout = await dbPostgres.pool.query(
            'SELECT * FROM payout_requests WHERE group_id = $1 AND cycle_number = $2',
            [groupId, currentCycle]
        );
        
        // Check payout method
        const payoutMethodResult = await dbPostgres.pool.query(
            'SELECT * FROM user_payout_methods WHERE user_id = $1 ORDER BY is_default DESC LIMIT 1',
            [user_id]
        );
        
        // Calculate amounts
        const grossAmount = parseFloat(contribResult.rows[0].total) || 0;
        const coordinatorFee = grossAmount * 0.03;
        const platformFee = coordinatorFee * 0.10;
        const netAmount = grossAmount - coordinatorFee - platformFee;
        
        sendSuccess(res, {
            eligible: isBeneficiary && cycleComplete && existingPayout.rows.length === 0,
            is_beneficiary: isBeneficiary,
            cycle_complete: cycleComplete,
            already_requested: existingPayout.rows.length > 0,
            has_payout_method: payoutMethodResult.rows.length > 0,
            default_payout_method: payoutMethodResult.rows[0] || null,
            current_cycle: currentCycle,
            contributions_received: contributionsCount,
            members_count: memberCount,
            amounts: { gross: grossAmount, coordinator_fee: coordinatorFee, platform_fee: platformFee, net: netAmount },
            existing_request: existingPayout.rows[0] || null
        });
    } catch (error) {
        console.error('Error checking eligibility:', error);
        sendError(res, 500, 'Error al verificar elegibilidad');
    }
    return;
}

// POST /api/groups/:id/payout/request
if (pathname.match(/^\/api\/groups\/[^/]+\/payout\/request$/) && method === 'POST') {
    const groupId = pathname.split('/')[3];
    const { user_id, payout_method_id } = body;
    
    if (!user_id || !payout_method_id) {
        sendError(res, 400, 'user_id y payout_method_id son requeridos');
        return;
    }
    
    try {
        const groupResult = await dbPostgres.pool.query('SELECT * FROM groups WHERE group_id = $1', [groupId]);
        if (groupResult.rows.length === 0) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }
        
        const group = groupResult.rows[0];
        const currentCycle = group.current_cycle || 1;
        
        // Verify beneficiary
        const memberResult = await dbPostgres.pool.query(
            'SELECT turn_order FROM group_members WHERE group_id = $1 AND user_id = $2',
            [groupId, user_id]
        );
        
        if (memberResult.rows.length === 0) {
            sendError(res, 403, 'No eres miembro');
            return;
        }
        
        const isBeneficiary = memberResult.rows[0].turn_order === currentCycle || 
                              group.current_beneficiary_id === user_id;
        
        if (!isBeneficiary) {
            sendError(res, 403, 'No eres el beneficiario de este ciclo');
            return;
        }
        
        // Check completion
        const contribResult = await dbPostgres.pool.query(
            `SELECT COUNT(*) as count, COALESCE(SUM(amount), 0) as total 
             FROM contributions WHERE group_id = $1 AND cycle_number = $2 AND status = 'completed'`,
            [groupId, currentCycle]
        );
        
        const memberCountResult = await dbPostgres.pool.query(
            'SELECT COUNT(*) as count FROM group_members WHERE group_id = $1', [groupId]
        );
        
        if (parseInt(contribResult.rows[0].count) < parseInt(memberCountResult.rows[0].count)) {
            sendError(res, 400, 'El ciclo aún no está completo');
            return;
        }
        
        // Check existing
        const existingResult = await dbPostgres.pool.query(
            'SELECT id FROM payout_requests WHERE group_id = $1 AND cycle_number = $2',
            [groupId, currentCycle]
        );
        
        if (existingResult.rows.length > 0) {
            sendError(res, 400, 'Ya existe una solicitud para este ciclo');
            return;
        }
        
        // Get payout method
        const methodResult = await dbPostgres.pool.query(
            'SELECT * FROM user_payout_methods WHERE id = $1 AND user_id = $2',
            [payout_method_id, user_id]
        );
        
        if (methodResult.rows.length === 0) {
            sendError(res, 404, 'Método de pago no encontrado');
            return;
        }
        
        const payoutMethod = methodResult.rows[0];
        const grossAmount = parseFloat(contribResult.rows[0].total) || 0;
        const coordinatorFee = grossAmount * 0.03;
        const platformFee = coordinatorFee * 0.10;
        const netAmount = grossAmount - coordinatorFee - platformFee;
        
        // Auto-approve since all checks passed
        const status = 'auto_approved';
        
        const result = await dbPostgres.pool.query(
            `INSERT INTO payout_requests (
                group_id, user_id, cycle_number, gross_amount, platform_fee, coordinator_fee, net_amount,
                payout_method_id, payout_method_snapshot, status, approved_at
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
            RETURNING *`,
            [groupId, user_id, currentCycle, grossAmount, platformFee, coordinatorFee, netAmount,
             payout_method_id, JSON.stringify(payoutMethod), status]
        );
        
        
        // Send notification to user about payout request
        try {
            await notificationsUtils.createNotification(
                dbPostgres.pool,
                user_id,
                autoApproved ? 'payout_approved' : 'payout_requested',
                autoApproved ? '¡Tu solicitud de cobro fue aprobada!' : 'Solicitud de cobro recibida',
                autoApproved
                    ? 'Tu solicitud de L. ' + netAmount.toFixed(2) + ' fue aprobada automáticamente. Pronto recibirás tu pago.'
                    : 'Tu solicitud de cobro de L. ' + netAmount.toFixed(2) + ' está en revisión.',
                { payout_request_id: payoutRequest.id, amount: netAmount, group_id }
            );
        } catch (notifError) {
            console.error('Error sending payout notification:', notifError);
        }

        log('info', 'Payout request created', { group_id: groupId, user_id, cycle: currentCycle, amount: netAmount });
        
        sendSuccess(res, {
            payout_request: result.rows[0],
            message: 'Solicitud aprobada automáticamente',
            auto_approved: true
        });
    } catch (error) {
        console.error('Error creating payout request:', error);
        sendError(res, 500, 'Error al crear solicitud');
    }
    return;
}

// GET /api/groups/:id/payout/status
if (pathname.match(/^\/api\/groups\/[^/]+\/payout\/status$/) && method === 'GET') {
    const groupId = pathname.split('/')[3];
    const user_id = url.parse(req.url, true).query.user_id;
    
    try {
        const query = user_id 
            ? 'SELECT * FROM payout_requests WHERE group_id = $1 AND user_id = $2 ORDER BY requested_at DESC'
            : 'SELECT * FROM payout_requests WHERE group_id = $1 ORDER BY requested_at DESC';
        const params = user_id ? [groupId, user_id] : [groupId];
        
        const result = await dbPostgres.pool.query(query, params);
        sendSuccess(res, { payout_requests: result.rows, count: result.rows.length });
    } catch (error) {
        console.error('Error fetching status:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// POST /api/groups/:id/payout/confirm
if (pathname.match(/^\/api\/groups\/[^/]+\/payout\/confirm$/) && method === 'POST') {
    const groupId = pathname.split('/')[3];
    const { user_id, payout_request_id, confirmation_url } = body;
    
    if (!user_id || !payout_request_id) {
        sendError(res, 400, 'user_id y payout_request_id son requeridos');
        return;
    }
    
    try {
        const payoutResult = await dbPostgres.pool.query(
            'SELECT * FROM payout_requests WHERE id = $1 AND user_id = $2 AND group_id = $3',
            [payout_request_id, user_id, groupId]
        );
        
        if (payoutResult.rows.length === 0) {
            sendError(res, 404, 'Solicitud no encontrada');
            return;
        }
        
        if (payoutResult.rows[0].status !== 'awaiting_confirmation') {
            sendError(res, 400, 'Esta solicitud no está esperando confirmación');
            return;
        }
        
        const result = await dbPostgres.pool.query(
            `UPDATE payout_requests SET 
                status = 'completed', user_confirmation_url = $1, confirmed_at = NOW()
             WHERE id = $2 RETURNING *`,
            [confirmation_url || null, payout_request_id]
        );
        
        // Advance cycle
        await dbPostgres.pool.query(
            'UPDATE groups SET current_cycle = COALESCE(current_cycle, 1) + 1 WHERE group_id = $1',
            [groupId]
        );
        
        log('info', 'Payout confirmed', { payout_request_id, group_id: groupId });
        
        // Notify completion
        try {
            const confirmedPayout = result.rows[0];
            await notificationsUtils.createNotification(
                dbPostgres.pool,
                confirmedPayout.user_id,
                'payout_confirmed',
                '¡Pago completado!',
                'Tu cobro de L. ' + parseFloat(confirmedPayout.net_amount).toFixed(2) + ' ha sido completado exitosamente.',
                { payout_request_id: confirmedPayout.id }
            );
        } catch (notifError) {
            console.error('Error sending confirmation notification:', notifError);
        }

        sendSuccess(res, { payout_request: result.rows[0], message: 'Recepción confirmada. Ciclo cerrado.' });
    } catch (error) {
        console.error('Error confirming:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// ========== ADMIN ENDPOINTS ==========

// GET /api/admin/payouts/pending
if (pathname === '/api/admin/payouts/pending' && method === 'GET') {
    try {
        const result = await dbPostgres.pool.query(
            `SELECT pr.*, u.name as user_name, u.email as user_email, u.phone as user_phone,
                    g.name as group_name
             FROM payout_requests pr
             LEFT JOIN users u ON pr.user_id = u.user_id
             LEFT JOIN groups g ON pr.group_id = g.group_id
             WHERE pr.status IN ('pending', 'auto_approved', 'needs_review', 'processing')
             ORDER BY pr.requested_at ASC`
        );
        
        sendSuccess(res, { payouts: result.rows, count: result.rows.length });
    } catch (error) {
        console.error('Error fetching pending payouts:', error);
        sendError(res, 500, 'Error al obtener pagos pendientes');
    }
    return;
}

// POST /api/admin/payouts/:id/approve
if (pathname.match(/^\/api\/admin\/payouts\/[^/]+\/approve$/) && method === 'POST') {
    const payoutId = pathname.split('/')[4];
    const { admin_id } = body;
    
    try {
        const result = await dbPostgres.pool.query(
            `UPDATE payout_requests SET status = 'auto_approved', approved_at = NOW(), approved_by = $1
             WHERE id = $2 AND status IN ('pending', 'needs_review') RETURNING *`,
            [admin_id, payoutId]
        );
        
        if (result.rows.length === 0) {
            sendError(res, 404, 'Solicitud no encontrada o ya procesada');
            return;
        }
        
        // Notify user of approval
        try {
            const approvedPayout = result.rows[0];
            await notificationsUtils.createNotification(
                dbPostgres.pool,
                approvedPayout.user_id,
                'payout_approved',
                '¡Tu solicitud de cobro fue aprobada!',
                'Tu solicitud de L. ' + parseFloat(approvedPayout.net_amount).toFixed(2) + ' fue aprobada. El pago será procesado pronto.',
                { payout_request_id: approvedPayout.id }
            );
        } catch (notifError) {
            console.error('Error sending approval notification:', notifError);
        }

        sendSuccess(res, { payout: result.rows[0], message: 'Solicitud aprobada' });
    } catch (error) {
        console.error('Error approving:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// OCR Verification for Outgoing Payouts
// This code should replace the existing process endpoint

// POST /api/admin/payouts/:id/process (with OCR verification)
if (pathname.match(/^\/api\/admin\/payouts\/[^/]+\/process$/) && method === 'POST') {
    const payoutId = pathname.split('/')[4];

    try {
        // Handle multipart form data for file upload
        let formData = body;
        let imageBuffer = null;
        let imageBase64 = null;

        // Check if it's base64 image in body
        if (body.proof_image) {
            const base64Data = body.proof_image.replace(/^data:image\/\w+;base64,/, '');
            imageBuffer = Buffer.from(base64Data, 'base64');
            imageBase64 = body.proof_image;
        } else if (body.proof_url && body.proof_url.startsWith('data:image')) {
            const base64Data = body.proof_url.replace(/^data:image\/\w+;base64,/, '');
            imageBuffer = Buffer.from(base64Data, 'base64');
            imageBase64 = body.proof_url;
        }

        const admin_id = body.admin_id;
        const notes = body.notes || '';

        if (!imageBuffer && !body.proof_url) {
            sendError(res, 400, 'Comprobante de transferencia es requerido');
            return;
        }

        // Get payout request with method snapshot
        const payoutResult = await dbPostgres.pool.query(
            `SELECT pr.*, u.name as user_name
             FROM payout_requests pr
             LEFT JOIN users u ON pr.user_id = u.user_id
             WHERE pr.id = $1 AND pr.status IN ('auto_approved', 'approved')`,
            [payoutId]
        );

        if (payoutResult.rows.length === 0) {
            sendError(res, 404, 'Solicitud no encontrada o no lista para procesar');
            return;
        }

        const payout = payoutResult.rows[0];
        const methodSnapshot = payout.payout_method_snapshot || {};

        // Save proof image
        let proofUrl = body.proof_url;
        if (imageBuffer) {
            const proofFilename = `payout_proof_${payoutId}_${Date.now()}.jpg`;
            const proofPath = path.join('/var/www/uploads/payout_proofs', proofFilename);

            // Ensure directory exists
            const proofDir = path.dirname(proofPath);
            if (!fs.existsSync(proofDir)) {
                fs.mkdirSync(proofDir, { recursive: true });
            }

            fs.writeFileSync(proofPath, imageBuffer);
            proofUrl = `/uploads/payout_proofs/${proofFilename}`;
        }

        // ========== OCR VERIFICATION OF OUTGOING PAYMENT ==========
        let ocrVerification = {
            performed: false,
            destination_match: false,
            amount_match: false,
            name_match: false,
            confidence: 0,
            matches: [],
            mismatches: [],
            warning: null
        };

        if (imageBuffer) {
            try {
                log('info', 'Starting OCR verification of payout proof', { payout_id: payoutId });

                // Perform OCR
                const { data: { text } } = await Tesseract.recognize(imageBuffer, 'spa', {
                    logger: m => {} // Suppress logs
                });

                const extractedText = text.toUpperCase();
                log('info', 'OCR extracted text from payout proof', {
                    payout_id: payoutId,
                    text_length: extractedText.length
                });

                ocrVerification.performed = true;
                const methodType = methodSnapshot.method_type;
                const expectedAmount = parseFloat(payout.net_amount);
                const userName = (payout.user_name || '').toUpperCase();

                // Verify based on payment method type
                if (methodType === 'bank_transfer') {
                    // Check account number
                    const accountNumber = (methodSnapshot.bank_account_number || '').replace(/[^0-9]/g, '');
                    if (accountNumber) {
                        // Check for last 4 digits (often shown in receipts)
                        const last4 = accountNumber.slice(-4);
                        const last6 = accountNumber.slice(-6);
                        if (extractedText.includes(accountNumber) ||
                            extractedText.includes(last6) ||
                            extractedText.replace(/[^0-9]/g, '').includes(accountNumber)) {
                            ocrVerification.destination_match = true;
                            ocrVerification.matches.push('Cuenta: ****' + last4);
                        } else {
                            ocrVerification.mismatches.push('Cuenta no encontrada');
                        }
                    }

                    // Check holder name
                    const holderName = (methodSnapshot.bank_account_holder || '').toUpperCase();
                    if (holderName) {
                        const nameParts = holderName.split(' ').filter(p => p.length > 2);
                        const matchedParts = nameParts.filter(part => extractedText.includes(part));
                        if (matchedParts.length >= 2 || (matchedParts.length === 1 && nameParts.length === 1)) {
                            ocrVerification.name_match = true;
                            ocrVerification.matches.push('Titular: ' + holderName);
                        }
                    }

                } else if (methodType === 'mobile_money') {
                    // Check Tigo phone number
                    const phone = (methodSnapshot.tigo_phone || '').replace(/[^0-9]/g, '');
                    if (phone) {
                        const phoneLast8 = phone.slice(-8);
                        const phoneLast4 = phone.slice(-4);
                        if (extractedText.replace(/[^0-9]/g, '').includes(phoneLast8) ||
                            extractedText.replace(/[^0-9]/g, '').includes(phone)) {
                            ocrVerification.destination_match = true;
                            ocrVerification.matches.push('Tigo: ****' + phoneLast4);
                        } else {
                            ocrVerification.mismatches.push('Telefono Tigo no encontrado');
                        }
                    }

                    // Check name
                    const tigoName = (methodSnapshot.tigo_name || '').toUpperCase();
                    if (tigoName) {
                        const nameParts = tigoName.split(' ').filter(p => p.length > 2);
                        const matchedParts = nameParts.filter(part => extractedText.includes(part));
                        if (matchedParts.length >= 1) {
                            ocrVerification.name_match = true;
                            ocrVerification.matches.push('Nombre: ' + tigoName);
                        }
                    }

                } else if (methodType === 'crypto') {
                    // Check wallet address (partial match is fine for crypto)
                    const address = (methodSnapshot.crypto_address || '').toUpperCase();
                    if (address) {
                        const addressStart = address.slice(0, 10);
                        const addressEnd = address.slice(-8);
                        if (extractedText.includes(addressStart) || extractedText.includes(addressEnd)) {
                            ocrVerification.destination_match = true;
                            ocrVerification.name_match = true; // Crypto doesn't have names
                            ocrVerification.matches.push('Direccion: ' + address.slice(0,6) + '...' + address.slice(-4));
                        } else {
                            ocrVerification.mismatches.push('Direccion crypto no encontrada');
                        }
                    }
                }

                // Check amount in the receipt
                const amountRegex = /L\.?\s*([0-9,]+\.?[0-9]*)|([0-9,]+\.?[0-9]*)\s*(?:LEMPIRAS?|HNL|L\.?)/gi;
                let amountMatch;
                while ((amountMatch = amountRegex.exec(extractedText)) !== null) {
                    const foundAmount = parseFloat((amountMatch[1] || amountMatch[2]).replace(/,/g, ''));
                    if (!isNaN(foundAmount)) {
                        const tolerance = expectedAmount * 0.05; // 5% tolerance
                        if (Math.abs(foundAmount - expectedAmount) <= tolerance) {
                            ocrVerification.amount_match = true;
                            ocrVerification.matches.push('Monto: L. ' + foundAmount.toFixed(2));
                            break;
                        }
                    }
                }

                if (!ocrVerification.amount_match) {
                    ocrVerification.mismatches.push('Monto esperado L. ' + expectedAmount.toFixed(2) + ' no encontrado');
                }

                // Calculate confidence
                let matchCount = 0;
                if (ocrVerification.destination_match) matchCount++;
                if (ocrVerification.amount_match) matchCount++;
                if (ocrVerification.name_match) matchCount++;
                ocrVerification.confidence = matchCount / 3;

                // Set warning if verification failed
                if (ocrVerification.confidence < 0.67) {
                    ocrVerification.warning = 'El comprobante no coincide completamente con los datos del beneficiario. Verificar manualmente.';
                    log('warn', 'Payout proof OCR verification incomplete', {
                        payout_id: payoutId,
                        confidence: ocrVerification.confidence,
                        matches: ocrVerification.matches,
                        mismatches: ocrVerification.mismatches
                    });
                } else {
                    log('info', 'Payout proof OCR verification passed', {
                        payout_id: payoutId,
                        confidence: ocrVerification.confidence,
                        matches: ocrVerification.matches
                    });
                }

            } catch (ocrError) {
                log('error', 'OCR verification of payout proof failed', {
                    payout_id: payoutId,
                    error: ocrError.message
                });
                ocrVerification.warning = 'OCR no pudo procesar la imagen. Verificar manualmente.';
            }
        }
        // ========== END OCR VERIFICATION ==========

        // Update payout request with proof and OCR results
        const updateResult = await dbPostgres.pool.query(
            `UPDATE payout_requests SET
                status = 'awaiting_confirmation',
                admin_proof_url = $1,
                processed_at = NOW(),
                processed_by = $2,
                notes = COALESCE(notes, '') || $3
             WHERE id = $4 RETURNING *`,
            [
                proofUrl,
                admin_id,
                notes + (ocrVerification.warning ? '\n[OCR] ' + ocrVerification.warning : ''),
                payoutId
            ]
        );

        log('info', 'Payout processed', {
            payout_id: payoutId,
            admin_id,
            ocr_confidence: ocrVerification.confidence
        });

        
        // Notify user that payment was sent
        try {
            await notificationsUtils.createNotification(
                dbPostgres.pool,
                payout.user_id,
                'payout_processed',
                '¡Tu pago ha sido enviado!',
                'Hemos enviado L. ' + parseFloat(payout.net_amount).toFixed(2) + ' a tu cuenta. Por favor confirma cuando lo recibas.',
                { payout_request_id: payoutId, proof_url: proofUrl }
            );

            // Also send email notification
            const userResult = await dbPostgres.pool.query('SELECT email, name FROM users WHERE user_id = $1', [payout.user_id]);
            if (userResult.rows.length > 0 && userResult.rows[0].email) {
                const userEmail = userResult.rows[0].email;
                const userName = userResult.rows[0].name || 'Usuario';
                await sendEmail(userEmail, '¡Tu pago de La Tanda ha sido enviado!',
                    '<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">' +
                    '<h2 style="color: #16a34a;">¡Hola ' + userName + '!</h2>' +
                    '<p>Te informamos que hemos procesado tu pago de <strong>L. ' + parseFloat(payout.net_amount).toFixed(2) + '</strong>.</p>' +
                    '<p>Por favor ingresa a tu cuenta de La Tanda para confirmar que recibiste el pago.</p>' +
                    '<a href="https://latanda.online" style="display: inline-block; background: #16a34a; color: white; padding: 12px 24px; border-radius: 8px; text-decoration: none; margin-top: 16px;">Confirmar Recepción</a>' +
                    '<p style="color: #6b7280; margin-top: 24px; font-size: 0.9rem;">Si tienes algún problema, contáctanos.</p>' +
                    '</div>', 'pagos'
                );
            }
        } catch (notifError) {
            console.error('Error sending processed notification:', notifError);
        }

        sendSuccess(res, {
            payout: updateResult.rows[0],
            message: 'Pago procesado. Esperando confirmación del usuario.',
            ocr_verification: ocrVerification
        });

    } catch (error) {
        console.error('Error processing payout:', error);
        sendError(res, 500, 'Error procesando el desembolso');
    }
    return;
}


// POST /api/admin/payouts/:id/reject
if (pathname.match(/^\/api\/admin\/payouts\/[^/]+\/reject$/) && method === 'POST') {
    const payoutId = pathname.split('/')[4];
    const { admin_id, rejection_reason } = body;
    
    if (!rejection_reason) {
        sendError(res, 400, 'Razón de rechazo es requerida');
        return;
    }
    
    try {
        const result = await dbPostgres.pool.query(
            `UPDATE payout_requests SET status = 'rejected', rejection_reason = $1,
             approved_by = $2, approved_at = NOW()
             WHERE id = $3 AND status NOT IN ('completed', 'rejected') RETURNING *`,
            [rejection_reason, admin_id, payoutId]
        );
        
        if (result.rows.length === 0) {
            sendError(res, 404, 'Solicitud no encontrada o ya finalizada');
            return;
        }
        
        // Notify user of rejection
        try {
            const rejectedPayout = result.rows[0];
            await notificationsUtils.createNotification(
                dbPostgres.pool,
                rejectedPayout.user_id,
                'payout_rejected',
                'Solicitud de cobro rechazada',
                'Tu solicitud fue rechazada. Razón: ' + rejection_reason,
                { payout_request_id: rejectedPayout.id, reason: rejection_reason }
            );
        } catch (notifError) {
            console.error('Error sending rejection notification:', notifError);
        }

        sendSuccess(res, { payout: result.rows[0], message: 'Solicitud rechazada' });
    } catch (error) {
        console.error('Error rejecting:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// GET /api/admin/payouts/history
if (pathname === '/api/admin/payouts/history' && method === 'GET') {
    const queryParams = url.parse(req.url, true).query;
    const status = queryParams.status;
    const limit = parseInt(queryParams.limit) || 50;
    
    try {
        let query = `SELECT pr.*, u.name as user_name, u.email as user_email, g.name as group_name
                     FROM payout_requests pr
                     LEFT JOIN users u ON pr.user_id = u.user_id
                     LEFT JOIN groups g ON pr.group_id = g.group_id`;
        const params = [];
        
        if (status) {
            query += ' WHERE pr.status = $1';
            params.push(status);
        }
        query += ' ORDER BY pr.requested_at DESC LIMIT $' + (params.length + 1);
        params.push(limit);
        
        const result = await dbPostgres.pool.query(query, params);
        sendSuccess(res, { payouts: result.rows, count: result.rows.length });
    } catch (error) {
        console.error('Error fetching history:', error);
        sendError(res, 500, 'Error');
    }
    return;
}


                // Create new contribution/payment (PostgreSQL)
        if (pathname === '/api/contributions' && method === 'POST') {
            const {
                user_id,
                group_id,
                amount,
                payment_method,
                status = 'pending',
                transaction_id,
                confirmation_code,
                notes,
                due_date,
                cycle_number = 1
            } = body;

            log('info', 'Creating contribution', { user_id, group_id, amount, payment_method });

            // Validation
            if (!user_id || !group_id || !amount || !payment_method) {
                sendError(res, 400, 'Faltan campos requeridos: user_id, group_id, amount, payment_method');
                return;
            }

            if (amount <= 0) {
                sendError(res, 400, 'El monto debe ser mayor a 0');
                return;
            }

            const validMethods = ['cash', 'bank_transfer', 'crypto', 'mobile_money', 'card'];
            if (!validMethods.includes(payment_method)) {
                sendError(res, 400, 'Metodo de pago invalido. Use: ' + validMethods.join(', '));
                return;
            }

            try {
                const contribution = await db.createContribution({
                    user_id,
                    group_id,
                    amount: parseFloat(amount),
                    payment_method,
                    status,
                    transaction_id: transaction_id || null,
                    confirmation_code: confirmation_code || null,
                    notes: notes || null,
                    due_date: due_date || null,
                    cycle_number: parseInt(cycle_number) || 1
                });

                sendSuccess(res, {
                    message: 'Contribucion registrada exitosamente',
                    contribution: {
                        id: contribution.id,
                        user_id: contribution.user_id,
                        group_id: contribution.group_id,
                        amount: parseFloat(contribution.amount),
                        payment_method: contribution.payment_method,
                        status: contribution.status,
                        created_at: contribution.created_at
                    }
                });
            } catch (error) {
                log('error', 'Error creating contribution', { error: error.message });
                sendError(res, 500, 'Error al registrar contribucion');
            }
            return;
        }

        // Mark member payment as received
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/payment$/) && method === "PATCH") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const memberId = parts[5];
            const { amount, payment_date, payment_method = "efectivo", notes = "" } = body;
            log("info", "Recording payment for member: " + memberId + " in group: " + groupId);
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            if (!database.groupMembers) {
                database.groupMembers = [];
            }
            const member = database.groupMembers.find(m => m.id === memberId && m.group_id === groupId);
            if (!member) {
                sendError(res, 404, "Miembro no encontrado");
                return;
            }
            const paymentAmount = parseFloat(amount) || group.contribution_amount;
            member.payment_status = "paid";
            member.total_paid = (member.total_paid || 0) + paymentAmount;
            member.last_payment_date = payment_date || new Date().toISOString();
            member.payment_method = payment_method;
            if (!member.payment_history) {
                member.payment_history = [];
            }
            const paymentRecord = {
                id: generateId("payment"),
                amount: paymentAmount,
                date: payment_date || new Date().toISOString(),
                method: payment_method,
                notes: notes,
                recorded_by: body.recorded_by || group.admin_id,
                recorded_at: new Date().toISOString()
            };
            member.payment_history.push(paymentRecord);
            group.total_amount_collected = (group.total_amount_collected || 0) + paymentAmount;
            saveDatabase();
            log("info", "Payment recorded: " + paymentAmount + " for member " + memberId);
            sendSuccess(res, {
                message: "Pago de L. " + paymentAmount + " registrado exitosamente",
                data: {
                    member: {
                        id: member.id,
                        user_name: member.user_name,
                        payment_status: member.payment_status,
                        total_paid: member.total_paid,
                        last_payment_date: member.last_payment_date
                    },
                    payment: paymentRecord,
                    group_total: group.total_amount_collected
                }
            });
            return;
        }
        // Add member manually (coordinador only)
        // Edit group (coordinador only)
        if (pathname.startsWith("/api/groups/") && pathname.endsWith("/edit") && method === "PATCH") {
            const groupId = pathname.split("/")[3];
            const { name, description, contribution_amount, max_members, frequency, location, meeting_schedule, edited_by } = body;
            log("info", "Editing group: " + groupId);
            const group = database.groups.find(g => g.id === groupId);
            log("info", "Received body:", body);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            if (name !== undefined) group.name = name;
            if (description !== undefined) group.description = description;
            if (contribution_amount !== undefined) {
                group.contribution_amount = parseFloat(contribution_amount);
            }
            if (max_members !== undefined) {
                const newMax = parseInt(max_members);
                if (newMax < group.member_count) {
                    sendError(res, 400, "No puedes reducir max_members por debajo del número actual de miembros");
                    return;
                }
                group.max_members = newMax;
            }
            if (frequency !== undefined) group.frequency = frequency;
            if (location !== undefined) group.location = location;
            if (meeting_schedule !== undefined) group.meeting_schedule = meeting_schedule;
            group.updated_at = new Date().toISOString();
            group.updated_by = edited_by || group.admin_id;
            saveDatabase();
            log("info", "Group " + groupId + " updated successfully");
            sendSuccess(res, {
                message: "Grupo actualizado exitosamente",
                data: {
                    group: {
                        id: group.id,
                        name: group.name,
                        description: group.description,
                        contribution_amount: group.contribution_amount,
                        max_members: group.max_members,
                        member_count: group.member_count,
                        frequency: group.frequency,
                        location: group.location,
                        meeting_schedule: group.meeting_schedule,
                        updated_at: group.updated_at
                    }
                }
            });
            return;
        }
        // Group members management endpoints (NUEVOS)
        if (pathname.startsWith('/api/groups/') && pathname.includes('/members/invite') && method === 'POST') {
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/add$/) && method === "POST") {
            const groupId = pathname.split("/")[3];
            const { userId, userName, userEmail, addedBy } = body;
            log("info", "Manually adding member to group: " + groupId);
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            if (group.member_count >= group.max_members) {
                sendError(res, 400, "El grupo está lleno");
                return;
            }
            if (group.status !== "active") {
                sendError(res, 400, "El grupo no está activo");
                return;
            }
            if (!database.groupMembers) {
                database.groupMembers = [];
            }
            const existingMember = database.groupMembers.find(
                m => m.group_id === groupId && m.user_id === userId
            );
            if (existingMember) {
                sendError(res, 400, "Este usuario ya es miembro del grupo");
                return;
            }
            const newMember = {
                id: generateId("member"),
                group_id: groupId,
                id: userId,  // Changed from user_id to id
                user_name: userName,
                user_email: userEmail,
                joined_at: new Date().toISOString(),
                status: "active",
                payment_status: "pending",
                total_paid: 0,
                added_manually: true,
                added_by: addedBy || group.admin_id
            };
            database.groupMembers.push(newMember);
            group.member_count = (group.member_count || 1) + 1;
            saveDatabase();
            log("info", "Member " + userId + " added manually to group " + groupId);
            sendSuccess(res, {
                message: "Miembro agregado exitosamente",
                data: {
                    membership: newMember,
                    group: {
                        id: group.id,
                        name: group.name,
                        member_count: group.member_count,
                        max_members: group.max_members
                    }
                }
            });
            return;
        // Get group members list
        if (pathname.startsWith("/api/groups/") && pathname.endsWith("/members") && method === "GET") {
            const groupId = pathname.split("/")[3];
            log("info", "Fetching members for group: " + groupId);
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            const members = (database.groupMembers || []).filter(m => m.group_id === groupId);
            sendSuccess(res, {
                group_id: groupId,
                group_name: group.name,
                members: members,
                total_members: members.length
            });
            return;
        }
        // Mark member payment as received
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/payment$/) && method === "PATCH") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const memberId = parts[5];
            const { amount, payment_date, payment_method = "efectivo", notes = "" } = body;
            log("info", "Recording payment for member: " + memberId + " in group: " + groupId);
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            if (!database.groupMembers) {
                database.groupMembers = [];
            }
            const member = database.groupMembers.find(m => m.id === memberId && m.group_id === groupId);
            if (!member) {
                sendError(res, 404, "Miembro no encontrado");
                return;
            }
            const paymentAmount = parseFloat(amount) || group.contribution_amount;
            member.payment_status = "paid";
            member.total_paid = (member.total_paid || 0) + paymentAmount;
            member.last_payment_date = payment_date || new Date().toISOString();
            member.payment_method = payment_method;
            if (!member.payment_history) {
                member.payment_history = [];
            }
            const paymentRecord = {
                id: generateId("payment"),
                amount: paymentAmount,
                date: payment_date || new Date().toISOString(),
                method: payment_method,
                notes: notes,
                recorded_by: body.recorded_by || group.admin_id,
                recorded_at: new Date().toISOString()
            };
            member.payment_history.push(paymentRecord);
            group.total_amount_collected = (group.total_amount_collected || 0) + paymentAmount;
            saveDatabase();
            log("info", "Payment recorded: " + paymentAmount + " for member " + memberId);
            sendSuccess(res, {
                message: "Pago de L. " + paymentAmount + " registrado exitosamente",
                data: {
                    member: {
                        id: member.id,
                        user_name: member.user_name,
                        payment_status: member.payment_status,
                        total_paid: member.total_paid,
                        last_payment_date: member.last_payment_date
                    },
                    payment: paymentRecord,
                    group_total: group.total_amount_collected
                }
            });
            return;
        }

        }
        }
        if (pathname.startsWith('/api/groups/') && pathname.includes('/notifications/payment-reminders') && method === 'POST') {
            const groupId = pathname.split('/')[3];
            
            log('info', `Sending payment reminders for group: ${groupId}`);
            
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, 'Group not found');
                return;
            }
            
            sendSuccess(res, { 
                message: `Recordatorios enviados a ${group.member_count} miembros`,
                reminders_sent: group.member_count,
                group_name: group.name
            });
            return;
        }

        if (pathname.startsWith('/api/groups/') && pathname.includes('/finances/summary') && method === 'GET' || method === 'HEAD') {
            const groupId = pathname.split('/')[3];
            
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, 'Group not found');
                return;
            }
            
            // Detect if it's a new group (no financial history)
            const createdDate = new Date(group.created_at);
            const daysSinceCreation = (Date.now() - createdDate.getTime()) / (1000 * 60 * 60 * 24);
            const isNewGroup = daysSinceCreation <= 7 || group.total_amount_collected === 0 || group.member_count <= 1;
            
            // Generate financial summary based on group age
            const financialSummary = {
                group_id: groupId,
                group_name: group.name,
                total_collected: group.total_amount_collected || 0,
                expected_per_cycle: group.contribution_amount * group.member_count,
                // New groups: 0% payment rate, older groups: realistic rates
                payment_rate: isNewGroup ? 0 : (Math.random() * 20 + 80), // 80-100% for established groups
                pending_payments: isNewGroup ? 0 : Math.floor(Math.random() * 3),
                next_payout_amount: group.contribution_amount * group.member_count,
                cycle_progress: isNewGroup ? 0 : Math.floor(Math.random() * 100),
                member_stats: {
                    active: group.member_count,
                    pending: isNewGroup ? 0 : Math.floor(Math.random() * 2),
                    total: group.member_count
                },
                is_new_group: isNewGroup
            };
            
            sendSuccess(res, financialSummary);
            return;
        }

        // Payment endpoints
        if (pathname === '/api/payments/methods/available' && method === 'POST') {
            const { user_id, amount } = body;
            const methods = [
                {
                    id: 'bank_transfer',
                    name: 'Transferencia Bancaria',
                    fee: 0,
                    processing_time: '1-2 horas',
                    available: true,
                    icon: '🏦'
                },
                {
                    id: 'tigo_money',
                    name: 'Tigo Money',
                    fee: (amount || 100) * 0.025,
                    processing_time: 'Inmediato',
                    available: true,
                    icon: '📱'
                },
                {
                    id: 'claro_money',
                    name: 'Claro Money',
                    fee: (amount || 100) * 0.02,
                    processing_time: 'Inmediato',
                    available: true,
                    icon: '📲'
                },
                {
                    id: 'cash',
                    name: 'Efectivo',
                    fee: 0,
                    processing_time: 'Manual',
                    available: true,
                    icon: '💵'
                }
            ];
            sendSuccess(res, { methods });
            return;
        }

        if (pathname === '/api/payments/process' && method === 'POST') {
            const { user_id, group_id, amount, method } = body;
            const paymentId = generateId('payment');
            const payment = {
                id: paymentId,
                user_id,
                group_id,
                amount,
                method,
                status: 'processing',
                transaction_date: new Date().toISOString(),
                confirmation_code: `CONF${Date.now()}`,
                estimated_completion: new Date(Date.now() + 300000).toISOString()
            };
            database.payments.push(payment);
            sendSuccess(res, payment);
            return;
        }

        // ===== WALLET DEPOSIT ENDPOINTS (4) =====
        
        // 1. Bank Transfer Deposit for Honduras Banks
        
        // Get pending payments for coordinator approval
        if (pathname.startsWith("/api/payments/pending/") && method === "GET") {
            const groupId = pathname.split("/")[4];
            const pendingPayments = (database.payments || []).filter(
                p => p.group_id === groupId && p.status === "processing"
            );
            sendSuccess(res, { group_id: groupId, pending_count: pendingPayments.length, payments: pendingPayments });
            return;
        }
        
        // Coordinator approves payment
        if (pathname === "/api/payments/approve" && method === "POST") {
            const { payment_id, coordinator_id } = body;
            const payment = (database.payments || []).find(p => p.id === payment_id);
            if (!payment) {
                sendError(res, 404, "Pago no encontrado");
                return;
            }
            payment.status = "completed";
            payment.approved_by = coordinator_id;
            payment.approved_at = new Date().toISOString();
            saveDatabase();
            sendSuccess(res, { message: "Pago aprobado", payment });
            return;
        }
        
        // Coordinator rejects payment
        if (pathname === "/api/payments/reject" && method === "POST") {
            const { payment_id, coordinator_id, reason } = body;
            const payment = (database.payments || []).find(p => p.id === payment_id);
            if (!payment) {
                sendError(res, 404, "Pago no encontrado");
                return;
            }
            payment.status = "rejected";
            payment.rejected_by = coordinator_id;
            payment.rejection_reason = reason;
            payment.rejected_at = new Date().toISOString();
            saveDatabase();
            sendSuccess(res, { message: "Pago rechazado", payment });
            return;
        }
        if (pathname === '/api/wallet/deposit/bank-transfer' && method === 'POST') {
            const { user_id, amount, bank_code, account_number } = body;
            
            // Honduras banks validation with La Tanda receptor accounts
            const honduras_banks = {
                'BAH': { 
                    name: 'Banco Atlántida', 
                    account: '30613012837',
                    account_holder: 'La Tanda Chain S.A.',
                    account_type: 'Cuenta Corriente',
                    swift: 'BAHNHNTE',
                    routing: '200101',
                    available: true
                },
                'BDO': { 
                    name: 'Banco de Occidente', 
                    account: 'Aún no disponible',
                    account_holder: 'Aún no disponible',
                    account_type: 'Aún no disponible',
                    swift: 'BDOOHNTN',
                    routing: '200102',
                    available: false
                },
                'BFI': { 
                    name: 'Banco Ficohsa', 
                    account: 'Aún no disponible',
                    account_holder: 'Aún no disponible',
                    account_type: 'Aún no disponible',
                    swift: 'FICOHNTN',
                    routing: '200103',
                    available: false
                },
                'BAC': { 
                    name: 'BAC Honduras', 
                    account: 'Aún no disponible',
                    account_holder: 'Aún no disponible',
                    account_type: 'Aún no disponible',
                    swift: 'CRECHNTN',
                    routing: '200104',
                    available: false
                },
                'BAN': { 
                    name: 'Banpais', 
                    account: 'Aún no disponible',
                    account_holder: 'Aún no disponible',
                    account_type: 'Aún no disponible',
                    swift: 'BANPAIHN',
                    routing: '200105',
                    available: false
                },
                'BCE': { 
                    name: 'Banco Central de Honduras', 
                    account: 'Aún no disponible',
                    account_holder: 'Aún no disponible',
                    account_type: 'Aún no disponible',
                    swift: 'BCENTHN',
                    routing: '200106',
                    available: false
                }
            };
            
            if (!honduras_banks[bank_code]) {
                sendError(res, 400, 'Código de banco no válido para Honduras');
                return;
            }
            
            // Check if bank is available
            if (!honduras_banks[bank_code].available) {
                sendError(res, 400, `${honduras_banks[bank_code].name} aún no está disponible para depósitos. Solo Banco Atlántida está habilitado.`);
                return;
            }
            
            // Validate amount (minimum $10, maximum $5000)
            if (amount < 10 || amount > 250000) {
                sendError(res, 400, 'Monto debe estar entre L. 10 y L. 250,000');
                return;
            }
            
            // Get bank info
            const bank_info = honduras_banks[bank_code];
            
            // Generate deposit transaction
            const depositId = generateId('deposit');
            const referenceNumber = `BT${Date.now()}`;
            const deposit = {
                id: depositId,
                user_id,
                type: 'bank_transfer',
                amount,
                bank_name: bank_info.name,
                bank_code,
                user_account_number: account_number.replace(/\d(?=\d{4})/g, '*'), // Mask user account
                latanda_account_number: bank_info.account,
                latanda_account_holder: bank_info.account_holder,
                latanda_account_type: bank_info.account_type,
                status: 'pending_transfer',
                processing_time: '2-4 horas laborales',
                transaction_fee: amount * 0.02, // 2% fee
                net_amount: amount - (amount * 0.02),
                reference_number: referenceNumber,
                estimated_completion: new Date(Date.now() + 4 * 3600000).toISOString(), // 4 hours
                created_at: new Date().toISOString(),
                instructions: {
                    step1: `Accede a tu ${bank_info.name} (banca en línea, app móvil o sucursal)`,
                    step2: `Realiza transferencia a: ${bank_info.account_holder}`,
                    step3: `Cuenta destino: ${bank_info.account} (${bank_info.account_type})`,
                    step4: `Monto exacto: $${amount} | Referencia obligatoria: ${referenceNumber}`,
                    step5: `Guarda tu comprobante - Verificación automática en 2-4 horas`,
                    additional_info: {
                        bank_name: bank_info.name,
                        routing_number: bank_info.routing,
                        swift_code: bank_info.swift,
                        important_note: 'La referencia es obligatoria para identificar tu depósito'
                    }
                },
                receptor_bank_details: {
                    bank_name: bank_info.name,
                    account_number: bank_info.account,
                    account_holder: bank_info.account_holder,
                    account_type: bank_info.account_type,
                    swift_code: bank_info.swift,
                    routing_number: bank_info.routing,
                    reference_required: referenceNumber
                }
            };
            
            // Add to database (simulated)
            database.deposits = database.deposits || [];
            database.deposits.push(deposit);
            saveDatabase(); // Persist new deposit
            
            // Send email notification to admins
            sendDepositNotification({
                type: 'new_deposit',
                deposit: deposit,
                user_id: user_id
            });
            
            // Update user balance (pending confirmation)
            const user = database.users.find(u => u.id === user_id);
            if (user) {
                user.pending_deposits = (user.pending_deposits || 0) + deposit.net_amount;
            }
            
            sendSuccess(res, {
                deposit_id: depositId,
                status: 'processing',
                bank_name: deposit.bank_name,
                amount: deposit.amount,
                net_amount: deposit.net_amount,
                transaction_fee: deposit.transaction_fee,
                reference_number: deposit.reference_number,
                processing_time: deposit.processing_time,
                instructions: deposit.instructions,
                tracking_url: `https://api.latanda.online/deposit/track/${depositId}`
            });
            return;
        }
        
        // 2. Cryptocurrency Deposit
        if (pathname === '/api/wallet/deposit/crypto' && method === 'POST') {
            const { user_id, currency, network } = body;
            
            const supported_crypto = {
                'BTC': { name: 'Bitcoin', network: 'mainnet', confirmations: 6 },
                'ETH': { name: 'Ethereum', network: 'mainnet', confirmations: 12 },
                'USDT': { name: 'Tether USD', network: 'ethereum', confirmations: 12 },
                'USDC': { name: 'USD Coin', network: 'ethereum', confirmations: 12 }
            };
            
            if (!supported_crypto[currency]) {
                sendError(res, 400, 'Criptomoneda no soportada');
                return;
            }
            
            // Generate unique deposit address (simulated)
            const deposit_address = `${currency}${generateId('addr')}${user_id.slice(0,6)}`;
            const depositId = generateId('crypto_deposit');
            
            const crypto_deposit = {
                id: depositId,
                user_id,
                currency,
                currency_name: supported_crypto[currency].name,
                network: supported_crypto[currency].network,
                deposit_address,
                qr_code: `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${deposit_address}`,
                status: 'waiting_for_payment',
                confirmations_required: supported_crypto[currency].confirmations,
                current_confirmations: 0,
                created_at: new Date().toISOString(),
                expires_at: new Date(Date.now() + 24 * 3600000).toISOString(), // 24 hours
                monitoring_active: true,
                instructions: {
                    step1: `Envía tu ${currency} a la dirección generada`,
                    step2: 'Escanea el código QR o copia la dirección',
                    step3: `Se requieren ${supported_crypto[currency].confirmations} confirmaciones`,
                    step4: 'El depósito se reflejará automáticamente tras las confirmaciones'
                }
            };
            
            database.crypto_deposits = database.crypto_deposits || [];
            database.crypto_deposits.push(crypto_deposit);
            
            sendSuccess(res, {
                deposit_id: depositId,
                currency: currency,
                currency_name: crypto_deposit.currency_name,
                deposit_address,
                qr_code: crypto_deposit.qr_code,
                network: crypto_deposit.network,
                confirmations_required: crypto_deposit.confirmations_required,
                expires_in: 24 * 3600, // seconds
                instructions: crypto_deposit.instructions,
                monitoring_url: `https://api.latanda.online/crypto/monitor/${depositId}`
            });
            return;
        }
        
        // 3. Mobile Payment Deposit (Tigo Money, Claro Pay)
        if (pathname === '/api/wallet/deposit/mobile' && method === 'POST') {
            const { user_id, amount, carrier, phone_number } = body;
            
            const honduras_carriers = {
                'tigo': { name: 'Tigo Money', fee_rate: 0.025, min: 20, max: 2000 },
                'claro': { name: 'Claro Money', fee_rate: 0.03, min: 25, max: 1500 }
            };
            
            if (!honduras_carriers[carrier]) {
                sendError(res, 400, 'Operadora no soportada en Honduras');
                return;
            }
            
            const carrier_info = honduras_carriers[carrier];
            
            if (amount < carrier_info.min || amount > carrier_info.max) {
                sendError(res, 400, `Monto debe estar entre $${carrier_info.min} y $${carrier_info.max} para ${carrier_info.name}`);
                return;
            }
            
            const depositId = generateId('mobile_deposit');
            const transaction_fee = amount * carrier_info.fee_rate;
            const net_amount = amount - transaction_fee;
            
            const mobile_deposit = {
                id: depositId,
                user_id,
                type: 'mobile_payment',
                carrier: carrier_info.name,
                amount,
                phone_number: phone_number.replace(/\d(?=\d{4})/g, '*'), // Mask phone
                transaction_fee,
                net_amount,
                status: 'pending_sms_confirmation',
                sms_code: Math.floor(100000 + Math.random() * 900000), // 6-digit code
                reference_number: `MP${Date.now()}`,
                created_at: new Date().toISOString(),
                expires_at: new Date(Date.now() + 5 * 60000).toISOString(), // 15 minutes
                instructions: {
                    step1: `Envía el código ${Math.floor(100000 + Math.random() * 900000)} al 7777`,
                    step2: `Confirma el pago de $${amount} desde tu ${carrier_info.name}`,
                    step3: 'Recibirás confirmación por SMS',
                    step4: 'El depósito se reflejará inmediatamente tras confirmación'
                }
            };
            
            database.mobile_deposits = database.mobile_deposits || [];
            database.mobile_deposits.push(mobile_deposit);
            
            sendSuccess(res, {
                deposit_id: depositId,
                carrier: carrier_info.name,
                amount: amount,
                net_amount: net_amount,
                transaction_fee: transaction_fee,
                sms_confirmation_required: true,
                expires_in: 5 * 60, // seconds
                instructions: mobile_deposit.instructions,
                reference_number: mobile_deposit.reference_number
            });
            return;
        }
        
        // 4. Get Wallet Balance and Transaction History
        if (pathname === '/api/wallet/balance' && method === 'GET' || method === 'HEAD') {
            const user_id = query.user_id;
            const user = database.users.find(u => u.id === user_id);
            
            if (!user) { // Usuario no encontrado - devolver balance 0 en lugar de error
                sendSuccess(res, { success: true, data: { balance: 0, ltd_balance: 0, balances: { available_usd: 0, locked_usd: 0, pending_deposits_usd: 0, total_usd: 0, ltd_tokens: 0 }, restrictions: { max_withdrawal: 0, can_withdraw: false }, recent_transactions: [], message: 'Usuario nuevo - sin historial' }});
                return;
            }
            
            // Calculate real balances from actual transactions
            let available_balance = 0;
            let pending_deposits_amount = 0;
            
            // Get confirmed deposits
            const confirmedDeposits = database.deposits?.filter(d => 
                d.user_id === user_id && d.status === 'confirmed'
            ) || [];
            
            confirmedDeposits.forEach(deposit => {
                available_balance += parseFloat(deposit.amount || 0);
            });
            
            // Get pending deposits
            const pendingDeposits = database.deposits?.filter(d => 
                d.user_id === user_id && ['pending_transfer', 'processing'].includes(d.status)
            ) || [];
            
            pendingDeposits.forEach(deposit => {
                pending_deposits_amount += parseFloat(deposit.amount || 0);
            });
            
            // Calculate locked balance (from active tandas)
            const userTandas = database.tandas?.filter(tanda => 
                tanda.members?.some(member => member.user_id === user_id && member.status === 'active')
            ) || [];
            
            let locked_balance = 0;
            userTandas.forEach(tanda => {
                const userMember = tanda.members.find(m => m.user_id === user_id);
                if (userMember) {
                    locked_balance += parseFloat(userMember.contribution_amount || 0);
                }
            });
            
            // LTD tokens = USD balance (1:1 ratio for now)
            const ltd_token_balance = available_balance;
            
            // Get actual recent transactions from database
            const userDeposits = database.deposits?.filter(d => d.user_id === user_id) || [];
            const recent_transactions = userDeposits
                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
                .slice(0, 5)
                .map(deposit => ({
                    id: deposit.id,
                    type: 'deposit',
                    method: deposit.method || 'bank_transfer',
                    amount: deposit.amount,
                    status: deposit.status,
                    date: deposit.created_at,
                    description: `${deposit.method === 'bank' ? 'Transferencia bancaria' : 
                                 deposit.method === 'mobile' ? 'Pago móvil' : 
                                 'Depósito'} - ${deposit.bank_name || 'N/A'}`
                }));
            
            sendSuccess(res, {
                success: true,
                data: {
                    balance: available_balance,
                    ltd_balance: ltd_token_balance,
                    balances: {
                        available_usd: available_balance,
                        locked_usd: locked_balance,
                        pending_deposits_usd: pending_deposits_amount,
                        total_usd: available_balance + locked_balance + pending_deposits_amount,
                        ltd_tokens: ltd_token_balance,
                        usd_to_ltd_rate: 1.0 // 1 USD = 1 LTD for now
                    },
                    restrictions: {
                        max_withdrawal: available_balance,
                        tanda_locked_amount: locked_balance,
                        can_withdraw: available_balance > 0
                    },
                    recent_transactions,
                    confirmed_deposits: confirmedDeposits.length,
                    pending_deposits: pendingDeposits.length,
                    active_tandas: userTandas.length,
                    last_updated: new Date().toISOString()
                }
            });
            return;
        }

        // ============================================
        // WALLET BALANCE HISTORY ENDPOINT
        // Returns historical balance data for charts
        // ============================================
        if (pathname === "/api/wallet/balance-history" && (method === "GET" || method === "HEAD")) {
            const user_id = query.user_id;
            const period = query.period || "30d";
            
            if (!user_id) {
                sendError(res, 400, "user_id es requerido");
                return;
            }
            
            const now = new Date();
            let startDate;
            switch(period) {
                case "7d": startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); break;
                case "30d": startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000); break;
                case "90d": startDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000); break;
                default: startDate = new Date("2024-01-01"); break;
            }
            
            const userDeposits = (database.deposits || []).filter(d => d.user_id === user_id && d.status === "confirmed" && new Date(d.created_at) >= startDate);
            
            if (userDeposits.length === 0) {
                sendSuccess(res, { period, start_date: startDate.toISOString(), end_date: now.toISOString(), data_points: [], summary: { current_balance: 0, max_balance: 0, min_balance: 0, total_deposits: 0, total_withdrawals: 0, total_transactions: 0, avg_balance: 0 }, message: "Sin historial de balance" });
                return;
            }
            
            let runningBalance = 0;
            const balanceHistory = [];
            userDeposits.sort((a, b) => new Date(a.created_at) - new Date(b.created_at)).forEach(deposit => {
                runningBalance += parseFloat(deposit.amount || 0);
                balanceHistory.push({ date: deposit.created_at, balance: runningBalance, change: parseFloat(deposit.amount || 0), type: "deposit" });
            });
            
            const balances = balanceHistory.map(h => h.balance);
            const totalDeposits = userDeposits.reduce((sum, d) => sum + parseFloat(d.amount || 0), 0);
            
            sendSuccess(res, { period, start_date: startDate.toISOString(), end_date: now.toISOString(), data_points: balanceHistory, summary: { current_balance: runningBalance, max_balance: Math.max(...balances, 0), min_balance: Math.min(...balances, 0), total_deposits: totalDeposits, total_withdrawals: 0, total_transactions: balanceHistory.length, avg_balance: balances.length > 0 ? balances.reduce((a,b) => a+b, 0) / balances.length : 0 } });
            return;
        }
        
        // ===== TRANSACTION TRACKING ENDPOINTS =====
        
        // Get user transaction history
        if (pathname.startsWith("/api/wallet/transactions/") && method === "GET" || method === "HEAD") {
            const userId = pathname.split("/").pop();
            
            // Get all deposits for this user
            const userDeposits = database.deposits?.filter(d => d.user_id === userId) || [];
            
            // Format as transaction history
            const transactions = userDeposits.map(deposit => ({
                id: deposit.id,
                type: "deposit",
                amount: deposit.amount,
                status: deposit.status,
                created_at: deposit.created_at || new Date().toISOString(),
                reference: deposit.reference || deposit.reference_number,
                bank_name: deposit.bank_name || "Banco Atlántida",
                method: deposit.method || "bank_transfer"
            }));
            
            sendSuccess(res, {
                id: userId,  // Changed from user_id to id
                transactions: transactions,
                total: transactions.length,
                page: 1,
                total_pages: 1
            });
            return;
        }
        
        // 1.
        // 1. Track specific deposit transaction
        if (pathname.startsWith('/api/deposit/track/') && (method === 'GET' || method === 'HEAD')) {
            const depositId = pathname.split('/').pop();
            const deposit = database.deposits?.find(d => d.id === depositId);
            
            if (!deposit) {
                sendError(res, 404, 'Transacción no encontrada');
                return;
            }
            
            sendSuccess(res, {
                transaction_id: deposit.id,
                current_status: deposit.status,
                status_description: transactionManager.getStateDescription(deposit.status),
                amount: deposit.amount,
                bank_name: deposit.bank_name,
                reference_number: deposit.reference_number,
                created_at: deposit.created_at,
                expires_at: deposit.expires_at,
                status_history: deposit.status_history || [],
                next_actions: getNextActionsForStatus(deposit.status)
            });
            return;
        }
        
        // 2. Update transaction status (for admin/system use)
        if (pathname === '/api/deposit/update-status' && method === 'POST') {
            const { transaction_id, new_status, reason, updated_by = 'system' } = body;
            
            if (!transaction_id || !new_status) {
                sendError(res, 400, 'transaction_id y new_status son requeridos');
                return;
            }
            
            const result = transactionManager.updateTransactionState(transaction_id, new_status, reason);
            
            if (!result.success) {
                sendError(res, 400, result.error);
                return;
            }
            
            // Update user balance if confirmed
            if (new_status === 'confirmed') {
                const deposit = database.deposits?.find(d => d.id === transaction_id);
                if (deposit) {
                    const user = database.users.find(u => u.id === deposit.user_id);
                    if (user) {
                        user.balance = (user.balance || 0) + deposit.net_amount;
                        user.pending_deposits = Math.max(0, (user.pending_deposits || 0) - deposit.net_amount);
                    }
                }
            }
            
            sendSuccess(res, {
                transaction_id,
                old_status: result.oldState,
                new_status: result.newState,
                status_description: result.description,
                expires_at: result.expiresAt,
                updated_by,
                timestamp: new Date().toISOString()
            });
            return;
        }
        

        // Serve contribution proof images
        if (pathname.startsWith('/api/proof/') && (method === 'GET' || method === 'HEAD')) {
            const filename = pathname.split('/').pop();
            const proofPath = path.join(__dirname, 'proofs', filename);
            
            // Basic security check
            if (!filename.startsWith('proof_') || filename.includes('..')) {
                sendError(res, 400, 'Nombre de archivo invalido');
                return;
            }
            
            if (!fs.existsSync(proofPath)) {
                sendError(res, 404, 'Comprobante no encontrado');
                return;
            }
            
            try {
                const fileContent = fs.readFileSync(proofPath);
                
                // Determine content type based on extension
                const ext = path.extname(filename).toLowerCase();
                let contentType = 'image/jpeg';
                if (ext === '.png') contentType = 'image/png';
                if (ext === '.gif') contentType = 'image/gif';
                if (ext === '.webp') contentType = 'image/webp';
                
                res.writeHead(200, {
                    'Content-Type': contentType,
                    'Content-Length': fileContent.length,
                    'Cache-Control': 'public, max-age=86400'
                });
                res.end(fileContent);
            } catch (error) {
                console.error('Error serving proof:', error);
                sendError(res, 500, 'Error al servir comprobante');
            }
            return;
        }

        // RECEIPT: Serve receipt images (admin only)
        if (pathname.startsWith('/api/receipt/') && method === 'GET' || method === 'HEAD') {
            const filename = pathname.split('/').pop();
            const receiptPath = path.join(__dirname, 'receipts', filename);
            console.log("DEBUG: receiptPath:", receiptPath);
            
            // Basic security check
            if (!filename.startsWith('receipt_') || filename.includes('..')) {
                sendError(res, 400, 'Nombre de archivo inválido');
                return;
            console.log("DEBUG: File exists check:", fs.existsSync(receiptPath));
            }
            
            if (!fs.existsSync(receiptPath)) {
                sendError(res, 404, 'Comprobante no encontrado');
                return;
            }
            
            try {
                const fileStats = fs.statSync(receiptPath);
                const fileContent = fs.readFileSync(receiptPath);
                
                // Determine content type based on extension
                const ext = path.extname(filename).toLowerCase();
                let contentType = 'application/octet-stream';
                
                switch (ext) {
                    case '.jpg':
                    case '.jpeg':
                        contentType = 'image/jpeg';
                        break;
                    case '.png':
                        contentType = 'image/png';
                        break;
                    case '.webp':
                        contentType = 'image/webp';
                        break;
                    case '.pdf':
                        contentType = 'application/pdf';
                        break;
                }
                
                res.writeHead(200, {                    "Content-Type": contentType,                    "Content-Length": fileStats.size,                    "Content-Disposition": `inline; filename="${filename}"`,                    "Access-Control-Allow-Origin": "*",                    "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",                    "Access-Control-Allow-Headers": "Content-Type, Authorization"                });
                res.end(fileContent);
                
            } catch (error) {
                console.error('Error serving receipt:', error);
                sendError(res, 500, 'Error al cargar comprobante');
            }
            return;
        }
        
        // DEBUG: List all deposits for debugging
        if (pathname === '/api/debug/deposits' && method === 'GET' || method === 'HEAD') {
            sendSuccess(res, {
                deposits: database.deposits || [],
                count: (database.deposits || []).length
            });
            return;
        }

        // ADMIN: Login endpoint
        if (pathname === '/api/admin/login' && method === 'POST') {
            const { username, password } = body;
            
            if (!username || !password) {
                sendError(res, 400, 'Usuario y contraseña son requeridos');
                return;
            }
            
            // Admin credentials (in production, should be hashed and in database)
            const adminUsers = {
                'admin': {
                    password: 'LaTanda2025!Admin', // Should be hashed
                    role: 'super_admin',
                    name: 'Administrador Principal',
                    permissions: ['confirm_deposits', 'reject_deposits', 'view_all_transactions', 'manage_users']
                },
                'finance': {
                    password: 'Finance2025!LT', // Should be hashed  
                    role: 'finance_manager',
                    name: 'Manager Financiero',
                    permissions: ['confirm_deposits', 'reject_deposits', 'view_all_transactions']
                },
                'support': {
                    password: 'Support2025!Help', // Should be hashed
                    role: 'support_agent', 
                    name: 'Agente de Soporte',
                    permissions: ['view_all_transactions']
                }
            };
            
            const user = adminUsers[username];
            if (!user || user.password !== password) {
                sendError(res, 401, 'Credenciales inválidas');
                return;
            }
            
            // Generate session token (in production, use JWT or proper session management)
            const sessionToken = crypto.randomBytes(32).toString('hex');
            const expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000); // 8 hours
            
            // Store session (in production, use Redis or database)
            database.admin_sessions = database.admin_sessions || {};
            database.admin_sessions[sessionToken] = {
                username: username,
                role: user.role,
                name: user.name,
                permissions: user.permissions,
                created_at: new Date().toISOString(),
                expires_at: expiresAt.toISOString(),
                last_activity: new Date().toISOString()
            };
            
            saveDatabase();
            
            log('info', 'Admin login successful', { username, role: user.role });
            
            sendSuccess(res, {
                token: sessionToken,
                user: {
                    username: username,
                    role: user.role,
                    name: user.name,
                    permissions: user.permissions
                },
                expires_at: expiresAt.toISOString(),
                message: 'Login exitoso'
            });
            return;
        }
        
        // ADMIN: Verify session endpoint
        if (pathname === '/api/admin/verify' && method === 'POST') {
            const { token } = body;
            
            if (!token) {
                sendError(res, 400, 'Token es requerido');
                return;
            }
            
            const session = database.admin_sessions?.[token];
            if (!session) {
                sendError(res, 401, 'Sesión inválida');
                return;
            }
            
            // Check if session is expired
            if (new Date() > new Date(session.expires_at)) {
                delete database.admin_sessions[token];
                saveDatabase();
                sendError(res, 401, 'Sesión expirada');
                return;
            }
            
            // Update last activity
            session.last_activity = new Date().toISOString();
            saveDatabase();
            
            sendSuccess(res, {
                user: {
                    username: session.username,
                    role: session.role,
                    name: session.name,
                    permissions: session.permissions
                },
                expires_at: session.expires_at
            });
            return;
        }
        
        // ADMIN: Logout endpoint
        if (pathname === '/api/admin/logout' && method === 'POST') {
            const { token } = body;
            
            if (token && database.admin_sessions?.[token]) {
                delete database.admin_sessions[token];
                saveDatabase();
                log('info', 'Admin logout', { username: database.admin_sessions[token]?.username });
            }
            
            sendSuccess(res, { message: 'Logout exitoso' });
            return;
        }

        // ADMIN: Get all pending deposits for manual verification
        if (pathname === '/api/admin/deposits/pending' && method === 'GET' || method === 'HEAD') {
            // Verify admin authentication
            const authHeader = req.headers.authorization;
            if (!authHeader || !authHeader.startsWith('Bearer ')) {
                sendError(res, 401, 'Token de autenticación requerido');
                return;
            }
            
            const token = authHeader.split(' ')[1];
            const session = database.admin_sessions?.[token];
            
            if (!session) {
                sendError(res, 401, 'Sesión inválida');
                return;
            }
            
            if (new Date() > new Date(session.expires_at)) {
                delete database.admin_sessions[token];
                saveDatabase();
                sendError(res, 401, 'Sesión expirada');
                return;
            }
            
            // Update last activity
            session.last_activity = new Date().toISOString();
            const pendingDeposits = (database.deposits || [])
                .filter(d => d.status === 'pending_transfer' || d.status === 'processing')
                .map(deposit => ({
                    id: deposit.id,
                    user_id: deposit.user_id,
                    amount: deposit.amount,
                    net_amount: deposit.net_amount,
                    bank_name: deposit.bank_name,
                    reference_number: deposit.reference_number,
                    user_account_number: deposit.user_account_number,
                    status: deposit.status,
                    status_description: transactionManager.getStateDescription(deposit.status),
                    created_at: deposit.created_at,
                    estimated_completion: deposit.estimated_completion,
                    time_remaining: deposit.expires_at ? 
                        Math.max(0, new Date(deposit.expires_at) - new Date()) / (1000 * 60 * 60) : null, // hours
                    receipt: deposit.receipt ? {
                        filename: deposit.receipt.filename,
                        original_name: deposit.receipt.original_name,
                        uploaded_at: deposit.receipt.uploaded_at,
                        size: deposit.receipt.size,
                        security_flags: deposit.receipt.security_flags || [],
                        requires_manual_review: deposit.receipt.requires_manual_review || false,
                        validation_status: deposit.receipt.validation_status || 'pending'
                    } : null,
                    security_score: deposit.receipt?.security_flags?.length || 0,
                    priority: deposit.receipt?.requires_manual_review ? 'high' : 'normal'
                }))
                .sort((a, b) => new Date(a.created_at) - new Date(b.created_at)); // Oldest first

            sendSuccess(res, {
                pending_deposits: pendingDeposits,
                total_pending: pendingDeposits.length,
                total_amount: pendingDeposits.reduce((sum, d) => sum + d.amount, 0),
                banks_summary: pendingDeposits.reduce((acc, d) => {
                    acc[d.bank_name] = (acc[d.bank_name] || 0) + 1;
                    return acc;
                }, {})
            });
            return;
        }

        // ADMIN: Confirm a deposit manually
        if (pathname === '/api/admin/deposits/confirm' && method === 'POST') {
            // Check authentication
            const authHeader = req.headers.authorization;
            if (!authHeader || !authHeader.startsWith('Bearer ')) {
                sendError(res, 401, 'Token de autorización requerido');
                return;
            }
            
            const token = authHeader.split(' ')[1];
            const session = database.admin_sessions?.[token];
            
            if (!session || new Date() > new Date(session.expires_at)) {
                if (session && database.admin_sessions) delete database.admin_sessions[token];
                sendError(res, 401, 'Sesión expirada');
                return;
            }
            
            // Check permissions
            if (!session.permissions.includes('confirm_deposits')) {
                sendError(res, 403, 'Sin permisos para confirmar depósitos');
                return;
            }
            
            const { deposit_id, admin_id, admin_notes, received_amount } = body;
            
            if (!deposit_id || !admin_id) {
                sendError(res, 400, 'deposit_id y admin_id son requeridos');
                return;
            }

            const depositIndex = database.deposits?.findIndex(d => d.id === deposit_id);
            
            if (depositIndex === -1) {
                sendError(res, 404, 'Depósito no encontrado');
                return;
            }

            const deposit = database.deposits[depositIndex];

            if (deposit.status !== 'pending_transfer' && deposit.status !== 'processing') {
                sendError(res, 400, 'Solo se pueden confirmar depósitos pendientes o en proceso');
                return;
            }

            // Update deposit status to confirmed
            const result = transactionManager.updateTransactionState(deposit_id, 'confirmed', 'admin_manual_confirmation');

            if (!result.success) {
                sendError(res, 400, result.error);
                return;
            }

            // Add admin confirmation data
            database.deposits[depositIndex].confirmed_by = admin_id;
            database.deposits[depositIndex].confirmed_at = new Date().toISOString();
            database.deposits[depositIndex].admin_notes = admin_notes || '';
            database.deposits[depositIndex].received_amount = received_amount || deposit.amount;

            // Update user balance
            const user = database.users?.find(u => u.id === deposit.user_id);
            if (user) {
                user.balance = (user.balance || 0) + deposit.net_amount;
                user.pending_deposits = Math.max(0, (user.pending_deposits || 0) - deposit.net_amount);
                user.total_deposits = (user.total_deposits || 0) + deposit.net_amount;
            }

            saveDatabase(); // Persist confirmation
            
            // Send confirmation notification
            sendDepositNotification({
                type: 'deposit_confirmed',
                deposit: deposit,
                user_id: deposit.user_id,
                admin_id: admin_id
            });

            sendSuccess(res, {
                deposit_id,
                user_id: deposit.user_id,
                old_status: 'pending_transfer',
                new_status: 'confirmed',
                confirmed_by: admin_id,
                confirmed_at: database.deposits[depositIndex].confirmed_at,
                amount: deposit.amount,
                net_amount: deposit.net_amount,
                received_amount: received_amount || deposit.amount,
                admin_notes: admin_notes || '',
                user_new_balance: user?.balance || 0,
                message: 'Depósito confirmado exitosamente'
            });
            return;
        }

        // ADMIN: Reject a deposit manually
        if (pathname === '/api/admin/deposits/reject' && method === 'POST') {
            // Check authentication
            const authHeader = req.headers.authorization;
            if (!authHeader || !authHeader.startsWith('Bearer ')) {
                sendError(res, 401, 'Token de autorización requerido');
                return;
            }
            
            const token = authHeader.split(' ')[1];
            const session = database.admin_sessions?.[token];
            
            if (!session || new Date() > new Date(session.expires_at)) {
                if (session && database.admin_sessions) delete database.admin_sessions[token];
                sendError(res, 401, 'Sesión expirada');
                return;
            }
            
            // Check permissions
            if (!session.permissions.includes('reject_deposits')) {
                sendError(res, 403, 'Sin permisos para rechazar depósitos');
                return;
            }
            
            const { deposit_id, admin_id, rejection_reason, admin_notes } = body;
            
            if (!deposit_id || !admin_id || !rejection_reason) {
                sendError(res, 400, 'deposit_id, admin_id y rejection_reason son requeridos');
                return;
            }

            const depositIndex = database.deposits?.findIndex(d => d.id === deposit_id);
            
            if (depositIndex === -1) {
                sendError(res, 404, 'Depósito no encontrado');
                return;
            }

            const deposit = database.deposits[depositIndex];

            if (deposit.status !== 'pending_transfer' && deposit.status !== 'processing') {
                sendError(res, 400, 'Solo se pueden rechazar depósitos pendientes o en proceso');
                return;
            }

            // Update deposit status to failed
            const result = transactionManager.updateTransactionState(deposit_id, 'failed', rejection_reason);

            if (!result.success) {
                sendError(res, 400, result.error);
                return;
            }

            // Add admin rejection data
            database.deposits[depositIndex].rejected_by = admin_id;
            database.deposits[depositIndex].rejected_at = new Date().toISOString();
            database.deposits[depositIndex].rejection_reason = rejection_reason;
            database.deposits[depositIndex].admin_notes = admin_notes || '';

            saveDatabase(); // Persist rejection
            
            // Send rejection notification
            sendDepositNotification({
                type: 'deposit_rejected',
                deposit: deposit,
                user_id: deposit.user_id,
                admin_id: admin_id,
                rejection_reason: rejection_reason,
                admin_notes: admin_notes || ''
            });

            sendSuccess(res, {
                deposit_id,
                user_id: deposit.user_id,
                old_status: deposit.status,
                new_status: 'failed',
                rejected_by: admin_id,
                rejected_at: database.deposits[depositIndex].rejected_at,
                rejection_reason,
                admin_notes: admin_notes || '',
                message: 'Depósito rechazado exitosamente'
            });
            return;
        }
        
        // 3. Cancel a pending deposit
        if (pathname === '/api/deposit/cancel' && method === 'POST') {
            const { deposit_id, user_id, reason = 'cancelled_by_user' } = body;
            
            if (!deposit_id || !user_id) {
                sendError(res, 400, 'deposit_id y user_id son requeridos');
                return;
            }
            
            // Find the deposit
            const deposit = database.deposits?.find(d => d.id === deposit_id && d.user_id === user_id);
            
            if (!deposit) {
                sendError(res, 404, 'Depósito no encontrado');
                return;
            }
            
            // Can only cancel pending deposits
            if (deposit.status !== 'pending_transfer') {
                sendError(res, 400, 'Solo se pueden cancelar depósitos pendientes');
                return;
            }
            
            // Update status to cancelled
            const result = transactionManager.updateTransactionState(deposit_id, 'cancelled', reason);
            
            if (!result.success) {
                sendError(res, 400, result.error);
                return;
            }
            
            saveDatabase(); // Persist cancellation
            
            sendSuccess(res, {
                deposit_id,
                user_id,
                old_status: 'pending_transfer',
                new_status: 'cancelled',
                reason,
                cancelled_at: new Date().toISOString(),
                message: 'Depósito cancelado exitosamente'
            });
            return;
        }
        
        // 4. Modify a pending deposit
        if (pathname === '/api/deposit/modify' && method === 'POST') {
            const { deposit_id, user_id, new_amount, new_account_number } = body;
            
            if (!deposit_id || !user_id || !new_amount) {
                sendError(res, 400, 'deposit_id, user_id y new_amount son requeridos');
                return;
            }
            
            if (new_amount < 10) {
                sendError(res, 400, 'El monto debe ser mayor a $10');
                return;
            }
            
            // Find the deposit
            const depositIndex = database.deposits?.findIndex(d => d.id === deposit_id && d.user_id === user_id);
            
            if (depositIndex === -1) {
                sendError(res, 404, 'Depósito no encontrado');
                return;
            }
            
            const deposit = database.deposits[depositIndex];
            
            // Can only modify pending deposits
            if (deposit.status !== 'pending_transfer') {
                sendError(res, 400, 'Solo se pueden modificar depósitos pendientes');
                return;
            }
            
            // Generate new reference
            const newReference = `BT${Date.now()}`;
            const oldAmount = deposit.amount;
            const oldAccountNumber = deposit.account_number;
            
            // Calculate new fees
            const feeAmount = new_amount * 0.02; // 2% fee
            const fees = { total: feeAmount };
            
            // Update deposit with new data
            database.deposits[depositIndex] = {
                ...deposit,
                amount: new_amount,
                net_amount: new_amount - fees.total,
                transaction_fee: fees.total,
                account_number: new_account_number || deposit.account_number,
                reference_number: newReference,
                modified_at: new Date().toISOString(),
                modification_history: [
                    ...(deposit.modification_history || []),
                    {
                        old_amount: oldAmount,
                        old_account_number: oldAccountNumber,
                        old_reference: deposit.reference_number,
                        modified_at: new Date().toISOString(),
                        reason: 'user_modification'
                    }
                ]
            };
            
            saveDatabase(); // Persist modification
            
            sendSuccess(res, {
                deposit_id,
                user_id,
                old_amount: oldAmount,
                new_amount: new_amount,
                old_reference: database.deposits[depositIndex].reference_number,
                new_reference: newReference,
                net_amount: new_amount - fees.total,
                transaction_fee: fees.total,
                modified_at: new Date().toISOString(),
                message: 'Depósito modificado exitosamente'
            });
            return;
        }
        
        // 5. Extend deposit expiration time
        if (pathname === '/api/deposit/extend' && method === 'POST') {
            const { deposit_id, user_id, extension_hours } = body;
            
            if (!deposit_id || !user_id || !extension_hours) {
                sendError(res, 400, 'deposit_id, user_id y extension_hours son requeridos');
                return;
            }
            
            if (extension_hours < 1 || extension_hours > 72) {
                sendError(res, 400, 'extension_hours debe estar entre 1 y 72 horas');
                return;
            }
            
            // Find the deposit
            const depositIndex = database.deposits?.findIndex(d => d.id === deposit_id && d.user_id === user_id);
            
            if (depositIndex === -1) {
                sendError(res, 404, 'Depósito no encontrado');
                return;
            }
            
            const deposit = database.deposits[depositIndex];
            
            // Can only extend pending deposits
            if (deposit.status !== 'pending_transfer') {
                sendError(res, 400, 'Solo se pueden extender depósitos pendientes');
                return;
            }
            
            // Check if already extended
            if (deposit.extension_count && deposit.extension_count >= 1) {
                sendError(res, 400, 'Este depósito ya ha sido extendido anteriormente');
                return;
            }
            
            // Calculate new expiry date
            const currentExpiry = new Date(deposit.expires_at || Date.now() + 24*60*60*1000);
            const newExpiry = new Date(currentExpiry.getTime() + (extension_hours * 60 * 60 * 1000));
            
            // Update deposit with extension
            database.deposits[depositIndex] = {
                ...deposit,
                expires_at: newExpiry.toISOString(),
                extension_count: (deposit.extension_count || 0) + 1,
                extension_hours: extension_hours,
                extended_at: new Date().toISOString(),
                extension_history: [
                    ...(deposit.extension_history || []),
                    {
                        extended_at: new Date().toISOString(),
                        hours_added: extension_hours,
                        old_expiry: currentExpiry.toISOString(),
                        new_expiry: newExpiry.toISOString()
                    }
                ]
            };
            
            saveDatabase(); // Persist extension
            
            sendSuccess(res, {
                deposit_id,
                user_id,
                extension_hours,
                old_expiry_date: currentExpiry.toISOString(),
                new_expiry_date: newExpiry.toISOString(),
                extended_at: new Date().toISOString(),
                extension_count: database.deposits[depositIndex].extension_count,
                message: `Tiempo extendido por ${extension_hours} horas`
            });
            return;
        }
        
        // 6. Get all transactions for user with status filtering
        if (pathname === '/api/user/transactions' && method === 'POST') {
            const { user_id, status_filter, limit = 20, offset = 0 } = body;
            
            if (!user_id) {
                sendError(res, 400, 'user_id es requerido');
                return;
            }
            
            let userTransactions = database.deposits?.filter(d => d.user_id === user_id) || [];
            
            // Apply status filter if provided
            if (status_filter && Array.isArray(status_filter)) {
                userTransactions = userTransactions.filter(t => status_filter.includes(t.status));
            }
            
            // Apply pagination
            const total = userTransactions.length;
            const paginatedTransactions = userTransactions
                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
                .slice(offset, offset + limit);
            
            sendSuccess(res, {
                user_id,
                transactions: paginatedTransactions.map(t => ({
                    id: t.id,
                    type: t.type,
                    status: t.status,
                    status_description: transactionManager.getStateDescription(t.status),
                    amount: t.amount,
                    net_amount: t.net_amount,
                    bank_name: t.bank_name,
                    reference_number: t.reference_number,
                    created_at: t.created_at,
                    expires_at: t.expires_at
                })),
                pagination: {
                    total,
                    limit,
                    offset,
                    has_more: (offset + limit) < total
                },
                status_summary: getStatusSummary(userTransactions)
            });
            return;
        }

        // Verification endpoints
        if (pathname === '/api/verification/phone/send' && method === 'POST') {
            const { user_id, phone_number } = body;
            const verificationId = generateId('verify');
            sendSuccess(res, {
                message: 'Código de verificación enviado',
                verification_id: verificationId,
                phone_number,
                expires_in: 600 // 10 minutes
            });
            return;
        }

        // Business analytics
        if (pathname === '/api/business/analytics/revenue' && method === 'POST') {
            const totalRevenue = database.groups.reduce((sum, g) => sum + g.total_amount_collected, 0);
            const totalCommission = totalRevenue * 0.05;
            
            sendSuccess(res, {
                total_revenue: totalRevenue,
                commission_earned: totalCommission,
                growth_rate: 18.5,
                active_groups: database.groups.filter(g => g.status === 'active').length,
                total_users: database.users.length,
                breakdown: {
                    payments: totalRevenue * 0.92,
                    fees: totalRevenue * 0.08
                }
            });
            return;
        }

        if (pathname === '/api/business/performance/dashboard' && method === 'GET' || method === 'HEAD') {
            sendSuccess(res, {
                kpis: {
                    total_revenue: 285000.00,
                    monthly_growth: 18.5,
                    active_users: database.users.filter(u => u.status === 'active').length,
                    active_groups: database.groups.filter(g => g.status === 'active').length
                },
                system_health: {
                    api_uptime: 99.9,
                    response_time: 65,
                    error_rate: 0.1,
                    mobile_app_health: 'excellent'
                },
                mobile_metrics: {
                    app_downloads: 1250,
                    daily_active_users: 890,
                    session_duration_avg: 420, // seconds
                    push_notification_rate: 0.78
                }
            });
            return;
        }

        // Notifications
        if (pathname === '/api/notifications/send' && method === 'POST') {
            const { user_id, type, title, message } = body;
            const notificationId = generateId('notif');
            const notification = {
                id: notificationId,
                user_id,
                type,
                title,
                message,
                sent_at: new Date().toISOString(),
                status: 'sent',
                channels: ['push', 'in_app'],
                push_delivered: true
            };
            database.notifications.push(notification);
            sendSuccess(res, {
                notification_id: notificationId,
                message: 'Notificación enviada exitosamente',
                delivery_status: 'sent'
            });
            return;
        }

        // Default 404 handler

        // ===== TANDAS ENDPOINTS (Rotative Turn-based System) =====

        // Create new tanda
        if (pathname === "/api/tandas/create" && method === "POST") {
            const {
                name,
                contribution_amount,
                participants,
                frequency,
                turns_order,
                coordinator_id,
                group_id
            } = body;

            log("info", `Creating tanda: ${name} by ${coordinator_id}`);

            // Validations
            if (!name || !contribution_amount || !participants || !coordinator_id) {
                sendError(res, 400, "Campos requeridos: name, contribution_amount, participants, coordinator_id");
                return;
            }

            if (participants < 2) {
                sendError(res, 400, "Se requieren al menos 2 participantes");
                return;
            }

            if (!turns_order || turns_order.length !== participants) {
                sendError(res, 400, "turns_order debe contener exactamente " + participants + " IDs de usuarios");
                return;
            }

            // Generate tanda
            const tandaId = generateId("tanda");
            const tanda = {
                id: tandaId,
                name: name,
                contribution_amount: parseFloat(contribution_amount),
                total_per_turn: parseFloat(contribution_amount) * participants,
                frequency: frequency || "weekly",
                coordinator_id: coordinator_id,
                group_id: group_id || null,
                status: "active",
                created_at: new Date().toISOString(),

                // Turns management
                current_turn: 1,
                total_turns: participants,
                turns_order: turns_order, // Array of user_ids

                // Turn history
                turn_history: [],

                // Current turn payments
                current_turn_payments: {
                    turn_number: 1,
                    recipient_user_id: turns_order[0],
                    paid_by: [], // Array of user_ids who paid
                    pending_from: turns_order.slice(1) // All except recipient initially
                }
            };

            // Store tanda
            if (!database.tandas) {
                database.tandas = [];
            }
            database.tandas.push(tanda);
            saveDatabase();

            log("info", `Tanda created: ${tandaId} - ${name}`);

            sendSuccess(res, {
                message: "Tanda creada exitosamente",
                tanda_id: tandaId,
                tanda: tanda
            });
            return;
        }

        // List tandas - MODIFIED to support JWT auth and groups with is_tanda
        // NEW PostgreSQL-based endpoint for my-tandas

        // POST /api/tandas/start - Start a tanda (coordinator only)
        if (pathname === "/api/tandas/start" && method === "POST") {
            
            try {
                
                const tandaId = body.tanda_id;
                let userId = body.user_id;
                
                // Try JWT auth if no user_id
                if (!userId) {
                    const authHeader = req.headers.authorization;
                    if (authHeader) {
                        const token = authHeader.replace("Bearer ", "");
                        try { const decoded = jwt.verify(token, JWT_SECRET); userId = decoded.userId || decoded.id || decoded.sub; } catch (e) {}
                    }
                }
                
                if (!tandaId) { sendError(res, 400, "tanda_id requerido"); return; }
                if (!userId) { sendError(res, 400, "user_id requerido"); return; }
                
                // Get tanda to verify coordinator
                const tanda = await dbPostgres.pool.query(
                    "SELECT * FROM tandas WHERE tanda_id = $1",
                    [tandaId]
                );
                
                if (!tanda.rows || tanda.rows.length === 0) {
                    sendError(res, 404, "Tanda no encontrada");
                    return;
                }
                
                const tandaData = tanda.rows[0];
                
                // Verify user is coordinator
                if (tandaData.coordinator_id !== userId) {
                    sendError(res, 403, "Solo el coordinador puede iniciar la tanda");
                    return;
                }
                
                // Verify tanda is in recruiting status
                if (tandaData.status !== "recruiting" && tandaData.status !== "pending") {
                    sendError(res, 400, `La tanda ya está en estado: ${tandaData.status}`);
                    return;
                }
                
                // Verify minimum members (at least 2)
                const turnsOrder = tandaData.turns_order || [];
                if (turnsOrder.length < 2) {
                    sendError(res, 400, "Se necesitan al menos 2 miembros para iniciar la tanda");
                    return;
                }
                
                // Start the tanda
                const updateResult = await dbPostgres.pool.query(
                    `UPDATE tandas SET 
                        status = 'active', 
                        current_turn = 1, 
                        total_turns = $1,
                        updated_at = NOW() 
                    WHERE tanda_id = $2
                    RETURNING *`,
                    [turnsOrder.length, tandaId]
                );
                
                log("info", `✅ Tanda iniciada: ${tandaId} por coordinador ${userId} con ${turnsOrder.length} miembros`);
                
                sendSuccess(res, { 
                    message: "Tanda iniciada exitosamente",
                    tanda_id: tandaId,
                    status: "active",
                    current_turn: 1,
                    total_members: turnsOrder.length,
                    first_collector: turnsOrder[0]
                });
            } catch (error) {
                log("error", `Error starting tanda: ${error.message}`);
                sendError(res, 500, "Error al iniciar la tanda");
            }
            return;
        }

        if (pathname === "/api/tandas/my-tandas" && method === "GET") {
            let userId = query.user_id;
            if (!userId) {
                const authHeader = req.headers.authorization;
                if (authHeader) {
                    const token = authHeader.replace("Bearer ", "");
                    try { const decoded = jwt.verify(token, JWT_SECRET); userId = decoded.userId || decoded.id || decoded.sub; } catch (e) {}
                }
            }
            if (!userId) { sendError(res, 400, "user_id requerido"); return; }
            // Clean userId - remove any query string artifacts
            if (userId.includes("?")) { userId = userId.split("?")[0]; }
            console.log("DEBUG my-tandas PostgreSQL: userId =", userId);
            try {
                const userTandas = await dbPostgres.getTandasByUser(userId);
                console.log("DEBUG my-tandas PostgreSQL: userTandas count =", userTandas.length, "userTandas:", JSON.stringify(userTandas).substring(0, 200));
                const enrichedTandas = userTandas.map(t => {
                    const turnsOrder = t.turns_order || [];
                    const myTurnPosition = turnsOrder.indexOf(userId) + 1 || 1;
                    const currentTurn = t.current_turn || 0;
                    const totalTurns = t.total_turns || turnsOrder.length || 1;
                    let status = t.status || "active";
                    const isCoordinator = t.coordinator_id === userId;
                    const hasTurnAssigned = turnsOrder.includes(userId) || isCoordinator;
                    
                    // For recruiting/pending tandas - no payment dates yet
                    if (status === "recruiting" || status === "pending") {
                        return {
                            tanda_id: t.id || t.tanda_id,
                            group_id: t.group_id,
                            group_name: t.name,
                            status: status,
                            contribution_amount: parseFloat(t.contribution_amount) || 0,
                            total_per_turn: parseFloat(t.total_per_turn) || (parseFloat(t.contribution_amount) * totalTurns),
                            frequency: t.frequency,
                            total_participants: totalTurns,
                            current_turn: 0,
                            my_turn_position: myTurnPosition,
                            next_payment_date: null,
                            next_payment_amount: parseFloat(t.contribution_amount),
                            collecting_member: null,
                            cycle_start_date: null,
                            progress_percentage: 0,
                            my_contributions_paid: 0,
                            my_contributions_total: totalTurns,
                            is_demo: t.is_demo,
                            is_coordinator: isCoordinator,
                            coordinator_name: t.coordinator_name || null,
                            members_joined: t.group_member_count || turnsOrder.length,
                            turns_assigned: turnsOrder.length,
                            members_needed: totalTurns,
                            has_turn_assigned: hasTurnAssigned
                        };
                    }
                    
                    // Active tanda logic
                    if (status === "active" && currentTurn === myTurnPosition) status = "collecting";
                    const cycleStart = t.start_date ? new Date(t.start_date) : new Date(t.created_at);
                    let nextPaymentDate = new Date(cycleStart);
                    if (t.frequency === "weekly") nextPaymentDate.setDate(nextPaymentDate.getDate() + (currentTurn * 7));
                    else if (t.frequency === "biweekly") nextPaymentDate.setDate(nextPaymentDate.getDate() + (currentTurn * 14));
                    else nextPaymentDate.setMonth(nextPaymentDate.getMonth() + currentTurn);
                    const collectingMember = currentTurn > 0 ? (turnsOrder[currentTurn - 1] || "Unknown") : (turnsOrder[0] || "Unknown");
                    
                    return {
                        tanda_id: t.id || t.tanda_id,
                        group_id: t.group_id,
                        group_name: t.name,
                        status: status,
                        contribution_amount: parseFloat(t.contribution_amount) || 0,
                        total_per_turn: parseFloat(t.total_per_turn) || (parseFloat(t.contribution_amount) * totalTurns),
                        frequency: t.frequency,
                        total_participants: totalTurns,
                        current_turn: currentTurn,
                        my_turn_position: myTurnPosition,
                        next_payment_date: nextPaymentDate.toISOString(),
                        next_payment_amount: parseFloat(t.contribution_amount),
                        collecting_member: collectingMember,
                        cycle_start_date: cycleStart.toISOString(),
                        progress_percentage: Math.round((currentTurn / totalTurns) * 100) || 0,
                        my_contributions_paid: currentTurn > 0 ? currentTurn - 1 : 0,
                        my_contributions_total: totalTurns,
                        is_demo: t.is_demo,
                        is_coordinator: isCoordinator,
                            coordinator_name: t.coordinator_name || null,
                        has_turn_assigned: hasTurnAssigned
                    };
                });
                log("info", `Returning ${enrichedTandas.length} tandas for ${userId} from PostgreSQL`);
                sendSuccess(res, { tandas: enrichedTandas, total: enrichedTandas.length, source: "postgresql" });
            } catch (error) {
                log("error", `PostgreSQL my-tandas error: ${error.message}`);
                sendError(res, 500, "Error fetching tandas");
            }
            return;
        }

        // GET /api/tandas/my-tandas - Get tandas where user is participant
        if (pathname === "/api/tandas/my-tandas" && method === "GET") {
            // Support both query param and JWT auth
            let userId = query.user_id;
            
            // If no user_id in query, try JWT
            if (!userId) {
                const authHeader = req.headers.authorization;
                if (authHeader) {
                    const token = authHeader.replace("Bearer ", "");
                    try {
                        const decoded = jwt.verify(token, JWT_SECRET);
                        userId = decoded.userId || decoded.id || decoded.sub;
                    } catch (e) {
                        // Token invalid, continue to check if user_id was provided
                    }
                }
            }
            
            if (!userId) {
                sendError(res, 400, "user_id requerido (via query param or JWT)");
                return;
            }
            
            // DEBUG: Log database state
            console.log("DEBUG my-tandas: groups count:", database.groups?.length);
            console.log("DEBUG my-tandas: groups with is_tanda:", database.groups?.filter(g => g.is_tanda)?.length);
            console.log("DEBUG my-tandas: first group is_tanda:", database.groups?.[0]?.is_tanda);
            console.log("DEBUG my-tandas: first group members:", database.groups?.[0]?.members?.length);

            // Find tandas in both database.tandas AND database.groups with is_tanda
            const standalonesTandas = (database.tandas || []).filter(
                t => t.turns_order && t.turns_order.includes(userId)
            );
            
            // Also find groups marked as tandas where user is member
            const groupTandas = (database.groups || [])
                .filter(g => g.is_tanda && g.members) // Allow all authenticated users to see demo tandas
                .map(g => ({
                    id: g.id,
                    group_id: g.id,
                    name: g.name,
                    turns_order: g.members?.map(m => m.user_id) || [],
                    current_turn: g.current_turn || 1,
                    total_turns: g.total_turns || g.members?.length || 0,
                    contribution_amount: g.contribution_amount || 0,
                    frequency: g.payment_frequency || 'monthly',
                    created_at: g.start_date || g.created_at,
                    turn_history: [],
                    status: g.status || 'active',
                    current_collector_id: g.current_collector_id,
                    members: g.members
                }));
            
            const userTandas = [...standalonesTandas, ...groupTandas];

            // Enrich tandas with calculated fields
            const enrichedTandas = userTandas.map(t => {
                // Find user position in turns_order (or assign demo position)
                let myTurnPosition = t.turns_order.indexOf(userId) + 1;
                // For demo users not in the list, assign position 3
                if (myTurnPosition === 0 && t.members) {
                    myTurnPosition = 3; // Demo position
                }
                
                // Determine status
                let status = t.status || 'active';
                if (status === 'active' && t.current_turn === myTurnPosition) {
                    status = 'collecting';
                } else if (status === 'active' && t.current_turn < myTurnPosition) {
                    status = 'waiting-turn';
                }

                // Find current collector
                const collectingMember = t.turns_order[t.current_turn - 1];
                const collectingUser = database.users?.find(u => u.id === collectingMember);
                
                // Calculate next payment date
                const cycleStart = new Date(t.created_at);
                let nextPaymentDate = new Date(cycleStart);
                if (t.frequency === 'weekly') {
                    nextPaymentDate.setDate(nextPaymentDate.getDate() + (t.current_turn * 7));
                } else if (t.frequency === 'biweekly') {
                    nextPaymentDate.setDate(nextPaymentDate.getDate() + (t.current_turn * 14));
                } else {
                    nextPaymentDate.setMonth(nextPaymentDate.getMonth() + t.current_turn);
                }

                // Calculate my payout date
                let myPayoutDate = new Date(cycleStart);
                if (t.frequency === 'weekly') {
                    myPayoutDate.setDate(myPayoutDate.getDate() + (myTurnPosition * 7));
                } else if (t.frequency === 'biweekly') {
                    myPayoutDate.setDate(myPayoutDate.getDate() + (myTurnPosition * 14));
                } else {
                    myPayoutDate.setMonth(myPayoutDate.getMonth() + myTurnPosition);
                }

                // Count my paid contributions
                const myContributionsPaid = t.turn_history?.reduce((count, turn) => {
                    return count + (turn.paid_by?.includes(userId) ? 1 : 0);
                }, 0) || 0;

                return {
                    tanda_id: t.id,
                    group_id: t.group_id,
                    group_name: t.name,
                    status: status,
                    contribution_amount: t.contribution_amount,
                    frequency: t.frequency,
                    total_participants: t.total_turns,
                    current_turn: t.current_turn,
                    my_turn_position: myTurnPosition,
                    next_payment_date: nextPaymentDate.toISOString(),
                    next_payment_amount: t.contribution_amount,
                    collecting_member: collectingUser?.name || collectingMember || 'Unknown',
                    cycle_start_date: t.created_at,
                    my_contributions_paid: myContributionsPaid,
                    my_contributions_total: t.total_turns,
                    total_collected: (t.turn_history?.length || 0) * t.total_per_turn,
                    my_payout_date: myPayoutDate.toISOString(),
                    trust_score: 95,
                    progress_percentage: Math.round((t.current_turn / t.total_turns) * 100)
                };
            });

            log("info", `Returning ${enrichedTandas.length} tandas for user ${userId}`);

            sendSuccess(res, {
                tandas: enrichedTandas,
                total: enrichedTandas.length
            });
            return;
        }

        if (pathname === "/api/tandas" && method === "GET") {
            const coordinatorId = query.coordinator_id;

            if (!coordinatorId) {
                sendError(res, 400, "coordinator_id requerido");
                return;
            }

            const userTandas = (database.tandas || []).filter(
                t => t.coordinator_id === coordinatorId
            );

            // Enrich with member info
            const enrichedTandas = userTandas.map(t => {
                const currentRecipient = database.users?.find(
                    u => u.id === t.current_turn_payments.recipient_user_id
                );

                return {
                    ...t,
                    current_recipient_name: currentRecipient?.name || "Unknown",
                    progress: `${t.current_turn}/${t.total_turns}`,
                    completion_percentage: Math.round((t.current_turn / t.total_turns) * 100)
                };
            });

            log("info", `Listed ${enrichedTandas.length} tandas for coordinator ${coordinatorId}`);

            sendSuccess(res, {
                tandas: enrichedTandas,
                total: enrichedTandas.length
            });
            return;
        }

        // Get tanda details
        if (pathname.startsWith("/api/tandas/") && method === "GET" &&
            !pathname.includes("/record-payment") &&
            !pathname.includes("/advance-turn") &&
            !pathname.includes("/complete")) {

            const tandaId = pathname.split("/")[3];

            log("info", `Fetching tanda details: ${tandaId}`);

            const tanda = database.tandas?.find(t => t.id === tandaId);
            if (!tanda) {
                sendError(res, 404, "Tanda no encontrada");
                return;
            }

            // Enrich with participant details
            const participants = tanda.turns_order.map((userId, index) => {
                const user = database.users?.find(u => u.id === userId);
                const hasPaidCurrentTurn = tanda.current_turn_payments.paid_by.includes(userId);
                const isCurrentRecipient = tanda.current_turn_payments.recipient_user_id === userId;

                return {
                    id: userId,  // Changed from user_id to id
                    name: user?.name || "Unknown",
                    email: user?.email || "",
                    turn_number: index + 1,
                    is_current_recipient: isCurrentRecipient,
                    paid_current_turn: hasPaidCurrentTurn,
                    status: isCurrentRecipient ? "receiving" : (hasPaidCurrentTurn ? "paid" : "pending")
                };
            });

            sendSuccess(res, {
                tanda: {
                    ...tanda,
                    participants: participants
                }
            });
            return;
        }

        // Record payment in tanda
        if (pathname.includes("/record-payment") && method === "POST") {
            const tandaId = pathname.split("/")[3];
            const { user_id, amount, coordinator_id } = body;

            log("info", `Recording payment in tanda ${tandaId} by user ${user_id}`);

            const tanda = database.tandas?.find(t => t.id === tandaId);
            if (!tanda) {
                sendError(res, 404, "Tanda no encontrada");
                return;
            }

            // Verify coordinator
            if (tanda.coordinator_id !== coordinator_id) {
                sendError(res, 403, "Solo el coordinador puede registrar pagos");
                return;
            }

            // Verify user is in tanda
            if (!tanda.turns_order.includes(user_id)) {
                sendError(res, 400, "Usuario no es parte de esta tanda");
                return;
            }

            // Verify user hasn't already paid
            if (tanda.current_turn_payments.paid_by.includes(user_id)) {
                sendError(res, 400, "Este usuario ya pagó en este turno");
                return;
            }

            // Add to paid list
            tanda.current_turn_payments.paid_by.push(user_id);

            // Remove from pending
            tanda.current_turn_payments.pending_from =
                tanda.current_turn_payments.pending_from.filter(id => id !== user_id);

            saveDatabase();

            log("info", `Payment recorded in tanda ${tandaId} by user ${user_id}`);

            sendSuccess(res, {
                message: "Pago registrado",
                tanda_id: tandaId,
                paid_count: tanda.current_turn_payments.paid_by.length,
                pending_count: tanda.current_turn_payments.pending_from.length,
                all_paid: tanda.current_turn_payments.pending_from.length === 0
            });
            return;
        }

        // Advance turn
        if (pathname.includes("/advance-turn") && method === "POST") {
            const tandaId = pathname.split("/")[3];
            const { coordinator_id } = body;

            log("info", `Advancing turn for tanda ${tandaId}`);

            const tanda = database.tandas?.find(t => t.id === tandaId);
            if (!tanda) {
                sendError(res, 404, "Tanda no encontrada");
                return;
            }

            // Verify coordinator
            if (tanda.coordinator_id !== coordinator_id) {
                sendError(res, 403, "Solo el coordinador puede avanzar turnos");
                return;
            }

            // Verify all paid
            const allPaid = tanda.current_turn_payments.pending_from.length === 0;
            if (!allPaid) {
                sendError(res, 400, `Aún hay ${tanda.current_turn_payments.pending_from.length} pagos pendientes. No se puede avanzar el turno.`);
                return;
            }

            // Save current turn to history
            tanda.turn_history.push({
                turn_number: tanda.current_turn,
                recipient_user_id: tanda.current_turn_payments.recipient_user_id,
                completed_at: new Date().toISOString(),
                paid_by: [...tanda.current_turn_payments.paid_by],
                total_collected: tanda.total_per_turn
            });

            // Advance turn
            tanda.current_turn++;

            // Check if tanda completed
            if (tanda.current_turn > tanda.total_turns) {
                tanda.status = "completed";
                tanda.completed_at = new Date().toISOString();

                saveDatabase();

                log("info", `Tanda ${tandaId} completed after ${tanda.total_turns} turns`);

                sendSuccess(res, {
                    message: "¡Tanda completada exitosamente!",
                    tanda_id: tandaId,
                    status: "completed",
                    total_turns: tanda.total_turns
                });
                return;
            }

            // Setup next turn
            tanda.current_turn_payments = {
                turn_number: tanda.current_turn,
                recipient_user_id: tanda.turns_order[tanda.current_turn - 1],
                paid_by: [],
                pending_from: [...tanda.turns_order] // All participants need to pay
            };

            saveDatabase();

            const nextRecipient = database.users?.find(
                u => u.id === tanda.current_turn_payments.recipient_user_id
            );

            log("info", `Tanda ${tandaId} advanced to turn ${tanda.current_turn}`);

            sendSuccess(res, {
                message: `Turno avanzado a #${tanda.current_turn}`,
                tanda_id: tandaId,
                current_turn: tanda.current_turn,
                total_turns: tanda.total_turns,
                next_recipient_name: nextRecipient?.name || "Unknown",
                next_recipient_id: tanda.current_turn_payments.recipient_user_id
            });
            return;
        }

        // Complete tanda manually
        if (pathname.includes("/complete") && method === "POST") {
            const tandaId = pathname.split("/")[3];
            const { coordinator_id } = body;

            log("info", `Manually completing tanda ${tandaId}`);

            const tanda = database.tandas?.find(t => t.id === tandaId);
            if (!tanda) {
                sendError(res, 404, "Tanda no encontrada");
                return;
            }

            // Verify coordinator
            if (tanda.coordinator_id !== coordinator_id) {
                sendError(res, 403, "Solo el coordinador puede completar la tanda");
                return;
            }

            tanda.status = "completed";
            tanda.completed_at = new Date().toISOString();

            saveDatabase();

            log("info", `Tanda ${tandaId} marked as completed manually`);

            sendSuccess(res, {
                message: "Tanda completada",
                tanda_id: tandaId,
                status: "completed"
            });
            return;
        }

        // ===== ANALYTICS ENDPOINTS =====

        // Get analytics dashboard for coordinator
        if (pathname.startsWith("/api/analytics/") && method === "GET" && !pathname.includes("/chart/")) {
            const userId = pathname.split("/")[3];
            const timeRange = query.range || "30days";

            log("info", `Fetching analytics for user ${userId}, range: ${timeRange}`);

            // Calculate date range
            const now = new Date();
            let startDate;
            switch(timeRange) {
                case "7days":
                    startDate = new Date(now - 7 * 24 * 60 * 60 * 1000);
                    break;
                case "30days":
                    startDate = new Date(now - 30 * 24 * 60 * 60 * 1000);
                    break;
                case "90days":
                    startDate = new Date(now - 90 * 24 * 60 * 60 * 1000);
                    break;
                case "year":
                    startDate = new Date(now.getFullYear(), 0, 1);
                    break;
                default:
                    startDate = new Date(0); // All time
            }

            // Get coordinator's groups
            const coordinatorGroups = (database.groups || []).filter(
                g => g.admin_id === userId
            );

            if (coordinatorGroups.length === 0) {
                sendSuccess(res, {
                    members: { total: 0, percentChange: 0, growth: [] },
                    revenue: { total: 0, percentChange: 0, history: [] },
                    payments: { rate: 0, paid: 0, pending: 0, rejected: 0 },
                    groups: { active: 0, total: 0, byRevenue: [] },
                    topMembers: []
                });
                return;
            }

            // Calculate total members
            let totalMembers = 0;
            const membersByDate = {};

            coordinatorGroups.forEach(g => {
                const members = (database.groupMembers || []).filter(
                    m => m.group_id === g.id
                );
                totalMembers += members.length;

                // Track member growth
                members.forEach(m => {
                    if (m.joined_at && new Date(m.joined_at) >= startDate) {
                        const date = new Date(m.joined_at).toISOString().split('T')[0];
                        membersByDate[date] = (membersByDate[date] || 0) + 1;
                    }
                });
            });

            // Calculate total collected
            let totalCollected = 0;
            const revenueByDate = {};

            coordinatorGroups.forEach(g => {
                totalCollected += (g.total_amount_collected || 0);

                // Get transactions for this group
                const groupTransactions = (database.transactions || []).filter(
                    t => t.group_id === g.id &&
                         t.status === "completed" &&
                         new Date(t.created_at) >= startDate
                );

                groupTransactions.forEach(t => {
                    const date = new Date(t.created_at).toISOString().split('T')[0];
                    revenueByDate[date] = (revenueByDate[date] || 0) + (t.amount || 0);
                });
            });

            // Calculate payment rate
            const allPayments = [];
            coordinatorGroups.forEach(g => {
                const groupPayments = (database.transactions || []).filter(
                    t => t.group_id === g.id &&
                         new Date(t.created_at) >= startDate
                );
                allPayments.push(...groupPayments);
            });

            const paidPayments = allPayments.filter(t => t.status === "completed");
            const pendingPayments = allPayments.filter(t => t.status === "pending" || t.status === "pending_verification" || t.status === "processing");
            const rejectedPayments = allPayments.filter(t => t.status === "rejected");

            const paymentRate = allPayments.length > 0
                ? Math.round((paidPayments.length / allPayments.length) * 100)
                : 0;

            // Active vs total groups
            const activeGroups = coordinatorGroups.filter(g => g.status === "active" || !g.status).length;

            // Revenue history for chart
            const revenueHistory = Object.entries(revenueByDate)
                .map(([date, amount]) => ({ date, amount }))
                .sort((a, b) => new Date(a.date) - new Date(b.date));

            // Member growth for chart
            const memberGrowth = Object.entries(membersByDate)
                .map(([date, count]) => ({ date, count }))
                .sort((a, b) => new Date(a.date) - new Date(b.date));

            // Top groups by revenue
            const topGroups = coordinatorGroups
                .map(g => {
                    const members = (database.groupMembers || []).filter(m => m.group_id === g.id);
                    const groupPayments = (database.transactions || []).filter(
                        t => t.group_id === g.id && t.status === "completed"
                    );
                    const totalPaid = groupPayments.filter(t => t.status === "completed").length;
                    const totalDue = members.length;
                    const paymentRate = totalDue > 0 ? Math.round((totalPaid / totalDue) * 100) : 0;

                    return {
                        id: g.id,
                        name: g.name,
                        revenue: g.total_amount_collected || 0,
                        members: members.length,
                        payment_rate: paymentRate
                    };
                })
                .sort((a, b) => b.revenue - a.revenue)
                .slice(0, 5);

            // Top members (most punctual)
            const memberStats = {};
            coordinatorGroups.forEach(g => {
                const members = (database.groupMembers || []).filter(m => m.group_id === g.id);
                members.forEach(m => {
                    if (!memberStats[m.user_id]) {
                        memberStats[m.user_id] = {
                            user_id: m.user_id,
                            name: m.user_name || "Unknown",
                            groups: 0,
                            total_payments: 0,
                            on_time_payments: 0
                        };
                    }
                    memberStats[m.user_id].groups++;

                    // Count payments
                    const userPayments = (database.transactions || []).filter(
                        t => t.user_id === m.user_id && t.status === "completed"
                    );
                    memberStats[m.user_id].total_payments += userPayments.length;

                    // Approximate on-time payments (completed payments)
                    memberStats[m.user_id].on_time_payments += userPayments.length;
                });
            });

            const topMembers = Object.values(memberStats)
                .map(m => ({
                    ...m,
                    on_time_rate: m.total_payments > 0
                        ? Math.round((m.on_time_payments / m.total_payments) * 100)
                        : 0
                }))
                .sort((a, b) => b.on_time_rate - a.on_time_rate)
                .slice(0, 10);

            // Calculate percent changes (simplified - comparing to all-time average)
            const membersPercentChange = 0; // TODO: Implement proper comparison
            const revenuePercentChange = 0; // TODO: Implement proper comparison

            log("info", `Analytics generated for user ${userId}: ${totalMembers} members, L.${totalCollected} revenue`);

            sendSuccess(res, {
                members: {
                    total: totalMembers,
                    percentChange: membersPercentChange,
                    growth: memberGrowth
                },
                revenue: {
                    total: totalCollected,
                    percentChange: revenuePercentChange,
                    history: revenueHistory
                },
                payments: {
                    rate: paymentRate,
                    paid: paidPayments.length,
                    pending: pendingPayments.length,
                    rejected: rejectedPayments.length
                },
                groups: {
                    active: activeGroups,
                    total: coordinatorGroups.length,
                    byRevenue: topGroups
                },
                topMembers: topMembers
            });
            return;
        }

        // Get specific chart data
        if (pathname.includes("/chart/") && method === "GET") {
            const parts = pathname.split("/");
            const userId = parts[3];
            const chartType = parts[5];
            const timeRange = query.range || "30days";
            const groupBy = query.groupBy || "day";

            log("info", `Fetching chart data: ${chartType} for user ${userId}`);

            // Calculate date range
            const now = new Date();
            let startDate;
            switch(timeRange) {
                case "7days":
                    startDate = new Date(now - 7 * 24 * 60 * 60 * 1000);
                    break;
                case "30days":
                    startDate = new Date(now - 30 * 24 * 60 * 60 * 1000);
                    break;
                case "90days":
                    startDate = new Date(now - 90 * 24 * 60 * 60 * 1000);
                    break;
                case "year":
                    startDate = new Date(now.getFullYear(), 0, 1);
                    break;
                default:
                    startDate = new Date(0);
            }

            const coordinatorGroups = (database.groups || []).filter(
                g => g.admin_id === userId
            );

            let chartData = {};

            switch(chartType) {
                case "revenue":
                    // Revenue over time
                    const revenueByPeriod = {};
                    coordinatorGroups.forEach(g => {
                        const transactions = (database.transactions || []).filter(
                            t => t.group_id === g.id &&
                                 t.status === "completed" &&
                                 new Date(t.created_at) >= startDate
                        );
                        transactions.forEach(t => {
                            const date = new Date(t.created_at).toISOString().split('T')[0];
                            revenueByPeriod[date] = (revenueByPeriod[date] || 0) + (t.amount || 0);
                        });
                    });
                    chartData = {
                        labels: Object.keys(revenueByPeriod).sort(),
                        data: Object.keys(revenueByPeriod).sort().map(date => revenueByPeriod[date])
                    };
                    break;

                case "members":
                    // Member growth over time
                    const membersByPeriod = {};
                    coordinatorGroups.forEach(g => {
                        const members = (database.groupMembers || []).filter(
                            m => m.group_id === g.id &&
                                 m.joined_at &&
                                 new Date(m.joined_at) >= startDate
                        );
                        members.forEach(m => {
                            const date = new Date(m.joined_at).toISOString().split('T')[0];
                            membersByPeriod[date] = (membersByPeriod[date] || 0) + 1;
                        });
                    });
                    chartData = {
                        labels: Object.keys(membersByPeriod).sort(),
                        data: Object.keys(membersByPeriod).sort().map(date => membersByPeriod[date])
                    };
                    break;

                case "payments":
                    // Payment status distribution
                    let paid = 0, pending = 0, rejected = 0;
                    coordinatorGroups.forEach(g => {
                        const transactions = (database.transactions || []).filter(
                            t => t.group_id === g.id &&
                                 new Date(t.created_at) >= startDate
                        );
                        paid += transactions.filter(t => t.status === "completed").length;
                        pending += transactions.filter(t =>
                            t.status === "pending" || t.status === "pending_verification" || t.status === "processing"
                        ).length;
                        rejected += transactions.filter(t => t.status === "rejected").length;
                    });
                    chartData = {
                        labels: ["Pagados", "Pendientes", "Rechazados"],
                        data: [paid, pending, rejected]
                    };
                    break;

                case "groups":
                    // Payments per group
                    const groupData = coordinatorGroups.map(g => {
                        const transactions = (database.transactions || []).filter(
                            t => t.group_id === g.id && t.status === "completed"
                        );
                        return {
                            name: g.name,
                            payments: transactions.length
                        };
                    }).sort((a, b) => b.payments - a.payments).slice(0, 10);

                    chartData = {
                        labels: groupData.map(g => g.name),
                        data: groupData.map(g => g.payments)
                    };
                    break;

                default:
                    sendError(res, 400, "Tipo de gráfico no soportado");
                    return;
            }

            log("info", `Chart data generated: ${chartType}`);

            sendSuccess(res, {
                chartType: chartType,
                timeRange: timeRange,
                groupBy: groupBy,
                data: chartData
            });
            return;
        }

        // ===== MATCHING ALGORITHM ENDPOINTS =====

        // Save/update user matching preferences
        if (pathname === "/api/matching/preferences" && method === "POST") {
            const {
                user_id,
                location,
                age_range,
                contribution_range,
                experience_level,
                preferred_frequency
            } = body;

            log("info", `Saving matching preferences for user ${user_id}`);

            // Validations
            if (!user_id) {
                sendError(res, 400, "user_id requerido");
                return;
            }

            // Find or create preferences
            if (!database.matchingPreferences) {
                database.matchingPreferences = [];
            }

            const existingIndex = database.matchingPreferences.findIndex(
                p => p.user_id === user_id
            );

            const preferences = {
                user_id: user_id,
                location: location || null,
                age_range: age_range || { min: 18, max: 65 },
                contribution_range: contribution_range || { min: 0, max: 10000 },
                experience_level: experience_level || "any", // beginner, intermediate, advanced, any
                preferred_frequency: preferred_frequency || "weekly",
                updated_at: new Date().toISOString()
            };

            if (existingIndex >= 0) {
                database.matchingPreferences[existingIndex] = preferences;
            } else {
                database.matchingPreferences.push(preferences);
            }

            saveDatabase();

            log("info", `Preferences saved for user ${user_id}`);

            sendSuccess(res, {
                message: "Preferencias guardadas exitosamente",
                preferences: preferences
            });
            return;
        }

        // Get matching preferences for a user
        if (pathname.startsWith("/api/matching/preferences/") && method === "GET") {
            const userId = pathname.split("/")[4];

            log("info", `Fetching matching preferences for user ${userId}`);

            const preferences = (database.matchingPreferences || []).find(
                p => p.user_id === userId
            );

            if (!preferences) {
                sendSuccess(res, {
                    preferences: null,
                    message: "No se encontraron preferencias guardadas"
                });
                return;
            }

            sendSuccess(res, {
                preferences: preferences
            });
            return;
        }

        // Get available users for matching (with scoring)
        if (pathname.startsWith("/api/users/available-for-matching") && method === "GET") {
            const rawUserId = query.user_id; const userId = rawUserId ? rawUserId.split("?")[0] : null; console.log("DEBUG: rawUserId=", rawUserId, "cleaned userId=", userId);
            const groupId = query.group_id;

            log("info", `Finding matches for user ${userId} in group ${groupId}`);

            if (!userId) {
                sendError(res, 400, "user_id requerido");
                return;
            }

            // Get group details
            const group = (database.groups || []).find(g => g.id === groupId);
            if (!group && groupId) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }

            // Get current members of the group (to exclude them)
            const currentMembers = (database.groupMembers || [])
                .filter(m => m.group_id === groupId)
                .map(m => m.user_id);

            // Get user's matching preferences
            const userPreferences = (database.matchingPreferences || []).find(
                p => p.user_id === userId
            );

            // Get requesting user's data
            const requestingUser = (database.users || []).find(u => u.id === userId);

            // Get all available users (not in current group)
            const availableUsers = (database.users || []).filter(u =>
                u.id !== userId &&
                (!groupId || !currentMembers.includes(u.id)) &&
                u.status !== "suspended" &&
                u.verification_level !== "none"
            );

            // Calculate matching score for each user
            const scoredUsers = availableUsers.map(user => {
                let score = 0;
                const breakdown = {};

                // 1. LOCATION SCORE (30%)
                if (userPreferences && userPreferences.location && user.location) {
                    const locationMatch = userPreferences.location.toLowerCase() === user.location.toLowerCase();
                    const locationScore = locationMatch ? 30 : 0;
                    score += locationScore;
                    breakdown.location = locationScore;
                } else {
                    breakdown.location = 15; // Neutral score if no preference
                    score += 15;
                }

                // 2. AGE SCORE (20%)
                if (userPreferences && userPreferences.age_range && user.age) {
                    const ageInRange = user.age >= userPreferences.age_range.min &&
                                      user.age <= userPreferences.age_range.max;
                    const ageScore = ageInRange ? 20 : 0;
                    score += ageScore;
                    breakdown.age = ageScore;
                } else {
                    breakdown.age = 10; // Neutral score
                    score += 10;
                }

                // 3. EXPERIENCE SCORE (25%)
                const userTandas = (database.tandas || []).filter(t =>
                    t.turns_order && t.turns_order.includes(user.id)
                );
                const userGroups = (database.groupMembers || []).filter(m =>
                    m.user_id === user.id
                );

                const totalExperience = userTandas.length + userGroups.length;
                let experienceScore = 0;

                if (userPreferences && userPreferences.experience_level !== "any") {
                    if (userPreferences.experience_level === "beginner" && totalExperience <= 2) {
                        experienceScore = 25;
                    } else if (userPreferences.experience_level === "intermediate" && totalExperience >= 3 && totalExperience <= 10) {
                        experienceScore = 25;
                    } else if (userPreferences.experience_level === "advanced" && totalExperience > 10) {
                        experienceScore = 25;
                    } else {
                        experienceScore = 10; // Partial match
                    }
                } else {
                    // No preference, score based on experience level
                    if (totalExperience === 0) experienceScore = 10;
                    else if (totalExperience <= 5) experienceScore = 20;
                    else experienceScore = 25;
                }

                score += experienceScore;
                breakdown.experience = experienceScore;

                // 4. TRUST SCORE (15%)
                const trustScore = (user.trust_score || 50) / 100 * 15;
                score += trustScore;
                breakdown.trust = Math.round(trustScore);

                // 5. CONTRIBUTION MATCH (10%)
                let contributionScore = 0;
                if (group && group.contribution_amount && user.avg_contribution) {
                    const diff = Math.abs(group.contribution_amount - user.avg_contribution);
                    const percentDiff = diff / group.contribution_amount;

                    if (percentDiff <= 0.1) contributionScore = 10; // Within 10%
                    else if (percentDiff <= 0.25) contributionScore = 7; // Within 25%
                    else if (percentDiff <= 0.5) contributionScore = 4; // Within 50%
                    else contributionScore = 1;
                } else {
                    contributionScore = 5; // Neutral
                }

                score += contributionScore;
                breakdown.contribution = contributionScore;

                // Round final score
                const finalScore = Math.round(score);

                return {
                    user_id: user.id,
                    name: user.name,
                    email: user.email,
                    location: user.location || "No especificada",
                    age: user.age || null,
                    avatar_url: user.avatar_url || null,
                    verification_level: user.verification_level,
                    trust_score: user.trust_score || 50,
                    total_groups: userGroups.length,
                    total_tandas: userTandas.length,
                    total_experience: totalExperience,
                    avg_contribution: user.avg_contribution || null,
                    match_score: finalScore,
                    score_breakdown: breakdown
                };
            });

            // Sort by match score (highest first)
            scoredUsers.sort((a, b) => b.match_score - a.match_score);

            // Limit to top 20
            const topMatches = scoredUsers.slice(0, 20);

            log("info", `Found ${topMatches.length} matches for user ${userId}`);

            sendSuccess(res, {
                matches: topMatches,
                total: topMatches.length,
                user_preferences: userPreferences || null
            });
            return;
        }

        // Invite user to group
        if (pathname.includes("/invite-user") && method === "POST") {
            const groupId = pathname.split("/")[3];
            const { user_id, invited_by, message } = body;

            log("info", `Inviting user ${user_id} to group ${groupId}`);

            // Validations
            const group = (database.groups || []).find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }

            const invitedUser = (database.users || []).find(u => u.id === user_id);
            if (!invitedUser) {
                sendError(res, 404, "Usuario no encontrado");
                return;
            }

            // Check if user is already a member
            const existingMember = (database.groupMembers || []).find(
                m => m.group_id === groupId && m.user_id === user_id
            );
            if (existingMember) {
                sendError(res, 400, "El usuario ya es miembro de este grupo");
                return;
            }

            // Check if invitation already exists
            if (!database.groupInvitations) {
                database.groupInvitations = [];
            }

            const existingInvitation = database.groupInvitations.find(
                inv => inv.group_id === groupId && inv.user_id === user_id && inv.status === "pending"
            );

            if (existingInvitation) {
                sendError(res, 400, "Ya existe una invitación pendiente para este usuario");
                return;
            }

            // Create invitation
            const invitationId = generateId("invitation");
            const invitation = {
                id: invitationId,
                group_id: groupId,
                group_name: group.name,
                user_id: user_id,
                invited_by: invited_by,
                message: message || null,
                status: "pending", // pending, accepted, rejected
                created_at: new Date().toISOString(),
                expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() // 7 days
            };

            database.groupInvitations.push(invitation);
            saveDatabase();

            log("info", `Invitation ${invitationId} created for user ${user_id} to group ${groupId}`);

            sendSuccess(res, {
                message: "Invitación enviada exitosamente",
                invitation_id: invitationId,
                invitation: invitation
            });
            return;
        }

        // Get invitations for a user
        if (pathname.startsWith("/api/invitations/") && !pathname.includes("/token/") && method === "GET") {
            const userId = pathname.split("/")[3];

            log("info", `Fetching invitations for user ${userId}`);

            const userInvitations = (database.groupInvitations || []).filter(
                inv => inv.user_id === userId
            );

            // Enrich with group details
            const enrichedInvitations = userInvitations.map(inv => {
                const group = (database.groups || []).find(g => g.id === inv.group_id);
                const inviter = (database.users || []).find(u => u.id === inv.invited_by);

                return {
                    ...inv,
                    group_details: group ? {
                        name: group.name,
                        description: group.description,
                        contribution_amount: group.contribution_amount,
                        frequency: group.frequency,
                        members_count: (database.groupMembers || []).filter(m => m.group_id === group.id).length
                    } : null,
                    inviter_name: inviter ? inviter.name : "Desconocido"
                };
            });

            sendSuccess(res, {
                invitations: enrichedInvitations,
                total: enrichedInvitations.length
            });
            return;
        }

        // GET invitation by token (for accepting from link)
        if (pathname.match(/^\/api\/invitations\/token\/[a-f0-9]+$/) && method === "GET") {
            const token = pathname.split("/").pop();
            
            log("info", "Get invitation by token", { token: token.substring(0, 10) + '...' });
            
            try {
                // Get invitation from PostgreSQL
                const invResult = await dbPostgres.pool.query(
                    `SELECT 
                        gi.*,
                        g.name as group_name,
                        g.description as group_description,
                        g.contribution_amount,
                        g.frequency,
                        g.member_count,
                        g.max_members,
                        u.name as inviter_name,
                        u.email as inviter_email
                    FROM group_invitations gi
                    JOIN groups g ON gi.group_id = g.group_id
                    LEFT JOIN users u ON gi.inviter_id = u.user_id
                    WHERE gi.token = \$1`,
                    [token]
                );
                
                if (invResult.rows.length === 0) {
                    sendError(res, 404, "Invitacion no encontrada o token invalido");
                    return;
                }
                
                const invitation = invResult.rows[0];
                
                // Check if expired
                if (new Date(invitation.expires_at) < new Date()) {
                    sendError(res, 400, "Esta invitacion ha expirado");
                    return;
                }
                
                // Check if already used
                if (invitation.status !== 'pending') {
                    sendError(res, 400, "Esta invitacion ya fue " + (invitation.status === 'accepted' ? 'aceptada' : 'rechazada'), 400);
                    return;
                }
                
                sendSuccess(res, {
                    invitation_id: invitation.id,
                    group_id: invitation.group_id,
                    group_name: invitation.group_name,
                    group_description: invitation.group_description,
                    contribution_amount: invitation.contribution_amount,
                    frequency: invitation.frequency,
                    member_count: invitation.member_count,
                    max_members: invitation.max_members,
                    inviter_name: invitation.inviter_name || 'Un miembro',
                    invitee_name: invitation.invitee_name,
                    message: invitation.message,
                    expires_at: invitation.expires_at,
                    status: invitation.status
                });
                return;
                
            } catch (error) {
                log("error", "Error getting invitation by token", { error: error.message });
                sendError(res, 500, "Error al obtener invitacion");
                return;
            }
        }

        // Accept invitation by token (POST)
        if (pathname.match(/^\/api\/invitations\/token\/[a-f0-9]+\/accept$/) && method === "POST") {
            const parts = pathname.split("/");
            const token = parts[4];
            const { user_id } = body;
            
            log("info", "Accept invitation by token", { token: token.substring(0, 10) + '...', user_id });
            
            try {
                // Get invitation
                const invResult = await dbPostgres.pool.query(
                    "SELECT * FROM group_invitations WHERE token = \$1",
                    [token]
                );
                
                if (invResult.rows.length === 0) {
                    sendError(res, 404, "Invitacion no encontrada");
                    return;
                }
                
                const invitation = invResult.rows[0];
                
                // Validations
                if (new Date(invitation.expires_at) < new Date()) {
                    sendError(res, 400, "Esta invitacion ha expirado");
                    return;
                }
                
                if (invitation.status !== 'pending') {
                    sendError(res, 400, "Esta invitacion ya fue procesada", 400);
                    return;
                }
                
                // Check if user is already a member
                const existingMember = await dbPostgres.pool.query(
                    "SELECT id FROM group_members WHERE group_id = \$1 AND user_id = \$2 AND status = 'active'",
                    [invitation.group_id, user_id]
                );
                
                if (existingMember.rows.length > 0) {
                    sendError(res, 400, "Ya eres miembro de este grupo");
                    return;
                }
                
                // Add user to group
                await dbPostgres.pool.query(
                    "INSERT INTO group_members (group_id, user_id, role, status, invited_by) VALUES (\$1, \$2, 'member', 'active', \$3)",
                    [invitation.group_id, user_id, invitation.inviter_id]
                );
                
                // Update invitation status
                await dbPostgres.pool.query(
                    "UPDATE group_invitations SET status = 'accepted', responded_at = NOW() WHERE id = \$1",
                    [invitation.id]
                );
                
                // Get group info for response
                const groupResult = await dbPostgres.pool.query(
                    "SELECT name FROM groups WHERE group_id = \$1",
                    [invitation.group_id]
                );
                
                log("info", "User joined group via invitation", { user_id, group_id: invitation.group_id });
                
                sendSuccess(res, {
                    message: "Te has unido al grupo exitosamente",
                    group_id: invitation.group_id,
                    group_name: groupResult.rows[0]?.name || 'Grupo'
                });
                return;
                
            } catch (error) {
                log("error", "Error accepting invitation", { error: error.message });
                sendError(res, 500, "Error al aceptar invitacion: " + error.message, 500);
                return;
            }
        }


        // Accept/Reject invitation
        if (pathname.includes("/invitations/") && pathname.includes("/respond") && method === "POST") {
            const invitationId = pathname.split("/")[3];
            const { user_id, action } = body; // action: "accept" or "reject"

            log("info", `User ${user_id} responding to invitation ${invitationId} with action: ${action}`);

            const invitation = (database.groupInvitations || []).find(
                inv => inv.id === invitationId
            );

            if (!invitation) {
                sendError(res, 404, "Invitación no encontrada");
                return;
            }

            if (invitation.user_id !== user_id) {
                sendError(res, 403, "No tienes permiso para responder a esta invitación");
                return;
            }

            if (invitation.status !== "pending") {
                sendError(res, 400, `La invitación ya fue ${invitation.status === "accepted" ? "aceptada" : "rechazada"}`);
                return;
            }

            // Check if expired
            if (new Date(invitation.expires_at) < new Date()) {
                invitation.status = "expired";
                saveDatabase();
                sendError(res, 400, "La invitación ha expirado");
                return;
            }

            if (action === "accept") {
                // Add user to group
                const memberId = generateId("member");
                const member = {
                    id: memberId,
                    group_id: invitation.group_id,
                    user_id: user_id,
                    user_name: (database.users || []).find(u => u.id === user_id)?.name || "Unknown",
                    role: "member",
                    joined_at: new Date().toISOString(),
                    payment_status: "pending",
                    total_paid: 0
                };

                if (!database.groupMembers) {
                    database.groupMembers = [];
                }
                database.groupMembers.push(member);

                invitation.status = "accepted";
                invitation.responded_at = new Date().toISOString();

                saveDatabase();

                log("info", `User ${user_id} accepted invitation and joined group ${invitation.group_id}`);

                sendSuccess(res, {
                    message: "Invitación aceptada. ¡Bienvenido al grupo!",
                    member_id: memberId,
                    group_id: invitation.group_id
                });
            } else if (action === "reject") {
                invitation.status = "rejected";
                invitation.responded_at = new Date().toISOString();
                saveDatabase();

                log("info", `User ${user_id} rejected invitation ${invitationId}`);

                sendSuccess(res, {
                    message: "Invitación rechazada"
                });
            } else {
                sendError(res, 400, "Acción inválida. Usa 'accept' o 'reject'");
                return;
            }
            return;
        }

        // =====================================================================
        // POSITION SELECTION & ASSIGNMENT SYSTEM - 10 ENDPOINTS
        // =====================================================================

        // Para Participantes (Tab Tandas)
        if (pathname === '/api/tandas/available-positions' && method === 'GET') {
            handleGetAvailablePositions(req, res, query, database);
            return;
        }

        if (pathname === '/api/tandas/request-position' && method === 'POST') {
            handleRequestPosition(req, res, body, database);
            return;
        }

        if (pathname === '/api/tandas/change-position-request' && method === 'PUT') {
            handleChangePositionRequest(req, res, body, database);
            return;
        }

        if (pathname === '/api/tandas/my-position-status' && method === 'GET') {
            handleGetMyPositionStatus(req, res, query, database);
            return;
        }

        // Para Coordinadores (Tab My Groups)
        if (pathname === '/api/groups/position-requests' && method === 'GET') {
            handleGetPositionRequests(req, res, query, database);
            return;
        }

        if (pathname === '/api/groups/approve-position-request' && method === 'POST') {
            handleApprovePositionRequest(req, res, body, database);
            return;
        }

        if (pathname === '/api/groups/reject-position-request' && method === 'POST') {
            handleRejectPositionRequest(req, res, body, database);
            return;
        }

        if (pathname === '/api/groups/assign-position-manually' && method === 'POST') {
            handleAssignPositionManually(req, res, body, database);
            return;
        }

        if (pathname === '/api/groups/auto-assign-positions' && method === 'POST') {
            handleAutoAssignPositions(req, res, body, database);
            return;
        }

        if (pathname === '/api/groups/activate-tanda' && method === 'POST') {
            handleActivateTanda(req, res, body, database);
            return;
        }


        // POST /api/tandas/pay - Registrar pago de tanda (PostgreSQL)
        if (pathname === "/api/tandas/pay" && method === "POST") {
            try {
                const { tanda_id, amount, payment_method = "wallet", user_id } = body;

                if (!tanda_id || !amount) {
                    sendError(res, 400, "Faltan datos requeridos (tanda_id, amount)");
                    return;
                }

                const userId = user_id || body.user_id;
                if (!userId) {
                    sendError(res, 400, "user_id es requerido");
                    return;
                }

                // Buscar la tanda en PostgreSQL
                const tandaResult = await dbPostgres.pool.query(
                    "SELECT * FROM tandas WHERE tanda_id = $1",
                    [tanda_id]
                );

                if (tandaResult.rows.length === 0) {
                    sendError(res, 404, "Tanda no encontrada");
                    return;
                }

                const tanda = tandaResult.rows[0];

                // Verificar que la tanda esté activa
                if (tanda.status === "recruiting" || tanda.status === "pending") {
                    sendError(res, 400, "La tanda aún no ha iniciado. Está en estado: " + tanda.status);
                    return;
                }

                // Verificar monto
                const expectedAmount = parseFloat(tanda.contribution_amount);
                if (Math.abs(parseFloat(amount) - expectedAmount) > 0.01) {
                    sendError(res, 400, "El monto debe ser L." + expectedAmount.toFixed(2));
                    return;
                }

                // Si es pago con wallet, verificar saldo
                if (payment_method === "wallet") {
                    const walletResult = await dbPostgres.pool.query(
                        "SELECT balance FROM user_wallets WHERE user_id = $1",
                        [userId]
                    );
                    
                    const walletBalance = walletResult.rows.length > 0 
                        ? parseFloat(walletResult.rows[0].balance) 
                        : 0;

                    if (walletBalance < expectedAmount) {
                        sendError(res, 400, "Saldo insuficiente", { 
                            balance: walletBalance, 
                            required: expectedAmount 
                        });
                        return;
                    }

                    // Descontar del saldo
                    await dbPostgres.pool.query(
                        "UPDATE user_wallets SET balance = balance - $1, updated_at = NOW() WHERE user_id = $2",
                        [expectedAmount, userId]
                    );
                }

                // Crear el pago en contributions
                const paymentResult = await dbPostgres.pool.query(
                    "INSERT INTO contributions (user_id, group_id, amount, payment_method, status, cycle_number, paid_date) VALUES ($1, $2, $3, $4, 'completed', $5, NOW()) RETURNING *",
                    [userId, tanda.group_id || tanda_id, expectedAmount, payment_method, tanda.current_turn || 1]
                );

                const payment = paymentResult.rows[0];

                // Obtener nuevo saldo si pagó con wallet
                let newBalance = null;
                if (payment_method === "wallet") {
                    const newBalanceResult = await dbPostgres.pool.query(
                        "SELECT balance FROM user_wallets WHERE user_id = $1",
                        [userId]
                    );
                    newBalance = newBalanceResult.rows.length > 0 
                        ? parseFloat(newBalanceResult.rows[0].balance) 
                        : 0;
                }

                sendSuccess(res, { 
                    message: "¡Pago registrado exitosamente!",
                    payment: {
                        id: payment.id,
                        amount: parseFloat(payment.amount),
                        payment_method: payment.payment_method,
                        status: payment.status,
                        paid_date: payment.paid_date
                    },
                    new_balance: newBalance
                });
                return;

            } catch (error) {
                console.error("Error processing payment:", error);
                sendError(res, 500, "Error al procesar el pago: " + error.message);
                return;
            }
        }
        // GET /api/payments/history - Historial personal de pagos y cobros (PostgreSQL)
        if (pathname === "/api/payments/history" && method === "GET") {
            try {
                const urlParams = new URL(req.url, "http://localhost").searchParams;
                const userId = urlParams.get("user_id");
                const type = urlParams.get("type") || "all";

                if (!userId) {
                    sendError(res, 400, "user_id es requerido");
                    return;
                }

                let payments = [];

                // Obtener pagos enviados desde contributions
                if (type === "sent" || type === "all") {
                    const sentResult = await dbPostgres.pool.query(
                        "SELECT c.id, c.amount, c.payment_method, c.status, c.paid_date as date, c.created_at, t.name as tanda_name, t.tanda_id FROM contributions c LEFT JOIN tandas t ON c.group_id = t.group_id OR c.group_id = t.tanda_id WHERE c.user_id = $1 ORDER BY COALESCE(c.paid_date, c.created_at) DESC LIMIT 50",
                        [userId]
                    );
                    
                    sentResult.rows.forEach(row => {
                        payments.push({
                            id: row.id,
                            amount: parseFloat(row.amount || 0),
                            payment_method: row.payment_method || "wallet",
                            status: row.status || "completed",
                            date: row.date || row.created_at,
                            tanda_name: row.tanda_name || "Tanda",
                            tanda_id: row.tanda_id,
                            direction: "sent",
                            user_id: userId
                        });
                    });
                }

                // Obtener cobros recibidos desde tanda_turn_payments
                if (type === "received" || type === "all") {
                    const receivedResult = await dbPostgres.pool.query(
                        "SELECT tp.id, tp.amount, tp.status, tp.paid_at as date, t.name as tanda_name, t.tanda_id, t.coordinator_id FROM tanda_turn_payments tp JOIN tandas t ON tp.tanda_id = t.tanda_id WHERE t.coordinator_id = $1 ORDER BY tp.paid_at DESC LIMIT 50",
                        [userId]
                    );
                    
                    receivedResult.rows.forEach(row => {
                        payments.push({
                            id: row.id,
                            amount: parseFloat(row.amount || 0),
                            payment_method: "tanda",
                            status: row.status || "completed",
                            date: row.date,
                            tanda_name: row.tanda_name || "Tanda",
                            tanda_id: row.tanda_id,
                            direction: "received"
                        });
                    });
                }

                payments.sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0));

                const totalSent = payments.filter(p => p.direction === "sent").reduce((sum, p) => sum + p.amount, 0);
                const totalReceived = payments.filter(p => p.direction === "received").reduce((sum, p) => sum + p.amount, 0);

                sendSuccess(res, {
                    payments: payments,
                    count: payments.length,
                    totals: { sent: totalSent, received: totalReceived, net: totalReceived - totalSent }
                });
                return;

            } catch (error) {
                console.error("Error loading history:", error);
                sendError(res, 500, "Error al cargar historial: " + error.message);
                return;
            }
        }
        
        // ========== ADMIN: All pending contributions ==========
        if (pathname === '/api/admin/contributions/pending' && (method === 'GET' || method === 'HEAD')) {
            try {
                const result = await dbPostgres.pool.query(`
                    SELECT
                        c.id,
                        c.user_id,
                        c.group_id,
                        c.amount,
                        c.payment_method,
                        c.status,
                        c.reference_code,
                        c.proof_url,
                        c.created_at,
                        c.verified_at,
                        c.verified_by,
                        u.name as user_name,
                        u.email as user_email,
                        g.name as group_name
                    FROM contributions c
                    LEFT JOIN users u ON c.user_id = u.user_id
                    LEFT JOIN groups g ON c.group_id = g.group_id
                    WHERE c.status IN ('pending_verification', 'awaiting_payment')
                    ORDER BY c.created_at DESC
                    LIMIT 100
                `);

                const pendingVerification = result.rows.filter(c => c.status === 'pending_verification');
                const awaitingPayment = result.rows.filter(c => c.status === 'awaiting_payment');

                sendSuccess(res, {
                    contributions: result.rows,
                    summary: {
                        total: result.rows.length,
                        pending_verification: pendingVerification.length,
                        awaiting_payment: awaitingPayment.length,
                        total_amount_pending: result.rows.reduce((sum, c) => sum + parseFloat(c.amount), 0)
                    }
                });
            } catch (error) {
                console.error('Error fetching admin pending contributions:', error);
                sendError(res, 500, 'Error al obtener contribuciones pendientes');
            }
            return;
        }

        // Admin: Dashboard stats
        if (pathname === '/api/admin/dashboard/stats' && (method === 'GET' || method === 'HEAD')) {
            try {
                const stats = await dbPostgres.pool.query(`
                    SELECT
                        (SELECT COUNT(*) FROM users) as total_users,
                        (SELECT COUNT(*) FROM groups WHERE status = 'active') as active_groups,
                        (SELECT COUNT(*) FROM contributions WHERE status = 'pending_verification') as pending_verifications,
                        (SELECT COALESCE(SUM(amount), 0) FROM contributions WHERE status = 'completed') as total_processed,
                        (SELECT COUNT(*) FROM cycle_distributions) as total_distributions
                `);

                sendSuccess(res, {
                    overview: stats.rows[0]
                });
            } catch (error) {
                console.error('Error fetching admin dashboard stats:', error);
                sendError(res, 500, 'Error al obtener estadisticas');
            }
            return;
        }
        // ========== END ADMIN ENDPOINTS ==========

        sendError(res, 404, 'Endpoint not found', {
            requested_path: pathname,
            method: method,
            available_docs: '/docs',
            total_endpoints: 99
        });

    } catch (error) {
        console.error('Server error:', error);
        log('error', 'Server error', { error: error.message, pathname, method });
        sendError(res, 500, 'Internal server error', {
            message: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Helper functions for MIA
function generateMiaResponse(message, context) {
    const responses = {
        'grupos': 'Te puedo ayudar a encontrar el grupo perfecto para ti. ¿Cuánto puedes ahorrar semanalmente?',
        'pagos': 'Tenemos varios métodos de pago disponibles: Tigo Money, Claro Money, transferencia bancaria y efectivo. ¿Cuál prefieres?',
        'ayuda': 'Estoy aquí para ayudarte con todo lo relacionado a La Tanda. ¿Qué necesitas saber?',
        'verificacion': 'Para completar tu verificación necesitas subir tu cédula y una selfie. ¿Ya tienes los documentos listos?'
    };
    
    const lowerMessage = message.toLowerCase();
    for (const key in responses) {
        if (lowerMessage.includes(key)) {
            return responses[key];
        }
    }
    
    return 'Entiendo tu consulta. Te puedo ayudar con información sobre grupos, pagos, verificación y más. ¿Podrías ser más específico?';
}

function getSuggestedActions(message) {
    const lowerMessage = message.toLowerCase();
    if (lowerMessage.includes('grupo')) {
        return ['Ver grupos disponibles', 'Crear nuevo grupo', 'Unirse a grupo'];
    }
    if (lowerMessage.includes('pago')) {
        return ['Ver métodos de pago', 'Realizar pago', 'Historial de pagos'];
    }
    return ['Ver perfil', 'Contactar soporte', 'Ver ayuda'];
}

// Email notification system
const sendDepositNotification = async (data) => {
    try {
        const { type, deposit, user_id } = data;
        
        // Admin emails (in production, this should come from environment variables)
        const adminEmails = [
            'admin@latanda.online',
            'finance@latanda.online'
        ];
        
        let subject, htmlContent;
        
        switch (type) {
            case 'new_deposit':
                subject = `🆕 Nuevo Depósito - $${deposit.amount} - ${deposit.reference_number}`;
                htmlContent = `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                        <div style="background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); color: white; padding: 20px; border-radius: 10px;">
                            <h2 style="color: #00FFFF; margin-bottom: 10px;">🆕 Nuevo Depósito Pendiente</h2>
                            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px;">
                                <p><strong>Usuario:</strong> ${user_id}</p>
                                <p><strong>Monto:</strong> $${deposit.amount.toFixed(2)}</p>
                                <p><strong>Neto:</strong> $${deposit.net_amount.toFixed(2)}</p>
                                <p><strong>Referencia:</strong> ${deposit.reference_number}</p>
                                <p><strong>Banco:</strong> ${deposit.bank_name}</p>
                                <p><strong>Cuenta Usuario:</strong> ${deposit.user_account_number}</p>
                                <p><strong>Fecha:</strong> ${new Date(deposit.created_at).toLocaleString('es-ES')}</p>
                            </div>
                            <div style="margin-top: 20px; text-align: center;">
                                <a href="https://latanda.online/admin-panel.html" 
                                   style="background: #00FFFF; color: #0f172a; padding: 12px 24px; 
                                          text-decoration: none; border-radius: 6px; font-weight: bold;">
                                    Ver Panel de Administración
                                </a>
                            </div>
                            <p style="font-size: 12px; color: #94a3b8; margin-top: 20px;">
                                Este depósito requiere verificación manual. Use el panel de administración para confirmar o rechazar.
                            </p>
                        </div>
                    </div>
                `;
                break;
                
            case 'deposit_confirmed':
                subject = `✅ Depósito Confirmado - $${deposit.amount} - ${deposit.reference_number}`;
                htmlContent = `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                        <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 20px; border-radius: 10px;">
                            <h2 style="margin-bottom: 10px;">✅ Depósito Confirmado</h2>
                            <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                                <p><strong>Usuario:</strong> ${user_id}</p>
                                <p><strong>Monto:</strong> $${deposit.amount.toFixed(2)}</p>
                                <p><strong>Referencia:</strong> ${deposit.reference_number}</p>
                                <p><strong>Confirmado por:</strong> ${data.admin_id}</p>
                                <p><strong>Fecha confirmación:</strong> ${new Date().toLocaleString('es-ES')}</p>
                            </div>
                        </div>
                    </div>
                `;
                break;
                
            case 'deposit_rejected':
                subject = `❌ Depósito Rechazado - $${deposit.amount} - ${deposit.reference_number}`;
                htmlContent = `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                        <div style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; padding: 20px; border-radius: 10px;">
                            <h2 style="margin-bottom: 10px;">❌ Depósito Rechazado</h2>
                            <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                                <p><strong>Usuario:</strong> ${user_id}</p>
                                <p><strong>Monto:</strong> $${deposit.amount.toFixed(2)}</p>
                                <p><strong>Referencia:</strong> ${deposit.reference_number}</p>
                                <p><strong>Rechazado por:</strong> ${data.admin_id}</p>
                                <p><strong>Razón:</strong> ${data.rejection_reason}</p>
                                <p><strong>Notas:</strong> ${data.admin_notes}</p>
                            </div>
                        </div>
                    </div>
                `;
                break;
        }
        
        // Log the email notification (in production, integrate with email service)
        log('info', 'Email notification sent', {
            type,
            subject,
            recipients: adminEmails,
            deposit_id: deposit.id
        });
        
        // TODO: Integrate with actual email service (SendGrid, AWS SES, etc.)
        console.log('📧 EMAIL NOTIFICATION:', {
            to: adminEmails,
            subject,
            html: htmlContent
        });
        
    } catch (error) {
        log('error', 'Failed to send deposit notification', { error: error.message });
    }
};

// Load existing database on startup
loadDatabase();

// Start server
server.listen(port, hostname, () => {
    log('info', 'Server started', { port, hostname });
    console.log('🚀 LA TANDA COMPLETE MOBILE API - 95 ENDPOINTS DEPLOYED');
    console.log(`✅ Server running at http://${hostname}:${port}/`);
    console.log('📱 Mobile-optimized with complete integration');
    console.log('📊 Total Endpoints: 85');
    console.log('📝 Documentation: /docs');
    console.log('🔒 Authentication: Bearer token');
    console.log('🎯 Complete mobile ecosystem ready!');
    console.log('');
    console.log('📋 Endpoint Categories:');
    console.log('   • Core System: 4 endpoints');
    console.log('   • User Journey: 3 endpoints');
    console.log('   • Registration: 9 endpoints');
    console.log('   • Payments: 9 endpoints');
    console.log('   • Verification: 8 endpoints');
    console.log('   • Notifications: 6 endpoints');
    console.log('   • Business Intelligence: 8 endpoints');
    console.log('   • Mobile App Specific: 6 endpoints');
    console.log('   • User Authentication: 4 endpoints');
    console.log('   • Push Notifications: 2 endpoints');
    console.log('   • Offline Sync: 3 endpoints');
    console.log('   • MIA Assistant: 5 endpoints');
    console.log('   • Documentation: 1 endpoint');
    console.log('');
    console.log('🌟 Mobile Features:');
    console.log('   ✅ Real-time push notifications');
    console.log('   ✅ Offline data synchronization');
    console.log('   ✅ MIA AI assistant integration');
    console.log('   ✅ Mobile-optimized user flows');
    console.log('   ✅ Cross-platform compatibility');
    console.log('   ✅ Advanced user analytics');
    console.log('');
    console.log('🎉 Ready for production deployment!');
});

process.on('SIGTERM', () => {
    log('info', 'SIGTERM received');
    server.close(() => process.exit(0));
});

process.on('SIGINT', () => {
    log('info', 'SIGINT received');
    server.close(() => process.exit(0));
});