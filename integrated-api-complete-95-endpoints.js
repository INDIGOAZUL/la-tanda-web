// Load environment variables FIRST
require("dotenv").config({ path: "/var/www/latanda.online/.env" });
// Security middleware
const securityMiddleware = require("./security-middleware.js");
const metricsModule = require("./metrics.js");

// Validate critical environment variables
const requiredEnvVars = ["JWT_SECRET", "SMTP_USER", "SMTP_PASS", "DB_PASSWORD"];
const missingVars = requiredEnvVars.filter(v => !process.env[v]);
if (missingVars.length > 0) {
    console.error("❌ FATAL: Missing required environment variables:", missingVars.join(", "));
    console.error("Please ensure .env file exists with all required variables");
    process.exit(1);
}

const http = require("http");
const https = require("https");
const url = require("url");
// H7: Safe URL parser (replaces deprecated url.parse)
function parseUrl(reqUrl) {
  const u = new URL(reqUrl, 'http://localhost');
  const query = {};
  u.searchParams.forEach((v, k) => { query[k] = v; });
  return { pathname: u.pathname, query };
}
const crypto = require("crypto");
const bcrypt = require("bcrypt");
// const formidable = require("formidable"); // Not needed - using manual parsing
const jwt = require("jsonwebtoken");

// JWT Configuration - NO FALLBACKS (security critical)
const JWT_SECRET = process.env.JWT_SECRET;
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || "24h";
const REFRESH_TOKEN_EXPIRES_IN = process.env.REFRESH_TOKEN_EXPIRES_IN || "7d";

const dns = require("dns").promises;
const nodemailer = require("nodemailer");

// Tesseract OCR for payment verification
const Tesseract = require("tesseract.js");
const emailTemplates = require("./email-templates");
// 2FA Authentication (added 2025-12-15)
const speakeasy = require("speakeasy");
const QRCode = require("qrcode");

// Web Push notifications (VAPID)
const webpush = require("web-push");
if (process.env.VAPID_PUBLIC_KEY && process.env.VAPID_PRIVATE_KEY) {
    webpush.setVapidDetails(
        'mailto:' + (process.env.VAPID_EMAIL || 'admin@latanda.online'),
        process.env.VAPID_PUBLIC_KEY,
        process.env.VAPID_PRIVATE_KEY
    );
}

// WebSocket for live lottery
const wsLottery = require("./websocket-lottery.js");
const lotteryApi = require("./lottery-api.js");
const marketplaceApi = require("./marketplace-api.js");
const miaApi = require("./mia-api.js");


// Payment accounts for OCR verification
const PAYMENT_ACCOUNTS = {
    bank_transfer: {
        bank_name: "Banco Atlántida",
        account_number: "30613012837",
        account_variants: ["30613012837", "3061-301-2837", "3061 301 2837"],
        account_holder: "La Tanda Chain S.A.",
        holder_variants: ["LA TANDA", "TANDA CHAIN", "LA TANDA CHAIN"]
    },
    mobile_money: {
        phone: "+50494485859",
        phone_variants: ["94485859", "50494485859", "+50494485859", "9448-5859", "9448 5859"],
        name: "Narjell Ramon Ebanks Martinez",
        name_variants: ["NARJELL", "EBANKS", "MARTINEZ", "NARJELL RAMON", "EBANKS MARTINEZ"]
    },
    crypto: {
        address: "0x58EA31ceba1B3DeFacB06A5B7fc7408656b91bf7",
        address_short: "0x58EA31",
        address_end: "91bf7"
    }
};

// Email configuration - FROM ENVIRONMENT VARIABLES
const emailTransporter = nodemailer.createTransport({
    service: process.env.SMTP_SERVICE || "gmail",
    auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS
    }
});

// Email senders by type
const EMAIL_SENDERS = {
    // Seguridad y autenticación
    security: "La Tanda Security <security@latanda.online>",
    
    // Transacciones y pagos
    pagos: "La Tanda Pagos <pagos@latanda.online>",
    
    // Notificaciones automáticas
    notificaciones: "La Tanda <notificaciones@latanda.online>",
    noreply: "La Tanda <noreply@latanda.online>",
    
    // Comunicaciones del equipo
    team: "Equipo La Tanda <team@latanda.online>",
    admin: "Admin La Tanda <admin@latanda.online>",
    
    // Soporte y contacto
    soporte: "Soporte La Tanda <soporte@latanda.online>",
    info: "La Tanda <info@latanda.online>",
    hola: "La Tanda <hola@latanda.online>",
    
    // Beta testers
    beta: "La Tanda Beta <beta@latanda.online>"
};

// Send email function with sender type
async function sendEmail(to, subject, htmlContent, senderType) {
    try {
        const from = EMAIL_SENDERS[senderType] || EMAIL_SENDERS.security;
        const mailOptions = {
            from: from,
            to: to,
            subject: subject,
            html: htmlContent
        };
        const result = await emailTransporter.sendMail(mailOptions);
        log("info", "Email sent", { to: to, subject: subject, from: senderType, messageId: result.messageId });
        return { success: true, messageId: result.messageId };
    } catch (error) {
        log("error", "Email error:", error.message);
        return { success: false, error: "Error interno" };
    }
}

const hostname = '127.0.0.1';

// ===== DATA STORAGE CONFIGURATION =====
// Set to false to disable JSON backup writes (use only PostgreSQL)
const ENABLE_JSON_BACKUP_WRITE = process.env.ENABLE_JSON_BACKUP !== "false";
const JSON_BACKUP_COLLECTIONS = ["payments", "admin_sessions"];  // Collections still using JSON (deposits migrated to PostgreSQL v4.7.0)
const port = process.env.PORT || 3002;

// Create logs directory
const fs = require('fs');
const path = require('path');
// ============================================
// POSTGRESQL INTEGRATION - Phase 1: READ operations
// Date: 2025-11-14
// ============================================
const db = require('./db-unified.js');
const dbHelpers = require("./db-helpers-groups");
const dbPostgres = require('./db-postgres.js');
const exportUtils = require('./export-utils.js');
const notificationsUtils = require('./notifications-utils.js');

// Keep legacy database object for non-migrated collections

const logsDir = path.join(__dirname, 'logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

// Enhanced logging
const log = (level, message, data = {}) => {
  const timestamp = new Date().toISOString();
  const logEntry = { timestamp, level, message, ...data };
  console.log(`[${timestamp}] ${level.toUpperCase()}: ${message}`);
  
  const logFile = path.join(logsDir, 'api.log');
  // fs.appendFileSync(logFile, JSON.stringify(logEntry) + '\n');
};

// Database persistence functions
const dbFile = path.join(__dirname, 'database.json');

const saveDatabase = () => {
  try {
    fs.writeFileSync(dbFile, JSON.stringify(database, null, 2));
    log('info', 'Database saved to disk');
  } catch (error) {
    log('error', 'Failed to save database', { error: error.message });
  }
};

const loadDatabase = () => {
  try {
    if (fs.existsSync(dbFile)) {
      const data = fs.readFileSync(dbFile, 'utf8');
      const loadedData = JSON.parse(data);
      
      // Merge with existing structure, preserving tanda fields in groups
      Object.keys(loadedData).forEach(key => {
        if (key === 'groups' && loadedData.groups && database.groups) {
          // Merge groups preserving tanda fields from hardcoded data
          loadedData.groups.forEach((loadedGroup, idx) => {
            const hardcodedGroup = database.groups.find(g => g.id === loadedGroup.id);
            if (hardcodedGroup && hardcodedGroup.is_tanda) {
              // Preserve tanda fields from hardcoded data
              loadedGroup.is_tanda = hardcodedGroup.is_tanda;
              loadedGroup.tanda_type = hardcodedGroup.tanda_type;
              loadedGroup.current_turn = hardcodedGroup.current_turn;
              loadedGroup.total_turns = hardcodedGroup.total_turns;
              loadedGroup.frequency = hardcodedGroup.payment_frequency;
              loadedGroup.next_payment_date = hardcodedGroup.next_payment_date;
              loadedGroup.current_collector_id = hardcodedGroup.current_collector_id;
              loadedGroup.members = hardcodedGroup.members;
              loadedGroup.contribution_amount = hardcodedGroup.contribution_amount;
            }
          });
          database.groups = loadedData.groups;
        } else {
          database[key] = loadedData[key];
        }
      });
      
      log('info', 'Database loaded from disk', {
        users: database.users?.length || 0,
        groups: database.groups?.length || 0,
        groups_with_tanda: database.groups?.filter(g => g.is_tanda)?.length || 0,
        first_group_is_tanda: database.groups?.[0]?.is_tanda
      });
    }
  } catch (error) {
    log('error', 'Failed to load database', { error: error.message });
  }
};

// Auto-save every 5 minutes and on process exit
setInterval(saveDatabase, 5 * 60 * 1000); // 5 minutes
// Signal handlers consolidated at end of file (server.close + process.exit)

// Transaction State Management System (v4.7.0 — validation only, state updates in PostgreSQL)
class TransactionStateManager {
    constructor() {
        this.states = {
            'pending': 'Esperando confirmación bancaria',
            'pending_transfer': 'Esperando que realices la transferencia',
            'processing': 'Comprobante recibido - En revisión administrativa',
            'confirmed': 'Confirmado y completado',
            'cancelled': 'Cancelado por el usuario',
            'failed': 'Falló la verificación',
            'expired': 'Expiró el tiempo límite'
        };

        this.validTransitions = {
            'pending': ['processing', 'cancelled', 'expired'],
            'pending_transfer': ['processing', 'cancelled', 'expired', 'confirmed', 'failed'],
            'processing': ['confirmed', 'failed', 'cancelled'],
            'confirmed': [],
            'cancelled': [],
            'failed': ['pending', 'pending_transfer'],
            'expired': ['pending', 'pending_transfer']
        };
    }

    isValidTransition(currentState, newState) {
        return this.validTransitions[currentState]?.includes(newState) || false;
    }

    getStateDescription(state) {
        return this.states[state] || 'Estado desconocido';
    }
}

// Initialize transaction state manager
const transactionManager = new TransactionStateManager();

// Helper functions for transaction management
function getNextActionsForStatus(status) {
    const actions = {
        'pending': [
            'Realiza la transferencia bancaria según las instrucciones',
            'Conserva el comprobante de transferencia',
            'El sistema verificará automáticamente en 24 horas'
        ],
        'pending_transfer': [
            'Realiza la transferencia bancaria según las instrucciones proporcionadas',
            'Usa exactamente la referencia indicada: es obligatoria',
            'Guarda el comprobante - verificación automática en 2-4 horas'
        ],
        'processing': [
            'Tu transferencia está siendo verificada',
            'No se requiere acción adicional',
            'Recibirás notificación cuando se complete'
        ],
        'confirmed': [
            'Transacción completada exitosamente',
            'El saldo está disponible en tu cuenta'
        ],
        'cancelled': [
            'Transacción cancelada',
            'Puedes intentar un nuevo depósito si deseas'
        ],
        'failed': [
            'La verificación falló',
            'Verifica los datos bancarios',
            'Contacta soporte si persiste el problema'
        ],
        'expired': [
            'La transacción expiró',
            'Puedes crear un nuevo depósito',
            'Las instrucciones de transferencia ya no son válidas'
        ]
    };
    
    return actions[status] || ['Estado desconocido - contacta soporte'];
}

// Enhanced database with comprehensive mobile app data
const database = {
    // Groups data
    groups: [
        {
            id: 'group_001',
            name: 'Grupo Ahorro Familiar',
            contribution_amount: 2000,
            frequency: 'monthly',
            member_count: 6,
            max_members: 12,
            total_amount_collected: 3000.00,
            admin_name: 'Juan Pérez',
            admin_id: 'user_001',
            status: 'active',
            created_at: '2025-01-01T00:00:00Z',
            location: 'Tegucigalpa',
            description: 'Tanda familiar mensual',
            image_url: '/uploads/groups/group_001.jpg',
            category: 'family',
            meeting_schedule: 'Sábados 2:00 PM',
            // TANDA fields
            is_tanda: true,
            tanda_type: 'mensual',
            current_turn: 2,
            total_turns: 6,
            frequency: 'monthly',
            next_payment_date: '2025-12-05',
            current_collector_id: 'user_002',
            members: [
                { user_id: 'user_001', name: 'Juan Pérez', position: 1, payments_made: 2, total_paid: 4000, status: 'active' },
                { user_id: 'user_002', name: 'María González', position: 2, payments_made: 2, total_paid: 4000, status: 'active' },
                { user_id: 'user_003', name: 'Carlos López', position: 3, payments_made: 1, total_paid: 2000, status: 'active' },
                { user_id: 'user_004', name: 'Ana Martínez', position: 4, payments_made: 1, total_paid: 2000, status: 'active' },
                { user_id: 'user_005', name: 'Pedro Sánchez', position: 5, payments_made: 1, total_paid: 2000, status: 'active' },
                { user_id: 'user_006', name: 'Laura Torres', position: 6, payments_made: 1, total_paid: 2000, status: 'active' }
            ]
        },
        {
            id: 'group_002',
            name: 'Emprendedores Unidos',
            contribution_amount: 500.00,
            frequency: 'biweekly',
            member_count: 8,
            max_members: 15,
            total_amount_collected: 12000.00,
            admin_name: 'María González',
            admin_id: 'user_002',
            status: 'active',
            created_at: '2025-01-15T00:00:00Z',
            location: 'San Pedro Sula',
            description: 'Grupo de emprendedores para inversión',
            image_url: '/uploads/groups/group_002.jpg',
            category: 'business',
            meeting_schedule: 'Jueves 6:00 PM'
        }
    ],

    // Users data with mobile app fields
    users: [
        {
            id: 'user_001',
            telegram_id: '123456789',
            name: 'Juan Pérez',
            email: 'juan@example.com',
            phone: '+50498765432',
            verification_level: 'advanced',
            registration_date: '2025-01-01T00:00:00Z',
            status: 'active',
            groups: ['group_001'],
            total_contributions: 1800.00,
            payment_methods: ['bank_transfer', 'tigo_money'],
            // Mobile app specific fields
            avatar_url: '/uploads/avatars/user_001.jpg',
            push_token: 'fcm_token_123456',
            app_version: '4.3.0',
            device_type: 'android',
            last_app_access: '2025-07-24T14:30:00Z',
            notification_preferences: {
                payment_reminders: true,
                group_updates: true,
                marketing: false,
                push_enabled: true
            },
            app_settings: {
                theme: 'light',
                language: 'es',
                biometric_enabled: false,
                auto_backup: true
            }
        },
        {
            id: 'user_002',
            telegram_id: '987654321',
            name: 'María González',
            email: 'maria@example.com',
            phone: '+50487654321',
            verification_level: 'intermediate',
            registration_date: '2025-01-10T00:00:00Z',
            status: 'active',
            groups: ['group_002'],
            total_contributions: 4000.00,
            payment_methods: ['claro_money', 'cash'],
            avatar_url: '/uploads/avatars/user_002.jpg',
            push_token: 'fcm_token_789012',
            app_version: '4.3.0',
            device_type: 'ios',
            last_app_access: '2025-07-24T13:15:00Z',
            notification_preferences: {
                payment_reminders: true,
                group_updates: true,
                marketing: true,
                push_enabled: true
            },
            app_settings: {
                theme: 'dark',
                language: 'es',
                biometric_enabled: true,
                auto_backup: true
            }
        }
    ],

    // Payments data with mobile receipts
    payments: [
        {
            id: 'payment_001',
            user_id: 'user_001',
            group_id: 'group_001',
            amount: 100.00,
            method: 'bank_transfer',
            status: 'completed',
            transaction_date: '2025-07-20T10:00:00Z',
            receipt_url: '/uploads/receipts/payment_001.jpg',
            confirmation_code: 'CONF123456',
            processing_time: 1800, // seconds
            fees: 0.00,
            mobile_uploaded: true
        },
        {
            id: 'payment_002',
            user_id: 'user_002',
            group_id: 'group_002',
            amount: 500.00,
            method: 'tigo_money',
            status: 'pending',
            transaction_date: '2025-07-24T14:30:00Z',
            receipt_url: null,
            confirmation_code: null,
            processing_time: null,
            fees: 10.00,
            mobile_uploaded: false
        }
    ],

    // Verifications with mobile documents
    verifications: [
        {
            id: 'verify_001',
            user_id: 'user_001',
            type: 'identity',
            status: 'approved',
            documents: ['id_front.jpg', 'id_back.jpg', 'selfie.jpg'],
            verified_at: '2025-01-02T00:00:00Z',
            verification_level: 'advanced',
            mobile_captured: true,
            ai_confidence: 0.98
        }
    ],

    // Notifications with mobile push data
    notifications: [
        {
            id: 'notif_001',
            user_id: 'user_001',
            type: 'payment_reminder',
            title: 'Recordatorio de Pago',
            message: 'Tu contribución semanal vence mañana',
            sent_at: '2025-07-23T09:00:00Z',
            status: 'sent',
            channels: ['push', 'email'],
            push_delivered: true,
            opened: false,
            action_taken: false
        }
    ],

    // Mobile app sessions
    app_sessions: [
        {
            id: 'session_001',
            user_id: 'user_001',
            start_time: '2025-07-24T14:00:00Z',
            end_time: '2025-07-24T14:25:00Z',
            duration: 1500, // seconds
            screens_visited: ['Home', 'Groups', 'Payments'],
            actions_performed: 5,
            device_info: {
                os: 'Android 14',
                app_version: '4.3.0',
                device_model: 'Samsung Galaxy S23'
            }
        }
    ],

    // Offline sync data
    sync_data: [
        {
            id: 'sync_001',
            user_id: 'user_001',
            data_type: 'user_profile',
            last_sync: '2025-07-24T14:00:00Z',
            pending_changes: false,
            conflict_resolution: 'server_wins'
        }
    ],

    // MIA chat conversations
    mia_conversations: [
        {
            id: 'conv_001',
            user_id: 'user_001',
            messages: [
                {
                    id: 'msg_001',
                    sender: 'mia',
                    content: '¡Hola! Soy MIA, ¿en qué puedo ayudarte?',
                    timestamp: '2025-07-24T14:00:00Z'
                },
                {
                    id: 'msg_002',
                    sender: 'user',
                    content: '¿Cómo puedo unirme a un grupo?',
                    timestamp: '2025-07-24T14:01:00Z'
                }
            ],
            context: {
                current_screen: 'Groups',
                user_intent: 'group_registration'
            },
            status: 'active'
        }
    ]
};

// Utility functions
function generateId(prefix) {
    return `${prefix}_${crypto.randomBytes(8).toString('hex')}`;
}

// Validate ID format: prefix_[16-char-hex]
function isValidId(id, expectedPrefix) {
    if (!id || typeof id !== "string") return false;
    const pattern = new RegExp(`^${expectedPrefix}_[a-f0-9]{16}$`);
    return pattern.test(id);
}

// Validate user_id format
function isValidUserId(userId) {
    return isValidId(userId, "user");
}

// Validate group_id format
function isValidGroupId(groupId) {
    return isValidId(groupId, "group");
}

// ===== JWT AUTHENTICATION FUNCTIONS =====
function generateAuthToken(user) {
    return jwt.sign(
        { userId: user.user_id || user.id, email: user.email, role: user.role || "user",
                        verification_level: user.verification_level || "basic",
                        email_verified: user.email_verified || false },
        JWT_SECRET,
        { expiresIn: JWT_EXPIRES_IN }
    );
}

function generateRefreshToken(user) {
    return jwt.sign(
        { userId: user.user_id || user.id, type: "refresh" },
        JWT_SECRET,
        { expiresIn: REFRESH_TOKEN_EXPIRES_IN }
    );
}

function verifyAuthToken(token) {
    try {
        return jwt.verify(token, JWT_SECRET, { algorithms: ["HS256"] });
    } catch (err) {
        return null;
    }
}

function extractTokenFromHeader(req) {
    const authHeader = req.headers.authorization || req.headers["authorization"];
    if (authHeader && authHeader.startsWith("Bearer ")) {
        return authHeader.substring(7);
    }
    return null;
}

function authenticateRequest(req) {
    const token = extractTokenFromHeader(req);
    if (!token) return { authenticated: false, error: "No token provided" };
    
    const decoded = verifyAuthToken(token);
    if (!decoded) return { authenticated: false, error: "Invalid or expired token" };
    
    return { authenticated: true, user: decoded };
}
// Get authenticated user - JWT only (query param fallback removed in v3.79.0 for security)
function getAuthenticatedUser(req, query) {
    const auth = authenticateRequest(req);
    if (auth.authenticated) {
        return { userId: auth.user.userId, email: auth.user.email, role: auth.user.role, method: "jwt" };
    }
    return null;
}

// Require JWT authentication (no fallback)
function requireAuth(req, res) {
    const auth = authenticateRequest(req);
    if (!auth.authenticated) {
        sendError(res, 401, auth.error || "Authentication required");
        return null;
    }
    return auth.user;
}


/**
 * Require a valid admin session from request headers.
 * Checks x-admin-token or Authorization Bearer token against in-memory admin_sessions.
 * Returns the session object or null (after sending 401).
 */
function requireAdminSession(req, res) {
    const adminToken = req.headers['x-admin-token'] || req.headers.authorization?.replace('Bearer ', '');
    if (!adminToken) {
        sendError(res, 401, 'Token de administrador requerido');
        return null;
    }
    const session = database.admin_sessions?.[adminToken];
    if (!session || new Date() > new Date(session.expires_at)) {
        sendError(res, 401, 'Sesion de admin invalida o expirada');
        return null;
    }
    // Update last activity
    session.last_activity = new Date().toISOString();
    return session;
}

// ===== END JWT FUNCTIONS =====


// ============================================
// SMART APPROVAL & NOTIFICATION HELPERS
// Added: 2025-12-25
// ============================================

/**
 * Create in-app notification
 */
async function createNotification(userId, type, title, message, data = {}) {
    try {
        await dbPostgres.pool.query(
            'INSERT INTO notifications (user_id, type, title, message, data, created_at) VALUES ($1, $2, $3, $4, $5, NOW())',
            [userId, type, title, message, JSON.stringify(data)]
        );

        // Web Push — fire and forget, respecting per-category preferences
        const typeToPreference = {
            payment_reminder: 'payment_reminders', payment_received: 'payment_reminders',
            payment_due_soon: 'payment_reminders', payment_late: 'payment_reminders',
            suspension_warning: 'payment_reminders',
            payout_ready: 'payment_reminders', payout_approved: 'payment_reminders',
            member_joined: 'group_updates', group_update: 'group_updates',
            group_joined: 'group_updates', group_rejected: 'group_updates',
            lottery_turn_assigned: 'group_updates', lottery_skipped: 'group_updates',
            mention: 'member_activity', referral_success: 'member_activity',
            recruitment_starting: 'marketing', recruitment_halfway: 'marketing'
        };
        const prefColumn = typeToPreference[type] || 'group_updates';
        try {
            const prefs = await dbPostgres.pool.query(
                'SELECT push_enabled, payment_reminders, group_updates, member_activity, marketing FROM notification_preferences WHERE user_id = $1',
                [userId]
            );
            const userPrefs = prefs.rows[0];
            if (!userPrefs || (userPrefs.push_enabled && userPrefs[prefColumn] !== false)) {
                sendPushToUser(userId, {
                    title: title,
                    body: message,
                    icon: '/img/icons/icon-192x192.png',
                    badge: '/img/icons/badge-72x72.png',
                    url: data?.url || '/home-dashboard.html',
                    type: type
                });
            }
        } catch (pushErr) {
            // Push failure should never block notification creation
        }

        return true;
    } catch (err) {
        log('error', 'Failed to create notification', { error: err.message, userId, type });
        return false;
    }
}

/**
 * Send Web Push notification to all subscribed devices for a user
 */
async function sendPushToUser(userId, payload) {
    if (!process.env.VAPID_PUBLIC_KEY || !process.env.VAPID_PRIVATE_KEY) return;
    try {
        const prefs = await dbPostgres.pool.query(
            'SELECT push_enabled FROM notification_preferences WHERE user_id = $1',
            [userId]
        );
        if (prefs.rows.length && !prefs.rows[0].push_enabled) return;

        const subs = await dbPostgres.pool.query(
            'SELECT endpoint, p256dh, auth FROM push_subscriptions WHERE user_id = $1',
            [userId]
        );

        for (const sub of subs.rows) {
            const pushSub = {
                endpoint: sub.endpoint,
                keys: { p256dh: sub.p256dh, auth: sub.auth }
            };
            try {
                await webpush.sendNotification(pushSub, JSON.stringify(payload));
            } catch (err) {
                if (err.statusCode === 410 || err.statusCode === 404) {
                    await dbPostgres.pool.query(
                        'DELETE FROM push_subscriptions WHERE user_id = $1 AND endpoint = $2',
                        [userId, sub.endpoint]
                    );
                }
            }
        }
    } catch (err) {
        log('error', 'Push send error', { userId, error: err.message });
    }
}

/**
 * Notify all group admins/coordinators
 */
async function notifyGroupAdmins(groupId, type, title, message, data = {}) {
    try {
        const adminsResult = await dbPostgres.pool.query(
            "SELECT user_id FROM group_members WHERE group_id = $1 AND role IN ('creator', 'coordinator', 'admin') AND status = 'active'",
            [groupId]
        );
        
        for (const admin of adminsResult.rows) {
            await createNotification(admin.user_id, type, title, message, data);
        }
        
        log('info', 'Group admins notified', { groupId, adminCount: adminsResult.rows.length, type });
        return adminsResult.rows.length;
    } catch (err) {
        log('error', 'Failed to notify group admins', { error: err.message, groupId });
        return 0;
    }
}

/**
 * Check if user qualifies for auto-approval
 */
async function checkAutoApproval(userId, groupId, invitedBy = null) {
    try {
        // Get group approval settings
        const groupResult = await dbPostgres.pool.query(
            'SELECT approval_settings, name FROM groups WHERE group_id = $1',
            [groupId]
        );
        
        if (groupResult.rows.length === 0) {
            return { autoApprove: false, reason: 'group_not_found' };
        }
        
        const settings = groupResult.rows[0].approval_settings || {};
        const groupName = groupResult.rows[0].name;
        
        // If manual approval is required, skip auto-approval
        if (settings.require_manual_approval === true && 
            !settings.auto_approve_kyc_verified && 
            !settings.auto_approve_invited && 
            !settings.auto_approve_email_verified) {
            return { autoApprove: false, reason: 'manual_required', groupName };
        }
        
        // Get user info
        const userResult = await dbPostgres.pool.query(
            'SELECT email_verified, verification_level, name FROM users WHERE user_id = $1',
            [userId]
        );
        
        if (userResult.rows.length === 0) {
            return { autoApprove: false, reason: 'user_not_found', groupName };
        }
        
        const user = userResult.rows[0];
        
        // Check auto-approval rules in order of priority
        
        // Rule 1: Invited by existing member
        if (settings.auto_approve_invited && invitedBy) {
            const inviterResult = await dbPostgres.pool.query(
                "SELECT 1 FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = 'active'",
                [groupId, invitedBy]
            );
            if (inviterResult.rows.length > 0) {
                return { autoApprove: true, reason: 'invited_by_member', groupName, userName: user.name };
            }
        }
        
        // Rule 2: KYC verified (verification_level must be intermediate or higher)
        // SECURITY FIX 2025-12-31: Removed "basic" - it is assigned automatically to all new users
        // Only intermediate, full, or verified indicate actual KYC completion
        if (settings.auto_approve_kyc_verified) {
            if (user.verification_level && ['intermediate', 'full', 'verified'].includes(user.verification_level.toLowerCase())) {
                return { autoApprove: true, reason: 'kyc_verified', groupName, userName: user.name };
            }
        }
        
        // Rule 3: Email verified
        if (settings.auto_approve_email_verified && user.email_verified === true) {
            return { autoApprove: true, reason: 'email_verified', groupName, userName: user.name };
        }
        
        // Check if user has completed a tanda before (trust indicator)
        const completedTandaResult = await dbPostgres.pool.query(
            "SELECT 1 FROM group_members gm JOIN groups g ON gm.group_id = g.group_id WHERE gm.user_id = $1 AND gm.status = 'active' AND g.status = 'completed' LIMIT 1",
            [userId]
        );
        if (completedTandaResult.rows.length > 0) {
            return { autoApprove: true, reason: 'completed_tanda', groupName, userName: user.name };
        }
        
        return { autoApprove: false, reason: 'no_matching_rule', groupName, userName: user.name };
        
    } catch (err) {
        log('error', 'Error checking auto-approval', { error: err.message, userId, groupId });
        return { autoApprove: false, reason: 'error', error: 'Error interno' };
    }
}


// ===== AUDIT LOGGING FUNCTIONS =====
async function auditLog(action, details = {}) {
    try {
        const { userId, userEmail, resource, resourceId, ip, userAgent, status, error } = details;
        
        await dbPostgres.pool.query(
            `INSERT INTO audit_logs (user_id, user_email, action, resource, resource_id, details, ip_address, user_agent, status, error_message)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
            [
                userId || null,
                userEmail || null,
                action,
                resource || null,
                resourceId || null,
                JSON.stringify(details.extra || {}),
                ip || null,
                userAgent || null,
                status || "success",
                error || null
            ]
        );
    } catch (err) {
        log("error", "[AuditLog] Error saving audit log:", err.message);
    }
}

function getClientInfo(req) {
    return {
        ip: req.headers["x-forwarded-for"] || req.socket?.remoteAddress || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
    };
}
// ===== END AUDIT FUNCTIONS =====


// Helper: Credit LTD tokens to user's wallet
async function creditLTDTokens(userId, amount, reason, txClient = null) {
    try {
        // Check if user has a wallet
        const db = txClient || dbPostgres.pool;
        const walletCheck = await db.query(
            'SELECT id, crypto_balances FROM user_wallets WHERE user_id = $1',
            [userId]
        );

        if (walletCheck.rows.length === 0) {
            // Create wallet with initial LTD balance
            await db.query(`
                INSERT INTO user_wallets (user_id, balance, currency, crypto_balances)
                VALUES ($1, 0, 'HNL', $2)
            `, [userId, JSON.stringify({ BTC: 0, ETH: 0, LTD: amount })]);
            log('info', '[LTD] Created wallet and credited tokens', { userId, amount, reason });
        } else {
            // Atomic update — no read-modify-write race condition
            const updateResult = await db.query(
                `UPDATE user_wallets
                 SET crypto_balances = jsonb_set(
                     COALESCE(crypto_balances, '{"BTC":0,"ETH":0,"LTD":0}'::jsonb),
                     '{LTD}',
                     to_jsonb(COALESCE((crypto_balances->>'LTD')::numeric, 0) + $1)
                 ),
                 updated_at = NOW()
                 WHERE user_id = $2
                 RETURNING (crypto_balances->>'LTD')::numeric as new_balance`,
                [amount, userId]
            );
            const newLTD = updateResult.rows[0]?.new_balance || amount;
            log('info', '[LTD] Credited tokens to existing wallet', { userId, amount, newBalance: newLTD, reason });
        }

        // Record the transaction
        auditLog('LTD_TOKENS_CREDITED', {
            user_id: userId,
            amount: amount,
            reason: reason,
            timestamp: new Date().toISOString()
        });

        return true;
    } catch (error) {
        log('error', '[LTD] Failed to credit tokens', { userId, amount, reason, error: error.message });
        return false;
    }
}

// ===== MINING SYSTEM HELPER FUNCTIONS =====

// Calculate user tier based on achievements
async function calculateUserTier(userId) {
    try {
        const result = await dbPostgres.pool.query(`
            SELECT COALESCE(SUM(ad.points), 0) as total_points
            FROM user_achievements ua
            JOIN achievement_definitions ad ON ua.achievement_key = ad.achievement_key
            WHERE ua.user_id = $1
        `, [userId]);

        const points = parseInt(result.rows[0].total_points) || 0;

        let tier = 'bronze';
        let pointsToNextTier = 50 - points;
        let nextTier = 'silver';

        if (points >= 150) {
            tier = 'gold';
            pointsToNextTier = null;
            nextTier = null;
        } else if (points >= 50) {
            tier = 'silver';
            pointsToNextTier = 150 - points;
            nextTier = 'gold';
        }

        return { tier, points, pointsToNextTier, nextTier };
    } catch (error) {
        log('error', '[TIER] Error calculating tier: ' + error.message);
        return { tier: 'bronze', points: 0, pointsToNextTier: 50, nextTier: 'silver' };
    }
}

// Format time remaining in human readable format
function formatTimeRemaining(ms) {
    if (ms <= 0) return 'Disponible';
    const hours = Math.floor(ms / (1000 * 60 * 60));
    const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    if (hours > 0) return `${hours}h ${minutes}m`;
    return `${minutes}m`;
}

// Unlock achievement for user (requires client from transaction)
async function unlockAchievement(client, userId, achievementKey) {
    try {
        const defResult = await client.query(
            'SELECT points FROM achievement_definitions WHERE achievement_key = $1',
            [achievementKey]
        );
        if (defResult.rows.length === 0) return false;

        await client.query(`
            INSERT INTO user_achievements (user_id, achievement_key, points_awarded)
            VALUES ($1, $2, $3)
            ON CONFLICT (user_id, achievement_key) DO NOTHING
        `, [userId, achievementKey, defResult.rows[0].points]);
        
        log('info', '[ACHIEVEMENT] Unlocked: ' + achievementKey, { userId });
        return true;
    } catch (error) {
        log('error', '[ACHIEVEMENT] Error unlocking: ' + error.message);
        return false;
    }
}

// Calculate fraud score (0-100, higher = more suspicious)
function calculateFraudScore(data) {
    let score = 0;

    // Account age check (newer = riskier)
    if (data.accountAgeDays < 7) score += 30;
    else if (data.accountAgeDays < 30) score += 15;
    else if (data.accountAgeDays < 90) score += 5;

    // KYC level check
    if (!data.kycLevel || data.kycLevel === 'none') score += 25;
    else if (data.kycLevel === 'basic') score += 10;

    // Activity check (no real activity = suspicious)
    if (!data.totalContributions || data.totalContributions === 0) score += 15;
    if (!data.referralCount || data.referralCount === 0) score += 5;

    // Mining pattern check
    if (data.totalClaims < 7) score += 10;
    if (data.miningStreak < 3) score += 5;

    // Balance vs activity ratio (high balance with no activity = suspicious)
    if (data.testnetBalance > 100 && (!data.totalContributions || data.totalContributions === 0)) {
        score += 20;
    }

    return Math.min(score, 100);
}

// Generate hash of mining history for verification
function generateHistoryHash(history) {
    const crypto = require('crypto');
    const data = history.map(h => `${h.claim_timestamp}:${h.total_reward}`).join('|');
    return crypto.createHash('sha256').update(data).digest('hex');
}

// Constant-time string comparison to prevent timing attacks
function safeCompare(a, b) {
    if (typeof a !== 'string' || typeof b !== 'string') return false;
    const hashA = require('crypto').createHash('sha256').update(a).digest();
    const hashB = require('crypto').createHash('sha256').update(b).digest();
    return require('crypto').timingSafeEqual(hashA, hashB);
}

// Round financial values to 2 decimal places to prevent floating-point drift
function toMoney(value) {
    return Math.round((parseFloat(value) || 0) * 100) / 100;
}

// Password complexity: min 8 chars, 1 uppercase, 1 lowercase, 1 digit
function validatePassword(password) {
    if (!password || password.length < 8) return 'La contrasena debe tener al menos 8 caracteres';
    if (!/[A-Z]/.test(password)) return 'La contrasena debe incluir al menos una letra mayuscula';
    if (!/[a-z]/.test(password)) return 'La contrasena debe incluir al menos una letra minuscula';
    if (!/[0-9]/.test(password)) return 'La contrasena debe incluir al menos un numero';
    return null;
}

// ===== END MINING SYSTEM HELPER FUNCTIONS =====
// ===== SECURITY VALIDATION FUNCTIONS (Added 2025-12-22) =====

function sanitizeFileName(fileName) {
    if (!fileName || typeof fileName !== "string") return null;
    let safe = fileName.replace(/\0/g, "");
    safe = safe.replace(/\.\./g, "");
    safe = safe.replace(/\.\.\\/g, "");
    safe = safe.replace(/^[/\\]+/, "");
    safe = safe.replace(/[^a-zA-Z0-9._-]/g, "_");
    if (safe.startsWith(".")) safe = "_" + safe.substring(1);
    if (safe.length > 255) safe = safe.substring(0, 255);
    return safe || null;
}

function isAllowedExtension(fileName, allowedExts) {
    if (!allowedExts) allowedExts = [".jpg", ".jpeg", ".png", ".webp", ".pdf", ".gif"];
    if (!fileName) return false;
    const ext = fileName.toLowerCase().match(/\.[a-z0-9]+$/);
    return ext && allowedExts.includes(ext[0]);
}

function validateMimeType(buffer) {
    if (!buffer || buffer.length < 12) return { valid: false, type: null };
    const b = buffer;
    if (b[0] === 0xFF && b[1] === 0xD8 && b[2] === 0xFF) return { valid: true, type: "image/jpeg" };
    if (b[0] === 0x89 && b[1] === 0x50 && b[2] === 0x4E && b[3] === 0x47) return { valid: true, type: "image/png" };
    if (b[0] === 0x47 && b[1] === 0x49 && b[2] === 0x46 && b[3] === 0x38) return { valid: true, type: "image/gif" };
    if (b[0] === 0x52 && b[1] === 0x49 && b[2] === 0x46 && b[3] === 0x46 && b[8] === 0x57 && b[9] === 0x45 && b[10] === 0x42 && b[11] === 0x50) return { valid: true, type: "image/webp" };
    if (b[0] === 0x25 && b[1] === 0x50 && b[2] === 0x44 && b[3] === 0x46) return { valid: true, type: "application/pdf" };
    return { valid: false, type: null };
}

function mimeToExtension(mimeType) {
    const map = {
        "image/jpeg": [".jpg", ".jpeg"],
        "image/png": [".png"],
        "image/gif": [".gif"],
        "image/webp": [".webp"],
        "application/pdf": [".pdf"]
    };
    return map[mimeType] || [];
}

function validateFileIntegrity(buffer, fileName) {
    const mimeResult = validateMimeType(buffer);
    if (!mimeResult.valid) {
        return { valid: false, error: "Tipo de archivo no reconocido o corrupto" };
    }
    const ext = (fileName.match(/\.[a-z0-9]+$/i) || [""])[0].toLowerCase();
    const allowedExts = mimeToExtension(mimeResult.type);
    if (!allowedExts.includes(ext)) {
        return { valid: false, error: "La extension del archivo no coincide con su contenido", detectedType: mimeResult.type };
    }
    return { valid: true, type: mimeResult.type };
}
// ============================================
// SOCIAL FEED HELPER FUNCTIONS
// Added: 2026-01-24 for public social feed
// ============================================

/**
 * Insert an event into the social_feed table
 * @param {Object} eventData - Event data
 * @param {string} eventData.event_type - Type: group_created, product_posted, lottery_result, etc.
 * @param {string} eventData.actor_id - User ID who performed the action (optional)
 * @param {string} eventData.actor_name - Display name of the actor (optional)
 * @param {string} eventData.title - Main event title
 * @param {string} eventData.description - Optional description
 * @param {string} eventData.image_url - Optional image URL
 * @param {string} eventData.action_url - Optional URL to navigate to
 * @param {Object} eventData.metadata - Additional JSON metadata
 */
async function insertSocialEvent(eventData) {
    try {
        const result = await dbPostgres.pool.query(`
            INSERT INTO social_feed (event_type, actor_id, actor_name, title, description, image_url, action_url, metadata)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            RETURNING id
        `, [
            eventData.event_type,
            eventData.actor_id || null,
            eventData.actor_name || null,
            eventData.title,
            eventData.description || null,
            eventData.image_url || null,
            eventData.action_url || null,
            JSON.stringify(eventData.metadata || {})
        ]);
        log("info", `[SOCIAL_FEED] Event inserted: ${eventData.event_type} - ${eventData.title}`);
        return result.rows[0]?.id;
    } catch (error) {
        log("error", `[SOCIAL_FEED] Error inserting event: ${error.message}`);
        return null;
    }
}


/**
 * Format a date as relative time (e.g., "hace 5 min")
 */
function formatTimeAgo(date) {
    const now = new Date();
    const then = new Date(date);
    const diffMs = now - then;
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHrs = Math.floor(diffMin / 60);
    const diffDays = Math.floor(diffHrs / 24);

    if (diffSec < 60) return "hace un momento";
    if (diffMin < 60) return "hace " + diffMin + " min";
    if (diffHrs < 24) return "hace " + diffHrs + "h";
    if (diffDays < 7) return "hace " + diffDays + " dia" + (diffDays > 1 ? "s" : "");
    return then.toLocaleDateString("es-HN", { day: "numeric", month: "short" });
}


function validateNumericInput(value, options) {
    if (!options) options = {};
    const min = options.min !== undefined ? options.min : 0;
    const max = options.max !== undefined ? options.max : Number.MAX_SAFE_INTEGER;
    const allowFloat = options.allowFloat !== undefined ? options.allowFloat : true;
    const fieldName = options.fieldName || "valor";
    if (value === null || value === undefined || value === "") {
        return { valid: false, error: fieldName + " es requerido" };
    }
    const num = allowFloat ? parseFloat(value) : parseInt(value, 10);
    if (isNaN(num) || !isFinite(num)) {
        return { valid: false, error: fieldName + " debe ser un numero valido" };
    }
    if (num < min) return { valid: false, error: fieldName + " debe ser al menos " + min };
    if (num > max) return { valid: false, error: fieldName + " no puede exceder " + max };
    return { valid: true, value: num };
}

function validateMonetaryAmount(value, options) {
    if (!options) options = {};
    const min = options.min !== undefined ? options.min : 0.01;
    const max = options.max !== undefined ? options.max : 1000000;
    const currency = options.currency || "HNL";
    const fieldName = options.fieldName || "monto";
    const result = validateNumericInput(value, { min: min, max: max, allowFloat: true, fieldName: fieldName });
    if (!result.valid) return result;
    const rounded = Math.round(result.value * 100) / 100;
    return { valid: true, value: rounded, formatted: currency + " " + rounded.toFixed(2) };
}

// ===== END SECURITY VALIDATION FUNCTIONS =====



function createResponse(success, data, meta = {}) {
    return {
        success,
        data,
        meta: {
            timestamp: new Date().toISOString(),
            version: '4.11.0',
            server: 'production',
            environment: 'production',
            ...meta
        }
    };
}

function sendResponse(res, statusCode, data, rateLimitInfo = null) {
    res.statusCode = statusCode;
    res.setHeader('Content-Type', 'application/json');
    res.setHeader("Access-Control-Allow-Origin", "https://latanda.online");
    res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
    
    // Apply comprehensive security headers
    securityMiddleware.applySecurityHeaders(res);
    
    // Add rate limit headers if available
    if (rateLimitInfo) {
        res.setHeader("X-RateLimit-Remaining", rateLimitInfo.remaining);
        res.setHeader("X-RateLimit-Reset", Math.ceil(rateLimitInfo.resetIn / 1000));
    }
    
    res.end(JSON.stringify(data, null, 2));
}

function sendError(res, statusCode, message, details = null) {
    const error = createResponse(false, {
        error: {
            code: statusCode,
            message: message,
            details: details,
            timestamp: new Date().toISOString()
        }
    });
    sendResponse(res, statusCode, error);
    return true;
}

function sendSuccess(res, data, meta = {}) {
    // Return true to signal response was sent
    const response = createResponse(true, data, meta);
    sendResponse(res, 200, response);
    return true;
}

// Parse request body
function parseBody(req) {
    return new Promise((resolve, reject) => {
        const MAX_BODY_SIZE = 1048576; // 1MB limit
        let body = "";
        let size = 0;
        req.on("data", chunk => {
            size += chunk.length;
            if (size > MAX_BODY_SIZE) {
                req.destroy();
                resolve({ _parseError: true, _parseMessage: 'Body too large (max 1MB)' });
                return;
            }
            body += chunk.toString();
        });
        req.on("end", () => {
            try {
                if (!body || body.trim() === "") {
                    resolve({});
                    return;
                }
                
                // Fix invalid JSON escapes from mobile keyboards
                // Characters like ! @ # etc don't need escaping in JSON
                // but some mobile browsers incorrectly add backslashes
                let fixedBody = body;
                try {
                    // Remove invalid escape sequences (backslash before chars that don't need escaping)
                    fixedBody = body.replace(/\\([!@#$%^&*()_+={}|:"'<>?~\`\[\];,.\/\-])/g, '$1');
                    
                    // Log if we fixed anything
                    if (fixedBody !== body) {
                    }
                } catch (fixError) {
                }
                
                const parsed = JSON.parse(fixedBody);
                // Sanitize all input to prevent XSS
                const sanitized = securityMiddleware.sanitizeData(parsed);
                resolve(sanitized);
            } catch (error) {
                // Return parse error info instead of empty object
                resolve({ _parseError: true, _parseMessage: error.message, _rawBody: body.substring(0, 100) });
            }
        });
    });
}


// ============================================
// EMAIL MX RECORD VALIDATION
// Verifies that the email domain has valid mail servers
// ============================================
async function verifyEmailDomain(email) {
    try {
        const domain = email.split("@")[1];
        if (!domain) {
            return { valid: false, reason: "Formato de email inválido" };
        }
        
        // List of known disposable/temporary email domains to block
        const disposableDomains = [
            "tempmail.com", "throwaway.email", "guerrillamail.com", 
            "mailinator.com", "10minutemail.com", "temp-mail.org",
            "fakeinbox.com", "trashmail.com", "maildrop.cc"
        ];
        
        if (disposableDomains.includes(domain.toLowerCase())) {
            return { valid: false, reason: "No se permiten emails temporales" };
        }
        
        // Check MX records
        const mxRecords = await dns.resolveMx(domain);
        
        if (!mxRecords || mxRecords.length === 0) {
            return { valid: false, reason: "El dominio del email no tiene servidor de correo" };
        }
        
        return { valid: true, mxRecords: mxRecords.length };
    } catch (error) {
        // ENOTFOUND = domain doesnt exist
        // ENODATA = no MX records
        if (error.code === "ENOTFOUND" || error.code === "ENODATA") {
            return { valid: false, reason: "El dominio del email no existe o no puede recibir correos" };
        }
        // For other errors (network issues), allow registration but log warning
        return { valid: true, warning: "No se pudo verificar el dominio" };
    }
}
let requestCount = 0;
let statsCache = { data: null, expires: 0 };
const startTime = Date.now();

// Main server

// =============================================================================
// POSITION SELECTION & ASSIGNMENT - HELPER FUNCTIONS (10 ENDPOINTS)
// =============================================================================

// HELPER FUNCTIONS
// =============================================================================

/**
 * Genera ID único para solicitudes de posición
 */
function generateRequestId() {
    return `req_${Date.now()}_${crypto.randomBytes(6).toString('hex')}`;
}

/**
 * Verifica si una posición está disponible
 */
function isPositionAvailable(group, position) {
    if (!group.positions) {
        group.positions = [];
    }

    const existingPosition = group.positions.find(p => p.position === position);
    return !existingPosition || existingPosition.status !== 'confirmed';
}

/**
 * Obtiene posiciones sin asignar
 */
function getUnassignedPositions(group) {
    const assignedPositions = (group.positions || [])
        .filter(p => p.status === 'confirmed')
        .map(p => p.position);

    const allPositions = Array.from({ length: group.participant_count }, (_, i) => i + 1);
    return allPositions.filter(pos => !assignedPositions.includes(pos));
}

/**
 * Obtiene usuarios sin posición asignada
 */
function getUsersWithoutPosition(group) {
    if (!group.members || !group.positions) {
        return group.members || [];
    }

    const usersWithPosition = group.positions
        .filter(p => p.status === 'confirmed')
        .map(p => p.user_id);

    return group.members.filter(m => !usersWithPosition.includes(m.user_id));
}

// =============================================================================
// ENDPOINTS - PARA PARTICIPANTES (Tab Tandas)
// =============================================================================

// 1. GET /api/tandas/available-positions
// Obtener posiciones disponibles en un grupo
function handleGetAvailablePositions(req, res, query, database) {
    try {
        const { group_id } = query;

        if (!group_id) {
            sendError(res, 400, 'group_id es requerido');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        // Inicializar arrays si no existen
        if (!group.positions) group.positions = [];
        if (!group.position_requests) group.position_requests = [];

        // Construir array de posiciones con su estado
        const positions = [];
        for (let i = 1; i <= group.participant_count; i++) {
            const confirmedPosition = group.positions.find(p => p.position === i && p.status === 'confirmed');
            const pendingRequest = group.position_requests.find(r => r.requested_position === i && r.status === 'pending');

            let status = 'available';
            if (confirmedPosition) {
                status = 'confirmed';
            } else if (pendingRequest) {
                status = 'requested';
            }

            positions.push({
                position: i,
                status: status,
                isAvailable: status !== 'confirmed',
                hasRequest: status === 'requested'
            });
        }

        const positionsConfirmed = group.positions.filter(p => p.status === 'confirmed').length;
        const canActivate = positionsConfirmed === group.participant_count;

        sendSuccess(res, {
            group_id: group_id,
            participant_count: group.participant_count,
            positions: positions,
            positions_assigned: positionsConfirmed,
            can_activate: canActivate
        });

        log('info', 'Available positions retrieved', { group_id });
    } catch (error) {
        log('error', 'Error getting available positions', { error: error.message });
        sendError(res, 500, 'Error al obtener posiciones disponibles');
    }
}

// 2. POST /api/tandas/request-position
// Solicitar una posición específica
function handleRequestPosition(req, res, body, database, authUser) {
    try {
        const { group_id, position, reason } = body;
        // SECURITY FIX: Always use authenticated user (2025-12-31)
        const user_id = authUser?.userId || authUser?.user_id;
        const user_name = authUser?.name || authUser?.email || 'Usuario';

        if (!user_id) {
            sendError(res, 401, 'Autenticación requerida');
            return;
        }

        if (!group_id || !position) {
            sendError(res, 400, 'group_id y position son requeridos');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        // Inicializar arrays
        if (!group.positions) group.positions = [];
        if (!group.position_requests) group.position_requests = [];

        // Validar rango de posición
        if (position < 1 || position > group.participant_count) {
            sendError(res, 400, `Posición debe estar entre 1 y ${group.participant_count}`);
            return;
        }

        // Verificar si la posición está disponible
        if (!isPositionAvailable(group, position)) {
            sendError(res, 400, 'Esta posición ya está asignada');
            return;
        }

        // Verificar si el usuario ya tiene una solicitud pendiente
        const existingRequest = group.position_requests.find(r =>
            r.user_id === user_id && r.status === 'pending'
        );

        if (existingRequest) {
            sendError(res, 400, 'Ya tienes una solicitud pendiente. Cámbiala en lugar de crear una nueva.');
            return;
        }

        // Crear solicitud
        const request = {
            id: generateRequestId(),
            user_id: user_id,
            user_name: user_name || 'Usuario',
            requested_position: position,
            reason: reason || '',
            status: 'pending',
            created_at: new Date().toISOString(),
            approved_by: null,
            approved_at: null,
            rejected_by: null,
            rejected_at: null,
            rejection_reason: null
        };

        group.position_requests.push(request);

        // Crear posición temporal (pending)
        group.positions.push({
            position: position,
            user_id: null,
            user_name: null,
            assignment_type: null,
            requested_by: user_id,
            requested_at: new Date().toISOString(),
            approved_by: null,
            approved_at: null,
            status: 'pending',
            request_id: request.id
        });

        saveDatabase();

        sendSuccess(res, {
            message: 'Solicitud enviada exitosamente',
            request: request
        });

        log('info', 'Position request created', { group_id, user_id, position, request_id: request.id });
    } catch (error) {
        log('error', 'Error creating position request', { error: error.message });
        sendError(res, 500, 'Error al crear solicitud de posición');
    }
}

// 3. PUT /api/tandas/change-position-request
// Cambiar una solicitud de posición existente
function handleChangePositionRequest(req, res, body, database, authUser) {
    try {
        // SECURITY FIX: Verify authenticated user (2025-12-31)
        const user_id = authUser?.userId || authUser?.user_id;
        if (!user_id) {
            sendError(res, 401, 'Autenticación requerida');
            return;
        }

        const { request_id, new_position, new_reason } = body;

        if (!request_id || !new_position) {
            sendError(res, 400, 'request_id y new_position son requeridos');
            return;
        }

        // Buscar la solicitud en todos los grupos
        let foundGroup = null;
        let foundRequest = null;

        for (const group of (database.groups || [])) {
            if (!group.position_requests) continue;

            const request = group.position_requests.find(r => r.id === request_id);
            if (request) {
                foundGroup = group;
                foundRequest = request;
                break;
            }
        }

        if (!foundRequest) {
            sendError(res, 404, 'Solicitud no encontrada');
            return;
        }

        // SECURITY: Verify user owns this request
        if (foundRequest.user_id !== user_id) {
            sendError(res, 403, 'Solo puedes modificar tus propias solicitudes');
            return;
        }

        if (foundRequest.status !== 'pending') {
            sendError(res, 400, 'Solo puedes cambiar solicitudes pendientes');
            return;
        }

        // Validar nueva posición
        if (new_position < 1 || new_position > foundGroup.participant_count) {
            sendError(res, 400, `Posición debe estar entre 1 y ${foundGroup.participant_count}`);
            return;
        }

        // Verificar si nueva posición está disponible
        if (!isPositionAvailable(foundGroup, new_position)) {
            sendError(res, 400, 'La nueva posición ya está asignada');
            return;
        }

        // Eliminar posición temporal anterior
        foundGroup.positions = foundGroup.positions.filter(p => p.request_id !== request_id);

        // Actualizar solicitud
        foundRequest.requested_position = new_position;
        if (new_reason !== undefined) {
            foundRequest.reason = new_reason;
        }
        foundRequest.updated_at = new Date().toISOString();

        // Crear nueva posición temporal
        foundGroup.positions.push({
            position: new_position,
            user_id: null,
            user_name: null,
            assignment_type: null,
            requested_by: foundRequest.user_id,
            requested_at: new Date().toISOString(),
            approved_by: null,
            approved_at: null,
            status: 'pending',
            request_id: request_id
        });

        saveDatabase();

        sendSuccess(res, {
            message: 'Solicitud actualizada exitosamente',
            request: {
                id: foundRequest.id,
                requested_position: foundRequest.requested_position,
                reason: foundRequest.reason,
                updated_at: foundRequest.updated_at
            }
        });

        log('info', 'Position request updated', { request_id, new_position });
    } catch (error) {
        log('error', 'Error updating position request', { error: error.message });
        sendError(res, 500, 'Error al actualizar solicitud de posición');
    }
}

// 4. GET /api/tandas/my-position-status
// Ver el estado de mi solicitud/posición
function handleGetMyPositionStatus(req, res, query, database, authUser) {
    try {
        const { group_id } = query;
        // SECURITY FIX: Always use authenticated user (2025-12-31)
        const user_id = authUser?.userId || authUser?.user_id;

        if (!user_id) {
            sendError(res, 401, 'Autenticación requerida');
            return;
        }

        if (!group_id) {
            sendError(res, 400, 'group_id es requerido');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        // Inicializar arrays
        if (!group.positions) group.positions = [];
        if (!group.position_requests) group.position_requests = [];

        // Buscar solicitud del usuario
        const userRequest = group.position_requests.find(r => r.user_id === user_id);

        // Buscar posición confirmada
        const confirmedPosition = group.positions.find(p =>
            p.user_id === user_id && p.status === 'confirmed'
        );

        sendSuccess(res, {
            group_id: group_id,
            user_id: user_id,
            has_request: !!userRequest,
            request: userRequest ? {
                id: userRequest.id,
                requested_position: userRequest.requested_position,
                status: userRequest.status,
                reason: userRequest.reason,
                created_at: userRequest.created_at,
                rejection_reason: userRequest.rejection_reason
            } : null,
            has_confirmed_position: !!confirmedPosition,
            confirmed_position: confirmedPosition ? confirmedPosition.position : null,
            group_status: group.status
        });

        log('info', 'Position status retrieved', { group_id, user_id });
    } catch (error) {
        log('error', 'Error getting position status', { error: error.message });
        sendError(res, 500, 'Error al obtener estado de posición');
    }
}

// =============================================================================
// ENDPOINTS - PARA COORDINADORES (Tab My Groups)
// =============================================================================

// 5. GET /api/groups/position-requests
// Ver todas las solicitudes pendientes
function handleGetPositionRequests(req, res, query, database, authUser) {
    try {
        const { group_id } = query;
        // SECURITY FIX: Verify authenticated user (2025-12-31)
        const user_id = authUser?.userId || authUser?.user_id;

        if (!user_id) {
            sendError(res, 401, 'Autenticación requerida');
            return;
        }

        if (!group_id) {
            sendError(res, 400, 'group_id es requerido');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        // SECURITY: Verify user is coordinator/creator of this group
        const isCoordinator = group.createdBy === user_id ||
                             group.coordinator_id === user_id ||
                             (group.members && group.members.some(m =>
                                 m.user_id === user_id && ['creator', 'coordinator', 'admin'].includes(m.role)
                             ));
        if (!isCoordinator) {
            sendError(res, 403, 'Solo coordinadores pueden ver solicitudes');
            return;
        }

        // Inicializar arrays
        if (!group.position_requests) group.position_requests = [];
        if (!group.positions) group.positions = [];

        const pendingRequests = group.position_requests.filter(r => r.status === 'pending');
        const assignedPositions = group.positions.filter(p => p.status === 'confirmed').length;

        sendSuccess(res, {
            group_id: group_id,
            group_name: group.name,
            requests: pendingRequests,
            total_positions: group.participant_count,
            assigned_positions: assignedPositions,
            pending_requests: pendingRequests.length
        });

        log('info', 'Position requests retrieved', { group_id, pending_count: pendingRequests.length });
    } catch (error) {
        log('error', 'Error getting position requests', { error: error.message });
        sendError(res, 500, 'Error al obtener solicitudes de posición');
    }
}

// 6. POST /api/groups/approve-position-request
// Aprobar una solicitud de posición
function handleApprovePositionRequest(req, res, body, database, authUser) {
    try {
        const { request_id, group_id } = body;

        // SECURITY FIX: Use passed authUser (2025-12-31)
        if (!authUser) {
            sendError(res, 401, 'Autenticacion requerida');
            return;
        }
        const coordinator_id = authUser.userId || authUser.user_id || authUser.id;

        if (!request_id || !group_id) {
            sendError(res, 400, 'request_id y group_id son requeridos');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }
        
        // SECURITY FIX: Verify requester is coordinator/admin of the group
        const isAuthorized = group.admin_id === coordinator_id || 
            (group.members && group.members.some(m => 
                m.user_id === coordinator_id && 
                ["coordinator", "admin", "creator"].includes(m.role)
            ));
        if (!isAuthorized) {
            sendError(res, 403, 'No tienes permisos para aprobar posiciones');
            return;
        }

        if (!group.position_requests) group.position_requests = [];
        if (!group.positions) group.positions = [];

        const request = group.position_requests.find(r => r.id === request_id);
        if (!request) {
            sendError(res, 404, 'Solicitud no encontrada');
            return;
        }

        if (request.status !== 'pending') {
            sendError(res, 400, 'Solo se pueden aprobar solicitudes pendientes');
            return;
        }

        // Verificar que la posición aún esté disponible
        if (!isPositionAvailable(group, request.requested_position)) {
            sendError(res, 400, 'La posición solicitada ya no está disponible');
            return;
        }

        // Actualizar solicitud
        request.status = 'approved';
        request.approved_by = coordinator_id;
        request.approved_at = new Date().toISOString();

        // Actualizar o crear posición confirmada
        const existingPosition = group.positions.find(p => p.request_id === request_id);
        if (existingPosition) {
            existingPosition.user_id = request.user_id;
            existingPosition.user_name = request.user_name;
            existingPosition.assignment_type = 'approved';
            existingPosition.approved_by = coordinator_id;
            existingPosition.approved_at = new Date().toISOString();
            existingPosition.status = 'confirmed';
        } else {
            group.positions.push({
                position: request.requested_position,
                user_id: request.user_id,
                user_name: request.user_name,
                assignment_type: 'approved',
                requested_by: request.user_id,
                requested_at: request.created_at,
                approved_by: coordinator_id,
                approved_at: new Date().toISOString(),
                status: 'confirmed',
                request_id: request_id
            });
        }

        saveDatabase();

        sendSuccess(res, {
            message: 'Solicitud aprobada exitosamente',
            request: {
                id: request.id,
                status: request.status,
                approved_by: request.approved_by,
                approved_at: request.approved_at
            },
            position: {
                position: request.requested_position,
                user_id: request.user_id,
                user_name: request.user_name,
                status: 'confirmed',
                assignment_type: 'approved'
            }
        });

        log('info', 'Position request approved', { request_id, group_id, position: request.requested_position });
    } catch (error) {
        log('error', 'Error approving position request', { error: error.message });
        sendError(res, 500, 'Error al aprobar solicitud de posición');
    }
}

// 7. POST /api/groups/reject-position-request
// Rechazar una solicitud de posición
function handleRejectPositionRequest(req, res, body, database) {
    try {
        const { request_id, reason } = body;

        // ============================================
        // SECURITY: Require JWT authentication (Added 2025-12-31)
        // ============================================
        const authUser = getAuthenticatedUser(req, {});
        if (!authUser) {
            sendError(res, 401, 'Autenticacion requerida');
            return;
        }
        const coordinator_id = authUser.userId || authUser.user_id || authUser.id;

        if (!request_id) {
            sendError(res, 400, 'request_id es requerido');
            return;
        }

        // Buscar solicitud en todos los grupos
        let foundGroup = null;
        let foundRequest = null;

        for (const group of (database.groups || [])) {
            if (!group.position_requests) continue;

            const request = group.position_requests.find(r => r.id === request_id);
            if (request) {
                foundGroup = group;
                foundRequest = request;
                break;
            }
        }

        if (!foundRequest) {
            sendError(res, 404, 'Solicitud no encontrada');
            return;
        }

        if (foundRequest.status !== 'pending') {
            sendError(res, 400, 'Solo se pueden rechazar solicitudes pendientes');
            return;
        }

        // ============================================
        // SECURITY: Verify requester is coordinator/admin of the group (Added 2025-12-31)
        // ============================================
        const isAuthorized = foundGroup.admin_id === coordinator_id ||
            (foundGroup.members && foundGroup.members.some(m =>
                m.user_id === coordinator_id &&
                ["coordinator", "admin", "creator"].includes(m.role)
            ));
        if (!isAuthorized) {
            sendError(res, 403, 'No tienes permisos para rechazar posiciones');
            return;
        }

        // Actualizar solicitud
        foundRequest.status = 'rejected';
        foundRequest.rejected_by = coordinator_id;
        foundRequest.rejected_at = new Date().toISOString();
        foundRequest.rejection_reason = reason || 'No especificado';

        // Eliminar posición temporal
        foundGroup.positions = foundGroup.positions.filter(p => p.request_id !== request_id);

        saveDatabase();

        sendSuccess(res, {
            message: 'Solicitud rechazada',
            request: {
                id: foundRequest.id,
                status: foundRequest.status,
                rejected_by: foundRequest.rejected_by,
                rejected_at: foundRequest.rejected_at,
                rejection_reason: foundRequest.rejection_reason
            }
        });

        log('info', 'Position request rejected', { request_id, reason });
    } catch (error) {
        log('error', 'Error rejecting position request', { error: error.message });
        sendError(res, 500, 'Error al rechazar solicitud de posición');
    }
}

// 8. POST /api/groups/assign-position-manually
// Asignar posición manualmente (sin solicitud)
function handleAssignPositionManually(req, res, body, database) {
    try {
        const { group_id, user_id, user_name, position } = body;

        // SECURITY FIX: Require JWT authentication (2025-12-31)
        const authUser = getAuthenticatedUser(req, {});
        if (!authUser) {
            sendError(res, 401, 'Autenticacion requerida');
            return;
        }
        const coordinator_id = authUser.userId || authUser.user_id || authUser.id;

        if (!group_id || !user_id || !position) {
            sendError(res, 400, 'group_id, user_id y position son requeridos');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }
        
        // SECURITY FIX: Verify requester is coordinator/admin of the group
        const isAuthorized = group.admin_id === coordinator_id || 
            (group.members && group.members.some(m => 
                m.user_id === coordinator_id && 
                ["coordinator", "admin", "creator"].includes(m.role)
            ));
        if (!isAuthorized) {
            sendError(res, 403, 'No tienes permisos para asignar posiciones');
            return;
        }

        if (!group.positions) group.positions = [];

        // Validar posición
        if (position < 1 || position > group.participant_count) {
            sendError(res, 400, `Posición debe estar entre 1 y ${group.participant_count}`);
            return;
        }

        // Verificar disponibilidad
        if (!isPositionAvailable(group, position)) {
            sendError(res, 400, 'Esta posición ya está asignada');
            return;
        }

        // Crear posición confirmada
        group.positions.push({
            position: position,
            user_id: user_id,
            user_name: user_name || 'Usuario',
            assignment_type: 'manual',
            requested_by: null,
            requested_at: null,
            approved_by: coordinator_id,
            approved_at: new Date().toISOString(),
            status: 'confirmed',
            request_id: null
        });

        saveDatabase();

        sendSuccess(res, {
            message: 'Posición asignada exitosamente',
            position: {
                position: position,
                user_id: user_id,
                user_name: user_name,
                assignment_type: 'manual',
                status: 'confirmed'
            }
        });

        log('info', 'Position assigned manually', { group_id, user_id, position });
    } catch (error) {
        log('error', 'Error assigning position manually', { error: error.message });
        sendError(res, 500, 'Error al asignar posición manualmente');
    }
}

// 9. POST /api/groups/auto-assign-positions
// Asignar automáticamente posiciones restantes
function handleAutoAssignPositions(req, res, body, database, authUser) {
    try {
        const { group_id, method } = body;
    const coordinator_id = authUser ? authUser.userId : body.coordinator_id;

        if (!group_id) {
            sendError(res, 400, 'group_id es requerido');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        if (!group.positions) group.positions = [];
        if (!group.members) group.members = [];

        const usersWithoutPosition = getUsersWithoutPosition(group);
        const unassignedPositions = getUnassignedPositions(group);

        if (usersWithoutPosition.length === 0) {
            sendError(res, 400, 'Todos los usuarios ya tienen posición asignada');
            return;
        }

        if (unassignedPositions.length < usersWithoutPosition.length) {
            sendError(res, 400, 'No hay suficientes posiciones disponibles');
            return;
        }

        let assignmentMethod = method || 'random';
        let positionsToAssign = [...unassignedPositions];
        let usersToAssign = [...usersWithoutPosition];

        // Método de asignación
        if (assignmentMethod === 'random') {
            // Shuffle positions
            positionsToAssign.sort(() => crypto.randomInt(0, 2) - 1);
        } else if (assignmentMethod === 'order') {
            // Ordenar usuarios por fecha de unión
            usersToAssign.sort((a, b) => new Date(a.joined_at) - new Date(b.joined_at));
            positionsToAssign.sort((a, b) => a - b);
        }

        // Asignar posiciones
        let assignedCount = 0;
        for (let i = 0; i < usersToAssign.length && i < positionsToAssign.length; i++) {
            const user = usersToAssign[i];
            const position = positionsToAssign[i];

            group.positions.push({
                position: position,
                user_id: user.user_id,
                user_name: user.name || user.user_name || 'Usuario',
                assignment_type: assignmentMethod === 'random' ? 'random' : 'auto',
                requested_by: null,
                requested_at: null,
                approved_by: coordinator_id,
                approved_at: new Date().toISOString(),
                status: 'confirmed',
                request_id: null
            });

            assignedCount++;
        }

        saveDatabase();

        sendSuccess(res, {
            message: `${assignedCount} posiciones asignadas automáticamente`,
            method: assignmentMethod,
            assigned_count: assignedCount,
            assignments: group.positions
                .filter(p => p.assignment_type === assignmentMethod || p.assignment_type === 'auto')
                .slice(-assignedCount)
        });

        log('info', 'Positions auto-assigned', { group_id, method: assignmentMethod, count: assignedCount });
    } catch (error) {
        log('error', 'Error auto-assigning positions', { error: error.message });
        sendError(res, 500, 'Error al asignar posiciones automáticamente');
    }
}

// 10. POST /api/groups/activate-tanda
// Activar el grupo (requiere todas posiciones asignadas)
function handleActivateTanda(req, res, body, database, authUser) {
    try {
        const { group_id } = body;
        const coordinator_id = authUser.userId;

        if (!group_id) {
            sendError(res, 400, 'group_id es requerido');
            return;
        }

        const group = database.groups?.find(g => g.id === group_id);
        if (!group) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        if (!group.positions) group.positions = [];

        // Verificar que todas las posiciones estén asignadas
        const confirmedPositions = group.positions.filter(p => p.status === 'confirmed').length;

        if (confirmedPositions < group.participant_count) {
            sendError(res, 400, `No se puede activar. Faltan ${group.participant_count - confirmedPositions} posiciones por asignar`);
            return;
        }

        // Cambiar estado del grupo
        group.status = 'active';
        group.activated_at = new Date().toISOString();
        group.activated_by = coordinator_id;
        group.current_round = 1;

        // Generar payment_schedule basado en posiciones
        if (!group.payment_schedule) {
            group.payment_schedule = [];
        }

        const sortedPositions = [...group.positions]
            .filter(p => p.status === 'confirmed')
            .sort((a, b) => a.position - b.position);

        for (let i = 0; i < sortedPositions.length; i++) {
            const pos = sortedPositions[i];
            group.payment_schedule.push({
                round: i + 1,
                position: pos.position,
                beneficiary_id: pos.user_id,
                beneficiary_name: pos.user_name,
                amount: group.contribution_amount,
                due_date: calculateDueDate(group, i + 1),
                status: i === 0 ? 'current' : 'pending'
            });
        }

        saveDatabase();

        sendSuccess(res, {
            message: 'Tanda activada exitosamente',
            group: {
                id: group.id,
                name: group.name,
                status: group.status,
                current_round: group.current_round,
                activated_at: group.activated_at,
                payment_schedule_generated: true
            }
        });

        log('info', 'Tanda activated', { group_id, coordinator_id });
    } catch (error) {
        log('error', 'Error activating tanda', { error: error.message });
        sendError(res, 500, 'Error al activar tanda');
    }
}

/**
 * Helper: Calcular fecha de vencimiento para una ronda
 */
function calculateDueDate(group, round) {
    const startDate = new Date(group.activated_at || Date.now());
    const frequency = group.frequency || 'monthly';

    let daysToAdd = 0;
    switch (frequency) {
        case 'weekly':
            daysToAdd = (round - 1) * 7;
            break;
        case 'biweekly':
            daysToAdd = (round - 1) * 14;
            break;
        case 'monthly':
        default:
            daysToAdd = (round - 1) * 30;
            break;
    }

    const dueDate = new Date(startDate);
    dueDate.setDate(dueDate.getDate() + daysToAdd);
    return dueDate.toISOString();
}

// ============================================================
// Payment Date Helper — Single source of truth for due dates
// Used by: my-tandas, my-groups-pg, calendar, cron
// ============================================================
function getLastDayOfMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
}

/**
 * Calculate the payment due date for a specific cycle number.
 * @param {string} frequency - 'weekly' | 'biweekly' | 'monthly'
 * @param {Date|string} startDate - Group start date
 * @param {number} cycleNumber - 1-based cycle number
 * @param {number} gracePeriod - Grace days (default 5 for biweekly/monthly, 0 for weekly)
 * @returns {{ dueDate: string, graceDeadline: string, label: string }}
 *   dueDate: 'YYYY-MM-DD', graceDeadline: 'YYYY-MM-DD', label: Spanish description
 */
function getPaymentDueDate(frequency, startDate, cycleNumber, gracePeriod) {
    var start = typeof startDate === 'string' ? new Date(startDate + (startDate.includes('T') ? '' : 'T12:00:00')) : new Date(startDate);
    var cycle = Math.max(1, cycleNumber || 1);
    var grace = parseInt(gracePeriod) || 0;
    var freq = (frequency || 'monthly').toLowerCase();

    function pad2(n) { return String(n).padStart(2, '0'); }
    function toDateStr(y, m, d) { return y + '-' + pad2(m + 1) + '-' + pad2(d); }
    function addGrace(dateStr, days) {
        if (!days) return dateStr;
        var d = new Date(dateStr + 'T12:00:00');
        d.setDate(d.getDate() + days);
        return d.toISOString().split('T')[0];
    }

    if (freq === 'biweekly' || freq === 'quincenal') {
        // Fixed dates: 15th and last day of each month
        var baseDay = start.getDate();
        var startOnSecondHalf = baseDay > 15;
        var curYear = start.getFullYear();
        var curMonth = start.getMonth();
        var onSecondHalf = startOnSecondHalf;

        for (var i = 0; i < cycle; i++) {
            if (i === cycle - 1) {
                // This is the target cycle
                var payDay, label;
                if (!onSecondHalf) {
                    payDay = toDateStr(curYear, curMonth, 15);
                    label = 'Quincena (dia 15)';
                } else {
                    var lastDay = getLastDayOfMonth(curYear, curMonth);
                    payDay = toDateStr(curYear, curMonth, lastDay);
                    label = 'Fin de mes (dia ' + lastDay + ')';
                }
                return { dueDate: payDay, graceDeadline: addGrace(payDay, grace || 5), label: label };
            }
            // Advance to next half
            if (onSecondHalf) {
                curMonth++;
                if (curMonth > 11) { curMonth = 0; curYear++; }
            }
            onSecondHalf = !onSecondHalf;
        }
    } else if (freq === 'weekly' || freq === 'semanal') {
        // Every 7 days from start_date, no grace period
        var d = new Date(start);
        d.setDate(d.getDate() + ((cycle - 1) * 7));
        var payDay = d.toISOString().split('T')[0];
        return { dueDate: payDay, graceDeadline: payDay, label: 'Semana ' + cycle };

    } else {
        // Monthly: same day each month, clamped to last day
        var anchorDay = start.getDate();
        var d = new Date(start);
        d.setMonth(start.getMonth() + (cycle - 1));
        var maxDay = getLastDayOfMonth(d.getFullYear(), d.getMonth());
        if (anchorDay > maxDay) d.setDate(maxDay);
        var payDay = d.toISOString().split('T')[0];
        return { dueDate: payDay, graceDeadline: addGrace(payDay, grace || 5), label: 'Mes ' + cycle };
    }

    // Fallback (should not reach here)
    return { dueDate: null, graceDeadline: null, label: '' };
}
// ============================================================

// =============================================================================


        // =============================================
        // v4.11.0: HELPER — Check cycle advance with mora (threshold-based)
        // Replaces duplicated auto-advance logic in record-for-member and record-bulk
        // =============================================
        async function checkCycleAdvanceWithMora(groupId, targetCycle, currentCycle, contributionAmount) {
            try {
                const thresholdResult = await dbPostgres.pool.query(
                    "SELECT COALESCE(advance_threshold, 80) as threshold FROM groups WHERE group_id = $1",
                    [groupId]
                );
                const threshold = parseInt(thresholdResult.rows[0]?.threshold || 80);

                const activeCount = await dbPostgres.pool.query(
                    "SELECT COALESCE(SUM(COALESCE(num_positions, 1)), 0) as cnt FROM group_members WHERE group_id = $1 AND status IN ('active', 'suspended')",
                    [groupId]
                );
                const paidCount = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as cnt FROM contributions WHERE group_id = $1 AND cycle_number = $2 AND status IN ('completed', 'coordinator_approved', 'archived')",
                    [groupId, targetCycle]
                );

                const activeRequired = parseInt(activeCount.rows[0].cnt);
                const paid = parseInt(paidCount.rows[0].cnt);
                const thresholdCount = Math.ceil(activeRequired * threshold / 100);

                let advanced = false;
                let moraCount = 0;

                if (paid >= thresholdCount && targetCycle >= currentCycle) {
                    // Advance the cycle
                    await dbPostgres.pool.query(
                        "UPDATE groups SET current_cycle = $1, updated_at = NOW() WHERE group_id = $2",
                        [currentCycle + 1, groupId]
                    );
                    advanced = true;
                    log("info", "Auto-advanced group cycle (threshold)", { groupId, from: currentCycle, to: currentCycle + 1, paid, required: activeRequired, threshold });

                    // If not all paid, mark unpaid members as mora
                    if (paid < activeRequired) {
                        const unpaidMembers = await dbPostgres.pool.query(`
                            SELECT gm.user_id, COALESCE(gm.num_positions, 1) as num_positions
                            FROM group_members gm
                            WHERE gm.group_id = $1 AND gm.status IN ('active', 'suspended')
                            AND (
                                SELECT COUNT(*) FROM contributions c
                                WHERE c.user_id = gm.user_id AND c.group_id = $1 AND c.cycle_number = $2
                                AND c.status IN ('completed', 'coordinator_approved', 'archived')
                            ) < COALESCE(gm.num_positions, 1)
                        `, [groupId, targetCycle]);

                        for (const unpaid of unpaidMembers.rows) {
                            try {
                                await dbPostgres.pool.query(`
                                    INSERT INTO payment_deferrals (group_id, user_id, cycle_number, type, status, mora_applied_by, mora_applied_at, mora_method, positions_count, amount_owed, created_at, updated_at)
                                    VALUES ($1, $2, $3, 'mora', 'active', NULL, NOW(), 'auto_threshold', $4, $5, NOW(), NOW())
                                    ON CONFLICT (group_id, user_id, cycle_number, type) DO NOTHING
                                `, [groupId, unpaid.user_id, targetCycle, unpaid.num_positions, contributionAmount * unpaid.num_positions]);

                                await notificationsUtils.createNotification(dbPostgres.pool, unpaid.user_id, 'mora_applied',
                                    'Pago en Mora',
                                    'Tu pago fue marcado en mora porque el ciclo avanzó sin completar tu cuota.',
                                    { group_id: groupId, cycle_number: targetCycle }
                                );
                                moraCount++;
                            } catch (moraErr) {
                                log("warn", "Could not create mora for member", { groupId, userId: unpaid.user_id, error: moraErr.message });
                            }
                        }
                    }
                }

                return { advanced, moraCount, paid, activeRequired, thresholdCount };
            } catch (advErr) {
                log("warn", "Could not check cycle advance with mora", { groupId, error: advErr.message });
                return { advanced: false, moraCount: 0 };
            }
        }
const server = http.createServer(async (req, res) => {
    requestCount++;
    metricsModule.startRequest(req);
    const parsedUrl = parseUrl(req.url);
    const pathname = parsedUrl.pathname;
    const query = parsedUrl.query;
    const method = req.method;
    
    // Get client IP for rate limiting
    const clientIP = securityMiddleware.getClientIP(req);
    
    // Check rate limit
    const rateLimitResult = securityMiddleware.checkRateLimit(clientIP, pathname);
    if (!rateLimitResult.allowed) {
        res.statusCode = 429;
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Retry-After', rateLimitResult.retryAfter);
        res.setHeader('X-RateLimit-Remaining', 0);
        securityMiddleware.applySecurityHeaders(res);
        res.end(JSON.stringify({
            success: false,
            data: {
                error: {
                    code: 429,
                    message: "Demasiadas solicitudes. Por favor espera antes de intentar de nuevo.",
                    retry_after: rateLimitResult.retryAfter,
                    timestamp: new Date().toISOString()
                }
            }
        }));
        log('warn', 'Rate limit exceeded', { clientIP, pathname });
        return;
    }



    if (method === "OPTIONS") {        res.statusCode = 204;        res.setHeader("Access-Control-Allow-Origin", "https://latanda.online");        res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");        res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");        res.end();        return;    }

    // === Token Blacklist Enforcement (C3) ===
    const earlyToken = extractTokenFromHeader(req);
    if (earlyToken) {
        try {
            const isRevoked = await securityMiddleware.isTokenBlacklisted(earlyToken);
            if (isRevoked) {
                sendError(res, 401, 'Token ha sido revocado');
                return;
            }
        } catch (err) {
            // Redis unavailable — fail open (allow request)
        }
    }

    // Handle lottery endpoints
        if (pathname.startsWith("/api/lottery/")) {
            const handled = await lotteryApi.handleLotteryRequest(req, res, pathname, method, sendSuccess, sendError, authenticateRequest, parseBody, log);
            if (handled) return;
        }
    // Handle marketplace endpoints
        if (pathname.startsWith("/api/marketplace/")) {
            const handled = await marketplaceApi.handleMarketplaceRequest(req, res, pathname, method, sendSuccess, sendError, authenticateRequest, parseBody, log);
            if (handled) return;
        }

    // MIA AI Assistant
    if (pathname.startsWith("/api/mia")) {
        const handled = await miaApi.handleMiaRequest(req, res, pathname, method, sendSuccess, sendError, authenticateRequest, parseBody, log);
        if (handled !== false) return;
    }

    // ============================================
    // Handle social image upload BEFORE general parsing
    // POST /api/upload/social-image
    // Added: 2026-02-02
    // ============================================
    if (pathname === "/api/upload/social-image" && method === "POST") {
        try {
            let chunks = [];
            
            req.on("data", (chunk) => {
                chunks.push(chunk);
            });
            
            req.on("end", async () => {
                try {
                    const buffer = Buffer.concat(chunks);
                    const bodyString = buffer.toString();
                    
                    // Extract auth token from header
                    const authHeader = req.headers["authorization"] || "";
                    const token = authHeader.replace("Bearer ", "").trim();
                    
                    if (!token) {
                        sendError(res, 401, "Autenticacion requerida para subir imagenes");
                        return;
                    }
                    
                    // Verify token
                    let userId = null;
                    try {
                        const decoded = jwt.verify(token, process.env.JWT_SECRET, { algorithms: ['HS256'] });
                        userId = decoded.userId || decoded.user_id;
                    } catch (e) {
                        sendError(res, 401, "Token invalido");
                        return;
                    }
                    
                    if (!userId) {
                        sendError(res, 401, "Usuario no identificado");
                        return;
                    }
                    
                    // Parse filename from Content-Disposition
                    let fileName = "social-image.jpg";
                    const filenameMatch = bodyString.match(/filename="([^"]+)"/);
                    if (filenameMatch) fileName = sanitizeFileName(filenameMatch[1]) || "social-image.jpg";
                    
                    // Validate file extension
                    const allowedExts = [".jpg", ".jpeg", ".png", ".gif", ".webp"];
                    if (!isAllowedExtension(fileName, allowedExts)) {
                        sendError(res, 400, "Solo se permiten imagenes JPG, PNG, GIF o WebP");
                        return;
                    }
                    
                    // Extract image data from multipart
                    const contentType = req.headers["content-type"] || "";
                    const boundaryMatch = contentType.match(/boundary=(?:"([^"]+)"|([^\s;]+))/);
                    if (!boundaryMatch) {
                        sendError(res, 400, "Boundary no encontrado en multipart");
                        return;
                    }
                    const boundary = boundaryMatch[1] || boundaryMatch[2];
                    
                    // Find image data between boundaries
                    const boundaryBuffer = Buffer.from("--" + boundary);
                    const parts = [];
                    let start = 0;
                    let idx;
                    
                    while ((idx = buffer.indexOf(boundaryBuffer, start)) !== -1) {
                        if (start > 0) {
                            parts.push(buffer.slice(start, idx - 2)); // -2 for CRLF
                        }
                        start = idx + boundaryBuffer.length + 2; // +2 for CRLF
                    }
                    
                    // Find the file part
                    let imageBuffer = null;
                    for (const part of parts) {
                        const partString = part.toString("utf8", 0, Math.min(1000, part.length));
                        if (partString.includes("Content-Type: image/") || partString.includes("filename=")) {
                            // Find end of headers (double CRLF)
                            const headerEnd = part.indexOf("\r\n\r\n");
                            if (headerEnd !== -1) {
                                imageBuffer = part.slice(headerEnd + 4);
                                break;
                            }
                        }
                    }
                    
                    if (!imageBuffer || imageBuffer.length < 100) {
                        sendError(res, 400, "No se pudo extraer la imagen del formulario");
                        return;
                    }
                    
                    // Validate file size (max 5MB)
                    if (imageBuffer.length > 5 * 1024 * 1024) {
                        sendError(res, 400, "La imagen no puede exceder 5MB");
                        return;
                    }
                    
                    // Validate file integrity (check magic bytes)
                    const validationResult = validateFileIntegrity(imageBuffer, fileName);
                    if (!validationResult.valid) {
                        sendError(res, 400, validationResult.error || "Archivo de imagen invalido");
                        return;
                    }
                    
                    // Create uploads/social directory if not exists
                    const uploadsDir = path.join("/var/www/uploads/social");
                    if (!fs.existsSync(uploadsDir)) {
                        fs.mkdirSync(uploadsDir, { recursive: true });
                    }
                    
                    // Generate unique filename
                    const fileExt = path.extname(fileName).toLowerCase() || ".jpg";
                    const timestamp = Date.now();
                    const uniqueId = require("crypto").randomBytes(8).toString("hex");
                    const finalFileName = `${userId}-${timestamp}-${uniqueId}${fileExt}`;
                    
                    // Save file
                    const filePath = path.join(uploadsDir, finalFileName);
                    fs.writeFileSync(filePath, imageBuffer);
                    
                    // Return public URL
                    const imageUrl = `/uploads/social/${finalFileName}`;
                    
                    log("info", `[UPLOAD] Social image uploaded by user ${userId}: ${finalFileName}`);
                    
                    sendResponse(res, 201, {
                        success: true,
                        data: {
                            url: imageUrl,
                            filename: finalFileName,
                            size: imageBuffer.length,
                            type: fileExt.replace(".", "")
                        }
                    });
                    
                } catch (error) {
                    log("error", "[UPLOAD] Social image processing error: " + error.message);
                    log("error", "Error procesando imagen", { error: error.message }); sendError(res, 500, "Error interno del servidor");
                }
            });
            
            req.on("error", (error) => {
                log("error", "[UPLOAD] Social image request error: " + error.message);
                sendError(res, 500, "Error en la solicitud");
            });
            
        } catch (error) {
            log("error", "[UPLOAD] Social image error: " + error.message);
            sendError(res, 500, "Error al subir imagen");
        }
        return;
    }

    // ============================================
    // POST /api/upload/social-video
    // Added: 2026-02-05
    // ============================================
    if (pathname === "/api/upload/social-video" && method === "POST") {
        try {
            let chunks = [];
            let totalSize = 0;
            const MAX_VIDEO_SIZE = 50 * 1024 * 1024; // 50MB

            req.on("data", (chunk) => {
                totalSize += chunk.length;
                if (totalSize > MAX_VIDEO_SIZE + 1024) {
                    req.destroy();
                    sendError(res, 413, "El video no puede exceder 50MB");
                    return;
                }
                chunks.push(chunk);
            });

            req.on("end", async () => {
                try {
                    const buffer = Buffer.concat(chunks);

                    // Extract auth token
                    const authHeader = req.headers["authorization"] || "";
                    const token = authHeader.replace("Bearer ", "").trim();

                    if (!token) {
                        sendError(res, 401, "Autenticacion requerida para subir videos");
                        return;
                    }

                    // Verify token
                    let userId = null;
                    try {
                        const decoded = jwt.verify(token, process.env.JWT_SECRET, { algorithms: ['HS256'] });
                        userId = decoded.userId || decoded.user_id;
                    } catch (e) {
                        sendError(res, 401, "Token invalido");
                        return;
                    }

                    if (!userId) {
                        sendError(res, 401, "Usuario no identificado");
                        return;
                    }

                    // Parse filename from Content-Disposition
                    const bodyString = buffer.toString("utf8", 0, Math.min(2000, buffer.length));
                    let fileName = "social-video.mp4";
                    const filenameMatch = bodyString.match(/filename="([^"]+)"/);
                    if (filenameMatch) fileName = sanitizeFileName(filenameMatch[1]) || "social-video.mp4";

                    // Validate file extension
                    const allowedExts = [".mp4", ".webm", ".mov", ".avi", ".mkv"];
                    if (!isAllowedExtension(fileName, allowedExts)) {
                        sendError(res, 400, "Solo se permiten videos MP4, MOV, WebM, AVI o MKV");
                        return;
                    }

                    // Extract video data from multipart
                    const contentType = req.headers["content-type"] || "";
                    const boundaryMatch = contentType.match(/boundary=(?:"([^"]+)"|([^\s;]+))/);
                    if (!boundaryMatch) {
                        sendError(res, 400, "Boundary no encontrado en multipart");
                        return;
                    }
                    const boundary = boundaryMatch[1] || boundaryMatch[2];

                    // Find video data between boundaries
                    const boundaryBuffer = Buffer.from("--" + boundary);
                    const parts = [];
                    let start = 0;
                    let idx;

                    while ((idx = buffer.indexOf(boundaryBuffer, start)) !== -1) {
                        if (start > 0) {
                            parts.push(buffer.slice(start, idx - 2));
                        }
                        start = idx + boundaryBuffer.length + 2;
                    }

                    // Find the file part
                    let videoBuffer = null;
                    for (const part of parts) {
                        const partString = part.toString("utf8", 0, Math.min(1000, part.length));
                        if (partString.includes("Content-Type: video/") || partString.includes("filename=")) {
                            const headerEnd = part.indexOf("\r\n\r\n");
                            if (headerEnd !== -1) {
                                videoBuffer = part.slice(headerEnd + 4);
                                break;
                            }
                        }
                    }

                    if (!videoBuffer || videoBuffer.length < 100) {
                        sendError(res, 400, "No se pudo extraer el video del formulario");
                        return;
                    }

                    // Validate file size
                    if (videoBuffer.length > MAX_VIDEO_SIZE) {
                        sendError(res, 400, "El video no puede exceder 50MB");
                        return;
                    }

                    // Validate video magic bytes
                    const b = videoBuffer;
                    let validVideo = false;

                    // MP4/MOV: ftyp box at offset 4
                    if (b.length > 8 && b[4] === 0x66 && b[5] === 0x74 && b[6] === 0x79 && b[7] === 0x70) {
                        validVideo = true;
                    }
                    // WebM/MKV: EBML header 0x1A45DFA3
                    if (b[0] === 0x1A && b[1] === 0x45 && b[2] === 0xDF && b[3] === 0xA3) {
                        validVideo = true;
                    }
                    // AVI: RIFF....AVI
                    if (b[0] === 0x52 && b[1] === 0x49 && b[2] === 0x46 && b[3] === 0x46 && b.length > 11 && b[8] === 0x41 && b[9] === 0x56 && b[10] === 0x49) {
                        validVideo = true;
                    }

                    if (!validVideo) {
                        sendError(res, 400, "Archivo de video invalido o corrupto");
                        return;
                    }

                    // Create uploads/videos directory if not exists
                    const uploadsDir = "/var/www/uploads/videos";
                    if (!fs.existsSync(uploadsDir)) {
                        fs.mkdirSync(uploadsDir, { recursive: true });
                    }

                    // Generate unique filename
                    const fileExt = path.extname(fileName).toLowerCase() || ".mp4";
                    const timestamp = Date.now();
                    const uniqueId = require("crypto").randomBytes(8).toString("hex");
                    const finalFileName = userId + "-" + timestamp + "-" + uniqueId + fileExt;

                    // Save file
                    const filePath = path.join(uploadsDir, finalFileName);
                    fs.writeFileSync(filePath, videoBuffer);

                    // Return public URL
                    const videoUrl = "/uploads/videos/" + finalFileName;

                    log("info", "[UPLOAD] Social video uploaded by user " + userId + ": " + finalFileName + " (" + (videoBuffer.length / 1024 / 1024).toFixed(2) + "MB)");

                    sendResponse(res, 201, {
                        success: true,
                        data: {
                            url: videoUrl,
                            filename: finalFileName,
                            size: videoBuffer.length,
                            type: fileExt.replace(".", "")
                        }
                    });

                } catch (error) {
                    log("error", "[UPLOAD] Social video processing error: " + error.message);
                    log("error", "Error procesando video", { error: error.message }); sendError(res, 500, "Error interno del servidor");
                }
            });

            req.on("error", (error) => {
                log("error", "[UPLOAD] Social video request error: " + error.message);
                sendError(res, 500, "Error en la solicitud");
            });

        } catch (error) {
            log("error", "[UPLOAD] Social video error: " + error.message);
            sendError(res, 500, "Error al subir video");
        }
        return;
    }

    // Handle contribution proof upload BEFORE general parsing
    if (pathname.match(/^\/api\/contributions\/[^/]+\/upload-proof$/) && method === 'POST') {

        const contributionId = pathname.split('/')[3];
        
        try {
            // Authenticate via JWT (required)
            const authHeader = req.headers["authorization"] || "";
            const proofToken = authHeader.replace("Bearer ", "").trim();
            if (!proofToken) {
                sendError(res, 401, "Autenticacion requerida para subir comprobantes");
                return;
            }
            let authUserId = null;
            try {
                const decoded = jwt.verify(proofToken, process.env.JWT_SECRET, { algorithms: ['HS256'] });
                authUserId = decoded.userId || decoded.user_id;
            } catch (e) {
                sendError(res, 401, "Token invalido");
                return;
            }
            if (!authUserId) {
                sendError(res, 401, "Usuario no identificado");
                return;
            }

            const MAX_PROOF_SIZE = 5 * 1024 * 1024; // 5MB limit
            let totalSize = 0;
            let chunks = [];

            req.on('data', (chunk) => {
                totalSize += chunk.length;
                if (totalSize > MAX_PROOF_SIZE) {
                    req.destroy();
                    return;
                }
                chunks.push(chunk);
            });

            req.on('end', async () => {
                try {
                    const buffer = Buffer.concat(chunks);
                    const bodyString = buffer.toString();
                    
                    // Use authenticated user ID
                    const userId = authUserId;
                    let fileName = 'proof.jpg';
                    
                    
                    // Parse filename from Content-Disposition and sanitize
                    const filenameMatch = bodyString.match(/filename="([^"]+)"/);
                    if (filenameMatch) fileName = sanitizeFileName(filenameMatch[1]) || 'proof.jpg';
                    
                    // Validate contribution exists
                    const contribResult = await dbPostgres.pool.query(
                        'SELECT id, user_id, status, reference_code FROM contributions WHERE id = $1',
                        [contributionId]
                    );
                    
                    if (contribResult.rows.length === 0) {
                        sendError(res, 404, 'Contribucion no encontrada');
                        return;
                    }
                    
                    const contribution = contribResult.rows[0];

                    // Verify the authenticated user owns this contribution
                    if (String(contribution.user_id) !== String(userId)) {
                        sendError(res, 403, 'Solo puedes subir comprobante para tus propias contribuciones');
                        return;
                    }
                    
                    // Only allow proof upload for awaiting_payment or pending status
                    if (!['awaiting_payment', 'pending', 'pending_verification'].includes(contribution.status)) {
                        sendError(res, 400, 'Solo se puede subir comprobante para pagos pendientes');
                        return;
                    }
                    
                    // Extract image data from multipart (using raw buffer)
                    const boundaryMatch = bodyString.match(/--[^\r\n]+/);
                    if (!boundaryMatch) {
                        sendError(res, 400, 'Formato de multipart inválido');
                        return;
                    }
                    const boundary = boundaryMatch[0];
                    
                    // Find image content in raw buffer
                    let imageBuffer = null;
                    const boundaryBuffer = Buffer.from(boundary);
                    let start = 0;
                    
                    while (start < buffer.length) {
                        const boundaryPos = buffer.indexOf(boundaryBuffer, start);
                        if (boundaryPos === -1) break;
                        
                        // Find headers end (\r\n\r\n)
                        const headersEnd = buffer.indexOf(Buffer.from('\r\n\r\n'), boundaryPos);
                        if (headersEnd === -1) {
                            start = boundaryPos + boundaryBuffer.length;
                            continue;
                        }
                        
                        const headerSection = buffer.slice(boundaryPos, headersEnd + 4).toString('utf8');
                        
                        // Check if this part contains an image
                        if (headerSection.includes('Content-Type: image/')) {
                            const contentStart = headersEnd + 4;
                            const nextBoundary = buffer.indexOf(boundaryBuffer, contentStart);
                            
                            if (nextBoundary !== -1) {
                                // Remove trailing \r\n before boundary
                                let contentEnd = nextBoundary - 2;
                                if (contentEnd > contentStart) {
                                    imageBuffer = buffer.slice(contentStart, contentEnd);
                                }
                            }
                            break;
                        }
                        
                        start = boundaryPos + boundaryBuffer.length;
                    }
                    
                    if (!imageBuffer || imageBuffer.length < 100) {
                        sendError(res, 400, 'No se pudo extraer la imagen del formulario');
                        return;
                    }

                    // Validate file extension (images + PDF only)
                    const allowedProofExts = ['.jpg', '.jpeg', '.png', '.webp', '.pdf'];
                    if (!isAllowedExtension(fileName, allowedProofExts)) {
                        sendError(res, 400, 'Tipo de archivo no permitido. Solo: JPG, PNG, WEBP, PDF');
                        return;
                    }

                    // Validate magic bytes match extension
                    const integrityCheck = validateFileIntegrity(imageBuffer, fileName);
                    if (!integrityCheck.valid) {
                        sendError(res, 400, integrityCheck.error || 'Archivo corrupto o tipo no coincide');
                        return;
                    }
                    
                    // Create proofs directory if it doesn't exist
                    const proofsDir = path.join(__dirname, 'proofs');
            const resolvedProofs = path.resolve(proofsDir);
            if (!resolvedProofs.startsWith(path.resolve(__dirname, 'proofs'))) { sendError(res, 400, 'Ruta invalida'); return; }
                    if (!fs.existsSync(proofsDir)) {
                        fs.mkdirSync(proofsDir, { recursive: true });
                    }
                    
                    // Generate unique filename
                    const timestamp = Date.now();
                    const fileExt = path.extname(fileName).toLowerCase() || '.jpg';
                    const finalFileName = 'proof_' + contributionId.substring(0, 8) + '_' + timestamp + fileExt;
                    const filePath = path.join(proofsDir, finalFileName);
                    
                    // Save file
                    fs.writeFileSync(filePath, imageBuffer);
                    
                    // Update contribution with proof URL and status
                    const proofUrl = '/api/proof/' + finalFileName;
                    await dbPostgres.pool.query(
                        'UPDATE contributions SET proof_url = $1, status = $2, updated_at = NOW() WHERE id = $3',
                        [proofUrl, 'pending_verification', contributionId]
                    );
                    
                    log('info', 'Contribution proof uploaded', { 
                        contribution_id: contributionId, 
                        proof_url: proofUrl,
                        file_size: imageBuffer.length
                    });
                    
                    // ========== AUTOMATIC OCR VERIFICATION ==========
                    let ocrResult = null;
                    try {
                        log('info', 'Starting automatic OCR verification', { contribution_id: contributionId });
                        
                        // Get full contribution details for OCR
                        const fullContrib = await dbPostgres.pool.query(
                            `SELECT c.id, c.amount, c.payment_method, c.reference_code, c.status
                             FROM contributions c WHERE c.id = $1`,
                            [contributionId]
                        );
                        
                        if (fullContrib.rows.length > 0) {
                            const contrib = fullContrib.rows[0];
                            
                            // Perform OCR on the saved image
                            const { data: { text } } = await Tesseract.recognize(filePath, 'spa', {
                                logger: m => {} // Suppress logs
                            });
                            
                            const extractedText = text.toUpperCase();
                            log('info', 'OCR text extracted', { contribution_id: contributionId, text_length: extractedText.length });
                            
                            // Verification results
                            let verification = {
                                account_match: false,
                                name_match: false,
                                reference_match: false,
                                amount_match: false,
                                confidence: 0,
                                matches: [],
                                mismatches: []
                            };
                            
                            const paymentMethod = contrib.payment_method;
                            const expectedAmount = parseFloat(contrib.amount);
                            const referenceCode = contrib.reference_code;
                            
                            // Check based on payment method
                            if (paymentMethod === 'bank_transfer') {
                                for (const variant of PAYMENT_ACCOUNTS.bank_transfer.account_variants) {
                                    if (extractedText.includes(variant.replace(/-/g, '').replace(/ /g, ''))) {
                                        verification.account_match = true;
                                        verification.matches.push('Cuenta: ' + variant);
                                        break;
                                    }
                                }
                                for (const variant of PAYMENT_ACCOUNTS.bank_transfer.holder_variants) {
                                    if (extractedText.includes(variant)) {
                                        verification.name_match = true;
                                        verification.matches.push('Titular: ' + variant);
                                        break;
                                    }
                                }
                            } else if (paymentMethod === 'mobile_money') {
                                for (const variant of PAYMENT_ACCOUNTS.mobile_money.phone_variants) {
                                    const cleanVariant = variant.replace(/[^0-9]/g, '');
                                    if (extractedText.replace(/[^0-9]/g, '').includes(cleanVariant)) {
                                        verification.account_match = true;
                                        verification.matches.push('Teléfono: ' + variant);
                                        break;
                                    }
                                }
                                for (const variant of PAYMENT_ACCOUNTS.mobile_money.name_variants) {
                                    if (extractedText.includes(variant)) {
                                        verification.name_match = true;
                                        verification.matches.push('Nombre: ' + variant);
                                        break;
                                    }
                                }
                            } else if (paymentMethod === 'crypto') {
                                if (extractedText.includes(PAYMENT_ACCOUNTS.crypto.address_short.toUpperCase()) ||
                                    extractedText.includes(PAYMENT_ACCOUNTS.crypto.address_end.toUpperCase())) {
                                    verification.account_match = true;
                                    verification.name_match = true;
                                    verification.matches.push('Dirección crypto');
                                }
                            }
                            
                            // Check reference code
                            if (referenceCode) {
                                const refClean = referenceCode.replace(/-/g, '').toUpperCase();
                                if (extractedText.includes(refClean) || extractedText.includes(referenceCode.toUpperCase())) {
                                    verification.reference_match = true;
                                    verification.matches.push('Referencia: ' + referenceCode);
                                }
                            }
                            
                            // Check amount
                            const amountRegex = /L\.?\s*([0-9,]+\.?[0-9]*)|([0-9,]+\.?[0-9]*)\s*L/g;
                            let amountMatch;
                            while ((amountMatch = amountRegex.exec(extractedText)) !== null) {
                                const foundAmount = parseFloat((amountMatch[1] || amountMatch[2]).replace(/,/g, ''));
                                if (!isNaN(foundAmount)) {
                                    const tolerance = expectedAmount * 0.05;
                                    if (Math.abs(foundAmount - expectedAmount) <= tolerance) {
                                        verification.amount_match = true;
                                        verification.matches.push('Monto: L. ' + foundAmount.toFixed(2));
                                        break;
                                    }
                                }
                            }
                            
                            // Calculate confidence
                            let matchCount = 0;
                            if (verification.account_match) matchCount++;
                            if (verification.name_match) matchCount++;
                            if (verification.reference_match) matchCount++;
                            if (verification.amount_match) matchCount++;
                            verification.confidence = matchCount / 4;
                            
                            // Auto-approve if confidence >= 75%
                            if (verification.confidence >= 0.75) {
                                await dbPostgres.pool.query(`
                                    UPDATE contributions
                                    SET status = 'completed',
                                        verified_at = NOW(),
                                        verified_by = 'ocr_auto',
                                        notes = $1,
                                        updated_at = NOW()
                                    WHERE id = $2
                                `, ['Verificado automáticamente por OCR. Coincidencias: ' + verification.matches.join(', '), contributionId]);
                                
                                log('info', 'Contribution AUTO-APPROVED by OCR', { 
                                    contribution_id: contributionId, 
                                    confidence: verification.confidence,
                                    matches: verification.matches
                                });
                                
                                ocrResult = {
                                    auto_approved: true,
                                    confidence: verification.confidence,
                                    matches: verification.matches,
                                    status: 'completed'
                                };
                            } else {
                                log('info', 'OCR verification incomplete, requires manual review', { 
                                    contribution_id: contributionId, 
                                    confidence: verification.confidence,
                                    matches: verification.matches
                                });
                                
                                ocrResult = {
                                    auto_approved: false,
                                    confidence: verification.confidence,
                                    matches: verification.matches,
                                    status: 'pending_verification'
                                };
                            }
                        }
                    } catch (ocrError) {
                        log('error', 'OCR verification failed', { 
                            contribution_id: contributionId, 
                            error: ocrError.message 
                        });
                        ocrResult = { error: ocrError.message, auto_approved: false };
                    }
                    // ========== END OCR VERIFICATION ==========
                    
                    sendSuccess(res, {
                        success: true,
                        data: {
                            contribution_id: contributionId,
                            proof_url: proofUrl,
                            status: ocrResult?.auto_approved ? 'completed' : 'pending_verification',
                            message: ocrResult?.auto_approved 
                                ? 'Comprobante verificado automáticamente' 
                                : 'Comprobante subido, pendiente de verificación',
                            ocr_verification: ocrResult
                        }
                    });
                    
                } catch (error) {
                    log("error", 'Error processing proof upload:', error);
                    sendError(res, 500, 'Error al procesar comprobante');
                }
            });
            
        } catch (error) {
            log("error", 'Error in proof upload:', error);
            sendError(res, 500, 'Error al subir comprobante');
        }
        return;
    }

    // Handle upload-receipt endpoint BEFORE general parsing to avoid JSON parsing multipart data
    if (pathname === '/api/deposit/upload-receipt' && method === 'POST') {
            const authHeader = req.headers['authorization'];
            if (!authHeader || !authHeader.startsWith('Bearer ')) {
                sendError(res, 401, 'Token de autenticación requerido');
                return;
            }
        try {
            let chunks = [];
            req.on('data', (chunk) => { chunks.push(chunk); });
            req.on('end', async () => {
                try {
                    // Authenticate inside the async handler
                    const authUser = requireAuth(req, res);
                    if (!authUser) return;

                    const buffer = Buffer.concat(chunks);
                    const bodyString = buffer.toString();

                    // Extract form fields
                    let depositId = null;
                    let fileName = 'receipt.jpg';
                    let notes = '';

                    if (bodyString.includes('name="deposit_id"')) {
                        const depositMatch = bodyString.match(/name="deposit_id"[\s\S]*?\r\n\r\n([^\r\n]+)/);
                        if (depositMatch) depositId = depositMatch[1].trim();
                    }
                    if (bodyString.includes('name="notes"')) {
                        const notesMatch = bodyString.match(/name="notes"[\s\S]*?\r\n\r\n([^\r\n]+)/);
                        if (notesMatch) notes = notesMatch[1].trim().slice(0, 1000);
                    }
                    if (bodyString.includes('filename=')) {
                        const filenameMatch = bodyString.match(/filename="([^"]+)"/);
                        if (filenameMatch) fileName = filenameMatch[1];
                    }

                    if (!fileName || fileName === '') { sendError(res, 400, 'Archivo no encontrado'); return; }

                    const allowedExtensions = ['.jpg', '.jpeg', '.png', '.webp', '.pdf'];
                    const fileExt = path.extname(fileName).toLowerCase();
                    if (!allowedExtensions.includes(fileExt)) { sendError(res, 400, 'Formato de archivo no válido. Use: JPG, PNG, WebP, PDF'); return; }
                    if (buffer.length > 5 * 1024 * 1024) { sendError(res, 400, 'Archivo muy grande. Máximo 5MB'); return; }
                    if (buffer.length < 1000) { sendError(res, 400, 'Archivo muy pequeño. Asegúrese de subir una imagen válida'); return; }
                    if (!depositId) { sendError(res, 400, 'deposit_id es requerido'); return; }

                    // SECURITY: Use authenticated user ID for ownership check (no body.user_id)
                    const deposit = await dbPostgres.getDepositByIdAndUser(depositId, authUser.userId);
                    if (!deposit) { sendError(res, 404, 'Depósito no encontrado'); return; }
                    if (deposit.status !== 'pending_transfer') { sendError(res, 400, 'Solo se pueden subir comprobantes para depósitos pendientes'); return; }

                    // Security checks
                    const securityFlags = [];
                    if (fileName.includes('screenshot') || fileName.includes('screen')) securityFlags.push('SCREENSHOT_DETECTED');
                    if (fileName.includes('fake') || fileName.includes('test')) securityFlags.push('SUSPICIOUS_FILENAME');

                    const imgHeaders = { 'jpeg': [0xFF, 0xD8, 0xFF], 'png': [0x89, 0x50, 0x4E, 0x47], 'webp': [0x52, 0x49, 0x46, 0x46] };
                    let validImageHeader = false;
                    for (const header of Object.values(imgHeaders)) {
                        if (header.every((byte, i) => buffer[i] === byte)) { validImageHeader = true; break; }
                    }
                    if (!validImageHeader && fileExt !== '.pdf') securityFlags.push('INVALID_IMAGE_HEADER');

                    const timestamp = Date.now();
                    const finalFileName = `receipt_${depositId}_${timestamp}${fileExt}`;
                    const receiptsDir = path.join(__dirname, 'receipts');
                    const resolvedReceipts = path.resolve(receiptsDir);
                    if (!resolvedReceipts.startsWith(path.resolve(__dirname, 'receipts'))) { sendError(res, 400, 'Ruta invalida'); return; }
                    if (!fs.existsSync(receiptsDir)) fs.mkdirSync(receiptsDir, { recursive: true });

                    // Extract file data from multipart buffer
                    let imageBuffer = null;
                    const boundaryMatch = bodyString.match(/------WebKitFormBoundary[A-Za-z0-9]+/);
                    if (boundaryMatch) {
                        const boundary = boundaryMatch[0];
                        const filePartRegex = new RegExp(boundary + '[\\s\\S]*?Content-Type:\\s*(image|application)[\\s\\S]*?\\r\\n\\r\\n([\\s\\S]*?)\\r\\n' + boundary);
                        const filePartMatch = buffer.toString('binary').match(filePartRegex);
                        if (filePartMatch) {
                            const headerEndIndex = buffer.indexOf('\r\n\r\n');
                            if (headerEndIndex !== -1) {
                                const dataStartIndex = headerEndIndex + 4;
                                const nextBoundaryIndex = buffer.indexOf(boundary, dataStartIndex);
                                if (nextBoundaryIndex !== -1) {
                                    imageBuffer = buffer.slice(dataStartIndex, nextBoundaryIndex - 2);
                                }
                            }
                        }
                    }
                    if (!imageBuffer) {
                        const imgMarkers = [[0xFF, 0xD8, 0xFF], [0x89, 0x50, 0x4E, 0x47], [0x52, 0x49, 0x46, 0x46]];
                        for (let i = 0; i < buffer.length - 10; i++) {
                            for (const header of imgMarkers) {
                                if (header.every((byte, j) => buffer[i + j] === byte)) {
                                    const remainingBuffer = buffer.slice(i);
                                    const boundaryBytes = Buffer.from('------WebKitFormBoundary', 'binary');
                                    const endIndex = remainingBuffer.indexOf(boundaryBytes);
                                    imageBuffer = endIndex !== -1 ? remainingBuffer.slice(0, endIndex - 2) : remainingBuffer.slice(0, -50);
                                    break;
                                }
                            }
                            if (imageBuffer) break;
                        }
                    }
                    if (!imageBuffer || imageBuffer.length < 100) { sendError(res, 400, 'No se pudo extraer los datos de la imagen del formulario multipart'); return; }

                    fs.writeFileSync(path.join(receiptsDir, finalFileName), imageBuffer);

                    const receiptData = {
                        filename: finalFileName,
                        original_name: fileName || 'receipt.jpg',
                        uploaded_at: new Date().toISOString(),
                        path: path.join(receiptsDir, finalFileName),
                        notes: notes || '',
                        security_flags: securityFlags,
                        file_size: buffer.length,
                        requires_manual_review: securityFlags.length > 0,
                        validation_status: securityFlags.length > 0 ? 'flagged' : 'pending'
                    };

                    const updateResult = await dbPostgres.updateDepositReceipt(depositId, receiptData, 'user_receipt_upload');
                    if (!updateResult) { sendError(res, 400, 'No se pudo actualizar el depósito'); return; }

                    log('info', 'Receipt uploaded successfully', { depositId, userId: authUser.userId, filename: finalFileName });

                    sendDepositNotification({ type: 'receipt_uploaded', deposit, user_id: authUser.userId, receipt_filename: finalFileName });

                    sendSuccess(res, {
                        deposit_id: depositId,
                        old_status: 'pending_transfer',
                        new_status: 'processing',
                        status_description: securityFlags.length > 0 ?
                            'Comprobante recibido - Requiere revisión adicional' :
                            'Comprobante recibido - En revisión administrativa',
                        receipt: {
                            filename: finalFileName,
                            original_name: fileName,
                            uploaded_at: receiptData.uploaded_at,
                            size: buffer.length,
                            notes,
                            security_flags: securityFlags,
                            requires_manual_review: securityFlags.length > 0
                        },
                        message: 'Comprobante subido exitosamente. Su depósito está ahora en revisión.',
                        next_steps: [
                            'Su comprobante está siendo verificado por nuestro equipo',
                            'Recibirá una notificación cuando sea aprobado',
                            'El proceso de revisión toma entre 15-30 minutos'
                        ]
                    });
                } catch (parseError) {
                    log("error", 'Parse error:', parseError);
                    sendError(res, 400, 'Error al procesar datos del formulario');
                }
            });
        } catch (error) {
            log("error", 'Upload error:', error);
            sendError(res, 500, 'Error interno del servidor');
        }
        return;
    }

    try {
        let body = {};
        const contentType = req.headers["content-type"] || "";
        // Skip body parsing for multipart/form-data (handled by specific endpoints)
        if ((method === "POST" || method === "PUT" || method === "PATCH") && !contentType.includes("multipart/form-data")) {
            body = await parseBody(req);
            if (body && body._parseError) { sendError(res, 400, 'Formato de solicitud invalido'); return; }
        }

        // ===== CORE SYSTEM ENDPOINTS (4) =====
        
        // 1. Root endpoint
        if (pathname === '/') {
            sendSuccess(res, {
                message: "La Tanda Complete Mobile API",
                deployment: "Production - Complete Mobile Integration (140+ endpoints)",
                version: "4.11.0",
                environment: "production",
                mobile_optimized: true,
                features: [
                    "Mobile app integration",
                    "Push notifications",
                    "Offline sync",
                    "MIA AI assistant",
                    "Complete user journey"
                ]
            });
            return;
        }

        // 2. Health check
        if (pathname === '/health' && (method === 'GET' || method === 'HEAD')) {
            sendSuccess(res, { status: 'online', server: 'production' });
            return;
        }


        // ============================================
        // PUBLIC ENDPOINTS (No Auth Required)
        // Added: 2026-01-19 for Developer Onboarding
        // ============================================

        // Public Platform Stats
        if (pathname === '/api/public/stats' && (method === 'GET' || method === 'HEAD')) {
            // L1: Cache public stats for 5 minutes
            if (statsCache.data && Date.now() < statsCache.expires) {
                sendSuccess(res, statsCache.data, 200, { 'Cache-Control': 'public, max-age=60' });
                return;
            }
            try {
                const [users, groups, products, transactions] = await Promise.all([
                    dbPostgres.pool.query("SELECT COUNT(*) as count FROM users WHERE status = 'active'"),
                    dbPostgres.pool.query("SELECT COUNT(*) as count FROM groups WHERE status = 'active'"),
                    dbPostgres.pool.query("SELECT COUNT(*) as count FROM marketplace_products WHERE is_active = true"),
                    dbPostgres.pool.query("SELECT COUNT(*) as count FROM contributions")
                ]);
                
                const statsResponseData = {
                    platform: 'La Tanda',
                    version: '4.11.0',
                    stats: {
                        active_users: parseInt(users.rows[0].count),
                        active_groups: parseInt(groups.rows[0].count),
                        marketplace_products: parseInt(products.rows[0].count),
                        total_transactions: parseInt(transactions.rows[0].count)
                    },
                    api: {
                        endpoints_available: 135,
                        rate_limits: {
                            general: '100 req/min',
                            auth: '10 req/min',
                            transactions: '30 req/min'
                        }
                    },
                    developer_resources: {
                        docs: 'https://latanda.online/docs',
                        portal: 'https://latanda.online/dev-dashboard.html',
                        github: 'https://github.com/INDIGOAZUL/la-tanda-web'
                    }
                };
                // L1: Cache for 5 minutes (300,000 ms)
                statsCache = { data: statsResponseData, expires: Date.now() + 300000 };
                sendSuccess(res, statsResponseData, 200, {
                    'Cache-Control': 'public, max-age=60'
                });
            } catch (error) {
                sendError(res, 500, 'Error fetching stats');
            }
            return;
        }

        // Public Marketplace Products (no auth, limited fields)
        if (pathname === '/api/public/products' && (method === 'GET' || method === 'HEAD')) {
            try {
                const limit = Math.min(parseInt(query.limit) || 20, 100);
                const offset = parseInt(query.offset) || 0;
                const category = query.category || null;
                
                let queryStr = `
                    SELECT 
                        p.id, p.title, p.description, p.price, p.currency,
                        p.category_id, p.images, p.location, p.created_at,
                        u.name as seller_name
                    FROM marketplace_products p
                    LEFT JOIN users u ON p.seller_id = u.user_id
                    WHERE p.is_active = true
                `;
                const params = [];
                
                if (category) {
                    params.push(category);
                    queryStr += ` AND p.category_id = $${params.length}`;
                }
                
                queryStr += ` ORDER BY p.created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
                params.push(limit, offset);
                
                const result = await dbPostgres.pool.query(queryStr, params);
                const countResult = await dbPostgres.pool.query(
                    "SELECT COUNT(*) FROM marketplace_products WHERE is_active = true" + 
                    (category ? " AND category_id = $1" : ""),
                    category ? [category] : []
                );
                
                sendSuccess(res, {
                    products: result.rows,
                    pagination: {
                        total: parseInt(countResult.rows[0].count),
                        limit,
                        offset,
                        has_more: offset + result.rows.length < parseInt(countResult.rows[0].count)
                    }
                }, 200, {
                    'Cache-Control': 'public, max-age=30'
                });
            } catch (error) {
                log('error', 'Public products error', { error: error.message });
                sendError(res, 500, 'Error fetching products');
            }
            return;
        }

        // Public Lottery Recent Results
        if (pathname === '/api/public/lottery/recent' && (method === 'GET' || method === 'HEAD')) {
            try {
                const limit = Math.min(parseInt(query.limit) || 10, 50);
                
                const result = await dbPostgres.pool.query(`
                    SELECT 
                        draw_date, draw_time, main_number,
                        created_at
                    FROM hn_lottery_draws
                    ORDER BY draw_date DESC, 
                        CASE draw_time 
                            WHEN '9pm' THEN 1 
                            WHEN '3pm' THEN 2 
                            WHEN '11am' THEN 3 
                        END
                    LIMIT $1
                `, [limit]);
                
                sendSuccess(res, {
                    lottery: 'Honduras La Diaria',
                    time_slots: ['11am', '3pm', '9pm'],
                    recent_results: result.rows,
                    note: 'For predictions, register and use authenticated endpoints'
                }, 200, {
                    'Cache-Control': 'public, max-age=60'
                });
            } catch (error) {
                log('error', 'Public lottery error', { error: error.message });
                sendError(res, 500, 'Error fetching lottery results');
            }
            return;
        }

        // Public API Info
        if (pathname === '/api/public/info' && (method === 'GET' || method === 'HEAD')) {
            sendSuccess(res, {
                name: 'La Tanda API',
                version: '4.11.0',
                description: 'Web3 collaborative savings platform API',
                authentication: {
                    type: 'JWT Bearer Token',
                    endpoint: '/api/auth/login',
                    note: 'Use POST /api/auth/login with your credentials'
                },
                public_endpoints: [
                    'GET /health',
                    'GET /api/public/stats',
                    'GET /api/public/products',
                    'GET /api/public/lottery/recent',
                    'GET /api/public/info'
                ],
                resources: {
                    swagger_ui: 'https://latanda.online/docs',
                    developer_portal: 'https://latanda.online/dev-dashboard.html',
                    github: 'https://github.com/INDIGOAZUL/la-tanda-web',
                    postman: 'https://latanda.online/postman-collection.json'
                }
            }, 200, {
                'Cache-Control': 'public, max-age=3600'
            });
            return;
        }
        // 3. API Documentation
        // API Status endpoint - System health and stats
        if (pathname === "/api/status" && (method === "GET" || method === "HEAD")) {
            try {
                const dbCheck = await dbPostgres.pool.query("SELECT 1 as connected");
                const dbStatus = dbCheck.rows.length > 0 ? "connected" : "disconnected";

                sendSuccess(res, {
                    status: "operational",
                    version: "4.11.0",
                    database: { status: dbStatus },
                    timestamp: new Date().toISOString()
                });
            } catch (error) {
                sendSuccess(res, { status: "degraded", timestamp: new Date().toISOString() });
            }
            return;
        }
        // GET /api/link-preview - Fetch Open Graph metadata from a URL
        // Added: 2026-02-09
        // ============================================
        if (pathname === '/api/link-preview' && (method === 'GET' || method === 'HEAD')) {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }

            const targetUrl = query.url;
            if (!targetUrl) {
                sendError(res, 400, 'URL requerida');
                return;
            }

            let parsedUrl;
            try {
                parsedUrl = new URL(targetUrl);
                if (!['http:', 'https:'].includes(parsedUrl.protocol)) {
                    sendError(res, 400, 'URL invalida');
                    return;
                }
            } catch (e) {
                sendError(res, 400, 'URL invalida');
                return;
            }

            const isPrivateHost = (hostname) => {
                if (!hostname) return true;
                const h = hostname.toLowerCase();
                if (h === 'localhost' || h === '127.0.0.1' || h === '0.0.0.0' || h === '::1' || h === '[::1]') return true;
                if (h.startsWith('192.168.') || h.startsWith('10.') || h.startsWith('169.254.')) return true;
                if (h.startsWith('172.')) {
                    const second = parseInt(h.split('.')[1]);
                    if (second >= 16 && second <= 31) return true;
                }
                if (h.startsWith('fc') || h.startsWith('fd') || h.startsWith('fe80')) return true;
                return false;
            };

            if (isPrivateHost(parsedUrl.hostname)) {
                sendError(res, 400, 'URL no permitida');
                return;
            }

            try {
                const fetchUrl = (urlStr, depth = 0) => new Promise((resolve, reject) => {
                    if (depth > 3) { reject(new Error('too many redirects')); return; }
                    let redirectUrl;
                    try {
                        const p = new URL(urlStr);
                        if (!['http:', 'https:'].includes(p.protocol) || isPrivateHost(p.hostname)) {
                            reject(new Error('blocked redirect')); return;
                        }
                    } catch(e) { reject(new Error('invalid redirect URL')); return; }
                    const mod = urlStr.startsWith('https') ? https : http;
                    const r = mod.get(urlStr, {
                        headers: { 'User-Agent': 'Mozilla/5.0 (compatible; LaTandaBot/1.0)', 'Accept': 'text/html,application/xhtml+xml' }
                    }, (resp) => {
                        if ([301, 302, 303, 307, 308].includes(resp.statusCode) && resp.headers.location) {
                            resp.resume();
                            resolve(fetchUrl(new URL(resp.headers.location, urlStr).href, depth + 1));
                            return;
                        }
                        let data = '';
                        resp.setEncoding('utf8');
                        resp.on('data', (chunk) => { data += chunk; if (data.length > 50000) { resp.destroy(); resolve(data); } });
                        resp.on('end', () => resolve(data));
                        resp.on('error', reject);
                    });
                    r.on('error', reject);
                    r.setTimeout(5000, () => { r.destroy(); reject(new Error('timeout')); });
                });

                const html = await Promise.race([
                    fetchUrl(targetUrl),
                    new Promise((_, rej) => setTimeout(() => rej(new Error('global timeout')), 6000))
                ]);

                const getTag = (h, prop) => {
                    // Escape prop for regex safety (v3.97.0 - defense-in-depth)
                    const ep = prop.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const pats = [
                        new RegExp('<meta[^>]*property=["\']' + ep + '["\'][^>]*content=["\']([^"\']*)["\']', 'i'),
                        new RegExp('<meta[^>]*content=["\']([^"\']*)["\'][^>]*property=["\']' + ep + '["\']', 'i'),
                        new RegExp('<meta[^>]*name=["\']' + ep + '["\'][^>]*content=["\']([^"\']*)["\']', 'i'),
                        new RegExp('<meta[^>]*content=["\']([^"\']*)["\'][^>]*name=["\']' + ep + '["\']', 'i')
                    ];
                    for (const p of pats) { const m = h.match(p); if (m && m[1]) return m[1].trim(); }
                    return null;
                };

                const titleTag = (html.match(/<title[^>]*>([^<]*)<\/title>/i) || [])[1] || null;
                const ogTitle = getTag(html, 'og:title') || getTag(html, 'twitter:title') || (titleTag ? titleTag.trim() : null);
                const ogDesc = getTag(html, 'og:description') || getTag(html, 'twitter:description') || getTag(html, 'description');
                const ogImage = getTag(html, 'og:image') || getTag(html, 'twitter:image');
                const ogSiteName = getTag(html, 'og:site_name');

                if (!ogTitle && !ogDesc && !ogImage) {
                    sendResponse(res, 200, {
                        success: true,
                        data: {
                            url: targetUrl,
                            title: parsedUrl.hostname,
                            description: null,
                            image: null,
                            site_name: parsedUrl.hostname,
                            domain: parsedUrl.hostname
                        }
                    });
                    return;
                }

                let imageUrl = ogImage;
                if (imageUrl && !imageUrl.startsWith('http')) {
                    try { imageUrl = new URL(imageUrl, targetUrl).href; } catch(e) { imageUrl = null; }
                }

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        url: targetUrl,
                        title: ogTitle ? ogTitle.substring(0, 200) : null,
                        description: ogDesc ? ogDesc.substring(0, 300) : null,
                        image: imageUrl || null,
                        site_name: ogSiteName || parsedUrl.hostname,
                        domain: parsedUrl.hostname
                    }
                });
                return;
            } catch (error) {
                log('error', '[LINK-PREVIEW] Fetch error: ' + error.message);
                sendResponse(res, 200, { success: true, data: null });
                return;
            }
        }

        if (pathname === '/docs' || path === '/api/docs') {
            sendSuccess(res, {
                title: 'La Tanda Complete Mobile API Documentation',
                version: '4.11.0',
                description: 'Complete API for La Tanda mobile ecosystem (140+ endpoints)',
                endpoints: {
                    core_system: 4,
                    user_journey: 3,
                    registration_bot: 9,
                    payment_bot: 9,
                    verification_bot: 8,
                    notification_bot: 6,
                    business_intelligence: 8,
                    mobile_app_specific: 6,
                    user_authentication: 4,
                    push_notifications: 2,
                    offline_sync: 3,
                    mia_assistant: 5,
                    total: 85
                },
                mobile_features: [
                    'Real-time push notifications',
                    'Offline data synchronization',
                    'MIA AI assistant integration',
                    'Mobile-optimized user flows',
                    'Cross-platform compatibility'
                ],
                integration_status: 'complete'
            });
            return;
        }

        // 4. Complete system status

        // Serve OpenAPI documentation (Added 2025-12-22)
        if (pathname === "/api/docs/openapi.yaml" && (method === "GET" || method === "HEAD")) {
            try {
                const yamlContent = fs.readFileSync(path.join(__dirname, "openapi.yaml"), "utf8");
                res.writeHead(200, {
                    "Content-Type": "text/yaml",
                    "Access-Control-Allow-Origin": "https://latanda.online",
                    "Cache-Control": "public, max-age=3600"
                });
                res.end(yamlContent);
                return;
            } catch (err) {
                sendError(res, 404, "OpenAPI spec not found");
                return;
            }
        }

        if (pathname === '/api/system/status' && (method === 'GET' || method === 'HEAD')) {
            sendSuccess(res, {
                system: 'healthy',
                endpoints: 140,
                database: 'connected',
                mobile_services: {
                    push_notifications: 'active',
                    offline_sync: 'active',
                    mia_assistant: 'active',
                    real_time_updates: 'active'
                },
                performance: {
                    avg_response_time: '150ms',
                    requests_per_minute: 45,
                    error_rate: '0.1%'
                }
            });
            return;
        }

        // ===== MOBILE APP SPECIFIC ENDPOINTS (6) =====

        // 1. App initialization
        if (pathname === '/api/mobile/init' && method === 'POST') {
            const { user_id, device_info, app_version } = body;
            
            // user mutation removed — requires auth to modify user records

            sendSuccess(res, {
                welcome_message: '¡Bienvenido a La Tanda Ecosystem!',
                // SECURITY: user_profile removed - requires auth
                app_config: {
                    features_enabled: ['groups', 'payments', 'mia_assistant', 'notifications'],
                    api_endpoints: 140,
                    theme_options: ['light', 'dark'],
                    supported_languages: ['es']
                },
                initial_data: {
                    active_groups_count: database.groups.filter(g => g.status === 'active').length,
                    // SECURITY: notifications removed - requires auth
                    notification_count: 0
                }
            });
            return;
        }

        // 2. App settings management
                if (pathname === '/api/mobile/settings' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }

            const { settings } = body;
            const user_id = authUser.userId;
            
            // ============================================
            // DUAL-WRITE: PostgreSQL (Primary) + JSON (Backup)
            // Week 3 Day 2: User Settings Update
            // ============================================
            
            let pgWriteSuccess = false;
            let updatedUser = null;
            
            // Find user in JSON (for response)
            const user = database.users.find(u => u.id === user_id);
            if (!user) { // Usuario no encontrado - devolver balance 0 en lugar de error
                sendError(res, 404, 'User not found');
                return;
            }
            
            // Merge new settings
            const newSettings = { ...user.app_settings, ...settings };
            
            try {
                // PRIMARY WRITE: PostgreSQL
                const pgUpdateData = {
                    app_settings: newSettings
                };
                
                updatedUser = await db.updateUser(user_id, pgUpdateData);
                pgWriteSuccess = true;
                log('info', `✅ [DUAL-WRITE] User settings updated in PostgreSQL: ${user_id}`);
                
            } catch (pgError) {
                log('error', `❌ [DUAL-WRITE] PostgreSQL update failed for user settings: ${pgError.message}`, { user_id, error: pgError });
                // Continue to JSON write (graceful degradation)
            }
            
            // BACKUP WRITE: JSON (only if group exists in JSON)
            user.app_settings = newSettings;
            saveDatabase();  // CRITICAL: Save JSON to disk
            log('info', `✅ [DUAL-WRITE] User settings updated in JSON: ${user_id}`, { pgWriteSuccess });

            sendSuccess(res, {
                message: 'Configuración guardada exitosamente',
                settings: newSettings,
                sync_status: 'updated'
            });
            return;
        }


        // 3. User session tracking
        if (pathname === '/api/mobile/session/start' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }

            const { device_info } = body;
            const user_id = authUser.userId;
            
            const sessionId = generateId('session');
            const session = {
                id: sessionId,
                user_id,
                start_time: new Date().toISOString(),
                device_info,
                screens_visited: [],
                actions_performed: 0
            };
            
            database.app_sessions.push(session);
            // v4.2.0: Cap app_sessions to prevent unbounded growth
            if (database.app_sessions.length > 1000) {
                database.app_sessions = database.app_sessions.slice(-500);
            }
            sendSuccess(res, { session_id: sessionId, message: 'Sesión iniciada' });
            return;
        }

        // 4. User session end
        if (pathname === '/api/mobile/session/end' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticación requerida");
                return;
            }

            const { session_id, screens_visited, actions_performed } = body;
            
            const session = database.app_sessions.find(s => s.id === session_id);
            if (session) {
                session.end_time = new Date().toISOString();
                session.duration = new Date() - new Date(session.start_time);
                session.screens_visited = screens_visited;
                session.actions_performed = actions_performed;
            }

            sendSuccess(res, { message: 'Sesión finalizada', session_duration: session?.duration });
            return;
        }

        // 5. App feedback
        if (pathname === '/api/mobile/feedback' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticación requerida");
                return;
            }

            const { user_id, rating, feedback_text, screen, feature } = body;
            
            const feedbackId = generateId('feedback');
            const feedback = {
                id: feedbackId,
                user_id,
                rating,
                feedback_text,
                screen,
                feature,
                submitted_at: new Date().toISOString(),
                status: 'received'
            };

            sendSuccess(res, {
                message: 'Gracias por tu feedback',
                feedback_id: feedbackId,
                status: 'received'
            });
            return;
        }

        // 6. App analytics
        if (pathname === '/api/mobile/analytics' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const { user_id, event_type, event_data } = body;
            
            sendSuccess(res, {
                message: 'Analytics data recorded',
                event_id: generateId('event'),
                processed_at: new Date().toISOString()
            });
            return;
        }

        // ===== USER AUTHENTICATION ENDPOINTS (4) =====

        // 1. User login
        if (pathname === '/api/auth/login' && method === 'POST') {
            // Check for JSON parse error (special characters in password)
            if (body._parseError) {
                log("error", "[LOGIN] JSON parse error:", body._parseMessage);
                sendError(res, 400, "Error al procesar la solicitud. Verifica que tu contraseña no contenga caracteres que rompan el formato JSON.");
                return;
            }
            const { email, password, device_info } = body;
            
            // ============================================
            // INPUT VALIDATION
            // ============================================
            if (!email || !password) {
                sendError(res, 400, 'Email y contraseña son requeridos');
                return;
            }
            
            // ============================================
            // FIND USER BY EMAIL (PostgreSQL)
            // ============================================
            let user;
            try {
                user = await db.getUserByEmail(email);
            } catch (dbError) {
                log('error', 'Error fetching user for login', { email, error: dbError.message });
                sendError(res, 500, 'Error interno del servidor');
                return;
            }
            
            if (!user) {
                const clientInfo1 = getClientInfo(req);
                auditLog("LOGIN_FAILED", {
                    userEmail: email,
                    resource: "auth",
                    ip: clientInfo1.ip,
                    userAgent: clientInfo1.userAgent,
                    status: "failure",
                    error: "User not found"
                });
                // User not found - generic error for security
                sendError(res, 401, 'Credenciales inválidas');
                return;
            }
            
            // ============================================
            // CHECK IF USER HAS PASSWORD SET
            // ============================================
            if (!user.password_hash) {
                // User exists but has no password (legacy user)
                sendError(res, 403, 'Debes restablecer tu contraseña. Usa la opción Olvidé mi contraseña.', {
                    code: 'PASSWORD_RESET_REQUIRED',
                    email: email
                });
                return;
            }
            
            // ============================================
            // VERIFY PASSWORD
            // ============================================
            let validPassword;
            try {
                validPassword = await bcrypt.compare(password, user.password_hash);
            } catch (compareError) {
                log('error', 'Error comparing passwords', { email, error: compareError.message });
                sendError(res, 500, 'Error al verificar credenciales');
                return;
            }
            
            if (!validPassword) {
                sendError(res, 401, 'Credenciales inválidas');
                const clientInfo2 = getClientInfo(req);
                auditLog("LOGIN_FAILED", {
                    userId: user.id,
                    userEmail: email,
                    resource: "auth",
                    ip: clientInfo2.ip,
                    userAgent: clientInfo2.userAgent,
                    status: "failure",
                    error: "Invalid password"
                });
                return;
            }
            
            // ============================================
            // CHECK EMAIL VERIFICATION
            // ============================================
            if (!user.email_verified) {
                sendError(res, 403, 'Debes verificar tu correo electrónico antes de iniciar sesión', {
                    code: 'EMAIL_NOT_VERIFIED',
                    email: email
                });
                return;
            }
            
            // ============================================
            // GENERATE AUTH TOKEN AND RETURN SUCCESS
            // ============================================
            const authToken = generateAuthToken(user);
            const refreshToken = generateRefreshToken(user);
            
            log('info', '✅ User logged in successfully', { userId: user.id, email });
            
            // Audit log
            const clientInfo = getClientInfo(req);
            auditLog('LOGIN_SUCCESS', {
                userId: user.id,
                userEmail: email,
                resource: 'auth',
                ip: clientInfo.ip,
                userAgent: clientInfo.userAgent,
                extra: { role: user.role }
            });
            
            sendSuccess(res, {
                message: 'Inicio de sesión exitoso',
                user: {
                    id: user.id,
                    name: user.name,
                    email: user.email,
                    phone: user.phone,
                    verification_level: user.verification_level,
                    avatar_url: user.avatar_url,
                    status: user.status,
                    role: user.role || "user",
                        verification_level: user.verification_level || "basic",
                        email_verified: user.email_verified || false
                },
                auth_token: authToken,
                refresh_token: refreshToken,
                expires_in: 86400 // 24 hours
            });
            return;
        }

        // 2. User registration

        // ============================================
        // DUPLICATE ACCOUNT DETECTION
        // POST /api/auth/check-duplicates
        // ============================================
        if (pathname === "/api/auth/check-duplicates" && method === "POST") {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticacion requerida");
                return;
            }

            const { email, name, phone, exclude_user_id } = body;

            if (!email && !name && !phone) {
                sendError(res, 400, "Se requiere al menos email, nombre o telefono");
                return;
            }

            try {
                const duplicates = await dbPostgres.findSimilarAccounts(email, name, phone, exclude_user_id);

                // Get data summary for each duplicate
                const duplicatesWithData = await Promise.all(duplicates.map(async (acc) => {
                    const dataSummary = await dbPostgres.getAccountDataSummary(acc.id);
                    return { ...acc, ...dataSummary };
                }));

                sendSuccess(res, {
                    has_duplicates: duplicatesWithData.length > 0,
                    count: duplicatesWithData.length,
                    duplicates: duplicatesWithData
                });
            } catch (error) {
                log("error", "check-duplicates failed", { error: error.message });
                sendError(res, 500, "Error al buscar duplicados");
            }
            return;
        }

        // ============================================
        // GET ACCOUNT DATA SUMMARY
        // GET /api/auth/account-data/:userId
        // ============================================
        if (pathname.match(/^\/api\/auth\/account-data\/([^\/]+)$/) && method === "GET") {
            const userId = pathname.split("/").pop();

            // Verify token (user can only see their own data or admin)
            const authHeader = req.headers["authorization"];
            const token = authHeader && authHeader.split(" ")[1];

            if (!token) {
                sendError(res, 401, "Token requerido");
                return;
            }

            try {
                const decoded = jwt.verify(token, process.env.JWT_SECRET, { algorithms: ['HS256'] });
                const isAdmin = decoded.role === "admin";
                const isOwnAccount = decoded.id === userId;

                if (!isAdmin && !isOwnAccount) {
                    sendError(res, 403, "No autorizado");
                    return;
                }

                const dataSummary = await dbPostgres.getAccountDataSummary(userId);
                sendSuccess(res, dataSummary);
            } catch (error) {
                if (error.name === "JsonWebTokenError") {
                    sendError(res, 401, "Token invalido");
                } else {
                    log("error", "account-data failed", { error: error.message });
                    sendError(res, 500, "Error al obtener datos de cuenta");
                }
            }
            return;
        }

        // ============================================
        // DELETE ACCOUNT (SAFE)
        // DELETE /api/auth/delete-account/:userId
        // ============================================
        if (pathname.match(/^\/api\/auth\/delete-account\/([^\/]+)$/) && method === "DELETE") {
            const userId = pathname.split("/").pop();

            // Verify token
            const authHeader = req.headers["authorization"];
            const token = authHeader && authHeader.split(" ")[1];

            if (!token) {
                sendError(res, 401, "Token requerido");
                return;
            }

            try {
                const decoded = jwt.verify(token, process.env.JWT_SECRET, { algorithms: ['HS256'] });
                const isAdmin = decoded.role === "admin";
                const isOwnAccount = decoded.id === userId;

                // Only admin or account owner can delete
                if (!isAdmin && !isOwnAccount) {
                    sendError(res, 403, "No autorizado para eliminar esta cuenta");
                    return;
                }

                // Confirm account exists
                const user = await db.getUserById(userId);
                if (!user) {
                    sendError(res, 404, "Cuenta no encontrada");
                    return;
                }

                await dbPostgres.deleteAccountSafe(userId);

                auditLog("ACCOUNT_DELETED", {
                    deletedUserId: userId,
                    deletedBy: decoded.id,
                    resource: "auth",
                    ip: req.socket.remoteAddress
                });

                sendSuccess(res, { message: "Cuenta eliminada exitosamente" });
            } catch (error) {
                if (error.name === "JsonWebTokenError") {
                    sendError(res, 401, "Token invalido");
                } else {
                    log("error", "delete-account failed", { userId, error: error.message });
                    sendError(res, 500, "Error al eliminar cuenta");
                }
            }
            return;
        }

        // ============================================
        // MERGE ACCOUNTS
        // POST /api/auth/merge-accounts
        // ============================================
        if (pathname === "/api/auth/merge-accounts" && method === "POST") {
            const { target_id, source_id } = body;

            if (!target_id || !source_id) {
                sendError(res, 400, "Se requieren target_id y source_id");
                return;
            }

            // Verify token
            const authHeader = req.headers["authorization"];
            const token = authHeader && authHeader.split(" ")[1];

            if (!token) {
                sendError(res, 401, "Token requerido");
                return;
            }

            try {
                const decoded = jwt.verify(token, process.env.JWT_SECRET, { algorithms: ['HS256'] });
                const isAdmin = decoded.role === "admin";
                const ownsTarget = decoded.id === target_id;
                const ownsSource = decoded.id === source_id;

                // Must own both accounts or be admin
                if (!isAdmin && !(ownsTarget && ownsSource)) {
                    sendError(res, 403, "No autorizado para fusionar estas cuentas");
                    return;
                }

                // Verify both accounts exist
                const targetUser = await db.getUserById(target_id);
                const sourceUser = await db.getUserById(source_id);

                if (!targetUser) {
                    sendError(res, 404, "Cuenta destino no encontrada");
                    return;
                }
                if (!sourceUser) {
                    sendError(res, 404, "Cuenta origen no encontrada");
                    return;
                }

                await dbPostgres.mergeAccounts(target_id, source_id);

                auditLog("ACCOUNTS_MERGED", {
                    targetId: target_id,
                    sourceId: source_id,
                    mergedBy: decoded.id,
                    resource: "auth",
                    ip: req.socket.remoteAddress
                });

                sendSuccess(res, {
                    message: "Cuentas fusionadas exitosamente",
                    kept_account: target_id,
                    deleted_account: source_id
                });
            } catch (error) {
                if (error.name === "JsonWebTokenError") {
                    sendError(res, 401, "Token invalido");
                } else {
                    log("error", "merge-accounts failed", { error: error.message });
                    sendError(res, 500, "Error al fusionar cuentas");
                }
            }
            return;
        }
        if (pathname === '/api/auth/register' && method === 'POST') {
            // Check for JSON parse error (special characters in password)
            if (body._parseError) {
                log("error", "[REGISTER] JSON parse error:", body._parseMessage);
                sendError(res, 400, "Error al procesar la solicitud. Verifica que tu contraseña no contenga caracteres especiales que rompan el formato JSON.");
                return;
            }
            const { name, email, phone, password, device_info, referral_code } = body;
            
            // ============================================
            // INPUT VALIDATION
            // ============================================
            if (!name || !email || !password) {
                sendError(res, 400, 'Nombre, email y contraseña son requeridos');
                return;
            }
            
            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                sendError(res, 400, 'Formato de email inválido');
                return;
            }
            
            // Validate email domain has MX records
            const mxCheck = await verifyEmailDomain(email);
            if (!mxCheck.valid) {
                sendError(res, 400, mxCheck.reason);
                return;
            }
            
            // Validate password strength
            const pwError = validatePassword(password);
            if (pwError) {
                sendError(res, 400, pwError);
                return;
            }
            
            // ============================================
            // CHECK FOR EXISTING USER
            // ============================================
            try {
                const existingUser = await db.getUserByEmail(email);
                if (existingUser) {
                    sendError(res, 409, "No se pudo completar el registro. Verifica tus datos o intenta iniciar sesion");
                    return;
                }
            } catch (checkError) {
                log('error', 'Error checking existing user', { email, error: checkError.message });
            }
            
            // ============================================
            // HASH PASSWORD
            // ============================================
            let password_hash;
            try {
                password_hash = await bcrypt.hash(password, 12);
            } catch (hashError) {
                log('error', 'Error hashing password', { error: hashError.message });
                sendError(res, 500, 'Error al procesar la contraseña');
                return;
            }
            
            const userId = generateId('user');
            const registrationDate = new Date().toISOString();
            
            // ============================================
            // CREATE USER IN POSTGRESQL (PRIMARY)
            // ============================================
            try {
                const pgUserData = {
                    id: userId,
                    name,
                    email: email,
                    phone: phone || null,
                    password_hash: password_hash,
                    verification_level: 'basic',
                    registration_date: registrationDate,
                    status: 'active',
                    total_contributions: 0,
                    avatar_url: '/uploads/avatars/default.jpg',
                    notification_preferences: {
                        payment_reminders: true,
                        group_updates: true,
                        marketing: false,
                        push_enabled: true
                    },
                    app_settings: {
                        theme: 'light',
                        language: 'es',
                        biometric_enabled: false,
                        auto_backup: true
                    }
                };
                
                await db.createUser(pgUserData);
                log('info', '✅ User created in PostgreSQL', { userId, email });
                
            } catch (pgError) {
                // Handle specific PostgreSQL errors
                if (pgError.code === '23505') { // Unique violation
                    sendError(res, 409, "No se pudo completar el registro. Verifica tus datos o intenta iniciar sesion");
                    return;
                }
                log('error', '❌ PostgreSQL write failed', { userId, email, error: pgError.message });
                sendError(res, 500, 'Error al crear la cuenta. Intenta nuevamente.');
                return;
            }
            
            // Create user object for token generation
            const user = { id: userId, email: email, verification_level: 'basic' };

            // Generate auth token
            const authToken = generateAuthToken(user);
            const refreshToken = generateRefreshToken(user);
            
            // Return success (do NOT include password_hash in response)
            
            // Audit log for registration
            const regClientInfo = getClientInfo(req);
            auditLog("USER_REGISTERED", {
                userId: userId,
                userEmail: email,
                resource: "users",
                resourceId: userId,
                ip: regClientInfo.ip,
                userAgent: regClientInfo.userAgent,
                extra: { name: name }
            });

            // ============================================
            // APPLY REFERRAL CODE (if provided)
            // ============================================
            if (referral_code) {
                try {
                    const referrerResult = await dbPostgres.pool.query(
                        'SELECT user_id FROM users WHERE referral_code = $1',
                        [referral_code.toUpperCase()]
                    );

                    if (referrerResult.rows.length > 0) {
                        const referrerId = referrerResult.rows[0].user_id;

                        // Create referral record
                        await dbPostgres.pool.query(`
                            INSERT INTO user_referrals (referrer_id, referral_code, referred_user_id, referred_email, status, registered_at)
                            VALUES ($1, $2, $3, $4, 'registered', NOW())
                        `, [referrerId, referral_code.toUpperCase(), userId, email]);

                        // Update new user's referred_by
                        await dbPostgres.pool.query(
                            'UPDATE users SET referred_by = $1 WHERE user_id = $2',
                            [referrerId, userId]
                        );

                        // Increment referrer's count
                        await dbPostgres.pool.query(
                            'UPDATE users SET referral_count = COALESCE(referral_count, 0) + 1 WHERE user_id = $1',
                            [referrerId]
                        );

                        log('info', '[REFERRAL] Applied successfully', { referral_code, referrer: referrerId, new_user: userId });

                        // Credit LTD tokens for referral rewards
                        // New user gets 50 LTD signup bonus
                        await creditLTDTokens(userId, 50, 'REFERRAL_SIGNUP_BONUS');
                        
                        // Referrer gets 25 LTD reward
                        await creditLTDTokens(referrerId, 25, 'REFERRAL_REWARD');

                        // Update reward amount in referral record
                        await dbPostgres.pool.query(
                            'UPDATE user_referrals SET reward_amount = 25 WHERE referrer_id = $1 AND referred_user_id = $2',
                            [referrerId, userId]
                        );

                        // Audit log
                        auditLog('REFERRAL_APPLIED', {
                            referrer_id: referrerId,
                            new_user_id: userId,
                            referral_code: referral_code,
                            new_user_reward: '50 LTD',
                            referrer_reward: '25 LTD'
                        });
                    } else {
                        log('warn', '[REFERRAL] Invalid code provided', { referral_code });
                    }
                } catch (refError) {
                    log('error', '[REFERRAL] Error applying code', { referral_code, error: refError.message });
                    // Don't fail registration if referral fails
                }
            }

            sendSuccess(res, {
                message: 'Registro exitoso',
                user: {
                    id: userId,
                    name,
                    email,
                    phone: phone || null,
                    verification_level: 'basic',
                    registration_date: registrationDate,
                    status: 'active',
                    avatar_url: '/uploads/avatars/default.jpg'
                },
                auth_token: authToken,
                refresh_token: refreshToken,
                next_step: 'Verificar correo electrónico'
            });
            return;
        }

        // 3. Token refresh

        // ============================================
        // EMAIL VERIFICATION - Send Code
        // ============================================
        if (pathname === "/api/auth/send-verification" && method === "POST") {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticacion requerida");
                return;
            }

            const { user_id, email } = body;
            
            if (!user_id && !email) {
                sendError(res, 400, "Se requiere user_id o email");
                return;
            }
            
            try {
                let user;
                if (user_id) {
                    // Get user by ID from PostgreSQL
                    const pgResult = await dbPostgres.pool.query(
                        "SELECT user_id, email, name FROM users WHERE user_id = $1",
                        [user_id]
                    );
                    user = pgResult.rows[0];
                } else {
                    user = await db.getUserByEmail(email);
                }
                
                if (!user) {
                    sendError(res, 401, "Credenciales inválidas"); // SECURITY: Generic error to prevent user enumeration
                    return;
                }
                
                if (!user.email) {
                    sendError(res, 400, "El usuario no tiene email registrado");
                    return;
                }
                
                // Generate 6-digit code
                const verificationCode = crypto.randomInt(100000, 999999).toString();
                
                // Code expires in 15 minutes
                const expiresAt = new Date(Date.now() + 5 * 60 * 1000);
                
                // Save to database
                await db.setEmailVerificationCode(user.user_id || user.id, verificationCode, expiresAt);
                
                // Log the code (in production, send email)
                // Verification code sent via email (code NOT logged for security)
                
                // Send verification email
                const emailHtml = `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
                        <div style="text-align: center; margin-bottom: 30px;">
                            <h1 style="color: #22d55e;">La Tanda</h1>
                        </div>
                        <h2 style="color: #333;">Código de Verificación</h2>
                        <p>Tu código de verificación es:</p>
                        <div style="background: #f5f5f5; padding: 20px; text-align: center; font-size: 32px; font-weight: bold; letter-spacing: 8px; margin: 20px 0; border-radius: 8px;">
                            ${verificationCode}
                        </div>
                        <p style="color: #666;">Este código expira en 5 minutos.</p>
                        <p style="color: #999; font-size: 12px;">Si no solicitaste este código, ignora este mensaje.</p>
                    </div>
                `;
                await sendEmail(user.email, "Código de Verificación - La Tanda", emailHtml);
                // await notificationUtils.sendEmailNotification(user.email, "Código de verificación - La Tanda", `Tu código es: ${verificationCode}`);
                
                sendSuccess(res, {
                    message: "Código de verificación enviado",
                    email_sent_to: user.email.replace(/(.{2})(.*)(@.*)/, "$1***$3"),
                    expires_in_minutes: 5
                });
                return;
            } catch (error) {
                log("error", "Error sending verification", { error: error.message });
                sendError(res, 500, "Error al enviar código de verificación");
                return;
            }
        }

        // ============================================
        // EMAIL VERIFICATION - Verify Code
        // ============================================
        if (pathname === "/api/auth/verify-email" && method === "POST") {
            const { user_id, email, code } = body;
            
            // Accept either user_id or email
            if ((!user_id && !email) || !code) {
                sendError(res, 400, "Se requiere user_id o email, y código de verificación");
                return;
            }
            
            try {
                let userId = user_id;
                
                // If email provided instead of user_id, look up the user
                if (!userId && email) {
                    const user = await db.getUserByEmail(email);
                    if (!user) {
                        sendError(res, 401, "Credenciales inválidas"); // SECURITY: Generic error to prevent user enumeration
                        return;
                    }
                    userId = user.id;
                }
                
                const result = await db.verifyEmailCode(userId, code);
                
                if (!result.valid) {
                    sendError(res, 400, result.reason);
                    return;
                }
                
                // Get user data to return
                const user = await db.getUserById(userId);
                const authToken = user ? generateAuthToken(user) : null;
                
                sendSuccess(res, {
                    message: "Email verificado exitosamente",
                    email_verified: true,
                    user: user ? {
                        id: user.id,
                        name: user.name,
                        email: user.email,
                        phone: user.phone,
                        verification_level: user.verification_level,
                        avatar_url: user.avatar_url,
                        status: user.status,
                    role: user.role || "user",
                        verification_level: user.verification_level || "basic",
                        email_verified: user.email_verified || false
                    } : null,
                    auth_token: authToken
                });
                return;
            } catch (error) {
                log("error", "Error verifying email:", error);
                sendError(res, 500, "Error al verificar código");
                return;
            }
        }

        // ============================================
        // PASSWORD RESET - Request Reset Link
        // ============================================

        // ============================================
        // PASSWORD RESET - Request Reset Code
        // ============================================
        if (pathname === "/api/auth/request-reset" && method === "POST") {
            const { email } = body;
            
            if (!email) {
                sendError(res, 400, "Email es requerido");
                return;
            }
            
            try {
                const user = await db.getUserByEmail(email);
                
                // Always return success for security (dont reveal if email exists)
                if (!user) {
                    sendSuccess(res, {
                        message: "Si el email existe, recibirás un código para restablecer tu contraseña."
                    });
                    return;
                }
                
                // Generate 6-digit reset code
                const resetCode = crypto.randomInt(100000, 999999).toString();
                const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes
                
                // Save code to database
                await db.setPasswordResetToken(user.id, resetCode, expiresAt);
                
                // Log the code (in production, send email)
                // Reset code sent via email (code NOT logged for security)
                // Send email with reset code
                const resetEmailHtml = `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; border-radius: 10px 10px 0 0;">
                            <h1 style="color: white; margin: 0; text-align: center;">La Tanda</h1>
                            <p style="color: rgba(255,255,255,0.9); text-align: center; margin-top: 10px;">Restablecer Contrasena</p>
                        </div>
                        <div style="background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px;">
                            <p style="color: #333; font-size: 16px;">Has solicitado restablecer tu contrasena.</p>
                            <p style="color: #333; font-size: 16px;">Tu codigo de verificacion es:</p>
                            <div style="background: #667eea; color: white; font-size: 32px; font-weight: bold; padding: 20px; text-align: center; border-radius: 8px; letter-spacing: 8px; margin: 20px 0;">
                                ${resetCode}
                            </div>
                            <p style="color: #666; font-size: 14px;">Este codigo expirara en 5 minutos.</p>
                            <p style="color: #666; font-size: 14px;">Si no solicitaste restablecer tu contrasena, ignora este mensaje.</p>
                            <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;">
                            <p style="color: #999; font-size: 12px; text-align: center;">Este es un correo automatico de La Tanda. No responder.</p>
                        </div>
                    </div>
                `;
                
                const emailResult = await sendEmail(email, "Codigo de Restablecimiento - La Tanda", resetEmailHtml);
                if (emailResult.success) {
                    log("info", "Password reset email sent", { userId: user.id, email, messageId: emailResult.messageId });
                } else {
                    log("warn", "Failed to send password reset email", { userId: user.id, email, error: emailResult.error });
                }
                log("info", "Password reset code generated", { userId: user.id, email });
                
                sendSuccess(res, {
                    message: "Si el email existe, recibirás un código para restablecer tu contraseña.",
                    // DEV ONLY - Remove in production:
                });
                
            } catch (error) {
                log("error", "Error in request-reset", { email, error: error.message });
                sendError(res, 500, "Error al procesar la solicitud");
            }
            return;
        }

        // ============================================
        // PASSWORD RESET - Verify Reset Code
        // ============================================
        if (pathname === "/api/auth/verify-reset-token" && method === "POST") {
            const { email, code } = body;
            
            if (!email || !code) {
                sendError(res, 400, "Email y código son requeridos");
                return;
            }
            
            try {
                // Get user by email
                const user = await db.getUserByEmail(email);
                if (!user) {
                    sendError(res, 400, "Código inválido o expirado");
                    return;
                }
                
                // Verify the reset code
                const resetData = await db.getPasswordResetToken(user.id);
                
                if (!resetData || !safeCompare(resetData.token, String(code))) {
                    sendError(res, 400, "Código inválido o expirado");
                    return;
                }
                
                // Check expiration
                if (new Date() > new Date(resetData.expires_at)) {
                    sendError(res, 400, "El código ha expirado. Solicita uno nuevo.");
                    return;
                }
                
                log("info", "Reset code verified", { userId: user.id, email });
                
                sendSuccess(res, {
                    message: "Código verificado correctamente",
                    verified: true
                });
                
            } catch (error) {
                log("error", "Error in verify-reset-token", { email, error: error.message });
                sendError(res, 500, "Error al verificar código");
            }
            return;
        }

        if (pathname === "/api/auth/reset-password" && method === "POST") {
            const { email, code, new_password } = body;
            
            if (!email || !code || !new_password) {
                sendError(res, 400, "Email, código y nueva contraseña son requeridos");
                return;
            }
            
            const pwError2 = validatePassword(new_password);
            if (pwError2) {
                sendError(res, 400, pwError2);
                return;
            }
            
            try {
                // Find user by email
                const user = await db.getUserByEmail(email);
                
                if (!user) {
                    sendError(res, 400, "Código inválido o expirado");
                    return;
                }
                
                // Verify the reset code
                const resetData = await db.getPasswordResetToken(user.id);
                
                if (!resetData || !safeCompare(resetData.token, String(code))) {
                    sendError(res, 400, "Código inválido o expirado");
                    return;
                }
                
                // Check if code is expired
                if (new Date() > new Date(resetData.expires_at)) {
                    sendError(res, 400, "El código ha expirado. Solicita uno nuevo.");
                    return;
                }
                
                // Hash new password
                const password_hash = await bcrypt.hash(new_password, 12);
                
                // Update password and clear reset token
                await db.updateUserPassword(user.id, password_hash);
                
                log("info", "Password reset successful", { userId: user.id, email: user.email });
                
                sendSuccess(res, {
                    message: "Contraseña actualizada exitosamente. Ya puedes iniciar sesión."
                });
                
            } catch (error) {
                log("error", "Error in reset-password", { error: error.message });
                sendError(res, 500, "Error al restablecer la contraseña");
            }
            return;
        }




        if (pathname === '/api/auth/refresh' && method === 'POST') {
            const { refresh_token } = body;
            
            if (!refresh_token) {
                sendError(res, 400, 'refresh_token requerido');
                return;
            }
            
            const decoded = verifyAuthToken(refresh_token);
            if (!decoded || decoded.type !== 'refresh') {
                sendError(res, 401, 'Refresh token invalido o expirado');
                return;
            }
            
            // Check if refresh token has been revoked
            try {
                const isRevoked = await securityMiddleware.isTokenBlacklisted(refresh_token);
                if (isRevoked) {
                    sendError(res, 401, 'Refresh token ha sido revocado');
                    return;
                }
            } catch (err) { /* blacklist unavailable, continue */ }
            
            try {
                const userResult = await dbPostgres.pool.query(
                    'SELECT user_id, email, role FROM users WHERE user_id = $1',
                    [decoded.userId]
                );
                
                if (userResult.rows.length === 0) {
                    sendError(res, 404, 'Usuario no encontrado');
                    return;
                }
                
                const user = userResult.rows[0];
                const newAuthToken = generateAuthToken(user);
                const newRefreshToken = generateRefreshToken(user);
                
                // Revoke old refresh token (rotation)
                try {
                    await securityMiddleware.blacklistToken(refresh_token, 604800);
                } catch (err) { /* blacklist unavailable, continue */ }
                
                sendSuccess(res, {
                    auth_token: newAuthToken,
                    refresh_token: newRefreshToken,
                    expires_in: 86400,
                    refreshed_at: new Date().toISOString()
                });
            } catch (err) {
                sendError(res, 500, 'Error al refrescar token');
            }
            return;
        }

        // 4. Logout
        if (pathname === '/api/auth/logout' && method === 'POST') {
            const token = extractTokenFromHeader(req) || body.auth_token;
            
            if (token) {
                try {
                    await securityMiddleware.blacklistToken(token, 86400);
                } catch (err) {
                }
            }
            
            sendSuccess(res, {
                message: "Sesión cerrada exitosamente",
                token_invalidated: !!token,
                logged_out_at: new Date().toISOString()
            });
            return;
        }

        // ===== PUSH NOTIFICATIONS ENDPOINTS (4) =====

        // 1. Get VAPID public key (no auth needed — frontend needs it to subscribe)
        if (pathname === '/api/push/vapid-key' && (method === 'GET' || method === 'HEAD')) {
            sendSuccess(res, { publicKey: process.env.VAPID_PUBLIC_KEY || '' });
            return;
        }

        // 2. Subscribe to push notifications
        if (pathname === '/api/push/subscribe' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { endpoint, keys } = body;
            if (!endpoint || !keys || !keys.p256dh || !keys.auth) {
                sendError(res, 400, 'Datos de suscripción incompletos');
                return;
            }

            try {
                await dbPostgres.pool.query(
                    `INSERT INTO push_subscriptions (user_id, endpoint, p256dh, auth, user_agent, created_at)
                     VALUES ($1, $2, $3, $4, $5, NOW())
                     ON CONFLICT (user_id, endpoint)
                     DO UPDATE SET p256dh = $3, auth = $4, user_agent = $5`,
                    [authUser.userId, endpoint, keys.p256dh, keys.auth, req.headers['user-agent'] || '']
                );
                sendSuccess(res, { message: 'Suscripción push registrada' });
            } catch (err) {
                log('error', 'Push subscribe error', { error: err.message });
                sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // 3. Unsubscribe from push notifications
        if (pathname === '/api/push/unsubscribe' && method === 'DELETE') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { endpoint } = body;
            try {
                if (endpoint) {
                    await dbPostgres.pool.query(
                        'DELETE FROM push_subscriptions WHERE user_id = $1 AND endpoint = $2',
                        [authUser.userId, endpoint]
                    );
                } else {
                    // No endpoint = unsubscribe all devices
                    await dbPostgres.pool.query(
                        'DELETE FROM push_subscriptions WHERE user_id = $1',
                        [authUser.userId]
                    );
                }
                sendSuccess(res, { message: 'Suscripción push eliminada' });
            } catch (err) {
                log('error', 'Push unsubscribe error', { error: err.message });
                sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // 4. Send push notification (admin only)
        if (pathname === '/api/push/send' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            if (authUser.role !== 'admin') {
                sendError(res, 403, 'Solo administradores pueden enviar push notifications');
                return;
            }

            const { userId, title, message, url: pushUrl } = body;
            if (!userId || !title) {
                sendError(res, 400, 'userId y title son requeridos');
                return;
            }

            // H3: Validate push URL is same-origin
            const safePushUrl = (typeof pushUrl === 'string' && pushUrl.charAt(0) === '/') ? pushUrl : '/home-dashboard.html';

            try {
                await sendPushToUser(userId, {
                    title,
                    body: message || '',
                    icon: '/img/icons/icon-192x192.png',
                    badge: '/img/icons/badge-72x72.png',
                    url: safePushUrl
                });
                sendSuccess(res, { message: 'Push notification enviada' });
            } catch (err) {
                log('error', 'Admin push send error', { error: err.message });
                sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // ===== OFFLINE SYNC ENDPOINTS (3) =====

        // 1. Sync status
        if (pathname === '/api/sync/status' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }

            const { data_types } = body;
            if (!Array.isArray(data_types)) {
                sendError(res, 400, 'data_types debe ser un array');
                return;
            }
            const user_id = authUser.userId;
            
            const syncStatus = data_types.map(type => ({
                data_type: type,
                last_sync: new Date(Date.now() - crypto.randomInt(0, 3600000)).toISOString(),
                pending_changes: crypto.randomInt(0, 10) > 7,
                conflict_resolution: 'server_wins'
            }));

            sendSuccess(res, {
                user_id,
                sync_status: syncStatus,
                next_sync_window: '2025-07-24T20:00:00Z'
            });
            return;
        }

        // 2. Upload offline changes
        if (pathname === '/api/sync/upload' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }

            const { changes, last_sync_timestamp } = body;
            if (!Array.isArray(changes)) {
                sendError(res, 400, 'changes debe ser un array');
                return;
            }
            const user_id = authUser.userId;
            
            const conflicts = changes.filter(() => crypto.randomInt(0, 10) > 9);
            const accepted = changes.filter(c => !conflicts.includes(c));

            sendSuccess(res, {
                message: 'Cambios sincronizados',
                accepted_changes: accepted.length,
                conflicts: conflicts.length,
                conflict_details: conflicts,
                new_sync_timestamp: new Date().toISOString()
            });
            return;
        }

        // 3. Download server changes
        if (pathname === '/api/sync/download' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }

            const { last_sync_timestamp } = body;
            const user_id = authUser.userId;
            
            const serverChanges = [
                {
                    data_type: 'user_profile',
                    action: 'update',
                    data: { verification_level: 'intermediate' },
                    timestamp: new Date().toISOString()
                }
            ];

            sendSuccess(res, {
                changes: serverChanges,
                total_changes: serverChanges.length,
                sync_timestamp: new Date().toISOString()
            });
            return;
        }

        // ===== ORIGINAL 73 ENDPOINTS (Groups, Payments, Verification, etc.) =====
        // [Previous endpoints from the 73-endpoint file would continue here...]
        
        // Groups management with PostgreSQL
        if (pathname === '/api/groups' && (method === 'GET' || method === 'HEAD')) {
            // SECURITY: Sanitize group data to remove admin_id (added 2025-12-14)
            const sanitizeGroup = (g) => ({
                id: g.id,
                name: g.name,
                description: g.description,
                status: g.status,
                group_type: g.group_type,
                contribution_amount: g.contribution_amount,
                frequency: g.frequency,
                max_members: g.max_members,
                current_members: g.current_members,
                created_at: g.created_at,
                next_collection_date: g.next_collection_date,
                start_date: g.start_date
                // SECURITY: admin_id intentionally omitted
            });

            try {
                // Check for user_id filter to only show groups where user is active member
                const authUser = getAuthenticatedUser(req, parsedUrl.query); const userId = authUser?.userId || null;
                let activeGroups;
                
                if (userId) {
                    // Fetch only groups where user is an active member
                    const result = await dbPostgres.pool.query(`
                        SELECT g.group_id as id, g.name, g.description, g.status, g.category as group_type,
                               g.contribution_amount, g.frequency, g.max_members, g.member_count as current_members,
                               g.created_at, g.start_date, g.start_date as next_collection_date
                        FROM groups g
                        INNER JOIN group_members gm ON g.group_id = gm.group_id
                        WHERE gm.user_id = $1 AND gm.status IN ('active', 'suspended') AND g.status = 'active'
                    `, [userId]);
                    activeGroups = result.rows.map(sanitizeGroup);
                    log("info", `GET /api/groups?user_id=${userId}: ${activeGroups.length} groups for user`);
                } else {
                    // Fetch all active groups
                    const allGroups = await db.getGroups();
                    activeGroups = allGroups.filter(g => g.status === 'active').map(sanitizeGroup);
                    log("info", `GET /api/groups: ${activeGroups.length} active groups from PostgreSQL`);
                }
                sendSuccess(res, activeGroups, {
                    total: activeGroups.length,
                    source: "postgresql"
                });
            } catch (error) {
                // Fallback to JSON database if PostgreSQL fails
                log("error", `PostgreSQL error in GET /api/groups: ${error.message}`);
                const activeGroups = database.groups.filter(g => g.status === 'active').map(sanitizeGroup);
                log("warn", "Falling back to JSON database for GET /api/groups");
                sendSuccess(res, activeGroups, {
                    total: activeGroups.length,
                    source: "json_fallback"
                });
            }
            return;
        }


        // POST /api/groups - Create new group
        if (pathname === '/api/groups' && method === 'POST') {
            try {
            // REQUIRE JWT authentication for group creation
            const authUser = requireAuth(req, res);
            if (!authUser) return;
                log("info", `POST /api/groups: Creating new group "${body.name}"`);

                // Validate required fields (v4.1.0: removed createdBy — always use authUser.userId)
                if (!body.name || !body.type) {
                    sendError(res, 400, "Missing required fields: name, type");
                                    return;
                }


                // ============================================
                // VALIDATION: Input sanitization and limits (Added 2025-12-31)
                // ============================================

                // Sanitize name (prevent XSS)
                const sanitizedName = body.name.replace(/<[^>]*>/g, '').trim();
                if (sanitizedName.length < 3 || sanitizedName.length > 100) {
                    sendError(res, 400, "El nombre del grupo debe tener entre 3 y 100 caracteres");
                    return;
                }
                body.name = sanitizedName;

                // Sanitize description
                if (body.description) {
                    body.description = body.description.replace(/<[^>]*>/g, '').trim().substring(0, 500);
                }

                // Validate contribution amount
                const contributionAmount = parseFloat(body.contributionAmount || 0);
                if (isNaN(contributionAmount) || contributionAmount < 0 || contributionAmount > 100000) {
                    sendError(res, 400, "El monto de contribución debe estar entre 0 y 100,000");
                    return;
                }

                // Validate max members
                const maxMembers = parseInt(body.maxMembers || 12);
                if (isNaN(maxMembers) || maxMembers < 2 || maxMembers > 50) {
                    sendError(res, 400, "El número máximo de miembros debe estar entre 2 y 50");
                    return;
                }

                // Validate type
                const validTypes = ['tanda', 'savings', 'investment', 'lottery', 'community'];
                if (!validTypes.includes(body.type)) {
                    sendError(res, 400, "Tipo inválido. Opciones: " + validTypes.join(', '));
                    return;
                }

                // Validate privacy
                if (body.privacy) {
                    const validPrivacy = ['public', 'private', 'invite_only'];
                    if (!validPrivacy.includes(body.privacy)) {
                        sendError(res, 400, "Privacidad inválida. Opciones: " + validPrivacy.join(', '));
                        return;
                    }
                }

                // Validate startDate if provided
                if (body.startDate) {
                    const startDate = new Date(body.startDate);
                    if (isNaN(startDate.getTime())) {
                        sendError(res, 400, "Fecha de inicio inválida");
                        return;
                    }
                }

                // Validate frequency
                const validFrequencies = ['daily', 'weekly', 'biweekly', 'monthly', 'quarterly'];
                if (body.frequency && !validFrequencies.includes(body.frequency)) {
                    sendError(res, 400, "Frecuencia inválida. Opciones: " + validFrequencies.join(', '));
                    return;
                }

                // Rate limit: Check how many groups this user has created
                try {
                    const userGroupsResult = await dbPostgres.pool.query(`
                        SELECT COUNT(*) as count FROM groups
                        WHERE admin_id = $1 AND status != 'deleted'
                    `, [authUser.userId]);

                    const userGroupCount = parseInt(userGroupsResult.rows[0].count);
                    const MAX_GROUPS_PER_USER = 10;

                    if (userGroupCount >= MAX_GROUPS_PER_USER) {
                        sendError(res, 400, `Has alcanzado el límite de ${MAX_GROUPS_PER_USER} grupos. Elimina un grupo existente para crear uno nuevo.`);
                        return;
                    }
                } catch (limitError) {
                    log('warn', 'Could not check group limit: ' + limitError.message);
                    // Continue anyway
                }

                // v4.1.0: IDOR fix — always use authUser.userId, never body.createdBy
                const resolvedAdminId = authUser.userId;

                // v4.10.4: Validate optional commission_rate
                let commissionRateValue = null;
                if (body.commissionRate !== undefined && body.commissionRate !== null) {
                    const parsedRate = parseFloat(body.commissionRate);
                    if (isNaN(parsedRate) || !Number.isFinite(parsedRate) || parsedRate < 0 || parsedRate > 5) {
                        sendError(res, 400, "La comision debe ser entre 0% y 5%");
                        return;
                    }
                    commissionRateValue = Math.round(parsedRate * 100) / 100; // 2 decimal precision
                }

                // Generate group ID
                const groupId = body.id || 'group_' + Date.now();

                // Validate rules array (v3.97.0 - H1)
                let rules = [];
                if (Array.isArray(body.rules)) {
                    rules = body.rules.slice(0, 50).filter(r => typeof r === 'string').map(r => r.slice(0, 500));
                }
                // Validate coordinators array (v3.97.0 - H1)
                let coordinators = [];
                if (Array.isArray(body.coordinators)) {
                    coordinators = body.coordinators.slice(0, 10).filter(c => typeof c === 'string');
                }

                // Create new group object
                const newGroup = {
                    id: groupId,
                    name: body.name,
                    description: body.description || "",
                    type: body.type,
                    maxMembers: body.maxMembers || 12,
                    currentMembers: 1,
                    contributionAmount: body.contributionAmount || 0,
                    frequency: body.frequency || "monthly",
                    paymentMethod: body.paymentMethod || "bank_transfer",
                    startDate: body.startDate || new Date().toISOString(),
                    endDate: body.endDate || null,
                    status: body.status || "recruiting",
                    privacy: body.privacy || "public",
                    autoAssignPositions: body.autoAssignPositions !== undefined ? body.autoAssignPositions : true,
                    requireApproval: body.requireApproval !== undefined ? body.requireApproval : false,
                    latePaymentPenalty: body.latePaymentPenalty || 0,
                    rules: rules,
                    admin_id: resolvedAdminId,
                    coordinators: coordinators,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                    members: [{
                        userId: authUser.userId,
                        name: body.creatorName || "Admin",
                        role: "admin",
                        joinedAt: Date.now(),
                        status: "active"
                    }]
                };

                // ============================================
                // DUAL-WRITE: PostgreSQL (Primary) + JSON (Backup)
                // ============================================
                
                let pgWriteSuccess = false;
                
                try {
                    // PRIMARY WRITE: PostgreSQL
                    const pgGroupData = {
                        id: groupId,
                        name: body.name,
                        contribution_amount: parseFloat(body.contributionAmount || 0),
                        frequency: body.frequency || 'monthly',
                        max_members: parseInt(body.maxMembers || 12),
                        admin_id: resolvedAdminId,
                        status: 'active',
                        created_at: newGroup.created_at,
                        member_count: 1,
                        total_amount_collected: 0,
                        description: body.description || "",
                        location: 'Honduras',
                        category: body.type || 'general',
                        commission_rate: commissionRateValue
                    };

                    await db.createGroup(pgGroupData);
                    pgWriteSuccess = true;
                    log('info', `✅ [DUAL-WRITE] Group created in PostgreSQL: ${groupId}`);

                // Add creator as member in PostgreSQL
                try {
                    await db.addGroupMember({
                        group_id: groupId,
                        user_id: resolvedAdminId,
                        role: "creator",
                        status: "active",
                        invited_by: resolvedAdminId,
                        notes: "Creador del grupo"
                    });
                    log("info", "Creator added as member in PostgreSQL: " + coordinator_id);

                // ✅ AUTO-CREATE TANDA for the new group
                try {
                    const tandaId = "tanda_" + crypto.randomBytes(12).toString("hex");
                    const tandaData = {
                        tanda_id: tandaId,
                        name: "Tanda - " + (body.name || newGroup.name),
                        contribution_amount: parseFloat(body.contributionAmount || body.contribution_amount || 100),
                        total_per_turn: parseFloat(body.contributionAmount || body.contribution_amount || 100) * parseInt(body.maxMembers || body.max_members || 10),
                        frequency: body.frequency || "monthly",
                        coordinator_id: resolvedAdminId,
                        group_id: groupId,
                        status: "recruiting",
                        current_turn: 0,
                        total_turns: parseInt(body.maxMembers || body.max_members || 10),
                        turns_order: [resolvedAdminId],
                        is_demo: false
                    };
                    await dbPostgres.createTanda(tandaData);
                    log("info", "✅ Tanda auto-creada para grupo: " + tandaId + " (group: " + groupId + ")");
                } catch (tandaError) {
                    log("warn", "⚠️ Error creando tanda automática: " + tandaError.message);
                }
                } catch (memberError) {
                    log("warn", "Failed to add creator as member: " + memberError.message);
                }

                    
                } catch (pgError) {
                    log('error', `❌ [DUAL-WRITE] PostgreSQL write failed for group: ${pgError.message}`, { groupId, error: pgError });
                    // Continue to JSON write (graceful degradation)
                }
                
                // BACKUP WRITE: JSON (disabled for migrated collections)
                // Skip JSON write for groups (fully migrated to PostgreSQL)
                // database.groups.push(newGroup);

                // Skip JSON write for groupMembers (fully migrated to PostgreSQL)
                // if (database.groupMembers) {
                //     database.groupMembers.push({
                        id: 'member_' + Date.now(),
                //                         group_id: groupId,
                //                         user_id: body.createdBy,
                //                         role: 'creator',
                //                         position: body.preferredPosition || null,
                //                         joined_at: new Date().toISOString(),
                //                         status: 'active'
                //                     });
                //                 }

                // Save to database file
                saveDatabase();

                log("info", `Group created successfully: ${groupId}`);
                const grpCI = getClientInfo(req); auditLog("GROUP_CREATED", { userId: newGroup.creator_id, resource: "groups", resourceId: groupId, ip: grpCI.ip, userAgent: grpCI.userAgent, extra: { name: newGroup.name } });
                // SOCIAL FEED: Insert group_created event
                insertSocialEvent({
                    event_type: "group_created",
                    actor_id: resolvedAdminId,
                    actor_name: body.creatorName || authUser?.name || "Usuario",
                    title: body.name,
                    description: body.description || null,
                    action_url: "groups-advanced-system.html?group=" + groupId,
                    metadata: { group_id: groupId, type: body.type, frequency: body.frequency }
                });
                sendSuccess(res, newGroup, {
                    message: "Group created successfully",
                    groupId: groupId
                });
            } catch (error) {
                log("error", `Error creating group: ${error.message}`);
                log("error", "Error creating group", { error: error.message }); sendError(res, 500, "Error al crear grupo");
            }
            return;
        }

        // ===== MY GROUPS ENHANCED ENDPOINT =====

        // GET /api/groups/my-groups - Enhanced endpoint with role, payment status, and alerts

        // NEW: Simple PostgreSQL-only endpoint for my groups
        // NEW: Public groups endpoint for Matching tab (PostgreSQL)

        // NEW: Join group using PostgreSQL

        // GET: User's pending group join requests
        if (pathname === "/api/groups/my-pending-requests" && method === "GET") {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const userId = authUser.userId;

            log("info", `Fetching pending requests for user ${userId}`);

            try {
                const result = await dbPostgres.pool.query(`
                    SELECT
                        gm.group_id,
                        gm.status,
                        gm.joined_at as requested_at,
                        gm.display_name,
                        g.name as group_name,
                        g.contribution_amount,
                        g.frequency,
                        g.member_count,
                        g.max_members,
                        g.location,
                        u.name as admin_name
                    FROM group_members gm
                    JOIN groups g ON gm.group_id = g.group_id
                    LEFT JOIN users u ON g.admin_id = u.user_id
                    WHERE gm.user_id = $1 AND gm.status = 'pending'
                    ORDER BY gm.joined_at DESC
                `, [userId]);

                sendSuccess(res, {
                    requests: result.rows,
                    total: result.rows.length
                });

            } catch (err) {
                log("error", `Error fetching pending requests: ${err.message}`);
                log("error", "Error al obtener solicitudes", { error: err.message }); sendError(res, 500, "Error interno del servidor");
            }
            return;
        }

        if (pathname.startsWith("/api/groups/") && pathname.endsWith("/join-pg") && method === "POST") {
            // ============================================
            // SECURITY: Require JWT authentication (Added 2025-12-31)
            // ============================================
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const groupId = pathname.split("/")[3];
            const { user_name } = body;

            // Use authenticated user's ID (ignore body.user_id to prevent impersonation)
            const user_id = authUser.userId;

            log("info", `[PostgreSQL] User joining group: ${groupId}`, { user_id, user_name, authenticated: true });

            try {
                // 1. Verify group exists and has space (v4.10.4: include commission_rate)
                const groupResult = await dbPostgres.pool.query(
                    "SELECT group_id, name, member_count, max_members, status, commission_rate, contribution_amount, frequency FROM groups WHERE group_id = $1",
                    [groupId]
                );

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                const group = groupResult.rows[0];

                if (group.status !== "active") {
                    sendError(res, 400, "El grupo no está activo");
                    return;
                }

                if (group.member_count >= group.max_members) {
                    sendError(res, 400, "El grupo está lleno");
                    return;
                }


                // ============================================
                // DISABLED:                 // VALIDATION: Check if tanda has started (Added 2025-12-31)
                // DISABLED:                 // ============================================
                // DISABLED:                 const tandaStatusCheck = await dbPostgres.pool.query(`
                // DISABLED:                     SELECT tanda_id, status, lottery_executed_at, current_turn
                // DISABLED:                     FROM tandas WHERE group_id = $1
                // DISABLED:                     ORDER BY created_at DESC LIMIT 1
                // DISABLED:                 `, [groupId]);
                // DISABLED: 
                // DISABLED:                 if (tandaStatusCheck.rows.length > 0) {
                // DISABLED:                     const tanda = tandaStatusCheck.rows[0];
                // DISABLED:                     if (tanda.lottery_executed_at) {
                // DISABLED:                         sendError(res, 400, "No puedes unirte a este grupo porque la tanda ya ha iniciado. Los turnos ya fueron asignados.");
                // DISABLED:                         return;
                // DISABLED:                     }
                // DISABLED:                 }
                // DISABLED: 
                // 2. Check if user already member
                const existingMember = await dbPostgres.pool.query(
                    "SELECT id, status FROM group_members WHERE group_id = $1 AND user_id = $2",
                    [groupId, user_id]
                );

                if (existingMember.rows.length > 0) {
                    const member = existingMember.rows[0];
                    if (member.status === "active") {
                        sendError(res, 400, "Ya eres miembro de este grupo");
                        return;
                    } else if (member.status === "pending") {
                        sendError(res, 400, "Ya tienes una solicitud pendiente para este grupo");
                        return;
                    } else if (member.status === "left") {
                        // Re-activate membership for users who voluntarily left
                        await dbPostgres.pool.query(
                            "UPDATE group_members SET status = 'pending', left_at = NULL, updated_at = NOW() WHERE group_id = $1 AND user_id = $2",
                            [groupId, user_id]
                        );
                        log("info", `User ${user_id} re-requested to join group ${groupId} (previously left)`);
                        sendSuccess(res, {
                            message: "Solicitud enviada. El administrador revisará tu solicitud.",
                            group_id: groupId,
                            status: "pending"
                        });
                        return;
                    } else if (member.status === "removed") {
                        // User was removed by admin - check if they have a valid invitation
                        if (body.invited_by || body.invitation_token) {
                            // Has invitation - allow to rejoin as pending
                            await dbPostgres.pool.query(
                                "UPDATE group_members SET status = 'pending', removed_at = NULL, removed_by = NULL, removal_reason = NULL, updated_at = NOW() WHERE group_id = $1 AND user_id = $2",
                                [groupId, user_id]
                            );
                            log("info", `User ${user_id} re-invited to group ${groupId} (was removed)`);
                            sendSuccess(res, {
                                message: "Invitación aceptada. El administrador revisará tu solicitud.",
                                group_id: groupId,
                                status: "pending"
                            });
                            return;
                        }
                        sendError(res, 403, "Fuiste removido de este grupo por el administrador. Solo puedes volver a unirte mediante una invitación directa.");
                        return;
                    } else if (member.status === "rejected") {
                        // User's request was previously rejected - check if they have a valid invitation
                        if (body.invited_by || body.invitation_token) {
                            // Has invitation - allow to rejoin as pending
                            await dbPostgres.pool.query(
                                "UPDATE group_members SET status = 'pending', rejected_at = NULL, rejected_by = NULL, rejection_reason = NULL, updated_at = NOW() WHERE group_id = $1 AND user_id = $2",
                                [groupId, user_id]
                            );
                            log("info", `User ${user_id} re-invited to group ${groupId} (was rejected)`);
                            sendSuccess(res, {
                                message: "Invitación aceptada. El administrador revisará tu solicitud.",
                                group_id: groupId,
                                status: "pending"
                            });
                            return;
                        }
                        sendError(res, 403, "Tu solicitud anterior fue rechazada. Solo puedes unirte mediante una invitación directa del administrador.");
                        return;
                    }
                }

                // 3. Get user info
                const userResult = await dbPostgres.pool.query(
                    "SELECT user_id, name, email_verified, verification_level FROM users WHERE user_id = $1",
                    [user_id]
                );

                const displayName = userResult.rows.length > 0 ? userResult.rows[0].name : (user_name || "Usuario");
                const invitedBy = body.invited_by || null;

                // 4. Check auto-approval eligibility
                const approvalCheck = await checkAutoApproval(user_id, groupId, invitedBy);
                log('info', 'Auto-approval check result', { user_id, groupId, result: approvalCheck });

                if (approvalCheck.autoApprove) {
                    // AUTO-APPROVE: Add as active member (v4.10.4: include commission_accepted)
                    const joinCommAccepted = body.commission_accepted === true ? true : (body.commission_accepted === false ? false : null);
                    await dbPostgres.pool.query(
                        `INSERT INTO group_members (group_id, user_id, role, status, display_name, joined_at, approved_by, approved_at, commission_accepted)
                         VALUES ($1, $2, 'member', 'active', $3, NOW(), 'system_auto', NOW(), $4)`,
                        [groupId, user_id, displayName, joinCommAccepted]
                    );

                    // Update member count
                    await dbPostgres.pool.query(
                        'UPDATE groups SET member_count = member_count + 1 WHERE group_id = $1',
                        [groupId]
                    );

                    // Notify user of auto-approval
                    await createNotification(
                        user_id,
                        'group_joined',
                        '¡Bienvenido al grupo!',
                        `Tu solicitud para unirte a "${group.name}" fue aprobada automaticamente.`,
                        { group_id: groupId, reason: approvalCheck.reason }
                    );

                    // Notify admins (informational)
                    await notifyGroupAdmins(
                        groupId,
                        'member_auto_approved',
                        'Nuevo miembro (auto-aprobado)',
                        `${displayName} se unio al grupo automaticamente (${approvalCheck.reason}).`,
                        { group_id: groupId, user_id: user_id, user_name: displayName, reason: approvalCheck.reason }
                    );

                    log('info', `User ${user_id} auto-approved to join group ${groupId} (reason: ${approvalCheck.reason})`);

                    sendSuccess(res, {
                        message: "¡Te has unido al grupo exitosamente!",
                        group_id: groupId,
                        group_name: group.name,
                        status: "active",
                        auto_approved: true,
                        reason: approvalCheck.reason,
                        commission_rate: group.commission_rate !== null ? parseFloat(group.commission_rate) : null,
                        commission_accepted: joinCommAccepted
                    });

                } else {
                    // MANUAL APPROVAL: Add as pending member (v4.10.4: include commission_accepted)
                    const pendingCommAccepted = body.commission_accepted === true ? true : (body.commission_accepted === false ? false : null);
                    await dbPostgres.pool.query(
                        `INSERT INTO group_members (group_id, user_id, role, status, display_name, joined_at, invited_by, commission_accepted)
                         VALUES ($1, $2, 'member', 'pending', $3, NOW(), $4, $5)`,
                        [groupId, user_id, displayName, invitedBy, pendingCommAccepted]
                    );

                    // Notify group admins of pending request
                    await notifyGroupAdmins(
                        groupId,
                        'member_request_pending',
                        '📋 Nueva solicitud de ingreso',
                        `${displayName} quiere unirse al grupo "${group.name}". Revisa las solicitudes pendientes.`,
                        { group_id: groupId, user_id: user_id, user_name: displayName }
                    );

                    log('info', `User ${user_id} requested to join group ${groupId} (pending approval)`);

                    sendSuccess(res, {
                        message: "Solicitud enviada. El administrador del grupo revisara tu solicitud.",
                        group_id: groupId,
                        group_name: group.name,
                        status: "pending",
                        auto_approved: false,
                        commission_rate: group.commission_rate !== null ? parseFloat(group.commission_rate) : null,
                        commission_accepted: pendingCommAccepted
                    });
                }
            } catch (err) {
                log("error", `Error joining group: ${err.message}`);
                log("error", "Error al procesar solicitud", { error: err.message }); sendError(res, 500, "Error interno del servidor");
            }
            return;
        }

        if (pathname === "/api/groups/public-pg" && method === "GET") {
            // JWT auth with fallback to query param
            const authUser = getAuthenticatedUser(req, query);
            const userId = authUser?.userId || null;
            log("info", "Fetching public groups from PostgreSQL", { excludeUserId: userId });
            
            try {
                const groups = await dbHelpers.getPublicGroups(userId);
                sendSuccess(res, {
                    groups: groups,
                    total: groups.length,
                    source: "postgresql"
                });
            } catch (err) {
                log("error", "Error fetching public groups", { error: err.message });
                log("error", "Error al cargar grupos", { error: err.message }); sendError(res, 500, "Error interno del servidor");
            }
            return;
        }

        if (pathname === "/api/groups/my-groups-pg" && method === "GET") {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticación requerida");
                return;
            }

            const userId = String(authUser.userId);

            let groups = [];
            let source = "postgresql";

            // 1. Intentar PostgreSQL primero
            try {
                groups = await dbHelpers.getEnrichedGroupsByUser(userId);
                log("info", `Loaded ${groups.length} groups from PostgreSQL for user ${userId}`);
            } catch (pgError) {
                log("warn", `PostgreSQL failed for user ${userId}: ${pgError.message}`);
                source = "json_fallback";

                // 2. Fallback a JSON (database.groups)
                try {
                    const userMemberships = (database.groupMembers || []).filter(
                        m => m.user_id === userId
                    );
                    const memberGroupIds = userMemberships.map(m => m.group_id);

                    // También incluir grupos donde el usuario es admin/coordinator
                    groups = (database.groups || []).filter(g =>
                        memberGroupIds.includes(g.id) ||
                        g.admin_id === userId ||
                        g.coordinator_id === userId
                    );

                    log("info", `Loaded ${groups.length} groups from JSON fallback for user ${userId}`);
                } catch (jsonError) {
                    log("error", `JSON fallback also failed: ${jsonError.message}`);
                }
            }

            sendSuccess(res, {
                groups,
                total: groups.length,
                source: source
            });
            return;
        }

        if (pathname === "/api/groups/my-groups" && method === "GET") {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticación requerida");
                return;
            }

            const userId = String(authUser.userId);

            // Get all groups where user is a member
            const userMemberships = (database.groupMembers || []).filter(
                m => m.user_id === userId
            );

            const enhancedGroups = [];

            for (const membership of userMemberships) {
                const group = (database.groups || []).find(g => g.id === membership.group_id);

                if (!group) continue;

                // 1. DETERMINE USER ROLE
                let userRole = "member"; // default
                let userPermissions = ["view", "register_payment"];

                if (group.admin_id === userId) {
                    userRole = "creator";
                    userPermissions = [
                        "view", "edit", "delete", "manage_coordinators",
                        "approve_payments", "invite_members", "remove_members",
                        "pause_group", "close_group", "view_reports"
                    ];
                } else if (group.coordinators && group.coordinators.includes(userId)) {
                    userRole = "coordinator";
                    userPermissions = [
                        "view", "approve_payments", "invite_members",
                        "manage_turns", "send_reminders", "view_reports"
                    ];
                }

                // 2. GET USER PAYMENT STATUS
                const userPayments = (database.payments || []).filter(
                    p => p.group_id === group.id && p.user_id === userId
                );

                // Find latest payment
                const latestPayment = userPayments.sort((a, b) =>
                    new Date(b.payment_date || b.created_at) - new Date(a.payment_date || a.created_at)
                )[0];

                // Calculate next payment due date using centralized helper
                let nextPaymentDue = null;
                let nextPaymentGraceDeadline = null;
                let paymentStatus = "up_to_date";
                let daysLate = 0;

                if (group.frequency) {
                    const today = new Date();
                    const groupStartDate = group.start_date || group.created_at;
                    const cyclesPaid = userPayments.filter(p => p.status === "approved" || p.status === "completed" || p.status === "coordinator_approved" || p.status === "archived").length;
                    const userNextCycle = cyclesPaid + 1;
                    const gracePeriod = parseInt(group.grace_period) || 5;
                    const dueDateInfo = getPaymentDueDate(group.frequency, groupStartDate, userNextCycle, gracePeriod);

                    if (dueDateInfo.dueDate) {
                        nextPaymentDue = new Date(dueDateInfo.dueDate + "T12:00:00");
                        nextPaymentGraceDeadline = dueDateInfo.graceDeadline;
                    }

                    if (nextPaymentDue) {
                        var graceDate = nextPaymentGraceDeadline ? new Date(nextPaymentGraceDeadline + "T23:59:59") : nextPaymentDue;
                        if (today > graceDate) {
                            paymentStatus = "late";
                            daysLate = Math.floor((today - graceDate) / (1000 * 60 * 60 * 24));

                            // v4.10.3: No auto-suspend — display as "suspension_recommended" for coordinator awareness
                            const autoSuspendDays = 5;
                            if (daysLate >= autoSuspendDays) {
                                paymentStatus = "suspension_recommended";
                            }
                        } else if (today > nextPaymentDue) {
                            paymentStatus = "pending";
                            daysLate = Math.floor((today - nextPaymentDue) / (1000 * 60 * 60 * 24));
                        }
                    }

                    // Only show "suspended" if creator/coordinator manually suspended this member
                    if (membership.status === "suspended") {
                        paymentStatus = "suspended";
                    }
                }

                // 3. GET ACTIVE TANDA INFO (if exists)
                const activeTanda = (database.tandas || []).find(
                    t => t.group_id === group.id && t.status === "active"
                );

                let myTurnNumber = null;
                let currentTurnNumber = null;
                let currentTurnRecipient = null;
                let turnsUntilMine = null;

                if (activeTanda) {
                    currentTurnNumber = activeTanda.current_turn;

                    // Find user's turn number
                    if (activeTanda.turns_order && activeTanda.turns_order.length > 0) {
                        myTurnNumber = activeTanda.turns_order.indexOf(userId) + 1;

                        if (myTurnNumber > 0) {
                            turnsUntilMine = myTurnNumber - currentTurnNumber;
                        }
                    }

                    // Get current recipient
                    if (activeTanda.current_turn_payments) {
                        currentTurnRecipient = activeTanda.current_turn_payments.recipient_user_id;
                    }
                }

                // 4. CALCULATE TOTAL MEMBERS
                const groupMembers = (database.groupMembers || []).filter(
                    m => m.group_id === group.id
                );

                // 5. GENERATE ALERTS FOR THIS USER
                const alerts = [];
                const today = new Date();

                // Alert: Payment due soon (up_to_date, <= 5 days before due)
                if (paymentStatus === "up_to_date" && nextPaymentDue) {
                    const daysUntilDue = Math.floor((new Date(nextPaymentDue) - today) / (1000 * 60 * 60 * 24));
                    if (daysUntilDue <= 5 && daysUntilDue > 0) {
                        alerts.push({
                            type: "payment_due",
                            severity: daysUntilDue <= 2 ? "warning" : "info",
                            message: "Tu pago vence en " + daysUntilDue + " dia" + (daysUntilDue !== 1 ? "s" : ""),
                            metadata: { days_until: daysUntilDue, amount: group.contribution_amount }
                        });
                    }
                }

                // Alert: In grace period (pending — between due date and grace deadline)
                if (paymentStatus === "pending" && nextPaymentDue && nextPaymentGraceDeadline) {
                    const graceEnd = new Date(nextPaymentGraceDeadline + "T23:59:59");
                    const daysOfGraceLeft = Math.ceil((graceEnd - today) / (1000 * 60 * 60 * 24));
                    if (daysOfGraceLeft > 0) {
                        var graceMsg = "Pago vencido. Tienes " + daysOfGraceLeft + " dia" + (daysOfGraceLeft !== 1 ? "s" : "") + " de gracia";
                        alerts.push({
                            type: "payment_grace",
                            severity: "warning",
                            message: graceMsg,
                            metadata: { grace_days_left: daysOfGraceLeft, grace_deadline: nextPaymentGraceDeadline, amount: group.contribution_amount }
                        });
                    } else {
                        alerts.push({
                            type: "payment_overdue",
                            severity: "danger",
                            message: "Pago atrasado. Periodo de gracia vencido",
                            metadata: { amount: group.contribution_amount }
                        });
                    }
                }

                // Alert: Payment overdue (late — past grace deadline)
                if (paymentStatus === "late") {
                    alerts.push({
                        type: "payment_overdue",
                        severity: "danger",
                        message: "Pago atrasado por " + daysLate + " dia" + (daysLate !== 1 ? "s" : ""),
                        metadata: { days_late: daysLate, amount: group.contribution_amount }
                    });
                }

                // Alert: Suspension recommended (5+ days late)
                if (paymentStatus === "suspension_recommended") {
                    alerts.push({
                        type: "suspension_risk",
                        severity: "danger",
                        message: `Llevas ${daysLate} dias de atraso. Paga pronto para evitar suspension.`,
                        action_url: "/register-payment",
                        metadata: { days_late: daysLate, amount: group.contribution_amount }
                    });
                }

                // Alert: Member is suspended — can pay to reactivate
                if (paymentStatus === "suspended") {
                    alerts.push({
                        type: "member_suspended",
                        severity: "danger",
                        message: "Tu membresia esta suspendida. Realiza tu pago para reactivarla.",
                        action_url: "/register-payment",
                        metadata: { amount: group.contribution_amount }
                    });
                }

                // Alert: Your turn is coming soon
                if (turnsUntilMine !== null && turnsUntilMine > 0 && turnsUntilMine <= 2) {
                    const message = turnsUntilMine === 1
                        ? "¡Tu turno es el próximo!"
                        : `Faltan ${turnsUntilMine} turnos para el tuyo`;

                    alerts.push({
                        type: "turn_upcoming",
                        severity: "info",
                        message: message,
                        action_url: "/view-schedule",
                        metadata: {
                            turns_until: turnsUntilMine,
                            estimated_amount: group.contribution_amount * groupMembers.length
                        }
                    });
                }

                // Alert: It's your turn now
                if (currentTurnRecipient === userId) {
                    alerts.push({
                        type: "your_turn_now",
                        severity: "success",
                        message: "¡Es tu turno! Recibirás cuando todos paguen",
                        action_url: "/view-turn-status",
                        metadata: {
                            amount: group.contribution_amount * (groupMembers.length - 1)
                        }
                    });
                }

                // COORDINATOR ALERTS
                if (userRole === "coordinator" || userRole === "creator") {
                    // Alert: Pending payment approvals
                    const pendingPayments = (database.payments || []).filter(
                        p => p.group_id === group.id && p.status === "pending"
                    );

                    if (pendingPayments.length > 0) {
                        alerts.push({
                            type: "pending_approvals",
                            severity: "info",
                            message: `${pendingPayments.length} pago${pendingPayments.length !== 1 ? 's' : ''} pendiente${pendingPayments.length !== 1 ? 's' : ''} de aprobación`,
                            action_url: "/approve-payments",
                            metadata: {
                                count: pendingPayments.length
                            }
                        });
                    }

                    // Alert: Can advance turn
                    if (activeTanda && activeTanda.current_turn_payments) {
                        const pendingFrom = activeTanda.current_turn_payments.pending_from || [];

                        if (pendingFrom.length === 0 && activeTanda.status === "active") {
                            alerts.push({
                                type: "can_advance_turn",
                                severity: "success",
                                message: "Todos pagaron - Puedes avanzar el turno",
                                action_url: "/advance-turn",
                                metadata: {
                                    current_turn: activeTanda.current_turn
                                }
                            });
                        }
                    }

                    // Alert: Members with late payments
                    const lateMembers = groupMembers.filter(m => {
                        const memberPayments = (database.payments || []).filter(
                            p => p.group_id === group.id && p.user_id === m.user_id && p.status === "approved"
                        );

                        // Simple check - if no payments or last payment is old
                        if (memberPayments.length === 0) return false;

                        const lastPayment = memberPayments.sort((a, b) =>
                            new Date(b.payment_date || b.created_at) - new Date(a.payment_date || a.created_at)
                        )[0];

                        const daysSinceLastPayment = Math.floor(
                            (new Date() - new Date(lastPayment.payment_date || lastPayment.created_at)) / (1000 * 60 * 60 * 24)
                        );

                        let maxDays = 30; // monthly
                        if (group.frequency === "weekly") maxDays = 7;
                        else if (group.frequency === "biweekly") maxDays = 14;

                        return daysSinceLastPayment > maxDays + 3; // with grace period
                    });

                    if (lateMembers.length > 0) {
                        alerts.push({
                            type: "late_members",
                            severity: "warning",
                            message: `${lateMembers.length} miembro${lateMembers.length !== 1 ? 's' : ''} con pagos atrasados`,
                            action_url: "/view-delinquent",
                            metadata: {
                                count: lateMembers.length
                            }
                        });
                    }
                }

                // 6. BUILD ENHANCED GROUP OBJECT
                const enhancedGroup = {
                    // Basic group info
                    id: group.id,
                    name: group.name,
                    description: group.description || "",
                    category: group.category_id || "general",
                    location: group.location || "",

                    // Group settings
                    contribution_amount: group.contribution_amount,
                    frequency: group.frequency,
                    max_members: group.max_members,
                    members_count: groupMembers.length,
                    status: group.status || "active",

                    // Group admin
                    admin_id: group.admin_id,
                    coordinators: group.coordinators || [],

                    // Dates
                    created_at: group.created_at,

                    // MY ROLE (NEW)
                    my_role: userRole,
                    my_permissions: userPermissions,

                    // MY PAYMENT STATUS (NEW)
                    my_payment_status: paymentStatus,
                    my_next_payment_due: nextPaymentDue ? nextPaymentDue.toISOString().split('T')[0] : null,
                    my_next_payment_grace_deadline: nextPaymentGraceDeadline || null,
                    my_days_late: daysLate,
                    my_total_paid: userPayments.filter(p => p.status === "approved")
                        .reduce((sum, p) => sum + (p.amount || 0), 0),

                    // MY TANDA INFO (NEW)
                    my_turn_number: myTurnNumber,
                    turns_until_mine: turnsUntilMine,

                    // CURRENT GROUP STATE (NEW)
                    current_turn_number: currentTurnNumber,
                    current_turn_recipient: currentTurnRecipient,
                    has_active_tanda: activeTanda !== undefined,

                    // ALERTS (NEW)
                    my_alerts: alerts,

                    // POSITION ASSIGNMENT (NEW)
                    positions: group.positions || [],
                    position_requests: group.position_requests || []
                };

                enhancedGroups.push(enhancedGroup);
            }

            // Sort groups by most recent first
            enhancedGroups.sort((a, b) =>
                new Date(b.created_at) - new Date(a.created_at)
            );

            log("info", `Returning ${enhancedGroups.length} enhanced groups for user ${userId}`);

            sendSuccess(res, {
                groups: enhancedGroups,
                total: enhancedGroups.length
            });
            return;
        }

        // Registration endpoints
        if (pathname === '/api/registration/groups/list' && method === 'POST') {
            const availableGroups = database.groups.filter(g => 
                g.status === 'active' && g.member_count < g.max_members
            );
            sendSuccess(res, { groups: availableGroups, total_count: availableGroups.length });
            return;
        }        if (pathname === '/api/registration/groups/create' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }

            const { name, description, category, location, contribution_amount, frequency, max_members, grace_period, start_date, latePaymentPenalty, commissionRate } = body;
            const coordinator_id = authUser.userId;
            const groupId = generateId('group');

            // v4.10.4: Validate optional commission_rate
            let regCommissionRate = null;
            if (commissionRate !== undefined && commissionRate !== null) {
                const parsedRate = parseFloat(commissionRate);
                if (!isNaN(parsedRate) && Number.isFinite(parsedRate) && parsedRate >= 0 && parsedRate <= 5) {
                    regCommissionRate = Math.round(parsedRate * 100) / 100;
                }
            }
            const newGroup = {
                id: groupId,
                name,
                contribution_amount,
                frequency,
                member_count: 1,
                max_members,
                total_amount_collected: 0,
                admin_id: coordinator_id,
                admin_name: database.users.find(u => u.id === coordinator_id)?.name || 'Unknown',
                status: 'active',
                created_at: new Date().toISOString(),
                location: 'Honduras',
                description: (typeof description === 'string' && description.trim()) ? description.replace(/<[^>]*>/g, '').trim().substring(0, 500) : `Grupo ${name} - ${frequency}`,
                image_url: '/uploads/groups/default.jpg',
                category: (typeof category === 'string' && category.trim()) ? category.replace(/<[^>]*>/g, '').trim().substring(0, 50) : 'general',
                meeting_schedule: 'Por definir'
            };
            
            // ============================================
            // DUAL-WRITE: PostgreSQL (Primary) + JSON (Backup)
            // Week 3-4: Group Creation Implementation
            // ============================================
            
            let pgWriteSuccess = false;
            
            try {
                // PRIMARY WRITE: PostgreSQL
                const pgGroupData = {
                    id: groupId,
                    name,
                    contribution_amount: parseFloat(contribution_amount),
                    frequency,
                    max_members: parseInt(max_members),
                    admin_id: coordinator_id,
                    status: 'active',
                    created_at: newGroup.created_at,
                    member_count: 1,
                    total_amount_collected: 0,
                    description: newGroup.description,
                    location: newGroup.location,
                    category: newGroup.category,
                    start_date: start_date || null,
                    grace_period: parseInt(grace_period) || 3,
                    penalty_amount: parseFloat(latePaymentPenalty) || 50,
                    commission_rate: regCommissionRate
                };

                await db.createGroup(pgGroupData);
                pgWriteSuccess = true;
                log('info', `✅ [DUAL-WRITE] Group created in PostgreSQL: ${groupId}`);

                // ✅ Add creator as member in PostgreSQL
                try {
                    await db.addGroupMember({
                        group_id: groupId,
                        user_id: coordinator_id,
                        role: "creator",
                        status: "active",
                        invited_by: coordinator_id,
                        notes: "Creador del grupo"
                    });
                    log("info", "✅ Creator added as member in PostgreSQL: " + coordinator_id);

                // ✅ AUTO-CREATE TANDA for the new group
                try {
                    const tandaId = "tanda_" + crypto.randomBytes(12).toString("hex");
                    const tandaData = {
                        tanda_id: tandaId,
                        name: "Tanda - " + name,
                        contribution_amount: parseFloat(contribution_amount || 100),
                        total_per_turn: parseFloat(contribution_amount || 100) * parseInt(max_members || 10),
                        frequency: frequency || "monthly",
                        coordinator_id: coordinator_id,
                        group_id: groupId,
                        status: "recruiting",
                        current_turn: 0,
                        total_turns: parseInt(max_members || 10),
                        turns_order: [coordinator_id],
                        is_demo: false
                    };
                    await dbPostgres.createTanda(tandaData);
                    log("info", "✅ Tanda auto-creada para grupo: " + tandaId + " (group: " + groupId + ")");
                } catch (tandaError) {
                    log("warn", "⚠️ Error creando tanda automática: " + tandaError.message);
                }
                } catch (memberError) {
                    log("warn", "⚠️ Failed to add creator as member: " + memberError.message);
                }
                
            } catch (pgError) {
                log('error', `❌ [DUAL-WRITE] PostgreSQL write failed for group: ${pgError.message}`, { groupId, error: pgError });
                // Continue to JSON write (graceful degradation)
            }
            
            // BACKUP WRITE: JSON (only if group exists in JSON)
            database.groups.push(newGroup);
            saveDatabase();  // CRITICAL: Save JSON to disk
            log('info', `✅ [DUAL-WRITE] Group created in JSON: ${groupId}`, { pgWriteSuccess });
            
            sendSuccess(res, { group: newGroup, message: 'Grupo creado exitosamente' });
            return;
        }


        // Group update endpoint (NUEVO - Agregado para persistencia)
                                if (pathname.startsWith('/api/groups/') && pathname.endsWith('/update') && (method === 'PUT' || method === 'PATCH')) {
            // ============================================
            // SECURITY: Require JWT authentication (Added 2025-12-31)
            // ============================================
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const groupId = pathname.split('/')[3]; // Extract ID from /api/groups/GROUP_ID/update

            // ============================================
            // SECURITY: Verify user has permission to edit group (Added 2025-12-31)
            // ============================================
            try {
                // v4.10.3: Allow suspended creators/coordinators to edit (group suspension suspends all members)
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status IN ('active', 'suspended')
                `, [groupId, authUser.userId]);

                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para editar este grupo');
                    return;
                }
            } catch (permError) {
                log('error', 'Permission check failed for group update', { error: permError.message });
                sendError(res, 500, 'Error al verificar permisos');
                return;
            }

            const { name, description, contribution_amount, max_members, frequency, start_date, status, location, commissionRate, advanceThreshold } = body;

            // ============================================
            // VALIDATION: Check if tanda has started before allowing certain changes (Added 2025-12-31)
            // ============================================
            try {
                const tandaCheck = await dbPostgres.pool.query(`
                    SELECT status, lottery_executed_at FROM tandas
                    WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
                `, [groupId]);

                const tandaStarted = tandaCheck.rows.length > 0 &&
                                    (tandaCheck.rows[0].status !== 'recruiting' || tandaCheck.rows[0].lottery_executed_at);

                // If tanda has started, restrict changes to critical fields
                // Compare against current values — only block if ACTUALLY changing
                if (tandaStarted) {
                    const currentGroupData = await dbPostgres.pool.query(
                        "SELECT contribution_amount, max_members, frequency FROM groups WHERE group_id = $1", [groupId]
                    );
                    const current = currentGroupData.rows[0] || {};

                    if (contribution_amount !== undefined && parseFloat(contribution_amount) !== parseFloat(current.contribution_amount)) {
                        sendError(res, 400, 'No se puede cambiar el monto de contribucion despues de que la tanda ha iniciado');
                        return;
                    }
                    if (frequency !== undefined && frequency !== current.frequency) {
                        sendError(res, 400, 'No se puede cambiar la frecuencia despues de que la tanda ha iniciado');
                        return;
                    }
                    // max_members: allow increasing, block reducing below active members
                    if (max_members !== undefined) {
                        const newMax = parseInt(max_members);
                        const currentMax = parseInt(current.max_members) || 0;
                        if (newMax < currentMax) {
                            const memberCountResult = await dbPostgres.pool.query(
                                "SELECT COUNT(*) as cnt FROM group_members WHERE group_id = $1 AND status IN ('active', 'suspended', 'pending')", [groupId]
                            );
                            const activeMemberCount = parseInt(memberCountResult.rows[0].cnt);
                            if (newMax < activeMemberCount) {
                                sendError(res, 400, `No se puede reducir a ${newMax}. Hay ${activeMemberCount} miembros activos.`);
                                return;
                            }
                        }
                    }
                }
            } catch (validationError) {
                log('error', 'Validation error in group update', { error: validationError.message });
                sendError(res, 500, 'Error al validar estado de tanda');
                return;
            }

            log('info', `Updating group: ${groupId}`, { name, contribution_amount, updatedBy: authUser.userId });
            
            // ============================================
            // DUAL-WRITE: PostgreSQL (Primary) + JSON (Backup)
            // Week 3 Day 2: Group Update
            // ============================================
            
            let pgWriteSuccess = false;
            
            // Check PostgreSQL first, then JSON
            let groupExists = false;
            try {
                const pgGroup = await db.getGroupById(groupId);
                if (pgGroup) groupExists = true;
            } catch (e) { log('warn', 'PG group lookup failed', { groupId, error: e.message }); }

            const groupIndex = database.groups.findIndex(g => g.id === groupId);
            if (!groupExists && groupIndex === -1) {
                sendError(res, 404, 'Grupo no encontrado');
                return;
            }
            
            try {
                // PRIMARY WRITE: PostgreSQL
                const pgUpdateData = {};
                if (name) pgUpdateData.name = name;
                if (description !== undefined) pgUpdateData.description = description;
                if (contribution_amount) pgUpdateData.contribution_amount = parseFloat(contribution_amount);
                if (max_members) pgUpdateData.max_members = parseInt(max_members);
                if (frequency) pgUpdateData.frequency = frequency;
                if (start_date) pgUpdateData.start_date = start_date;
                if (status) pgUpdateData.status = status;
                if (location) pgUpdateData.location = location;
            if (commissionRate !== undefined) {
                if (commissionRate === null) {
                    pgUpdateData.commission_rate = null;
                } else {
                    const parsedRate = parseFloat(commissionRate);
                    if (!isNaN(parsedRate) && Number.isFinite(parsedRate) && parsedRate >= 0 && parsedRate <= 5) {
                        pgUpdateData.commission_rate = Math.round(parsedRate * 100) / 100;
                    }
                }
            }
                
            if (advanceThreshold !== undefined) {
                if (advanceThreshold === null) {
                    pgUpdateData.advance_threshold = 80;
                } else {
                    const parsedThreshold = parseInt(advanceThreshold);
                    if (!isNaN(parsedThreshold) && Number.isFinite(parsedThreshold) && parsedThreshold >= 50 && parsedThreshold <= 100) {
                        pgUpdateData.advance_threshold = parsedThreshold;
                    }
                }
            }
                await db.updateGroup(groupId, pgUpdateData);
                pgWriteSuccess = true;
                log('info', `✅ [DUAL-WRITE] Group updated in PostgreSQL: ${groupId}`);
                
            } catch (pgError) {
                log('error', `❌ [DUAL-WRITE] PostgreSQL update failed for group: ${pgError.message}`, { groupId, error: pgError });
                // Continue to JSON write (graceful degradation)
            }
            
            // BACKUP WRITE: JSON (only if group exists in JSON)
            if (groupIndex !== -1) {
                const group = database.groups[groupIndex];
                if (name) group.name = name;
                if (description !== undefined) group.description = description;
                if (contribution_amount) group.contribution_amount = parseFloat(contribution_amount);
                if (max_members) group.max_members = parseInt(max_members);
                if (frequency) group.frequency = frequency;
                if (start_date) group.start_date = start_date;
                if (status) group.status = status;
                if (location) group.location = location;
                group.updated_at = new Date().toISOString();
                
                database.groups[groupIndex] = group;
                saveDatabase();  // CRITICAL: Save JSON to disk
                log('info', `✅ [DUAL-WRITE] Group updated in JSON: ${groupId}`, { pgWriteSuccess });
            } else {
                log('info', `ℹ️ [DUAL-WRITE] Group not in JSON (PostgreSQL only): ${groupId}`, { pgWriteSuccess });
            }
            
            // Return updated group from PostgreSQL
            const updatedGroup = await db.getGroupById(groupId);
            sendSuccess(res, { group: updatedGroup, message: 'Group updated successfully' });
            return;
        }


        // Get individual group details (for invitation page)

        // ========== COMMISSION ENDPOINTS (v4.10.4) ==========

        // GET /api/groups/:id/commission-info — Public (no auth), needed before joining
        if (pathname.match(/^\/api\/groups\/[^/]+\/commission-info$/) && method === 'GET') {
            const groupId = pathname.split('/')[3];
            try {
                const result = await dbPostgres.pool.query(
                    `SELECT g.group_id, g.commission_rate, g.contribution_amount, g.max_members, g.frequency, g.member_count,
                            (SELECT COUNT(*) FROM group_members WHERE group_id = g.group_id AND status = 'active' AND commission_accepted = true) as accepted_count,
                            (SELECT COUNT(*) FROM group_members WHERE group_id = g.group_id AND status = 'active' AND commission_accepted IS NULL) as undecided_count
                     FROM groups g WHERE g.group_id = $1 AND g.status != 'deleted'`,
                    [groupId]
                );
                if (result.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                const g = result.rows[0];
                const rate = g.commission_rate !== null ? parseFloat(g.commission_rate) : null;
                sendSuccess(res, {
                    commission_rate: rate,
                    commission_type: rate !== null ? (rate === 0 ? 'none' : 'custom') : 'platform_default',
                    contribution_amount: parseFloat(g.contribution_amount) || 0,
                    max_members: parseInt(g.max_members) || 12,
                    member_count: parseInt(g.member_count) || 0,
                    frequency: g.frequency,
                    acceptance: {
                        accepted: parseInt(g.accepted_count) || 0,
                        undecided: parseInt(g.undecided_count) || 0
                    }
                });
            } catch (error) {
                log('error', 'Error fetching commission info:', error);
                sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // POST /api/groups/:id/commission/notify — Coordinator notifies undecided members
        if (pathname.match(/^\/api\/groups\/[^/]+\/commission\/notify$/) && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const groupId = pathname.split('/')[3];
            try {
                // Verify coordinator/creator role
                const roleCheck = await dbPostgres.pool.query(
                    `SELECT gm.role FROM group_members gm WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status = 'active'`,
                    [groupId, authUser.userId]
                );
                if (roleCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(roleCheck.rows[0].role)) {
                    sendError(res, 403, 'Solo el coordinador o creador puede enviar notificaciones de comision');
                    return;
                }

                // Get group commission rate
                const groupRes = await dbPostgres.pool.query(
                    'SELECT name, commission_rate, contribution_amount, max_members FROM groups WHERE group_id = $1',
                    [groupId]
                );
                if (groupRes.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                const grp = groupRes.rows[0];
                const rate = grp.commission_rate !== null ? parseFloat(grp.commission_rate) : null;

                // Find undecided members (commission_accepted IS NULL, excluding creators)
                const undecidedRes = await dbPostgres.pool.query(
                    `SELECT gm.user_id, u.name as user_name FROM group_members gm
                     LEFT JOIN users u ON gm.user_id = u.user_id
                     WHERE gm.group_id = $1 AND gm.status = 'active' AND gm.commission_accepted IS NULL AND gm.role != 'creator'`,
                    [groupId]
                );

                if (undecidedRes.rows.length === 0) {
                    sendSuccess(res, { message: 'Todos los miembros ya decidieron', notified: 0 });
                    return;
                }

                // Build commission description
                let rateDesc;
                if (rate === null) rateDesc = 'estandar (3% a 1% segun monto)';
                else if (rate === 0) rateDesc = 'sin comision (0%)';
                else rateDesc = rate + '%';

                // Send notification to each undecided member
                let notifiedCount = 0;
                for (const member of undecidedRes.rows) {
                    try {
                        await createNotification(
                            member.user_id,
                            'commission_request',
                            'Comision del grupo: ' + grp.name,
                            'El coordinador solicita aplicar una comision del ' + rateDesc + ' a tus pagos. Acepta o rechaza desde tu panel de grupo.',
                            { group_id: groupId, commission_rate: rate, action_url: 'groups-advanced-system.html?group=' + groupId }
                        );
                        notifiedCount++;
                    } catch (nErr) {
                        log('warn', 'Failed to notify member about commission:', nErr.message);
                    }
                }

                log('info', `Commission notifications sent for group ${groupId}: ${notifiedCount} members`);
                sendSuccess(res, { message: 'Notificaciones enviadas', notified: notifiedCount, total_undecided: undecidedRes.rows.length });
            } catch (error) {
                log('error', 'Error in commission notify:', error);
                sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // POST /api/groups/:id/commission/respond — Member accepts or declines commission
        if (pathname.match(/^\/api\/groups\/[^/]+\/commission\/respond$/) && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const groupId = pathname.split('/')[3];
            const { accepted } = body;

            if (typeof accepted !== 'boolean') {
                sendError(res, 400, 'El campo "accepted" debe ser true o false');
                return;
            }

            try {
                // Verify active membership
                const memberCheck = await dbPostgres.pool.query(
                    'SELECT id, role, commission_accepted FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = \'active\'',
                    [groupId, authUser.userId]
                );
                if (memberCheck.rows.length === 0) {
                    sendError(res, 403, 'No eres miembro activo de este grupo');
                    return;
                }

                // Update commission_accepted
                await dbPostgres.pool.query(
                    'UPDATE group_members SET commission_accepted = $1, updated_at = NOW() WHERE group_id = $2 AND user_id = $3',
                    [accepted, groupId, authUser.userId]
                );

                // Notify coordinator about the decision
                const groupRes = await dbPostgres.pool.query(
                    'SELECT admin_id, name FROM groups WHERE group_id = $1',
                    [groupId]
                );
                if (groupRes.rows.length > 0) {
                    const userName = authUser.name || 'Un miembro';
                    const decision = accepted ? 'acepto' : 'rechazo';
                    try {
                        await createNotification(
                            groupRes.rows[0].admin_id,
                            'commission_response',
                            'Respuesta de comision: ' + groupRes.rows[0].name,
                            userName + ' ' + decision + ' la comision del grupo.',
                            { group_id: groupId, user_id: authUser.userId, accepted: accepted }
                        );
                    } catch (nErr) {
                        log('warn', 'Failed to notify admin about commission response:', nErr.message);
                    }
                }

                log('info', `Commission response: user ${authUser.userId} ${accepted ? 'accepted' : 'declined'} for group ${groupId}`);
                sendSuccess(res, {
                    message: accepted ? 'Comision aceptada' : 'Comision rechazada',
                    commission_accepted: accepted
                });
            } catch (error) {
                log('error', 'Error in commission respond:', error);
                sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // GET /api/groups/:id/commission/members — Per-member commission acceptance (v4.10.7)
        if (pathname.match(/^\/api\/groups\/[^/]+\/commission\/members$/) && method === 'GET') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const groupId = pathname.split('/')[3];
            try {
                const groupRes = await dbPostgres.pool.query(
                    'SELECT group_id, name, commission_rate, admin_id FROM groups WHERE group_id = $1 AND status != $2',
                    [groupId, 'deleted']
                );
                if (groupRes.rows.length === 0) { sendError(res, 404, 'Grupo no encontrado'); return; }
                const group = groupRes.rows[0];

                // Auth: creator, coordinator, or admin
                const memberRes = await dbPostgres.pool.query(
                    'SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = $3',
                    [groupId, authUser.userId, 'active']
                );
                const role = memberRes.rows.length > 0 ? memberRes.rows[0].role : null;
                if (role !== 'creator' && role !== 'coordinator' && authUser.role !== 'admin') {
                    sendError(res, 403, 'No tienes acceso a esta informacion');
                    return;
                }

                // Get all active members with commission status
                const membersRes = await dbPostgres.pool.query(
                    `SELECT gm.user_id, u.name as user_name, u.avatar_url, gm.role, gm.commission_accepted
                     FROM group_members gm
                     JOIN users u ON u.user_id = gm.user_id
                     WHERE gm.group_id = $1 AND gm.status = $2
                     ORDER BY
                        CASE gm.role WHEN 'creator' THEN 0 WHEN 'coordinator' THEN 1 ELSE 2 END,
                        gm.joined_at ASC`,
                    [groupId, 'active']
                );

                const members = membersRes.rows;
                const rate = group.commission_rate !== null ? parseFloat(group.commission_rate) : null;
                const accepted = members.filter(m => m.commission_accepted === true).length;
                const declined = members.filter(m => m.commission_accepted === false).length;
                const undecided = members.filter(m => m.commission_accepted === null).length;

                sendSuccess(res, {
                    group_name: group.name,
                    commission_rate: rate,
                    commission_type: rate !== null ? (rate === 0 ? 'none' : 'custom') : 'platform_default',
                    summary: { accepted, declined, undecided, total: members.length },
                    members: members.map(m => ({
                        user_id: m.user_id,
                        user_name: m.user_name,
                        avatar_url: m.avatar_url,
                        role: m.role,
                        commission_accepted: m.commission_accepted
                    }))
                });
            } catch (error) {
                log('error', 'Error in commission members:', error);
                sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // PATCH /api/groups/:id/commission/rate — Change commission rate (v4.10.7)
        if (pathname.match(/^\/api\/groups\/[^/]+\/commission\/rate$/) && method === 'PATCH') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const groupId = pathname.split('/')[3];
            try {
                const groupRes = await dbPostgres.pool.query(
                    'SELECT group_id, name, admin_id FROM groups WHERE group_id = $1 AND status != $2',
                    [groupId, 'deleted']
                );
                if (groupRes.rows.length === 0) { sendError(res, 404, 'Grupo no encontrado'); return; }
                const group = groupRes.rows[0];

                // Auth: creator, coordinator, or admin
                const memberRes = await dbPostgres.pool.query(
                    'SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = $3',
                    [groupId, authUser.userId, 'active']
                );
                const role = memberRes.rows.length > 0 ? memberRes.rows[0].role : null;
                if (role !== 'creator' && role !== 'coordinator' && authUser.role !== 'admin') {
                    sendError(res, 403, 'No tienes permiso para cambiar la comision');
                    return;
                }

                const { commission_rate, auto_notify } = body;

                // Validate rate
                let newRate = null;
                if (commission_rate !== undefined && commission_rate !== null) {
                    const parsedRate = parseFloat(commission_rate);
                    if (isNaN(parsedRate) || !Number.isFinite(parsedRate) || parsedRate < 0 || parsedRate > 5) {
                        sendError(res, 400, 'La comision debe ser entre 0% y 5%');
                        return;
                    }
                    newRate = Math.round(parsedRate * 100) / 100;
                }

                // Transaction: update rate + reset member acceptance
                const client = await dbPostgres.pool.connect();
                let resetCount = 0;
                try {
                    await client.query('BEGIN');
                    await client.query(
                        'UPDATE groups SET commission_rate = $1, updated_at = NOW() WHERE group_id = $2',
                        [newRate, groupId]
                    );
                    const resetRes = await client.query(
                        `UPDATE group_members SET commission_accepted = NULL, updated_at = NOW()
                         WHERE group_id = $1 AND status = $2 AND role != $3`,
                        [groupId, 'active', 'creator']
                    );
                    resetCount = resetRes.rowCount;
                    await client.query('COMMIT');
                } catch (txErr) {
                    await client.query('ROLLBACK');
                    throw txErr;
                } finally {
                    client.release();
                }

                // Auto-notify (non-blocking)
                if (auto_notify !== false && resetCount > 0) {
                    (async function() {
                        try {
                            const undecidedRes = await dbPostgres.pool.query(
                                `SELECT gm.user_id FROM group_members gm
                                 WHERE gm.group_id = $1 AND gm.status = $2 AND gm.role != $3 AND gm.commission_accepted IS NULL`,
                                [groupId, 'active', 'creator']
                            );
                            let rateDesc;
                            if (newRate === null) rateDesc = 'estandar (3% a 1% segun monto)';
                            else if (newRate === 0) rateDesc = 'sin comision (0%)';
                            else rateDesc = newRate + '%';

                            for (const member of undecidedRes.rows) {
                                await createNotification(
                                    member.user_id,
                                    'commission_request',
                                    'Comision actualizada: ' + group.name,
                                    'La comision del grupo fue cambiada a ' + rateDesc + '. Acepta o rechaza desde tu panel de grupo.',
                                    { group_id: groupId, commission_rate: newRate, action_url: 'groups-advanced-system.html?group=' + groupId }
                                );
                            }
                        } catch (notifErr) {
                            log('error', 'Error sending commission rate change notifications', { error: notifErr.message });
                        }
                    })();
                }

                const rateDisplay = newRate !== null ? (newRate === 0 ? 'sin comision' : newRate + '%') : 'estandar';
                log('info', 'Commission rate changed', { groupId, newRate, resetCount, changedBy: authUser.userId });
                sendSuccess(res, {
                    message: 'Comision actualizada a ' + rateDisplay + '. ' + resetCount + ' miembros notificados.',
                    commission_rate: newRate,
                    commission_type: newRate !== null ? (newRate === 0 ? 'none' : 'custom') : 'platform_default',
                    members_reset: resetCount
                });
            } catch (error) {
                log('error', 'Error in commission rate change:', error);
                sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // ========== CYCLE DISTRIBUTION ENDPOINTS ==========

        // Calculate and preview cycle distribution
        if (pathname.match(/^\/api\/groups\/[^/]+\/distribution\/preview$/) && (method === 'GET' || method === 'HEAD')) {
            // SECURITY: Require JWT authentication (Added 2025-12-31)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }

            const groupId = pathname.split('/')[3];

            try {
                // SECURITY: Verify user has coordinator/admin permission (Added 2025-12-31)
                // v4.10.3: Allow suspended creators/coordinators to manage
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status IN ('active', 'suspended')
                `, [groupId, authUser.userId]);

                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para ver la distribución de este grupo');
                    return;
                }

                // VALIDATION: Check tanda is active and lottery executed (Added 2025-12-31)
                const tandaCheck = await dbPostgres.pool.query(`
                    SELECT t.status, t.lottery_executed_at, t.turns_order, t.current_turn
                    FROM tandas t
                    WHERE t.group_id = $1 ORDER BY t.created_at DESC LIMIT 1
                `, [groupId]);

                if (tandaCheck.rows.length === 0 || tandaCheck.rows[0].status === 'recruiting') {
                    sendError(res, 400, 'La tanda aún no ha iniciado. No hay distribución disponible.');
                    return;
                }

                if (!tandaCheck.rows[0].lottery_executed_at) {
                    sendError(res, 400, 'La tómbola no ha sido ejecutada. Las posiciones deben ser asignadas primero.');
                    return;
                }

                const turnsOrder = tandaCheck.rows[0].turns_order || [];

                // Get group info
                const groupResult = await dbPostgres.pool.query(`
                    SELECT g.group_id, g.name, g.contribution_amount, g.frequency, g.max_members,
                           g.current_cycle, g.commission_rate,
                           g.admin_id, g.status,
                           (SELECT COUNT(*) FROM group_members WHERE group_id = g.group_id AND status = 'active') as active_member_count,
                           (SELECT SUM(COALESCE(num_positions, 1)) FROM group_members WHERE group_id = g.group_id AND status = 'active') as active_positions
                    FROM groups g WHERE g.group_id = $1
                `, [groupId]);

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                const group = groupResult.rows[0];
                const maxMembers = parseInt(group.max_members) || 0;
                const contributionAmount = parseFloat(group.contribution_amount) || 0;
                const activePositions = parseInt(group.active_positions) || 0;

                // v4.10.8: Target total based on max_members (designed capacity), not active members
                const targetTotal = maxMembers * contributionAmount;

                // v4.10.8: Distribution cycle = next after last completed distribution
                const distResult = await dbPostgres.pool.query(
                    'SELECT COALESCE(MAX(cycle_number), 0) + 1 AS next_dist_cycle FROM cycle_distributions WHERE group_id = $1',
                    [groupId]
                );
                const nextDistCycle = distResult.rows[0].next_dist_cycle;

                // v4.10.8: Beneficiary from turns_order[nextDistCycle - 1] (0-indexed)
                const turnIndex = nextDistCycle - 1;
                let beneficiaryUserId = null;
                let beneficiaryName = 'Por asignar';
                let beneficiaryTurnPosition = turnIndex + 1;

                if (turnIndex < turnsOrder.length) {
                    const turnEntry = turnsOrder[turnIndex];
                    // turns_order is text[] with JSON strings like {"user_id":"...","slot":0}
                    try {
                        const parsed = typeof turnEntry === 'string' ? JSON.parse(turnEntry) : turnEntry;
                        beneficiaryUserId = parsed.user_id || parsed;
                    } catch (e) {
                        beneficiaryUserId = turnEntry; // plain user_id string
                    }

                    if (beneficiaryUserId) {
                        const userResult = await dbPostgres.pool.query(
                            'SELECT name FROM users WHERE user_id = $1', [beneficiaryUserId]
                        );
                        beneficiaryName = userResult.rows[0]?.name || 'Desconocido';
                    }
                }

                // Get completed contributions for current active cycle
                const contribResult = await dbPostgres.pool.query(`
                    SELECT
                        COUNT(*) as total_contributions,
                        SUM(amount) as total_collected,
                        SUM(CASE WHEN payment_method = 'cash' THEN amount ELSE 0 END) as cash_collected,
                        SUM(CASE WHEN payment_method != 'cash' THEN amount ELSE 0 END) as transfer_collected
                    FROM contributions
                    WHERE group_id = $1 AND status IN ('completed', 'coordinator_approved', 'archived')
                `, [groupId]);

                const contrib = contribResult.rows[0];
                const totalCollected = parseFloat(contrib.total_collected) || 0;
                const cashCollected = parseFloat(contrib.cash_collected) || 0;
                const transferCollected = parseFloat(contrib.transfer_collected) || 0;
                const totalContributions = parseInt(contrib.total_contributions) || 0;

                // v4.10.8: Commissions based on targetTotal (not totalCollected)
                let commissionRate;
                const groupCommissionRate = group.commission_rate;
                if (groupCommissionRate !== null && groupCommissionRate !== undefined) {
                    commissionRate = parseFloat(groupCommissionRate) / 100;
                } else {
                    // Platform default tiered
                    commissionRate = 0.03;
                    if (targetTotal >= 100000) commissionRate = 0.01;
                    else if (targetTotal >= 50000) commissionRate = 0.02;
                }

                // v4.10.4: Count members who accepted commission (democratic)
                const commAcceptResult = await dbPostgres.pool.query(
                    `SELECT COUNT(*) as accepted_count FROM group_members WHERE group_id = $1 AND status = 'active' AND commission_accepted = true`,
                    [groupId]
                );
                const commAcceptedCount = parseInt(commAcceptResult.rows[0].accepted_count) || 0;

                // v4.10.8: Fees based on targetTotal
                const coordinatorFee = targetTotal * commissionRate;
                const platformFee = coordinatorFee * 0.10;  // Platform gets 10% of coordinator fee
                const coordinatorNetFee = coordinatorFee - platformFee;

                // Check if beneficiary is the group creator (coordinator)
                const isCoordinatorTurn = beneficiaryUserId === group.admin_id;

                // Calculate what each party receives
                let beneficiaryReceives, coordinatorReceives;
                if (isCoordinatorTurn) {
                    beneficiaryReceives = targetTotal - platformFee;
                    coordinatorReceives = 0;
                } else {
                    beneficiaryReceives = targetTotal - coordinatorFee;
                    coordinatorReceives = coordinatorNetFee;
                }

                const collectionPercentage = targetTotal > 0 ? Math.round((totalCollected / targetTotal) * 1000) / 10 : 0;

                sendSuccess(res, {
                    group_id: groupId,
                    group_name: group.name,
                    cycle_number: group.current_cycle || 1,
                    next_distribution_cycle: nextDistCycle,
                    target_total: targetTotal,
                    actual_collected: totalCollected,
                    positions_filled: activePositions,
                    positions_total: maxMembers,
                    collection_percentage: collectionPercentage,
                    collection: {
                        total_contributions: totalContributions,
                        expected_contributions: activePositions,
                        total_collected: totalCollected,
                        cash_collected: cashCollected,
                        transfer_collected: transferCollected,
                        is_complete: totalContributions >= activePositions
                    },
                    fees: {
                        coordinator_fee: isCoordinatorTurn ? 0 : coordinatorFee,
                        coordinator_rate: commissionRate * 100,
                        platform_fee: platformFee,
                        platform_rate: 10,
                        coordinator_net: isCoordinatorTurn ? 0 : coordinatorNetFee,
                        is_coordinator_turn: isCoordinatorTurn,
                        custom_rate: groupCommissionRate !== null && groupCommissionRate !== undefined,
                        commission_source: groupCommissionRate !== null && groupCommissionRate !== undefined ? 'custom' : 'platform_default'
                    },
                    commission_acceptance: {
                        total_active_members: parseInt(group.active_member_count) || 0,
                        accepted: commAcceptedCount,
                        pending: (parseInt(group.active_member_count) || 0) - commAcceptedCount,
                        applies_to_accepted_only: true
                    },
                    distribution: {
                        coordinator_receives: {
                            gross_commission: isCoordinatorTurn ? 0 : coordinatorFee,
                            platform_fee_paid: isCoordinatorTurn ? 0 : platformFee,
                            net_commission: coordinatorReceives,
                            method: 'Comision + efectivo en mano'
                        },
                        beneficiary_receives: {
                            amount: beneficiaryReceives,
                            user_id: beneficiaryUserId,
                            user_name: beneficiaryName,
                            turn_number: beneficiaryTurnPosition,
                            method: 'Distribucion manual por coordinador',
                            is_coordinator: isCoordinatorTurn
                        }
                    },
                    can_distribute: totalContributions >= activePositions && totalCollected > 0
                });
            } catch (error) {
                log("error", 'Error calculating distribution preview:', error);
                sendError(res, 500, 'Error al calcular distribucion');
            }
            return;
        }

        // Execute cycle distribution
        if (pathname.match(/^\/api\/groups\/[^/]+\/distribution\/execute$/) && method === 'POST') {
            // SECURITY: Require JWT authentication (Added 2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const groupId = pathname.split('/')[3];
            const { transfer_reference } = body;
            const executed_by = authUser.userId;

            try {
                // SECURITY: Verify user has coordinator/admin permission (Added 2025-12-31)
                // v4.10.3: Allow suspended creators/coordinators to manage
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status IN ('active', 'suspended')
                `, [groupId, authUser.userId]);

                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para ejecutar distribuciones en este grupo');
                    return;
                }

                // VALIDATION: Check tanda is active and lottery executed (Added 2025-12-31)
                const tandaCheck = await dbPostgres.pool.query(`
                    SELECT t.tanda_id, t.status, t.lottery_executed_at, t.turns_order, t.current_turn
                    FROM tandas t
                    WHERE t.group_id = $1 ORDER BY t.created_at DESC LIMIT 1
                `, [groupId]);

                if (tandaCheck.rows.length === 0 || tandaCheck.rows[0].status === 'recruiting') {
                    sendError(res, 400, 'La tanda aún no ha iniciado. No se puede ejecutar la distribución.');
                    return;
                }

                if (!tandaCheck.rows[0].lottery_executed_at) {
                    sendError(res, 400, 'La tómbola no ha sido ejecutada. Las posiciones deben ser asignadas primero.');
                    return;
                }

                const turnsOrder = tandaCheck.rows[0].turns_order || [];
                const tandaId = tandaCheck.rows[0].tanda_id;

                // Get group and verify
                const groupResult = await dbPostgres.pool.query(`
                    SELECT g.group_id, g.name, g.contribution_amount, g.frequency, g.max_members,
                           g.current_cycle, g.commission_rate, g.admin_id, g.status,
                           (SELECT COUNT(*) FROM group_members WHERE group_id = g.group_id AND status = 'active') as active_member_count,
                           (SELECT SUM(COALESCE(num_positions, 1)) FROM group_members WHERE group_id = g.group_id AND status = 'active') as active_positions
                    FROM groups g WHERE g.group_id = $1
                `, [groupId]);

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                const group = groupResult.rows[0];
                const maxMembers = parseInt(group.max_members) || 0;
                const contributionAmount = parseFloat(group.contribution_amount) || 0;
                const activePositions = parseInt(group.active_positions) || 0;

                // v4.10.8: Target total based on max_members
                const targetTotal = maxMembers * contributionAmount;

                // v4.10.8: Distribution cycle from cycle_distributions (not groups.current_cycle)
                const distResult = await dbPostgres.pool.query(
                    'SELECT COALESCE(MAX(cycle_number), 0) + 1 AS next_dist_cycle FROM cycle_distributions WHERE group_id = $1',
                    [groupId]
                );
                const nextDistCycle = distResult.rows[0].next_dist_cycle;

                // v4.10.8: Beneficiary from turns_order[nextDistCycle - 1]
                const turnIndex = nextDistCycle - 1;
                let finalBeneficiary = null;

                if (turnIndex < turnsOrder.length) {
                    const turnEntry = turnsOrder[turnIndex];
                    try {
                        const parsed = typeof turnEntry === 'string' ? JSON.parse(turnEntry) : turnEntry;
                        finalBeneficiary = parsed.user_id || parsed;
                    } catch (e) {
                        finalBeneficiary = turnEntry;
                    }
                }

                if (!finalBeneficiary) {
                    sendError(res, 400, 'No se pudo determinar el beneficiario para el turno ' + nextDistCycle);
                    return;
                }

                // Get contributions summary
                const contribResult = await dbPostgres.pool.query(`
                    SELECT
                        COUNT(*) as total_contributions,
                        SUM(amount) as total_collected,
                        SUM(CASE WHEN payment_method = 'cash' THEN amount ELSE 0 END) as cash_collected,
                        SUM(CASE WHEN payment_method != 'cash' THEN amount ELSE 0 END) as transfer_collected
                    FROM contributions
                    WHERE group_id = $1 AND status IN ('completed', 'coordinator_approved', 'archived')
                `, [groupId]);

                const contrib = contribResult.rows[0];
                const totalCollected = parseFloat(contrib.total_collected) || 0;
                const cashCollected = parseFloat(contrib.cash_collected) || 0;
                const transferCollected = parseFloat(contrib.transfer_collected) || 0;
                const totalContributions = parseInt(contrib.total_contributions) || 0;

                if (totalContributions < activePositions) {
                    sendError(res, 400, 'No todas las contribuciones han sido completadas');
                    return;
                }

                // v4.10.8: Fees based on targetTotal
                let commissionRate;
                const groupCommissionRate = group.commission_rate;
                if (groupCommissionRate !== null && groupCommissionRate !== undefined) {
                    commissionRate = parseFloat(groupCommissionRate) / 100;
                } else {
                    commissionRate = 0.03;
                    if (targetTotal >= 100000) commissionRate = 0.01;
                    else if (targetTotal >= 50000) commissionRate = 0.02;
                }

                const isCoordinatorTurn = finalBeneficiary === group.admin_id;
                const coordinatorFee = targetTotal * commissionRate;
                const platformFee = coordinatorFee * 0.10;
                const coordinatorNet = isCoordinatorTurn ? 0 : (coordinatorFee - platformFee);
                const beneficiaryNet = isCoordinatorTurn ? (targetTotal - platformFee) : (targetTotal - coordinatorFee);

                // v4.10.8: Wrap in transaction to prevent double-distribution
                const client = await dbPostgres.pool.connect();
                try {
                    await client.query('BEGIN');

                    // Lock: check no distribution already exists for this cycle
                    const dupCheck = await client.query(
                        'SELECT id FROM cycle_distributions WHERE group_id = $1 AND cycle_number = $2 FOR UPDATE',
                        [groupId, nextDistCycle]
                    );
                    if (dupCheck.rows.length > 0) {
                        await client.query('ROLLBACK');
                        sendError(res, 409, 'La distribución del ciclo ' + nextDistCycle + ' ya fue ejecutada');
                        return;
                    }

                    // Create distribution record with target_total
                    const distributionResult = await client.query(`
                        INSERT INTO cycle_distributions (
                            group_id, cycle_number, beneficiary_user_id,
                            total_collected, target_total, platform_fee, coordinator_fee, coordinator_net,
                            net_amount, cash_amount, transfer_amount,
                            member_count, contribution_amount,
                            status, transfer_reference, distributed_at
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, 'completed', $14, NOW())
                        RETURNING id
                    `, [
                        groupId, nextDistCycle, finalBeneficiary,
                        totalCollected, targetTotal, platformFee, coordinatorFee, coordinatorNet,
                        beneficiaryNet, cashCollected, transferCollected,
                        activePositions, group.contribution_amount || 0,
                        transfer_reference || null
                    ]);

                    // Archive current contributions
                    await client.query(`
                        UPDATE contributions
                        SET status = 'archived', notes = COALESCE(notes, '') || ' [Ciclo ' || $2 || ' completado]'
                        WHERE group_id = $1 AND status IN ('completed', 'coordinator_approved')
                    `, [groupId, nextDistCycle]);

                    // v4.10.8: Increment tandas.current_turn (NOT groups.current_cycle — record-bulk handles that)
                    await client.query(`
                        UPDATE tandas SET current_turn = current_turn + 1, updated_at = NOW()
                        WHERE tanda_id = $1
                    `, [tandaId]);

                    await client.query('COMMIT');

                    log('info', 'Cycle distribution executed', {
                        group_id: groupId,
                        distribution_cycle: nextDistCycle,
                        beneficiary: finalBeneficiary,
                        target_total: targetTotal,
                        total_collected: totalCollected,
                        executed_by
                    });

                    // v4.11.0: Notify beneficiary (in-app + email)
                    notificationsUtils.createNotification(dbPostgres.pool, finalBeneficiary, 'distribution_executed',
                        'Distribucion Completada',
                        'Recibiste la distribucion del ciclo ' + nextDistCycle + ' en ' + group.name + '.',
                        { group_id: groupId, cycle_number: nextDistCycle, amount: beneficiaryNet }
                    ).catch(function(){});

                    (async function() {
                        try {
                            var prefResult = await dbPostgres.pool.query(
                                "SELECT email_enabled, payment_reminders FROM notification_preferences WHERE user_id = ",
                                [finalBeneficiary]
                            );
                            var emailOk = !prefResult.rows.length || prefResult.rows[0].email_enabled !== false;
                            if (emailOk) {
                                var bInfo = await dbPostgres.pool.query(
                                    "SELECT email, name FROM users WHERE user_id = ",
                                    [finalBeneficiary]
                                );
                                if (bInfo.rows[0] && bInfo.rows[0].email) {
                                    var tpl = emailTemplates.distributionExecutedEmail({
                                        beneficiaryName: bInfo.rows[0].name || 'Miembro',
                                        beneficiaryEmail: bInfo.rows[0].email,
                                        groupName: group.name || 'Grupo',
                                        grossAmount: targetTotal,
                                        netAmount: beneficiaryNet,
                                        coordinatorFee: coordinatorFee,
                                        platformFee: platformFee,
                                        cycle: nextDistCycle,
                                        date: new Date()
                                    });
                                    sendEmail(bInfo.rows[0].email, tpl.subject, tpl.html, 'pagos');
                                }
                            }
                        } catch (emailErr) { /* non-blocking */ }
                    })();

                    sendSuccess(res, {
                        distribution_id: distributionResult.rows[0].id,
                        cycle_number: nextDistCycle,
                        beneficiary_user_id: finalBeneficiary,
                        target_total: targetTotal,
                        total_collected: totalCollected,
                        coordinator_net: coordinatorNet,
                        beneficiary_net: beneficiaryNet,
                        next_distribution_cycle: nextDistCycle + 1,
                        status: 'completed',
                        message: 'Distribucion ejecutada exitosamente'
                    });
                } catch (txError) {
                    await client.query('ROLLBACK');
                    throw txError;
                } finally {
                    client.release();
                }
            } catch (error) {
                log('error', 'Error executing distribution: ' + String(error.message) + ' | Stack: ' + String(error.stack));
                sendError(res, 500, 'Error al ejecutar distribucion');
            }
            return;
        }


        // v4.10.8: Get tanda balances (administrative tracking)
        if (pathname.match(/^\/api\/groups\/[^/]+\/tanda-balances$/) && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const groupId = pathname.split('/')[3];

            try {
                // Verify membership or admin
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status IN ('active', 'suspended')
                `, [groupId, authUser.userId]);

                const isAdmin = authUser.role === 'admin';
                if (permCheck.rows.length === 0 && !isAdmin) {
                    sendError(res, 403, 'No tienes acceso a este grupo');
                    return;
                }

                // Group info
                const groupResult = await dbPostgres.pool.query(`
                    SELECT g.group_id, g.name, g.max_members, g.contribution_amount
                    FROM groups g WHERE g.group_id = $1
                `, [groupId]);

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                const group = groupResult.rows[0];
                const maxMembers = parseInt(group.max_members) || 0;
                const contributionAmount = parseFloat(group.contribution_amount) || 0;
                const targetPerCycle = maxMembers * contributionAmount;

                // All contributions per member (completed + archived)
                const contribResult = await dbPostgres.pool.query(`
                    SELECT user_id, SUM(amount) as total_contributed, COUNT(*) as payments
                    FROM contributions
                    WHERE group_id = $1 AND status IN ('completed', 'coordinator_approved', 'archived')
                    GROUP BY user_id
                `, [groupId]);

                const contribMap = {};
                for (const row of contribResult.rows) {
                    contribMap[row.user_id] = {
                        total: parseFloat(row.total_contributed) || 0,
                        payments: parseInt(row.payments) || 0
                    };
                }

                // Distributions received per member (as beneficiary)
                const distribResult = await dbPostgres.pool.query(`
                    SELECT beneficiary_user_id,
                           SUM(COALESCE(target_total, total_collected)) as total_received,
                           COUNT(*) as times_received
                    FROM cycle_distributions
                    WHERE group_id = $1 AND status = 'completed'
                    GROUP BY beneficiary_user_id
                `, [groupId]);

                const distribMap = {};
                for (const row of distribResult.rows) {
                    distribMap[row.beneficiary_user_id] = {
                        total: parseFloat(row.total_received) || 0,
                        times: parseInt(row.times_received) || 0
                    };
                }

                // Completed distribution count
                const distCountResult = await dbPostgres.pool.query(
                    'SELECT COUNT(*) as dist_count FROM cycle_distributions WHERE group_id = $1 AND status = $2',
                    [groupId, 'completed']
                );
                const distributionsCompleted = parseInt(distCountResult.rows[0].dist_count) || 0;

                // Active members
                const membersResult = await dbPostgres.pool.query(`
                    SELECT gm.user_id, gm.turn_position, gm.num_positions, gm.role,
                           u.name, u.avatar_url
                    FROM group_members gm
                    LEFT JOIN users u ON gm.user_id = u.user_id
                    WHERE gm.group_id = $1 AND gm.status = 'active'
                    ORDER BY gm.turn_position ASC
                `, [groupId]);

                let totalContributedAll = 0;
                let totalDistributedAll = 0;
                let totalPositions = 0;

                const members = membersResult.rows.map(m => {
                    const contributed = contribMap[m.user_id]?.total || 0;
                    const received = distribMap[m.user_id]?.total || 0;
                    const balance = contributed - received;
                    const numPositions = parseInt(m.num_positions) || 1;

                    totalContributedAll += contributed;
                    totalDistributedAll += received;
                    totalPositions += numPositions;

                    return {
                        user_id: m.user_id,
                        name: m.name || 'Desconocido',
                        avatar_url: m.avatar_url || null,
                        role: m.role,
                        turn_position: m.turn_position,
                        num_positions: numPositions,
                        total_contributed: contributed,
                        total_received: received,
                        tanda_balance: balance,
                        has_received: (distribMap[m.user_id]?.times || 0) > 0,
                        payments_count: contribMap[m.user_id]?.payments || 0
                    };
                });

                sendSuccess(res, {
                    group_id: groupId,
                    group_name: group.name,
                    target_per_cycle: targetPerCycle,
                    distributions_completed: distributionsCompleted,
                    members: members,
                    summary: {
                        total_contributed_all: totalContributedAll,
                        total_distributed_all: totalDistributedAll,
                        positions_filled: totalPositions,
                        positions_total: maxMembers,
                        note: 'Positivo = ahorro acumulado. Negativo = prestamo pendiente'
                    }
                });
            } catch (error) {
                log("error", 'Error fetching tanda balances:', error);
                sendError(res, 500, 'Error al obtener saldos');
            }
            return;
        }


        // Get distribution history for a group
        if (pathname.match(/^\/api\/groups\/[^/]+\/distributions$/) && (method === 'GET' || method === 'HEAD')) {
            // SECURITY: Require JWT authentication (Added 2025-12-31)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }

            const groupId = pathname.split('/')[3];

            try {
                // SECURITY: Verify user is a member of this group (Added 2025-12-31)
                const memberCheck = await dbPostgres.pool.query(`
                    SELECT user_id FROM group_members
                    WHERE group_id = $1 AND user_id = $2 AND status = 'active'
                `, [groupId, authUser.userId]);

                if (memberCheck.rows.length === 0) {
                    sendError(res, 403, 'No eres miembro de este grupo');
                    return;
                }

                const result = await dbPostgres.pool.query(`
                    SELECT cd.id, cd.group_id, cd.cycle_number, cd.beneficiary_user_id, cd.total_collected, cd.platform_fee, cd.coordinator_fee, cd.net_amount, cd.status, cd.distributed_at, cd.created_at, u.name as beneficiary_name
                    FROM cycle_distributions cd
                    LEFT JOIN users u ON cd.beneficiary_user_id = u.user_id
                    WHERE cd.group_id = $1
                    ORDER BY cd.cycle_number DESC
                `, [groupId]);

                sendSuccess(res, {
                    distributions: result.rows,
                    total: result.rows.length
                });
            } catch (error) {
                log("error", 'Error fetching distributions:', error);
                sendError(res, 500, 'Error al obtener historial de distribuciones');
            }
            return;
        }

        // ========== END CYCLE DISTRIBUTION ENDPOINTS ==========

        if (pathname.startsWith("/api/groups/") && !pathname.includes("/update") && !pathname.includes("/members") && !pathname.includes("/notifications") && !pathname.includes("/finances") && !pathname.includes("/join") && !pathname.includes("/my-groups") && !pathname.includes("/position-requests") && !pathname.includes("/approve-position-request") && !pathname.includes("/reject-position-request") && !pathname.includes("/assign-position-manually") && !pathname.includes("/auto-assign-positions") && !pathname.includes("/activate-tanda") && !pathname.includes("/contributions") && !pathname.includes("/export") && !pathname.includes("/stats") && !pathname.includes("/calendar") && !pathname.includes("/start-summary") && !pathname.includes("/settings") && !pathname.includes("/lottery-schedule") && !pathname.includes("/lottery-status") && !pathname.includes("/lottery-results") && !pathname.includes("/lottery-assign") && !pathname.includes("/lottery-live") && !pathname.includes("/toggle-pause") && !pathname.includes("/payout") && !pathname.includes("/extensions") && !pathname.includes("/mark-mora") && !pathname.includes("/tanda-balances") && method === "GET") {
            const groupId = pathname.split("/")[3];

            // SECURITY: Require authentication (v4.10.1)
            const authUserGD = requireAuth(req, res);
            if (!authUserGD) return;
            
            log("info", `Fetching group details: ${groupId}`);
            
            // Check PostgreSQL first, then JSON
            let group = null;
            try {
                group = await db.getGroupById(groupId);
            } catch (e) {
                log("warn", "PostgreSQL fetch failed, falling back to JSON", { error: e.message });
            }
            
            if (!group) {
                group = database.groups.find(g => g.id === groupId);
            }
            
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            
            // SECURITY: Check membership (group member, group admin, or platform admin)
            const gdMemberCheck = await dbPostgres.pool.query(
                "SELECT 1 FROM group_members WHERE group_id = $1 AND user_id = $2 AND status NOT IN ('removed', 'rejected') UNION SELECT 1 FROM groups WHERE group_id = $1 AND admin_id = $2",
                [groupId, authUserGD.userId]
            );
            if (gdMemberCheck.rows.length === 0 && authUserGD.role !== 'admin') {
                sendError(res, 403, "No tienes acceso a este grupo");
                return;
            }

            sendSuccess(res, { data: group });
            return;
        }

        // Join a group (for invitation acceptance)
        if (pathname.startsWith("/api/groups/") && pathname.endsWith("/join") && method === "POST") {
            // ============================================
            // SECURITY: Require JWT authentication (Added 2025-12-31)
            // ============================================
            const authUserJoin = requireAuth(req, res);
            if (!authUserJoin) return;

            const groupId = pathname.split("/")[3];
            const { userName, userEmail } = body; const userId = authUserJoin.userId; // Use authenticated user
            
            log("info", `User joining group: ${groupId}`, { userId, userName });
            
            // Validate group exists
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            
            // Check if group is full
            if (group.member_count >= group.max_members) {
                sendError(res, 400, "El grupo está lleno");
                return;
            }
            
            // Check if group is active
            if (group.status !== "active") {
                sendError(res, 400, "El grupo no está activo");
                return;
            }
            
            // Initialize members array if it does not exist
            if (!database.groupMembers) {
                database.groupMembers = [];
            }
            
            // Check if user is already a member
            const existingMember = database.groupMembers.find(
                m => m.group_id === groupId && m.user_id === userId
            );
            
            if (existingMember) {
                sendError(res, 400, "Ya eres miembro de este grupo");
                return;
            }
            
            // Add user to group
            const newMember = {
                id: generateId("member"),
                group_id: groupId,
                id: userId,  // Changed from user_id to id
                user_name: userName,
                user_email: userEmail,
                joined_at: new Date().toISOString(),
                status: "active",
                payment_status: "pending",
                total_paid: 0
            };
            
            database.groupMembers.push(newMember);
            
            // Update group member count
            group.member_count = (group.member_count || 1) + 1;
            
            // Save database
            saveDatabase();
            
            log("info", `User ${userId} successfully joined group ${groupId}`);
            
            // Audit log
            const joinInfo = getClientInfo(req);
            auditLog("GROUP_JOINED", { userId: userId, resource: "groups", resourceId: groupId, ip: joinInfo.ip, userAgent: joinInfo.userAgent, extra: { group_name: group.name } });
            
            sendSuccess(res, {
                message: "Te has unido al grupo exitosamente",
                data: {
                    membership: newMember,
                    group: {
                        id: group.id,
                        name: group.name,
                        member_count: group.member_count,
                        max_members: group.max_members
                    }
                }
            });
            return;
        }

        // Group members management endpoints (NUEVOS)

        // GET /api/users/search-to-invite - Search users to invite to a group
        if (pathname === "/api/users/search-to-invite" && method === "GET") {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const urlParams = new URL(req.url, "http://localhost").searchParams;
            const query = urlParams.get("q") || "";
            const groupId = urlParams.get("group_id");
            const limit = parseInt(urlParams.get("limit")) || 10;

            if (!query || query.length < 2) {
                sendSuccess(res, { users: [] });
                return;
            }

            log("info", "Searching users to invite", { query, groupId, by: authUser.userId });

            try {
                const searchPattern = "%" + query.toLowerCase() + "%";

                // Search users excluding: current user, already members of the group, already invited
                let excludeClause = "AND u.user_id != $2";
                let params = [searchPattern, authUser.userId, limit];

                if (groupId) {
                    excludeClause += " AND u.user_id NOT IN (SELECT user_id FROM group_members WHERE group_id = $4 AND status IN ('active', 'pending'))";
                    excludeClause += " AND u.user_id NOT IN (SELECT invitee_user_id FROM group_invitations WHERE group_id = $4 AND status = 'pending' AND invitee_user_id IS NOT NULL)";
                    params = [searchPattern, authUser.userId, limit, groupId];
                }

                const result = await dbPostgres.pool.query(
                    `SELECT user_id, name, email,
                            CASE WHEN email_verified THEN 'verified' ELSE 'unverified' END as status
                     FROM users u
                     WHERE (LOWER(name) LIKE $1 OR LOWER(email) LIKE $1)
                     AND u.status != 'deleted'
                     ${excludeClause}
                     ORDER BY name ASC
                     LIMIT $3`,
                    params
                );

                // Mask email for privacy (show first 3 chars + domain)
                // v4.1.0: Removed full email from response (was leaking PII)
                const users = result.rows.map(u => ({
                    user_id: u.user_id,
                    name: u.name,
                    email_masked: u.email ? u.email.replace(/^(.{3}).*@/, "$1***@") : '',
                    status: u.status
                }));

                sendSuccess(res, { users });
            } catch (error) {
                log("error", "Error searching users", { error: error.message });
                sendError(res, 500, "Error al buscar usuarios");
            }
            return;
        }

        // ============================================
        // GET /api/users/by-handle/:handle - Lookup user by handle
        // Added: 2026-02-03 for @mentions support
        // ============================================
        if (pathname.match(/^\/api\/users\/by-handle\/[\w\-\.]+$/) && (method === 'GET' || method === 'HEAD')) {
            const handle = pathname.split('/')[4].toLowerCase();

            try {
                const result = await dbPostgres.pool.query(
                    `SELECT user_id, name, email, avatar_url, verification_level, handle
                     FROM users 
                     WHERE LOWER(handle) = $1
                     LIMIT 1`,
                    [handle]
                );

                if (result.rows.length === 0) {
                    sendResponse(res, 404, { success: false, message: 'Usuario no encontrado' });
                    return;
                }

                const user = result.rows[0];
                sendResponse(res, 200, {
                    success: true,
                    data: {
                        user_id: user.user_id,
                        name: user.name,
                        avatar_url: user.avatar_url,
                        verification_level: user.verification_level,
                        handle: user.handle || handle
                    }
                });
            } catch (error) {
                log('error', '[USERS] Handle lookup error: ' + error.message);
                sendError(res, 500, 'Error buscando usuario');
            }
            return;
        }

        // ============================================
        // GET /api/users/search-mentions - Search users for @mention autocomplete
        // Added: 2026-02-03
        // ============================================
        if (pathname === '/api/users/search-mentions' && (method === 'GET' || method === 'HEAD')) {
            // Require authentication
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const searchQuery = (query.q || '').toLowerCase().trim();
            const limit = Math.min(parseInt(query.limit) || 5, 10);

            if (!searchQuery || searchQuery.length < 1) {
                sendResponse(res, 200, { success: true, data: { users: [] } });
                return;
            }

            try {
                const searchPattern = searchQuery + '%';
                
                const result = await dbPostgres.pool.query(
                    `SELECT user_id, name, handle, avatar_url, verification_level
                     FROM users
                     WHERE status = 'active'
                       AND (LOWER(handle) LIKE $1 
                            OR LOWER(name) LIKE $1)
                     ORDER BY 
                       CASE WHEN LOWER(handle) LIKE $1 THEN 0 ELSE 1 END,
                       name ASC
                     LIMIT $2`,
                    [searchPattern, limit]
                );

                const users = result.rows.map(u => ({
                    user_id: u.user_id,
                    name: u.name,
                    handle: u.handle || u.name.toLowerCase().replace(/\s+/g, ''),
                    avatar_url: u.avatar_url,
                    verified: u.verification_level && parseInt(u.verification_level) >= 2
                }));

                sendResponse(res, 200, { success: true, data: { users } });
            } catch (error) {
                log('error', '[USERS] Mention search error: ' + error.message);
                sendError(res, 500, 'Error buscando usuarios');
            }
            return;
        }
                if (pathname.startsWith('/api/groups/') && pathname.includes('/members/invite') && method === 'POST') {
            const groupId = pathname.split('/')[3];
            // Require authentication
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const {
                email,
                phone,
                name,
                user_id: inviteeUserId,  // For inviting existing users
                message = 'Te invitan a unirte a nuestro grupo de ahorro',
                is_reusable = false,
                max_uses = null,
            } = body;

            log('info', `Inviting member to group: ${groupId}`, { email, phone, invitedBy: authUser.userId });

            try {
                // Verify group exists
                const group = await db.getGroupById(groupId);
                if (!group) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                // ============================================
                // SECURITY: Verify user has permission to invite (Added 2025-12-31)
                // v4.10.3: Allow suspended creators/coordinators to invite
                // ============================================
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status IN ('active', 'suspended')
                `, [groupId, authUser.userId]);

                if (permCheck.rows.length === 0) {
                    sendError(res, 403, 'No eres miembro de este grupo');
                    return;
                }

                // Only creator, coordinator, admin, or members with invite permission can invite
                const userRole = permCheck.rows[0].role;
                if (!['creator', 'coordinator', 'admin', 'member'].includes(userRole)) {
                    sendError(res, 403, 'No tienes permisos para invitar miembros');
                    return;
                }

                // ============================================
                // VALIDATION: Check if group is full (Added 2025-12-31)
                // ============================================
                const memberCount = await dbPostgres.pool.query(`
                    SELECT COUNT(*) as count FROM group_members
                    WHERE group_id = $1 AND status IN ('active', 'pending')
                `, [groupId]);

                if (parseInt(memberCount.rows[0].count) >= (group.max_members || 50)) {
                    sendError(res, 400, 'El grupo está lleno. No se pueden enviar más invitaciones.');
                    return;
                }

                // ============================================
                // DISABLED:                 // VALIDATION: Check if tanda has started (Added 2025-12-31)
                // DISABLED:                 // ============================================
                // DISABLED:                 const tandaCheck = await dbPostgres.pool.query(`
                // DISABLED:                     SELECT lottery_executed_at FROM tandas
                // DISABLED:                     WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
                // DISABLED:                 `, [groupId]);
                // DISABLED: 
                // DISABLED:                 if (tandaCheck.rows.length > 0 && tandaCheck.rows[0].lottery_executed_at) {
                // DISABLED:                     sendError(res, 400, 'No se pueden enviar invitaciones después de que la tanda ha iniciado');
                // DISABLED:                     return;
                // DISABLED:                 }
                // DISABLED: 
                // Check if inviting an existing user
                let inviteeName = name;
                let inviteeEmail = email;

                if (inviteeUserId) {
                    // Verify the user exists
                    const userCheck = await dbPostgres.pool.query(
                        "SELECT user_id, name, email FROM users WHERE user_id = $1 AND status != 'deleted'",
                        [inviteeUserId]
                    );

                    if (userCheck.rows.length === 0) {
                        sendError(res, 404, 'Usuario no encontrado');
                        return;
                    }

                    // Check if user is already a member
                    const memberCheck = await dbPostgres.pool.query(
                        "SELECT 1 FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'pending')",
                        [groupId, inviteeUserId]
                    );

                    if (memberCheck.rows.length > 0) {
                        sendError(res, 400, 'Este usuario ya es miembro del grupo');
                        return;
                    }

                    // Check if already has a pending invitation
                    const inviteCheck = await dbPostgres.pool.query(
                        "SELECT 1 FROM group_invitations WHERE group_id = $1 AND invitee_user_id = $2 AND status = 'pending'",
                        [groupId, inviteeUserId]
                    );

                    if (inviteCheck.rows.length > 0) {
                        sendError(res, 400, 'Este usuario ya tiene una invitación pendiente');
                        return;
                    }

                    inviteeName = userCheck.rows[0].name;
                    inviteeEmail = userCheck.rows[0].email;
                }

                // Create invitation in database
                const invitation = await db.createGroupInvitation({
                    group_id: groupId,
                    inviter_id: authUser.userId,
                    invitee_email: inviteeEmail || null,
                    invitee_phone: phone || null,
                    invitee_name: inviteeName || null,
                    invitee_user_id: inviteeUserId || null,
                    message: message,
                    is_reusable: inviteeUserId ? false : is_reusable,  // Direct invites are not reusable
                    max_uses: inviteeUserId ? 1 : max_uses
                });

                // If inviting an existing user, send them a notification
                if (inviteeUserId) {
                    const inviterResult = await dbPostgres.pool.query(
                        "SELECT name FROM users WHERE user_id = $1",
                        [authUser.userId]
                    );
                    const inviterName = inviterResult.rows[0]?.name || 'Alguien';

                    await createNotification(
                        inviteeUserId,
                        'group_invitation',
                        'Nueva invitación a grupo',
                        inviterName + ' te ha invitado a unirte al grupo "' + group.name + '"',
                        {
                            group_id: groupId,
                            invitation_id: invitation.id,
                            invitation_token: invitation.token,
                            inviter_id: authUser.userId
                        }
                    );

                    log("info", "Notification sent for direct invitation", {
                        inviteeUserId,
                        groupId,
                        invitationId: invitation.id
                    });

                    // Send email notification to invited user
                    if (inviteeEmail) {
                        const inviteLink = `https://latanda.online/invite/${invitation.token}`;
                        const emailHtml = `
                            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
                                <div style="text-align: center; margin-bottom: 30px;">
                                    <h1 style="color: #7c3aed; margin: 0;">La Tanda</h1>
                                    <p style="color: #6b7280; font-size: 14px;">Tu plataforma de ahorro grupal</p>
                                </div>
                                <div style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); padding: 20px; border-radius: 12px; text-align: center; margin-bottom: 20px;">
                                    <h2 style="color: white; margin: 0 0 10px;">¡Te han invitado a un grupo!</h2>
                                </div>
                                <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                                    <p style="margin: 0 0 15px; color: #374151;">Hola <strong>${inviteeName || 'Usuario'}</strong>,</p>
                                    <p style="margin: 0 0 15px; color: #374151;"><strong>${inviterName}</strong> te ha invitado a unirte al grupo "<strong>${group.name}</strong>" en La Tanda.</p>
                                    ${message ? `<p style="margin: 0 0 15px; color: #6b7280; font-style: italic;">Mensaje: "${message}"</p>` : ''}
                                    <p style="margin: 0; color: #374151;">Haz clic en el siguiente enlace para ver la invitación:</p>
                                </div>
                                <div style="text-align: center; margin-bottom: 20px;">
                                    <a href="${inviteLink}" style="display: inline-block; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; padding: 14px 28px; border-radius: 8px; text-decoration: none; font-weight: 600;">Ver Invitación</a>
                                </div>
                                <p style="color: #9ca3af; font-size: 12px; text-align: center;">Si no solicitaste esta invitación, puedes ignorar este correo.</p>
                                <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 20px 0;">
                                <p style="color: #9ca3af; font-size: 11px; text-align: center;">© 2026 La Tanda - Ahorro Grupal Seguro</p>
                            </div>
                        `;

                        await sendEmail(inviteeEmail, '🎉 Te invitaron a un grupo en La Tanda', emailHtml, 'security');
                        log("info", "Email sent for group invitation", { inviteeEmail, groupId });
                    }
                }

                // Generate invitation link
                const inviteLink = `https://latanda.online/invite/${invitation.token}`;

                sendSuccess(res, {
                    message: `Invitación creada exitosamente`,
                    invitation_id: invitation.id,
                    token: invitation.token,
                    invite_link: inviteLink,
                    status: 'pending',
                    is_reusable: invitation.is_reusable,
                    max_uses: invitation.max_uses,
                    expires_at: invitation.expires_at
                });
            } catch (error) {
                log('error', 'Error creating invitation', { groupId, error: error.message });
                sendError(res, 500, 'Error al crear invitación');
            }
            return;
        }


        // POST /api/groups/:groupId/invitations/:invitationId/remind - Send reminder
        if (pathname.match(/^\/api\/groups\/[^\/]+\/invitations\/[^\/]+\/remind$/) && method === "POST") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const invitationId = parts[5];

            const authUser = requireAuth(req, res);
            if (!authUser) return;

            log("info", `Sending reminder for invitation: ${invitationId}`, { groupId, userId: authUser.userId });

            try {
                // Verify invitation exists and is pending
                const invResult = await dbPostgres.pool.query(`
                    SELECT gi.id, gi.group_id, gi.inviter_id, gi.invitee_email, gi.invitee_name, gi.status, gi.token, gi.created_at, gi.expires_at, g.name as group_name
                    FROM group_invitations gi
                    JOIN groups g ON gi.group_id = g.group_id
                    WHERE gi.id = $1 AND gi.group_id = $2 AND gi.status = 'pending'
                `, [invitationId, groupId]);

                if (invResult.rows.length === 0) {
                    sendError(res, 404, "Invitación no encontrada");
                    return;
                }

                const invitation = invResult.rows[0];

                // Verify user is a member
                const memberCheck = await dbPostgres.pool.query(`
                    SELECT role FROM group_members
                    WHERE group_id = $1 AND user_id = $2 AND status = 'active'
                `, [groupId, authUser.userId]);

                if (memberCheck.rows.length === 0) {
                    sendError(res, 403, "No eres miembro de este grupo");
                    return;
                }

                // Check 24-hour cooldown
                if (invitation.last_reminded_at) {
                    const hours = (Date.now() - new Date(invitation.last_reminded_at).getTime()) / 3600000;
                    if (hours < 24) {
                        sendError(res, 429, "Intenta de nuevo en 24 horas");
                        return;
                    }
                }

                // Update reminder count
                await dbPostgres.pool.query(`
                    UPDATE group_invitations
                    SET reminder_count = COALESCE(reminder_count, 0) + 1,
                        last_reminded_at = NOW()
                    WHERE id = $1
                `, [invitationId]);

                const inviteLink = `https://latanda.online/invite/${invitation.token}`;

                sendSuccess(res, {
                    message: "Recordatorio registrado",
                    invitation_id: invitationId,
                    invite_link: inviteLink,
                    reminder_count: (invitation.reminder_count || 0) + 1,
                    invitee_name: invitation.invitee_name
                });
            } catch (error) {
                log("error", "Error sending reminder", { invitationId, error: error.message });
                sendError(res, 500, "Error al enviar recordatorio");
            }
            return;
        }

        // DELETE /api/groups/:groupId/invitations/:invitationId - Delete/cancel a pending invitation
        const deleteInvitationMatch = pathname.match(/^\/api\/groups\/([^\/]+)\/invitations\/([^\/]+)$/);
        if (deleteInvitationMatch && method === "DELETE") {
            const groupId = deleteInvitationMatch[1];
            const invitationId = deleteInvitationMatch[2];

            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                // Verify invitation exists and belongs to this user/group
                const invResult = await dbPostgres.pool.query(`
                    SELECT gi.id, gi.status, gi.inviter_id, gi.invitee_name
                    FROM group_invitations gi
                    WHERE gi.id = $1 AND gi.group_id = $2
                `, [invitationId, groupId]);

                if (invResult.rows.length === 0) {
                    sendError(res, 404, 'Invitación no encontrada');
                    return;
                }

                const invitation = invResult.rows[0];

                // Only the inviter or a group admin can delete
                const permCheck = await dbPostgres.pool.query(`
                    SELECT role FROM group_members
                    WHERE group_id = $1 AND user_id = $2 AND status = 'active'
                `, [groupId, authUser.userId]);

                const isInviter = invitation.inviter_id === authUser.userId;
                const isAdmin = permCheck.rows.length > 0 && ['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role);

                if (!isInviter && !isAdmin) {
                    sendError(res, 403, 'No tienes permiso para eliminar esta invitación');
                    return;
                }

                // Only allow deleting pending invitations
                if (invitation.status !== 'pending') {
                    sendError(res, 400, 'Solo se pueden eliminar invitaciones pendientes');
                    return;
                }

                // Delete the invitation
                await dbPostgres.pool.query(`
                    DELETE FROM group_invitations WHERE id = $1
                `, [invitationId]);

                log("info", "Invitation deleted", { invitationId, groupId, deletedBy: authUser.userId });

                sendSuccess(res, {
                    message: 'Invitación eliminada exitosamente',
                    invitation_id: invitationId
                });
            } catch (error) {
                log("error", "Error deleting invitation: " + error.message);
                sendError(res, 500, "Error al eliminar invitación");
            }
            return;
        }

        // GET /api/groups/:groupId/export/members - Export members as PDF or CSV
        if (pathname.match(/^\/api\/groups\/[^\/]+\/export\/members$/) && method === 'GET') {
            // v4.10.3: Require auth + membership check
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const groupId = pathname.split('/')[3];
            const urlParts = parseUrl(req.url);
            const format = urlParts.query.format || 'pdf';

            log('info', 'Exporting members', { groupId, format });

            try {
                // Membership check
                const memCheck = await dbPostgres.pool.query(
                    "SELECT 1 FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = 'active'",
                    [groupId, authUser.userId]
                );
                if (memCheck.rows.length === 0 && authUser.role !== 'admin') {
                    sendError(res, 403, 'No tienes acceso a este grupo');
                    return;
                }

                const groupResult = await dbPostgres.pool.query(
                    'SELECT g.group_id, g.name, g.contribution_amount, g.frequency, g.member_count, g.max_members, g.total_amount_collected, g.admin_id, g.status, g.created_at, g.location, g.description, g.image_url, g.category, g.meeting_schedule, g.updated_at, g.is_demo, g.start_date, g.grace_period, g.penalty_amount, g.current_cycle, g.lottery_executed, g.lottery_executed_at, g.lottery_scheduled_at, g.deleted_at, g.deleted_by, g.approval_settings, g.last_recruitment_notification_at, t.status as tanda_status FROM groups g LEFT JOIN (SELECT DISTINCT ON (group_id) group_id, status FROM tandas ORDER BY group_id, created_at DESC) t ON g.group_id = t.group_id WHERE g.group_id = $1',
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                
                const groupData = groupResult.rows[0];
                
                const membersResult = await dbPostgres.pool.query(
                    `SELECT gm.id, gm.group_id, gm.user_id, gm.role, gm.status, gm.turn_position, gm.joined_at, gm.num_positions, gm.is_anonymous, gm.display_name, u.name
                     FROM group_members gm
                     LEFT JOIN users u ON gm.user_id = u.user_id
                     WHERE gm.group_id = $1 AND gm.status != 'left'
                     ORDER BY gm.role DESC, gm.joined_at ASC`,
                    [groupId]
                );
                
                const members = membersResult.rows;
                
                let result;
                if (format === 'csv') {
                    result = await exportUtils.generateMembersCSV(groupData, members);
                } else {
                    result = await exportUtils.generateMembersPDF(groupData, members);
                }
                
                const fileContent = fs.readFileSync(result.filepath);
                const contentType = format === 'csv' ? 'text/csv' : 'application/pdf';
                
                res.writeHead(200, {
                    'Content-Type': contentType,
                    'Content-Disposition': 'attachment; filename="' + result.filename + '"',
                    'Content-Length': fileContent.length,
                    'Access-Control-Allow-Origin': 'https://latanda.online'
                });
                res.end(fileContent);
                
                setTimeout(function() {
                    try { fs.unlinkSync(result.filepath); } catch(e) {}
                }, 5000);
                
                return;
            } catch (error) {
                log('error', 'Export members failed', { error: error.message, groupId });
                sendError(res, 500, 'Error al exportar miembros');
                return;
            }
        }

        // Get group members list (PostgreSQL)

        if (pathname.startsWith("/api/groups/") && pathname.endsWith("/members") && method === "GET") {
            // SECURITY: Require authentication (v4.10.1)
            const authUserGM = requireAuth(req, res);
            if (!authUserGM) return;

            const groupId = pathname.split("/")[3];
            log("info", "Fetching members for group: " + groupId);
            
            try {
                // Get group info from PostgreSQL
                const group = await db.getGroupById(groupId);
                if (!group) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }
                
                // Get the tanda to calculate real turn positions from turns_order
                const tandaResult = await dbPostgres.pool.query(
                    "SELECT tanda_id, turns_order FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1",
                    [groupId]
                );
                const tanda = tandaResult.rows[0];
                let turnsOrder = tanda && tanda.turns_order ? tanda.turns_order : [];
                
                // Create position map and expanded order from turns_order
                const positionMap = {};
                let expandedOrder = [];
                
                // Check if turns_order is in expanded format (could be objects or JSON strings)
                let parsedTurnsOrder = turnsOrder.map(item => {
                    if (typeof item === 'string') {
                        try { return JSON.parse(item); } catch(e) { return item; }
                    }
                    return item;
                });
                const isExpandedFormat = parsedTurnsOrder.length > 0 && typeof parsedTurnsOrder[0] === 'object' && parsedTurnsOrder[0].user_id;
                if (isExpandedFormat) turnsOrder = parsedTurnsOrder;
                
                if (isExpandedFormat) {
                    // New format: already expanded
                    turnsOrder.forEach(function(item, index) {
                        if (!positionMap[item.user_id]) {
                            positionMap[item.user_id] = index + 1;
                        }
                        expandedOrder.push({ user_id: item.user_id, slot: item.slot || 0, position: index + 1 });
                    });
                } else {
                    // Old format: need to expand based on num_positions from group_members
                    // First, get num_positions for all members
                    const positionsResult = await dbPostgres.pool.query(
                        "SELECT user_id, COALESCE(num_positions, 1) as num_positions, COALESCE(position_locks, '[]'::jsonb) as position_locks FROM group_members WHERE group_id = $1 AND status = 'active'",
                        [groupId]
                    );
                    const memberPositions = {};
                    positionsResult.rows.forEach(r => {
                        memberPositions[r.user_id] = { num: parseInt(r.num_positions) || 1, locks: r.position_locks || [] };
                    });
                    
                    // Now expand turns_order
                    let position = 1;
                    turnsOrder.forEach(function(userId) {
                        const info = memberPositions[userId] || { num: 1, locks: [] };
                        if (!positionMap[userId]) {
                            positionMap[userId] = position;
                        }
                        // Add all positions for this user
                        for (let slot = 0; slot < info.num; slot++) {
                            expandedOrder.push({ user_id: userId, slot: slot, position: position++ });
                        }
                    });
                }
                
                // Get members from PostgreSQL with user details
                const membersResult = await dbPostgres.pool.query(
                    `SELECT 
                        gm.id,
                        gm.user_id,
                        gm.role,
                        gm.status,
                        gm.joined_at,
                        gm.invited_by,
                        gm.turn_position,
                        gm.turn_locked,
                        COALESCE(gm.num_positions, 1) as num_positions,
                        COALESCE(gm.position_locks, '[]'::jsonb) as position_locks,
                        gm.is_anonymous,
                        COALESCE(u.name, 'Usuario') as name,
                        u.email,
                        u.phone,
                        u.telegram_id,
                        u.avatar_url
                    FROM group_members gm
                    LEFT JOIN users u ON gm.user_id = u.user_id
                    WHERE gm.group_id = $1 AND gm.status NOT IN ('left', 'removed', 'rejected')
                    ORDER BY COALESCE(gm.turn_position, 999), gm.joined_at`,
                    [groupId]
                );
                const members = membersResult.rows;
                
                sendSuccess(res, {
                    group_id: groupId,
                    group_name: group.name || group.group_name,
                    members: members.map(m => ({
                        id: m.id,
                        user_id: m.user_id,
                        name: m.name || 'Usuario',
                        email: m.email,
                        phone: m.phone,
                        telegram_id: m.telegram_id,
                        avatar_url: m.avatar_url,
                        role: m.role,
                        status: m.status,
                        joined_at: m.joined_at,
                        invited_by: m.invited_by,
                        turn_position: positionMap[m.user_id] || m.turn_position || null,
                        has_turn_assigned: !!(positionMap[m.user_id] || m.turn_position),
                        is_anonymous: m.is_anonymous || false,
                        turn_locked: m.turn_locked || false,
                        num_positions: parseInt(m.num_positions) || 1,
                        position_locks: m.position_locks || []
                    })),
                    total_members: members.length,
                    turns_assigned: turnsOrder.length,
                    expanded_order: expandedOrder
                });
            } catch (error) {
                log("error", "Error fetching group members", { groupId, error: error.message });
                sendError(res, 500, "Error al obtener miembros del grupo");
            }
            return;
        }
        // ============================================
        // MEMBER ADMIN ACTIONS (Nov 25, 2025)
        // ============================================

        // Change member role (PATCH /api/groups/:groupId/members/:userId/role)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/role$/) && method === "PATCH") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const userId = parts[5];
            const { role } = body;

            log("info", "Changing member role", { groupId, userId, newRole: role });

            try {
                // SECURITY FIX: Require JWT authentication (2025-12-31)
                const authUser = getAuthenticatedUser(req, query);
                if (!authUser) {
                    sendError(res, 401, "Autenticacion requerida");
                    return;
                }
                const requesterId = authUser.userId || authUser.user_id || authUser.id;

                // SECURITY FIX: Verify requester has admin permissions
                // v4.10.3: Allow suspended creators/coordinators to manage
                const requesterResult = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, requesterId]
                );

                if (requesterResult.rows.length === 0 || !["creator", "coordinator", "admin"].includes(requesterResult.rows[0].role)) {
                    sendError(res, 403, "No tienes permisos para cambiar roles de miembros");
                    return;
                }

                // Validate role
                if (!["coordinator", "member"].includes(role)) {
                    sendError(res, 400, "Rol invalido. Use: coordinator o member");
                    return;
                }

                // Get current member to check if they are creator
                // Get ALL members including suspended (for admin actions)
                const membersResult = await dbPostgres.pool.query(
                    "SELECT user_id, role, status FROM group_members WHERE group_id = $1 AND status NOT IN ('removed', 'left')",
                    [groupId]
                );
                const members = membersResult.rows;
                const targetMember = members.find(m => m.user_id === userId);
                
                if (!targetMember) {
                    sendError(res, 404, "Miembro no encontrado");
                    return;
                }

                if (targetMember.role === "creator") {
                    sendError(res, 403, "No se puede cambiar el rol del creador del grupo");
                    return;
                }

                // Update member role
                await db.updateGroupMember(groupId, userId, { role });

                sendSuccess(res, {
                    message: "Rol actualizado exitosamente",
                    member: {
                        user_id: userId,
                        new_role: role
                    }
                });
            } catch (error) {
                log("error", "Error changing member role", { error: error.message });
                sendError(res, 500, "Error al cambiar rol del miembro");
            }
            return;
        }

        // Change member status - suspend/activate (PATCH /api/groups/:groupId/members/:userId/status)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/status$/) && method === "PATCH") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const userId = parts[5];
            const { status } = body;

            log("info", "Changing member status", { groupId, userId, newStatus: status });

            try {
                // SECURITY FIX: Require JWT authentication (2025-12-31)
                const authUser = getAuthenticatedUser(req, query);
                if (!authUser) {
                    sendError(res, 401, "Autenticacion requerida");
                    return;
                }
                const requesterId = authUser.userId || authUser.user_id || authUser.id;

                // SECURITY FIX: Verify requester has admin permissions
                // v4.10.3: Allow suspended creators/coordinators to manage
                const requesterResult = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, requesterId]
                );

                if (requesterResult.rows.length === 0 || !["creator", "coordinator", "admin"].includes(requesterResult.rows[0].role)) {
                    sendError(res, 403, "No tienes permisos para cambiar el estado de miembros");
                    return;
                }

                // Validate status
                if (!["active", "suspended"].includes(status)) {
                    sendError(res, 400, "Estado invalido. Use: active o suspended");
                    return;
                }

                // Get current member to check if they are creator
                // Get ALL members including suspended (for admin actions)
                const membersResult = await dbPostgres.pool.query(
                    "SELECT user_id, role, status FROM group_members WHERE group_id = $1 AND status NOT IN ('removed', 'left')",
                    [groupId]
                );
                const members = membersResult.rows;
                const targetMember = members.find(m => m.user_id === userId);
                
                if (!targetMember) {
                    sendError(res, 404, "Miembro no encontrado");
                    return;
                }

                if (targetMember.role === "creator") {
                    sendError(res, 403, "No se puede suspender al creador del grupo");
                    return;
                }

                // Update member status
                await db.updateGroupMember(groupId, userId, { status });

                sendSuccess(res, {
                    message: status === "suspended" ? "Miembro suspendido" : "Miembro activado",
                    member: {
                        user_id: userId,
                        new_status: status
                    }
                });
            } catch (error) {
                log("error", "Error changing member status", { error: error.message });
                sendError(res, 500, "Error al cambiar estado del miembro");
            }
            return;
        }

        // ============================================
        // APPROVE PENDING MEMBER - POST /api/groups/:groupId/members/:userId/approve
        // Approves a pending member join request
        // ============================================
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/approve$/) && method === 'POST') {
            const parts = pathname.split('/');
            const groupId = parts[3];
            const userId = parts[5];

            log('info', 'Approving pending member', { groupId, userId });

            try {
                // Get auth user
                const authUser = getAuthenticatedUser(req, query);
                if (!authUser) {
                    sendError(res, 401, 'Autenticacion requerida');
                    return;
                }

                // Check if requester is admin/coordinator/creator of the group
                const requesterResult = await dbPostgres.pool.query(
                    'SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = \'active\'',
                    [groupId, authUser.userId || authUser.user_id || authUser.id]
                );
                
                if (requesterResult.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(requesterResult.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para aprobar miembros');
                    return;
                }


                // ============================================
                // VALIDATION: Check if group is full (Added 2025-12-31)
                // ============================================
                const groupCheck = await dbPostgres.pool.query(`
                    SELECT g.max_members, COUNT(gm.id) as active_count
                    FROM groups g
                    LEFT JOIN group_members gm ON g.group_id = gm.group_id AND gm.status = 'active'
                    WHERE g.group_id = $1
                    GROUP BY g.group_id
                `, [groupId]);

                if (groupCheck.rows.length > 0) {
                    const { max_members, active_count } = groupCheck.rows[0];
                    if (parseInt(active_count) >= (max_members || 50)) {
                        sendError(res, 400, 'El grupo está lleno. No se pueden aprobar más miembros.');
                        return;
                    }
                }

                // ============================================
                // VALIDATION: Check if tanda has started (Added 2025-12-31)
                // ============================================
                const tandaCheck = await dbPostgres.pool.query(`
                    SELECT lottery_executed_at FROM tandas
                    WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
                `, [groupId]);

                if (tandaCheck.rows.length > 0 && tandaCheck.rows[0].lottery_executed_at) {
                    sendError(res, 400, 'No se pueden aprobar miembros después de que la tanda ha iniciado');
                    return;
                }

                // Check if pending member exists
                const memberResult = await dbPostgres.pool.query(
                    'SELECT id, group_id, user_id, role, status, joined_at, left_at, invited_by, notes, created_at, updated_at, turn_position, is_anonymous, display_name, approved_by, approved_at, removed_by, removed_at, removal_reason, position, turn_locked, turn_locked_by, turn_locked_at, num_positions, rejected_by, rejected_at, rejection_reason, position_locks, last_notified_payment_status, last_payment_notification_at FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = \'pending\'',
                    [groupId, userId]
                );

                if (memberResult.rows.length === 0) {
                    sendError(res, 404, 'Solicitud pendiente no encontrada');
                    return;
                }

                // Update member status to active
                await dbPostgres.pool.query(
                    'UPDATE group_members SET status = \'active\', approved_by = $1, approved_at = NOW(), updated_at = NOW() WHERE group_id = $2 AND user_id = $3',
                    [authUser.userId || authUser.user_id || authUser.id, groupId, userId]
                );

                // Get user info for response
                const userResult = await dbPostgres.pool.query(
                    'SELECT name, email FROM users WHERE user_id = $1',
                    [userId]
                );
                const userName = userResult.rows[0]?.name || 'Usuario';

                // Create notification for the approved user
                try {
                    await dbPostgres.pool.query(
                        'INSERT INTO notifications (user_id, type, title, message, data, created_at) VALUES ($1, $2, $3, $4, $5, NOW())',
                        [userId, 'group_joined', 'Solicitud Aprobada', 'Tu solicitud para unirte al grupo ha sido aprobada.', JSON.stringify({ group_id: groupId })]
                    );
                    
                    // Notify the person who invited if there was one (referral success)
                    const inviterCheck = await dbPostgres.pool.query(
                        'SELECT invited_by FROM group_members WHERE group_id = $1 AND user_id = $2',
                        [groupId, userId]
                    );
                    
                    if (inviterCheck.rows.length > 0 && inviterCheck.rows[0].invited_by) {
                        const inviterId = inviterCheck.rows[0].invited_by;
                        const groupNameResult = await dbPostgres.pool.query(
                            'SELECT name FROM groups WHERE group_id = $1',
                            [groupId]
                        );
                        const groupNameForNotif = groupNameResult.rows[0]?.name || 'el grupo';
                        
                        await dbPostgres.pool.query(
                            'INSERT INTO notifications (user_id, type, title, message, data, created_at) VALUES ($1, $2, $3, $4, $5, NOW())',
                            [
                                inviterId, 
                                'referral_success', 
                                '🎉 ¡Tu invitado se unió!',
                                userName + ' aceptó tu invitación y se unió a "' + groupNameForNotif + '". ¡Gracias por ayudar a crecer el grupo!',
                                JSON.stringify({ group_id: groupId, new_member: userId, new_member_name: userName })
                            ]
                        );
                        log('info', 'Referral success notification sent', { inviterId, newMember: userId, groupId });
                    }
                } catch (notifErr) {
                    log('warn', 'Failed to create notification', { error: notifErr.message });
                }

                log('info', 'Member approved successfully', { groupId, userId, approvedBy: authUser.userId || authUser.user_id || authUser.id });

                sendSuccess(res, {
                    message: 'Miembro aprobado exitosamente',
                    member: {
                        user_id: userId,
                        name: userName,
                        status: 'active',
                        approved_by: authUser.userId || authUser.user_id || authUser.id,
                        approved_at: new Date().toISOString()
                    }
                });
            } catch (error) {
                log('error', 'Error approving member', { error: error.message, groupId, userId });
                log('info', 'error', 'Error al aprobar miembro', { error: error.message }); sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // ============================================
        // REJECT PENDING MEMBER - POST /api/groups/:groupId/members/:userId/reject
        // Rejects a pending member join request
        // ============================================
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/reject$/) && method === 'POST') {
            const parts = pathname.split('/');
            const groupId = parts[3];
            const userId = parts[5];
            const { reason } = body;

            log('info', 'Rejecting pending member', { groupId, userId });

            try {
                // Get auth user
                const authUser = getAuthenticatedUser(req, query);
                if (!authUser) {
                    sendError(res, 401, 'Autenticacion requerida');
                    return;
                }

                // Check if requester is admin/coordinator/creator of the group
                const requesterResult = await dbPostgres.pool.query(
                    'SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = \'active\'',
                    [groupId, authUser.userId || authUser.user_id || authUser.id]
                );
                
                if (requesterResult.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(requesterResult.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para rechazar solicitudes');
                    return;
                }

                // Check if pending member exists
                const memberResult = await dbPostgres.pool.query(
                    'SELECT id, group_id, user_id, role, status, joined_at, left_at, invited_by, notes, created_at, updated_at, turn_position, is_anonymous, display_name, approved_by, approved_at, removed_by, removed_at, removal_reason, position, turn_locked, turn_locked_by, turn_locked_at, num_positions, rejected_by, rejected_at, rejection_reason, position_locks, last_notified_payment_status, last_payment_notification_at FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = \'pending\'',
                    [groupId, userId]
                );

                if (memberResult.rows.length === 0) {
                    sendError(res, 404, 'Solicitud pendiente no encontrada');
                    return;
                }

                // AUDIT FIX: Update status to rejected instead of DELETE (2025-12-31)
                // This preserves the audit trail of rejected requests
                await dbPostgres.pool.query(
                    'UPDATE group_members SET status = \'rejected\', rejected_by = $3, rejected_at = NOW(), rejection_reason = $4, updated_at = NOW() WHERE group_id = $1 AND user_id = $2 AND status = \'pending\'',
                    [groupId, userId, authUser.userId || authUser.user_id || authUser.id, reason || null]
                );

                // Create notification for the rejected user
                try {
                    await dbPostgres.pool.query(
                        'INSERT INTO notifications (user_id, type, title, message, data, created_at) VALUES ($1, $2, $3, $4, $5, NOW())',
                        [userId, 'group_rejected', 'Solicitud Rechazada', reason || 'Tu solicitud para unirte al grupo ha sido rechazada.', JSON.stringify({ group_id: groupId })]
                    );
                } catch (notifErr) {
                    log('warn', 'Failed to create notification', { error: notifErr.message });
                }

                log('info', 'Member request rejected', { groupId, userId, rejectedBy: authUser.userId || authUser.user_id || authUser.id });

                sendSuccess(res, {
                    message: 'Solicitud rechazada',
                    rejected: {
                        user_id: userId,
                        reason: reason || null,
                        rejected_by: authUser.userId || authUser.user_id || authUser.id,
                        rejected_at: new Date().toISOString()
                    }
                });
            } catch (error) {
                log('error', 'Error rejecting member', { error: error.message, groupId, userId });
                log('info', 'error', 'Error al rechazar solicitud', { error: error.message }); sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // ============================================
        // GROUP SETTINGS - GET & UPDATE
        // Added: 2025-12-25
        // ============================================
        
        // GET /api/groups/:groupId/settings - Get group approval settings
        if (pathname.match(/^\/api\/groups\/[^\/]+\/settings$/) && method === 'GET') {
            const groupId = pathname.split('/')[3];
            
            try {
                const authUser = getAuthenticatedUser(req, query);
                if (!authUser) {
                    sendError(res, 401, 'Autenticacion requerida');
                    return;
                }
                
                // Check if user is admin/coordinator of the group
                // v4.10.3: Allow suspended creators/coordinators to manage
                const memberResult = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = \$1 AND user_id = \$2 AND status IN ('active', 'suspended')",
                    [groupId, authUser.userId || authUser.user_id]
                );

                if (memberResult.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(memberResult.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para ver la configuracion');
                    return;
                }
                
                const groupResult = await dbPostgres.pool.query(
                    'SELECT approval_settings FROM groups WHERE group_id = \$1',
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                
                sendSuccess(res, {
                    group_id: groupId,
                    approval_settings: groupResult.rows[0].approval_settings || {}
                });
            } catch (err) {
                log('error', 'Error getting group settings', { error: err.message, groupId });
                sendError(res, 500, 'Error al obtener configuracion');
            }
            return;
        }
        
        // PUT /api/groups/:groupId/settings - Update group approval settings
        if (pathname.match(/^\/api\/groups\/[^\/]+\/settings$/) && (method === 'PUT' || method === 'PATCH')) {
            const groupId = pathname.split('/')[3];
            const { approval_settings } = body;
            
            try {
                const authUser = getAuthenticatedUser(req, query);
                if (!authUser) {
                    sendError(res, 401, 'Autenticacion requerida');
                    return;
                }
                
                // Check if user is admin/coordinator of the group
                // v4.10.3: Allow suspended creators/coordinators to manage
                const memberResult = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = \$1 AND user_id = \$2 AND status IN ('active', 'suspended')",
                    [groupId, authUser.userId || authUser.user_id]
                );

                if (memberResult.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(memberResult.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para modificar la configuracion');
                    return;
                }
                
                // Update settings
                await dbPostgres.pool.query(
                    'UPDATE groups SET approval_settings = \$1, updated_at = NOW() WHERE group_id = \$2',
                    [JSON.stringify(approval_settings), groupId]
                );
                
                log('info', 'Group settings updated', { groupId, updatedBy: authUser.userId || authUser.user_id });
                
                sendSuccess(res, {
                    message: 'Configuracion actualizada',
                    group_id: groupId,
                    approval_settings: approval_settings
                });
            } catch (err) {
                log('error', 'Error updating group settings', { error: err.message, groupId });
                sendError(res, 500, 'Error al actualizar configuracion');
            }
            return;
        }

        // ============================================
        // DELETE GROUP - Soft & Hard Delete Modes
        // ============================================
        // DELETE /api/groups/:groupId
        // Query params:
        //   mode=soft (default) - Changes status to 'deleted', preserves data
        //   mode=hard - Permanently deletes (super-admin only)
        //   confirm=GROUP_NAME - Required for hard delete
        // ============================================
        if (pathname.match(/^\/api\/groups\/[^\/]+$/) && method === "DELETE") {
            const groupId = pathname.split("/").pop();
            const deleteMode = query.mode || 'soft';
            const confirmName = query.confirm || '';
            
            log("info", "Delete group request", { groupId, mode: deleteMode });
            
            try {
                // 1. Authenticate user
                const authUser = getAuthenticatedUser(req, query);
                if (!authUser) {
                    sendError(res, 401, "Autenticación requerida");
                    return;
                }
                
                // 2. Get group details
                const groupResult = await dbPostgres.pool.query(
                    "SELECT group_id, name, contribution_amount, frequency, member_count, max_members, total_amount_collected, admin_id, status, created_at, location, description, image_url, category, meeting_schedule, updated_at, is_demo, start_date, grace_period, penalty_amount, current_cycle, lottery_executed, lottery_executed_at, lottery_scheduled_at, deleted_at, deleted_by, approval_settings, last_recruitment_notification_at FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                // SECURITY: Check membership (group member, group admin, or platform admin)
                const gmMemberCheck = await dbPostgres.pool.query(
                "SELECT 1 FROM group_members WHERE group_id = $1 AND user_id = $2 AND status NOT IN ('removed', 'rejected') UNION SELECT 1 FROM groups WHERE group_id = $1 AND admin_id = $2",
                [groupId, authUserGM.userId]
            );
                if (gmMemberCheck.rows.length === 0 && authUserGM.role !== 'admin') {
                    sendError(res, 403, "No tienes acceso a este grupo");
                    return;
                }

                
                const group = groupResult.rows[0];
                const actualGroupId = group.group_id || group.id;
                
                // 3. Check if user is super-admin (check admin session)
                const adminToken = req.headers['x-admin-token'] || req.headers.authorization?.split(' ')[1];
                const adminSession = adminToken ? database.admin_sessions?.[adminToken] : null;
                const SUPER_ADMIN_EMAIL = process.env.SUPER_ADMIN_EMAIL;
                const isSuperAdmin = authUser.email === SUPER_ADMIN_EMAIL || adminSession?.role === 'super_admin' || adminSession?.username === 'admin';
                
                // 4. Check permissions based on mode
                const isGroupAdmin = group.admin_id === authUser.userId;
                
                if (deleteMode === 'hard') {
                    // Hard delete requires super-admin
                    if (!isSuperAdmin) {
                        sendError(res, 403, "Solo el super-administrador puede eliminar permanentemente grupos");
                        return;
                    }
                    
                    // Require confirmation (group name)
                    if (confirmName !== group.name) {
                        sendError(res, 400, "Confirmación requerida. Envíe ?confirm=NOMBRE_DEL_GRUPO para eliminar permanentemente");
                        return;
                    }
                } else {
                    // Soft delete allows group admin or super-admin
                    if (!isGroupAdmin && !isSuperAdmin) {
                        sendError(res, 403, "Solo el administrador del grupo puede eliminarlo");
                        return;
                    }
                }
                

                // ============================================
                // VALIDATION: Check for active tanda with pending operations (Added 2025-12-31)
                // ============================================
                const forceDelete = query.force === 'true';

                if (!isSuperAdmin || !forceDelete) {
                    // Check for active tanda with lottery executed
                    const activeTandaResult = await dbPostgres.pool.query(`
                        SELECT t.tanda_id, t.status, t.current_turn, t.lottery_executed_at,
                               (SELECT COUNT(*) FROM contributions c WHERE c.tanda_id = t.tanda_id AND c.status = 'pending') as pending_contributions,
                               (SELECT COUNT(*) FROM contributions c WHERE c.tanda_id = t.tanda_id AND c.status = 'approved' AND c.payout_status = 'pending') as pending_payouts
                        FROM tandas t
                        WHERE t.group_id = $1 AND t.status IN ('active', 'in_progress')
                        ORDER BY t.created_at DESC LIMIT 1
                    `, [actualGroupId]);

                    if (activeTandaResult.rows.length > 0) {
                        const activeTanda = activeTandaResult.rows[0];

                        if (activeTanda.lottery_executed_at) {
                            // Tanda has started with lottery - check for pending operations
                            const pendingContributions = parseInt(activeTanda.pending_contributions) || 0;
                            const pendingPayouts = parseInt(activeTanda.pending_payouts) || 0;

                            if (pendingContributions > 0 || pendingPayouts > 0) {
                                sendError(res, 400, `No se puede eliminar el grupo. Hay ${pendingContributions} contribución(es) pendiente(s) y ${pendingPayouts} pago(s) por procesar. Complete o cancele estas operaciones primero.`);
                                return;
                            }

                            // Even without pending operations, warn about active tanda
                            if (deleteMode === 'soft') {
                                log("warn", "Deleting group with active tanda", {
                                    groupId: actualGroupId,
                                    tandaId: activeTanda.tanda_id,
                                    currentTurn: activeTanda.current_turn
                                });
                            }
                        }
                    }

                    // Check for any pending payouts in any tanda
                    const pendingPayoutsResult = await dbPostgres.pool.query(`
                        SELECT COUNT(*) as count, COALESCE(SUM(amount), 0) as total
                        FROM contributions
                        WHERE group_id = $1 AND payout_status = 'pending' AND status = 'approved'
                    `, [actualGroupId]);

                    const pendingPayoutCount = parseInt(pendingPayoutsResult.rows[0].count);
                    const pendingPayoutTotal = parseFloat(pendingPayoutsResult.rows[0].total);

                    if (pendingPayoutCount > 0) {
                        sendError(res, 400, `No se puede eliminar el grupo. Hay ${pendingPayoutCount} pago(s) pendiente(s) por un total de L. ${pendingPayoutTotal.toFixed(2)}. Complete estos pagos primero.`);
                        return;
                    }
                }

                // 5. Get contribution count for audit
                const contributionsResult = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count, COALESCE(SUM(amount), 0) as total FROM contributions WHERE group_id = $1",
                    [actualGroupId]
                );
                const contributionCount = parseInt(contributionsResult.rows[0].count);
                const contributionTotal = parseFloat(contributionsResult.rows[0].total);
                
                // 6. Get member count for audit
                const membersResult = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count FROM group_members WHERE group_id = $1",
                    [actualGroupId]
                );
                const memberCount = parseInt(membersResult.rows[0].count);
                
                // 7. Audit log entry
                const auditEntry = {
                    action: deleteMode === 'hard' ? 'GROUP_HARD_DELETE' : 'GROUP_SOFT_DELETE',
                    performed_by: authUser.userId,
                    performed_by_email: authUser.email,
                    is_super_admin: isSuperAdmin,
                    group_id: actualGroupId,
                    group_name: group.name,
                    group_admin_id: group.admin_id,
                    contribution_count: contributionCount,
                    contribution_total: contributionTotal,
                    member_count: memberCount,
                    timestamp: new Date().toISOString(),
                    ip_address: req.headers['x-forwarded-for'] || req.socket?.remoteAddress
                };
                
                // Save audit to database
                await dbPostgres.pool.query(
                    `INSERT INTO audit_logs (user_id, user_email, action, resource, resource_id, details, ip_address, status)
                     VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
                    [authUser.userId, authUser.email, auditEntry.action, 'group', actualGroupId, 
                     JSON.stringify(auditEntry), auditEntry.ip_address, 'success']
                );
                
                if (deleteMode === 'hard') {
                    // ========== HARD DELETE ==========
                    log("warn", "HARD DELETE initiated by super-admin", auditEntry);
                    
                    // Archive contributions before deleting (for accounting)
                    if (contributionCount > 0) {
                        await dbPostgres.pool.query(
                            `INSERT INTO deleted_contributions_archive 
                             SELECT *, NOW() as deleted_at, $2 as deleted_by 
                             FROM contributions WHERE group_id = $1`,
                            [actualGroupId, authUser.userId]
                        ).catch(() => {
                            // Archive table might not exist, continue anyway
                            log("warn", "Could not archive contributions (table may not exist)");
                        });
                    }
                    
                    // Delete in order (foreign key constraints)
                    await dbPostgres.pool.query("DELETE FROM contributions WHERE group_id = $1", [actualGroupId]);
                    await dbPostgres.pool.query("DELETE FROM tandas WHERE group_id = $1", [actualGroupId]);
                    await dbPostgres.pool.query("DELETE FROM group_members WHERE group_id = $1", [actualGroupId]);
                    await dbPostgres.pool.query("DELETE FROM groups WHERE group_id = $1", [actualGroupId]);
                    
                    // Remove from JSON backup
                    const jsonIndex = database.groups.findIndex(g => g.id === actualGroupId || g.group_id === actualGroupId);
                    if (jsonIndex > -1) {
                        database.groups.splice(jsonIndex, 1);
                        saveDatabase();
                    }
                    
                    log("info", "Group HARD DELETED permanently", { groupId: actualGroupId, by: authUser.userId });
                    
                    sendSuccess(res, {
                        message: "Grupo eliminado permanentemente",
                        mode: "hard",
                        group_id: actualGroupId,
                        group_name: group.name,
                        contributions_deleted: contributionCount,
                        members_removed: memberCount,
                        audit_logged: true
                    });
                    
                } else {
                    // ========== SOFT DELETE ==========
                    log("info", "Soft delete initiated", { groupId: actualGroupId, by: authUser.userId });
                    
                    // Update status to 'deleted'
                    await dbPostgres.pool.query(
                        "UPDATE groups SET status = 'deleted', deleted_at = NOW(), deleted_by = $2 WHERE group_id = $1",
                        [actualGroupId, authUser.userId]
                    );
                    
                    // Update JSON backup
                    const jsonGroup = database.groups.find(g => g.id === actualGroupId || g.group_id === actualGroupId);
                    if (jsonGroup) {
                        jsonGroup.status = 'deleted';
                        jsonGroup.deleted_at = new Date().toISOString();
                        jsonGroup.deleted_by = authUser.userId;
                        saveDatabase();
                    }
                    
                    log("info", "Group soft deleted", { groupId: actualGroupId, by: authUser.userId });
                    
                    sendSuccess(res, {
                        message: "Grupo marcado como eliminado",
                        mode: "soft",
                        group_id: actualGroupId,
                        group_name: group.name,
                        can_restore: true,
                        contributions_preserved: contributionCount,
                        members_preserved: memberCount,
                        audit_logged: true
                    });
                }
                
                return;
                
            } catch (error) {
                log("error", "Error deleting group", { groupId, error: error.message });
                log("error", "Error al eliminar grupo", { error: error.message }); sendError(res, 500, "Error interno del servidor");
                return;
            }
        }


        


        // ============================================
        // MEMBER ACTION ENDPOINTS
        // ============================================
        
        // Toggle anonymous mode (PUT /api/groups/:groupId/members/:userId/anonymous)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/anonymous$/) && method === "PUT") {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            const parts = pathname.split("/");
            const groupId = parts[3];
            const userId = parts[5];
            if (String(authUser.userId) !== String(userId)) {
                sendError(res, 403, 'Solo puedes cambiar tu propio modo anonimo');
                return;
            }
            
            log("info", "Toggle anonymous request", { groupId, userId });
            
            try {
                const { is_anonymous } = body;
                
                await dbPostgres.pool.query(
                    "UPDATE group_members SET is_anonymous = $1 WHERE group_id = $2 AND user_id = $3",
                    [is_anonymous, groupId, userId]
                );
                
                sendSuccess(res, { 
                    message: is_anonymous ? "Nombre oculto" : "Nombre visible",
                    is_anonymous: is_anonymous
                });
                return;
                
            } catch (error) {
                log("error", "Error toggling anonymous", { error: error.message });
                sendError(res, "Error al cambiar modo anonimo", 500);
                return;
            }
        }
        
        // Check if member can leave (GET /api/groups/:groupId/members/:userId/can-leave)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/can-leave$/) && method === "GET") {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) { sendError(res, 401, 'Autenticacion requerida'); return; }
            const parts = pathname.split("/");
            const groupId = parts[3];
            const userId = String(authUser.userId);
            
            log("info", "Check can leave request", { groupId, userId });
            
            try {
                // FIX 2025-12-31: First check if tanda has started
                // If tanda hasnt started, always allow leaving
                const groupStatusResult = await dbPostgres.pool.query(
                    "SELECT status, start_date FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                const groupStatus = groupStatusResult.rows[0]?.status;
                const startDate = groupStatusResult.rows[0]?.start_date;
                const hasStarted = groupStatus === 'active' && startDate && new Date(startDate) <= new Date();
                
                // If tanda hasnt started, allow leaving freely
                if (!hasStarted) {
                    log("info", "Tanda not started, allowing leave", { groupId, userId, groupStatus, startDate });
                    sendSuccess(res, { can_leave: true, reason: "La tanda aun no ha iniciado" });
                    return;
                }
                
                // Check for pending payments/contributions (only if tanda has started)
                const pendingResult = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count FROM contributions WHERE group_id = $1 AND user_id = $2 AND status = 'pending'",
                    [groupId, userId]
                );
                
                const hasPending = parseInt(pendingResult.rows[0].count) > 0;
                
                if (hasPending) {
                    sendSuccess(res, { 
                        can_leave: false, 
                        reason: "Tienes pagos pendientes en este grupo" 
                    });
                    return;
                }
                
                // Check if user is creator
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                if (groupResult.rows.length > 0 && groupResult.rows[0].admin_id === userId) {
                    sendSuccess(res, { 
                        can_leave: false, 
                        reason: "Eres el creador. Debes transferir la propiedad primero." 
                    });
                    return;
                }
                
                sendSuccess(res, { can_leave: true });
                return;
                
            } catch (error) {
                log("error", "Error checking can leave", { error: error.message });
                sendError(res, "Error al verificar", 500);
                return;
            }
        }
        
        // Leave/Remove member (DELETE /api/groups/:groupId/members/:userId)
        // Handles both: user leaving AND admin removing another member
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+$/) && method === "DELETE") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const targetUserId = parts[5];
            
            // Get authenticated user
            const authUser = getAuthenticatedUser(req, query);
            const requesterId = authUser ? (authUser.userId || authUser.user_id || authUser.id) : null;
            const isRemoveAction = body.action === 'remove' || (requesterId && requesterId !== targetUserId);
            
            log("info", isRemoveAction ? "Remove member request" : "Leave group request", { groupId, targetUserId, requesterId });
            
            try {
                // If REMOVE action (admin removing another), verify permissions
                if (isRemoveAction) {
                    if (!authUser) {
                        sendError(res, 401, "Autenticacion requerida");
                        return;
                    }
                    
                    // Check if requester is admin/coordinator
                    // v4.10.3: Allow suspended creators/coordinators to manage (group suspension suspends all members)
                    const requesterResult = await dbPostgres.pool.query(
                        "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                        [groupId, requesterId]
                    );

                    if (requesterResult.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(requesterResult.rows[0].role)) {
                        sendError(res, 403, "No tienes permisos para remover miembros");
                        return;
                    }
                    
                    // Cannot remove creator
                    const targetResult = await dbPostgres.pool.query(
                        "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2",
                        [groupId, targetUserId]
                    );
                    
                    if (targetResult.rows.length > 0 && targetResult.rows[0].role === 'creator') {
                        sendError(res, 403, "No se puede remover al creador del grupo");
                        return;
                    }
                    
                    // Remove member
                    await dbPostgres.pool.query(
                        "UPDATE group_members SET status = 'removed', removed_by = $3, removed_at = NOW() WHERE group_id = $1 AND user_id = $2",
                        [groupId, targetUserId, requesterId]
                    );

                    // v4.10.3: Clean up turns_order — remove all positions for this member
                    try {
                        await dbPostgres.pool.query(`
                            UPDATE tandas SET turns_order = (
                                SELECT COALESCE(array_agg(elem ORDER BY pos), '{}')
                                FROM (SELECT elem, row_number() OVER () as pos FROM unnest(turns_order) AS elem WHERE (elem::json->>'user_id') != $2) sub
                            ) WHERE group_id = $1 AND status IN ('active', 'in_progress', 'pending')
                        `, [groupId, targetUserId]);
                    } catch (turnsErr) {
                        log("warn", "Could not clean turns_order after member removal", { groupId, targetUserId, error: turnsErr.message });
                    }

                    log("info", "Member removed by admin", { groupId, targetUserId, removedBy: requesterId });
                    sendSuccess(res, { message: "Miembro removido exitosamente" });
                    return;
                }
                
                // LEAVE action (user leaving themselves)
                // ============================================
                // SECURITY: Require authentication for leave action (Added 2025-12-31)
                // ============================================
                if (!authUser) {
                    sendError(res, 401, "Autenticación requerida para salir del grupo");
                    return;
                }

                // Verify authenticated user matches target (prevent impersonation)
                if (requesterId !== targetUserId) {
                    sendError(res, 403, "Solo puedes salir tú mismo del grupo");
                    return;
                }

                const userId = targetUserId;

                // ============================================
                // VALIDATION: Check if it's user's turn to receive payout (Added 2025-12-31)
                // ============================================
                const turnCheck = await dbPostgres.pool.query(`
                    SELECT t.current_turn, gm.turn_position
                    FROM tandas t
                    JOIN group_members gm ON gm.group_id = t.group_id AND gm.user_id = $2
                    WHERE t.group_id = $1 AND t.status IN ('active', 'in_progress')
                    ORDER BY t.created_at DESC LIMIT 1
                `, [groupId, userId]);

                if (turnCheck.rows.length > 0) {
                    const { current_turn, turn_position } = turnCheck.rows[0];
                    if (turn_position && current_turn === turn_position) {
                        sendError(res, 400, "No puedes salir: es tu turno de recibir el pago. Espera a que se procese.");
                        return;
                    }
                }

                
                // FIX 2025-12-31: Check if tanda has started before blocking
                const groupStatusResult = await dbPostgres.pool.query(
                    "SELECT status, start_date FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                const groupStatus = groupStatusResult.rows[0]?.status;
                const startDate = groupStatusResult.rows[0]?.start_date;
                const hasStarted = groupStatus === 'active' && startDate && new Date(startDate) <= new Date();
                
                // Only check pending payments if tanda has started
                if (hasStarted) {
                    const pendingResult = await dbPostgres.pool.query(
                        "SELECT COUNT(*) as count FROM contributions WHERE group_id = $1 AND user_id = $2 AND status = 'pending'",
                        [groupId, userId]
                    );
                    
                    if (parseInt(pendingResult.rows[0].count) > 0) {
                        sendError(res, 400, "No puedes salir: tienes pagos pendientes");
                        return;
                    }
                }
                
                // Check if user is creator
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                if (groupResult.rows.length > 0 && groupResult.rows[0].admin_id === userId) {
                    sendError(res, 400, "Eres el creador. Debes transferir la propiedad primero.");
                    return;
                }
                
                // Update member status to 'left'
                await dbPostgres.pool.query(
                    "UPDATE group_members SET status = 'left', left_at = NOW() WHERE group_id = $1 AND user_id = $2",
                    [groupId, userId]
                );

                // v4.10.3: Clean up turns_order — remove all positions for this member
                try {
                    await dbPostgres.pool.query(`
                        UPDATE tandas SET turns_order = (
                            SELECT COALESCE(array_agg(elem ORDER BY pos), '{}')
                            FROM (SELECT elem, row_number() OVER () as pos FROM unnest(turns_order) AS elem WHERE (elem::json->>'user_id') != $2) sub
                        ) WHERE group_id = $1 AND status IN ('active', 'in_progress', 'pending')
                    `, [groupId, userId]);
                } catch (turnsErr) {
                    log("warn", "Could not clean turns_order after member leave", { groupId, userId, error: turnsErr.message });
                }

                log("info", "Member left group", { groupId, userId });
                sendSuccess(res, { message: "Has salido del grupo exitosamente" });
                return;
                
            } catch (error) {
                log("error", "Error leaving group", { error: error.message });
                sendError(res, "Error al salir del grupo", 500);
                return;
            }
        }
        
        // Create role request (POST /api/groups/:groupId/role-requests)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/role-requests$/) && method === "POST") {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            const groupId = pathname.split("/")[3];
            
            log("info", "Role request", { groupId, body });
            
            try {
                const { requested_role, reason } = body;
                
                // Check if already has pending request
                const existingResult = await dbPostgres.pool.query(
                    "SELECT id FROM role_requests WHERE group_id = $1 AND user_id = $2 AND status = 'pending'",
                    [groupId, authUser.userId]
                );
                
                if (existingResult.rows.length > 0) {
                    sendError(res, "Ya tienes una solicitud pendiente", 400);
                    return;
                }
                
                // Create request
                await dbPostgres.pool.query(
                    "INSERT INTO role_requests (group_id, user_id, requested_role, reason, status) VALUES ($1, $2, $3, $4, 'pending')",
                    [groupId, authUser.userId, requested_role, reason || '']
                );
                
                log("info", "Role request created", { groupId, userId: authUser.userId, requested_role });
                sendSuccess(res, { message: "Solicitud enviada exitosamente" });
                return;
                
            } catch (error) {
                log("error", "Error creating role request", { error: error.message });
                sendError(res, "Error al enviar solicitud", 500);
                return;
            }
        }
        
        // Transfer ownership (POST /api/groups/:groupId/transfer-ownership)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/transfer-ownership$/) && method === "POST") {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            const groupId = pathname.split("/")[3];
            
            log("info", "Transfer ownership request", { groupId, body });
            
            try {
                const { new_owner_id } = body;

                // Validate new_owner_id type (v3.97.0 - H2)
                if (typeof new_owner_id !== 'string' || !new_owner_id.trim()) {
                    sendError(res, 400, 'new_owner_id debe ser un string valido');
                    return;
                }

                // Get current owner
                const groupResult = await dbPostgres.pool.query(
                    "SELECT admin_id FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, "Grupo no encontrado", 404);
                    return;
                }
                
                const oldOwnerId = groupResult.rows[0].admin_id;

                // Verify caller is the current owner
                if (String(authUser.userId) !== String(oldOwnerId)) {
                    sendError(res, 403, 'Solo el propietario puede transferir la propiedad del grupo');
                    return;
                }
                
                // Verify new owner is a member
                // v4.10.3: Allow suspended members (group suspension suspends all members)
                const memberResult = await dbPostgres.pool.query(
                    "SELECT id FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, new_owner_id]
                );

                if (memberResult.rows.length === 0) {
                    sendError(res, 400, "El usuario seleccionado no es miembro del grupo");
                    return;
                }
                
                // Update group admin
                await dbPostgres.pool.query(
                    "UPDATE groups SET admin_id = $1 WHERE group_id = $2",
                    [new_owner_id, groupId]
                );
                
                // Update old owner role to 'member'
                await dbPostgres.pool.query(
                    "UPDATE group_members SET role = 'member' WHERE group_id = $1 AND user_id = $2",
                    [groupId, oldOwnerId]
                );
                
                // Update new owner role to 'creator'
                await dbPostgres.pool.query(
                    "UPDATE group_members SET role = 'creator' WHERE group_id = $1 AND user_id = $2",
                    [groupId, new_owner_id]
                );
                
                log("info", "Ownership transferred", { groupId, oldOwnerId, new_owner_id });
                sendSuccess(res, { message: "Propiedad transferida exitosamente" });
                return;
                
            } catch (error) {
                log("error", "Error transferring ownership", { error: error.message });
                sendError(res, "Error al transferir propiedad", 500);
                return;
            }
        }

        // Reorder turns (PUT /api/groups/:groupId/reorder-turns)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/reorder-turns$/) && method === "PUT") {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const groupId = pathname.split("/")[3];

            log("info", "Reorder turns request", { groupId });

            try {
                // v4.10.3: Permission check — creator/coordinator/admin only (was missing!)
                const permCheck = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, authUser.userId]
                );
                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    if (authUser.role !== 'admin') {
                        sendError(res, 403, 'No tienes permisos para reordenar turnos');
                        return;
                    }
                }
                const { member_turns } = body;
                
                if (!member_turns || !Array.isArray(member_turns)) {
                    sendError(res, 400, "member_turns debe ser un array");
                    return;
                }

                // Validate member_turns elements (v3.97.0 - M2)
                if (member_turns.length > 500) {
                    sendError(res, 400, "member_turns excede el limite de 500 elementos");
                    return;
                }
                for (const turn of member_turns) {
                    if (typeof turn.user_id !== 'string' || !turn.user_id.trim()) {
                        sendError(res, 400, "Cada turno requiere user_id valido");
                        return;
                    }
                    if (turn.new_position !== undefined && (!Number.isInteger(turn.new_position) || turn.new_position < 0)) {
                        sendError(res, 400, "new_position debe ser un entero no negativo");
                        return;
                    }
                    if (turn.num_positions !== undefined && (!Number.isInteger(turn.num_positions) || turn.num_positions < 1 || turn.num_positions > 50)) {
                        sendError(res, 400, "num_positions debe ser entre 1 y 50");
                        return;
                    }
                }

                // Update each member turn position
                for (const turn of member_turns) {
                    await dbPostgres.pool.query(
                        "UPDATE group_members SET turn_position = $1, turn_locked = $2, num_positions = $3, position_locks = $4 WHERE group_id = $5 AND user_id = $6",
                        [turn.new_position, turn.turn_locked || false, turn.num_positions || 1, JSON.stringify(turn.position_locks || []), groupId, turn.user_id]
                    );
                }
                
                // Also update tandas.turns_order (source of truth)
                try {
                    const tandaResult = await dbPostgres.pool.query(
                        "SELECT tanda_id FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1",
                        [groupId]
                    );

                    if (tandaResult.rows.length > 0) {
                        const tandaId = tandaResult.rows[0].tanda_id;

                        // Create expanded turns_order with individual positions
                        // If expanded_turns provided, use those; otherwise fall back to member_turns
                        let turnsOrder;
                        if (body.expanded_turns && Array.isArray(body.expanded_turns)) {
                            // New format: array of {user_id, slot_index} — filter out any entries with missing user_id
                            turnsOrder = body.expanded_turns
                                .filter(t => t.user_id && typeof t.user_id === 'string')
                                .map(t => ({ user_id: t.user_id, slot: t.slot_index || 0 }));
                        } else {
                            // Legacy format: just user_ids sorted by position
                            const sortedTurns = [...member_turns].sort((a, b) => a.new_position - b.new_position);
                            turnsOrder = sortedTurns.map(t => t.user_id);
                        }

                        // Update tandas.turns_order
                        await dbPostgres.pool.query(
                            "UPDATE tandas SET turns_order = $1, updated_at = NOW() WHERE tanda_id = $2",
                            [turnsOrder, tandaId]
                        );

                        log("info", "Updated tandas.turns_order", { tandaId, turnsOrder });
                    }
                } catch (tandaError) {
                    log("warn", "Could not update tandas.turns_order", { error: tandaError.message });
                }
                
                log("info", "Turns reordered successfully", { groupId, count: member_turns.length });

                // Notify members about turn changes
                try {
                    const groupNameResult = await dbPostgres.pool.query(
                        "SELECT name FROM groups WHERE group_id = $1",
                        [groupId]
                    );
                    const groupName = groupNameResult.rows[0]?.name || "Grupo";

                    for (const turn of member_turns) {
                        await createNotification(
                            turn.user_id,
                            "turn_updated",
                            "Turno Actualizado",
                            `Tu posicion en "${groupName}" ha sido actualizada a #${turn.new_position}.`,
                            { group_id: groupId, new_position: turn.new_position }
                        );
                    }
                    log("info", "Notified members about turn changes", { count: member_turns.length });
                } catch (notifErr) {
                    log("warn", "Could not notify about turn changes: " + notifErr.message);
                }
                sendSuccess(res, { message: "Turnos actualizados exitosamente", updated: member_turns.length });
                return;
                
            } catch (error) {
                log("error", "Error reordering turns", { groupId, error: error.message });
                log("error", "Error al reordenar turnos", { error: error.message }); sendError(res, 500, "Error interno del servidor");
                return;
            }
        }

        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+$/) && method === "DELETE") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const userId = parts[5];

            log("info", "Removing member from group", { groupId, userId });

            try {
                // Get current member to check if they are creator
                // Get ALL members including suspended (for admin actions)
                const membersResult = await dbPostgres.pool.query(
                    "SELECT user_id, role, status FROM group_members WHERE group_id = $1 AND status NOT IN ('removed', 'left')",
                    [groupId]
                );
                const members = membersResult.rows;
                const targetMember = members.find(m => m.user_id === userId);
                
                if (!targetMember) {
                    sendError(res, 404, "Miembro no encontrado");
                    return;
                }

                if (targetMember.role === "creator") {
                    sendError(res, 403, "No se puede remover al creador del grupo");
                    return;
                }

                // Remove member (soft delete)
                await db.removeGroupMember(groupId, userId);

                sendSuccess(res, {
                    message: "Miembro removido del grupo exitosamente",
                    removed_user_id: userId
                });
            } catch (error) {
                log("error", "Error removing member", { error: error.message });
                sendError(res, 500, "Error al remover miembro del grupo");
            }
            return;
        }


        // =============================================
        // EXPORT ENDPOINTS - PDF & CSV
        // Added: 2025-11-25
        // =============================================
        
        // GET /api/groups/:groupId/export/payments - Export payments as PDF or CSV
        if (pathname.match(/^\/api\/groups\/[^\/]+\/export\/payments$/) && method === 'GET') {
            const groupId = pathname.split('/')[3];
            const urlParts = parseUrl(req.url);
            const format = urlParts.query.format || 'pdf';
            
            log('info', 'Exporting payments', { groupId, format });
            
            try {
                const groupResult = await dbPostgres.pool.query(
                    'SELECT g.group_id, g.name, g.contribution_amount, g.frequency, g.member_count, g.max_members, g.total_amount_collected, g.admin_id, g.status, g.created_at, g.location, g.description, g.image_url, g.category, g.meeting_schedule, g.updated_at, g.is_demo, g.start_date, g.grace_period, g.penalty_amount, g.current_cycle, g.lottery_executed, g.lottery_executed_at, g.lottery_scheduled_at, g.deleted_at, g.deleted_by, g.approval_settings, g.last_recruitment_notification_at, t.status as tanda_status FROM groups g LEFT JOIN (SELECT DISTINCT ON (group_id) group_id, status FROM tandas ORDER BY group_id, created_at DESC) t ON g.group_id = t.group_id WHERE g.group_id = $1',
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                
                const groupData = groupResult.rows[0];
                
                const paymentsResult = await dbPostgres.pool.query(
                    `SELECT c.id, c.user_id, c.group_id, c.amount, c.payment_method, c.status, c.cycle_number, c.paid_date, c.created_at, c.proof_url, c.verified_by, c.verified_at, u.name as member_name
                     FROM contributions c
                     LEFT JOIN users u ON c.user_id = u.user_id
                     WHERE c.group_id = $1
                     ORDER BY c.created_at DESC LIMIT 500`,
                    [groupId]
                );
                
                const payments = paymentsResult.rows;
                
                let result;
                if (format === 'csv') {
                    result = await exportUtils.generatePaymentsCSV(groupData, payments);
                } else {
                    result = await exportUtils.generatePaymentsPDF(groupData, payments);
                }
                
                const fileContent = fs.readFileSync(result.filepath);
                const contentType = format === 'csv' ? 'text/csv' : 'application/pdf';
                
                res.writeHead(200, {
                    'Content-Type': contentType,
                    'Content-Disposition': 'attachment; filename="' + result.filename + '"',
                    'Content-Length': fileContent.length,
                    'Access-Control-Allow-Origin': 'https://latanda.online'
                });
                res.end(fileContent);
                
                setTimeout(function() {
                    try { fs.unlinkSync(result.filepath); } catch(e) {}
                }, 5000);
                
                return;
            } catch (error) {
                log('error', 'Export payments failed', { error: error.message, groupId });
                sendError(res, 500, 'Error al exportar pagos');
                return;
            }
        }
        

        
        // GET /api/groups/:groupId/export/summary - Export group summary as PDF
        if (pathname.match(/^\/api\/groups\/[^\/]+\/export\/summary$/) && method === 'GET') {
            const groupId = pathname.split('/')[3];
            
            log('info', 'Exporting group summary', { groupId });
            
            try {
                const groupResult = await dbPostgres.pool.query(
                    'SELECT g.group_id, g.name, g.contribution_amount, g.frequency, g.member_count, g.max_members, g.total_amount_collected, g.admin_id, g.status, g.created_at, g.location, g.description, g.image_url, g.category, g.meeting_schedule, g.updated_at, g.is_demo, g.start_date, g.grace_period, g.penalty_amount, g.current_cycle, g.lottery_executed, g.lottery_executed_at, g.lottery_scheduled_at, g.deleted_at, g.deleted_by, g.approval_settings, g.last_recruitment_notification_at, t.status as tanda_status FROM groups g LEFT JOIN (SELECT DISTINCT ON (group_id) group_id, status FROM tandas ORDER BY group_id, created_at DESC) t ON g.group_id = t.group_id WHERE g.group_id = $1',
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                
                const groupData = groupResult.rows[0];
                
                const membersCount = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count FROM group_members WHERE group_id = $1 AND status = 'active' AND status = 'active'",
                    [groupId]
                );
                
                const paymentsStats = await dbPostgres.pool.query(
                    `SELECT 
                        COUNT(*) as total_payments,
                        COALESCE(SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END), 0) as total_collected,
                        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_count
                     FROM contributions WHERE group_id = $1`,
                    [groupId]
                );
                
                const ps = paymentsStats.rows[0];
                const totalPayments = parseInt(ps.total_payments) || 0;
                const completedCount = parseInt(ps.completed_count) || 0;
                
                const stats = {
                    memberCount: parseInt(membersCount.rows[0].count) || 0,
                    totalCollected: parseFloat(ps.total_collected) || 0,
                    paymentCount: totalPayments,
                    completionRate: totalPayments > 0 ? Math.round((completedCount / totalPayments) * 100) : 100
                };
                
                const result = await exportUtils.generateSummaryPDF(groupData, stats);
                
                const fileContent = fs.readFileSync(result.filepath);
                
                res.writeHead(200, {
                    'Content-Type': 'application/pdf',
                    'Content-Disposition': 'attachment; filename="' + result.filename + '"',
                    'Content-Length': fileContent.length,
                    'Access-Control-Allow-Origin': 'https://latanda.online'
                });
                res.end(fileContent);
                
                setTimeout(function() {
                    try { fs.unlinkSync(result.filepath); } catch(e) {}
                }, 5000);
                
                return;
            } catch (error) {
                log('error', 'Export summary failed', { error: error.message, groupId });
                sendError(res, 500, 'Error al exportar resumen');
                return;
            }
        }


        // =============================================
        // NOTIFICATIONS ENDPOINTS
        // Added: 2025-11-25
        // =============================================
        
        // GET /api/notifications - Get user notifications
        if (pathname === '/api/notifications' && method === 'GET') {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const urlParts = parseUrl(req.url);
            const userId = authUser.userId;
            const unreadOnly = urlParts.query.unread === 'true';
            const limit = Math.min(parseInt(urlParts.query.limit) || 50, 100);
            const offset = parseInt(urlParts.query.offset) || 0;
            
            if (!userId) {
                sendError(res, 400, 'user_id requerido');
                return;
            }
            

            
            try {
                const result = await notificationsUtils.getNotifications(dbPostgres.pool, userId, {
                    unreadOnly: unreadOnly,
                    limit: limit,
                    offset: offset
                });
                
                sendSuccess(res, result);
            } catch (error) {
                log('error', 'Error getting notifications', { error: error.message });
                sendError(res, 500, 'Error al obtener notificaciones');
            }
            return;
        }

        // GET /api/notifications/unread-count - Get unread notification count
        if (pathname === "/api/notifications/unread-count" && method === "GET") {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const urlParts = parseUrl(req.url);
            const userId = authUser.userId;

            if (!userId) {
                sendError(res, 400, "user_id requerido");
                return;
            }

            try {
                const result = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as unread_count FROM notifications WHERE user_id = $1 AND read_at IS NULL",
                    [userId]
                );

                sendSuccess(res, {
                    unread_count: parseInt(result.rows[0].unread_count) || 0,
                    user_id: userId
                });
            } catch (error) {
                log("error", "Error getting unread count", { error: error.message });
                sendError(res, 500, "Error al obtener conteo");
            }
            return;
        }
        
        // POST /api/notifications/read/:id - Mark single notification as read
        if (pathname.match(/^\/api\/notifications\/read\/[^\/]+$/) && method === 'POST') {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const notificationId = pathname.split('/')[4];

            try {
                const userId = authUser.userId;
                    
                    if (!userId) {
                        sendError(res, 400, 'user_id requerido');
                        return;
                    }
                    
                    log('info', 'Marking notification as read', { notificationId, userId });
                    
                    const result = await notificationsUtils.markAsRead(dbPostgres.pool, notificationId, userId);
                    
                    if (!result) {
                        sendError(res, 404, 'Notificacion no encontrada');
                        return;
                    }
                    
                sendSuccess(res, { message: 'Notificacion marcada como leida', notification: result });
            } catch (error) {
                log('error', 'Error marking as read', { error: error.message });
                sendError(res, 500, 'Error al marcar notificacion');
            }
            return;
        }
        
        // POST /api/notifications/read-all - Mark all notifications as read
        if (pathname === '/api/notifications/read-all' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }

            try {
                const userId = authUser.userId;
                    
                    if (!userId) {
                        sendError(res, 400, 'user_id requerido');
                        return;
                    }
                    
                    log('info', 'Marking all notifications as read', { userId });
                    
                    const result = await notificationsUtils.markAllAsRead(dbPostgres.pool, userId);
                    
                sendSuccess(res, { message: 'Todas las notificaciones marcadas como leidas', ...result });
            } catch (error) {
                log('error', 'Error marking all as read', { error: error.message });
                sendError(res, 500, 'Error al marcar notificaciones');
            }
            return;
        }
        
        // GET /api/notifications/preferences - Get notification preferences
        if (pathname === '/api/notifications/preferences' && method === 'GET') {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const userId = authUser.userId;
            
            log('info', 'Getting notification preferences', { userId });
            
            try {
                const result = await notificationsUtils.getPreferences(dbPostgres.pool, userId);
                sendSuccess(res, result);
            } catch (error) {
                log('error', 'Error getting preferences', { error: error.message });
                sendError(res, 500, 'Error al obtener preferencias');
            }
            return;
        }
        
        // PUT /api/notifications/preferences - Update notification preferences
        if (pathname === '/api/notifications/preferences' && (method === 'PUT' || method === 'PATCH')) {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            try {
                const userId = authUser.userId;
                    
                    log('info', 'Updating notification preferences', { userId });
                    
                const result = await notificationsUtils.updatePreferences(dbPostgres.pool, userId, body);
                
                sendSuccess(res, { message: 'Preferencias actualizadas', preferences: result });
            } catch (error) {
                log('error', 'Error updating preferences', { error: error.message });
                sendError(res, 500, 'Error al actualizar preferencias');
            }
            return;
        }
        
        // POST /api/notifications/create - Create notification (internal/admin)
        if (pathname === '/api/notifications/create' && method === 'POST') {
            // SECURITY FIX: Require admin session (2025-12-31)
            const adminSession = requireAdminSession(req, res);
            if (!adminSession) return;

            try {
                const { type, title, message, notification_data, user_id } = body;
                    
                    if (!user_id || !type || !title) {
                        sendError(res, 400, 'user_id, type y title son requeridos');
                        return;
                    }
                    
                    log('info', 'Creating notification', { user_id, type, title });
                    
                    const result = await notificationsUtils.createNotification(
                        dbPostgres.pool, 
                        user_id, 
                        type, 
                        title, 
                        message || '', 
                        notification_data || {}
                    );
                    
                sendSuccess(res, { message: 'Notificacion creada', notification: result });
            } catch (error) {
                log('error', 'Error creating notification', { error: error.message });
                sendError(res, 500, 'Error al crear notificacion');
            }
            return;
        }


        // =============================================
        // PAYMENT STATUS NOTIFICATIONS CRON
        // POST /api/cron/check-payment-status
        // Called daily by cron job to check payments and send notifications
        // =============================================
        if (pathname === '/api/cron/check-payment-status' && method === 'POST') {
            // Verify internal cron key
            const cronKey = req.headers['x-cron-key'];
            if (!safeCompare(String(cronKey || ''), String(process.env.CRON_SECRET_KEY || ''))) {
                sendError(res, 401, 'Cron key invalida');
                return;
            }

            try {
                log('info', 'Running payment status check cron job');
                
                const gracePeriod = 3;
                const autoSuspendDays = 5;
                const today = new Date();
                
                // Get all active memberships with their payment info
                const membershipsResult = await dbPostgres.pool.query(`
                    SELECT
                        gm.user_id,
                        gm.group_id,
                        gm.status as member_status,
                        gm.last_notified_payment_status,
                        gm.last_payment_notification_at,
                        g.name as group_name,
                        g.contribution_amount,
                        g.frequency,
                        (SELECT MAX(paid_date) FROM contributions
                         WHERE group_id = gm.group_id AND user_id = gm.user_id AND status IN ('completed', 'coordinator_approved', 'verified', 'archived')) as last_payment,
                        g.start_date,
                        (SELECT cm.user_id FROM group_members cm
                         WHERE cm.group_id = gm.group_id AND cm.role = 'creator' AND cm.status IN ('active', 'suspended') LIMIT 1) as creator_user_id,
                        u.name as member_name,
                        u.email as member_email,
                        COALESCE(gm.num_positions, 1) as num_positions,
                        g.current_cycle,
                        (SELECT COUNT(*) FROM contributions c
                         WHERE c.group_id = gm.group_id AND c.user_id = gm.user_id
                         AND c.cycle_number = g.current_cycle
                         AND c.status IN ('completed', 'coordinator_approved', 'verified', 'archived')) as contributions_this_cycle
                    FROM group_members gm
                    JOIN groups g ON gm.group_id = g.group_id
                    JOIN users u ON gm.user_id = u.user_id
                    WHERE gm.status = 'active'
                    AND g.status = 'active'
                    LIMIT 500
                `);

                const notifications = {
                    due_soon: 0,
                    late: 0,
                    suspension_warning: 0,
                    suspension_recommended: 0
                };

                // v4.10.6: Collect late members per group for coordinator digest
                const lateByGroup = {};

                for (const membership of membershipsResult.rows) {
                    // Calculate next payment due using centralized helper
                    const memberGracePeriod = parseInt(membership.grace_period) || gracePeriod || 5;
                    const memberStartDate = membership.start_date || membership.created_at;
                    if (!memberStartDate) continue; // Skip if no date info
                    
                    const contribsThisMember = parseInt(membership.contributions_this_cycle) || 0;
                    const memberNextCycle = contribsThisMember + 1;
                    const dueDateInfo = getPaymentDueDate(membership.frequency, memberStartDate, memberNextCycle, memberGracePeriod);
                    
                    let nextPaymentDue;
                    if (dueDateInfo.dueDate) {
                        nextPaymentDue = new Date(dueDateInfo.dueDate + "T12:00:00");
                    } else if (membership.start_date) {
                        nextPaymentDue = new Date(membership.start_date);
                    } else {
                        continue; // Skip if no payment info
                    }

                    const dueWithGrace = dueDateInfo.graceDeadline ? new Date(dueDateInfo.graceDeadline + "T23:59:59") : new Date(nextPaymentDue.getTime() + gracePeriod * 86400000);
                    
                    // Calculate status
                    let paymentStatus = 'up_to_date';
                    let daysLate = 0;
                    let daysUntilDue = Math.floor((nextPaymentDue - today) / (1000 * 60 * 60 * 24));

                    if (today > dueWithGrace) {
                        paymentStatus = 'late';
                        daysLate = Math.floor((today - dueWithGrace) / (1000 * 60 * 60 * 24));
                        if (daysLate >= autoSuspendDays) {
                            paymentStatus = 'suspended';
                        }
                    } else if (today > nextPaymentDue) {
                        paymentStatus = 'pending';
                        daysLate = Math.floor((today - nextPaymentDue) / (1000 * 60 * 60 * 24));
                    }


                    // v4.10.6: Override status if member has incomplete payments for current cycle
                    // Members with num_positions > 1 need that many contributions per cycle
                    const requiredContributions = parseInt(membership.num_positions) || 1;
                    const actualContributions = parseInt(membership.contributions_this_cycle) || 0;
                    if (actualContributions < requiredContributions && paymentStatus === 'up_to_date') {
                        // Member appears up-to-date by date but hasn't completed all position payments
                        paymentStatus = 'pending';
                        daysLate = 0;
                    }

                    // Check if we already sent a notification for this status today
                    const lastNotified = membership.last_notified_payment_status;
                    const lastNotificationAt = membership.last_payment_notification_at;
                    const hoursSinceLastNotification = lastNotificationAt 
                        ? (today - new Date(lastNotificationAt)) / (1000 * 60 * 60) 
                        : 999;

                    // Only send if status changed or 24h passed
                    if (lastNotified === paymentStatus && hoursSinceLastNotification < 24) {
                        continue;
                    }

                    let notificationType = null;
                    let notificationTitle = null;
                    let notificationMessage = null;


                    // v4.11.0: Skip late/suspension notifications for members with approved extension
                    try {
                        const approvedExt = await dbPostgres.pool.query(
                            "SELECT id FROM payment_deferrals WHERE group_id = $1 AND user_id = $2 AND type = 'extension' AND status = 'approved' AND (proposed_date IS NULL OR proposed_date >= CURRENT_DATE) LIMIT 1",
                            [membership.group_id, membership.user_id]
                        );
                        if (approvedExt.rows.length > 0 && (paymentStatus === 'late' || paymentStatus === 'suspended' || paymentStatus === 'pending')) {
                            continue;
                        }
                    } catch (extErr) { /* non-blocking */ }

                    // Determine notification to send
                    if (paymentStatus === 'up_to_date' && daysUntilDue <= 3 && daysUntilDue > 0) {
                        notificationType = 'payment_due_soon';
                        notificationTitle = '⏰ Pago próximo a vencer';
                        notificationMessage = `Tu pago de L. ${membership.contribution_amount} en ${membership.group_name} vence en ${daysUntilDue} día${daysUntilDue !== 1 ? 's' : ''}`;
                        notifications.due_soon++;
                    } else if (paymentStatus === 'late' && daysLate < autoSuspendDays) {
                        const daysUntilSuspend = autoSuspendDays - daysLate;
                        if (daysUntilSuspend <= 2) {
                            notificationType = 'suspension_warning';
                            notificationTitle = '🚨 Advertencia de suspensión';
                            notificationMessage = `Tu membresía en ${membership.group_name} podría ser suspendida pronto si no realizas tu pago. Quedan ${daysUntilSuspend} día${daysUntilSuspend !== 1 ? 's' : ''}`;
                            notifications.suspension_warning++;
                        } else {
                            notificationType = 'payment_late';
                            notificationTitle = '⚠️ Pago atrasado';
                            notificationMessage = `Tienes un pago atrasado de ${daysLate} día${daysLate !== 1 ? 's' : ''} en ${membership.group_name}`;
                            notifications.late++;
                        }
                    } else if (paymentStatus === 'suspended' && lastNotified !== 'suspended') {
                        // v4.10.3: Semi-automatic — notify creator instead of auto-suspending
                        // Send warning to the late member
                        notificationType = 'suspension_recommended';
                        notificationTitle = '🚨 Riesgo de suspensión';
                        notificationMessage = `Llevas ${daysLate} días de atraso en ${membership.group_name}. El coordinador puede suspender tu membresía.`;
                        notifications.suspension_recommended++;

                        // Send recommendation to group creator to decide
                        if (membership.creator_user_id && membership.creator_user_id !== membership.user_id) {
                            const memberDisplayName = membership.member_name || membership.user_id;
                            await dbPostgres.pool.query(
                                'INSERT INTO notifications (user_id, type, title, message, data, created_at) VALUES ($1, $2, $3, $4, $5, NOW())',
                                [
                                    membership.creator_user_id,
                                    'suspension_recommendation',
                                    '⚠️ Miembro con pago muy atrasado',
                                    `${memberDisplayName} lleva ${daysLate} días de atraso en ${membership.group_name}. ¿Deseas suspender su membresía?`,
                                    JSON.stringify({
                                        group_id: membership.group_id,
                                        group_name: membership.group_name,
                                        target_user_id: membership.user_id,
                                        target_user_name: memberDisplayName,
                                        days_late: daysLate,
                                        action: 'suspend_member'
                                    })
                                ]
                            );
                        }
                    }

                    // Send notification if needed
                    if (notificationType) {
                        await dbPostgres.pool.query(
                            'INSERT INTO notifications (user_id, type, title, message, data, created_at) VALUES ($1, $2, $3, $4, $5, NOW())',
                            [membership.user_id, notificationType, notificationTitle, notificationMessage, 
                             JSON.stringify({ group_id: membership.group_id, group_name: membership.group_name, days_late: daysLate })]
                        );

                        // Update last notification status
                        await dbPostgres.pool.query(`
                            UPDATE group_members 
                            SET last_notified_payment_status = $1, last_payment_notification_at = NOW()
                            WHERE user_id = $2 AND group_id = $3
                        `, [paymentStatus, membership.user_id, membership.group_id]);
                        // v4.10.6: Send escalation email based on notification type
                        (async function() {
                            try {
                                const memberEmail = membership.member_email;
                                if (!memberEmail) return;
                                const prefResult = await dbPostgres.pool.query(
                                    "SELECT email_enabled, payment_reminders FROM notification_preferences WHERE user_id = $1",
                                    [membership.user_id]
                                );
                                const emailOk = !prefResult.rows.length || (prefResult.rows[0].email_enabled !== false && prefResult.rows[0].payment_reminders !== false);
                                if (!emailOk) return;
                                const emailData = {
                                    memberName: membership.member_name || 'Miembro',
                                    memberEmail: memberEmail,
                                    groupName: membership.group_name,
                                    amountOwed: parseFloat(membership.contribution_amount) * requiredContributions,
                                    daysLate: daysLate,
                                    cyclesPending: '1',
                                    numPositions: requiredContributions,
                                    contributionsCompleted: actualContributions,
                                };
                                let tpl = null;
                                if (notificationType === 'suspension_recommended') {
                                    tpl = emailTemplates.suspensionWarningEmail(emailData);
                                } else if (notificationType === 'suspension_warning') {
                                    tpl = emailTemplates.paymentLateEmail(emailData);
                                } else if (notificationType === 'payment_late') {
                                    tpl = emailTemplates.paymentReminderEmail(emailData);
                                }
                                if (tpl) {
                                    sendEmail(memberEmail, tpl.subject, tpl.html, 'pagos');
                                }
                            } catch (eErr) { /* non-blocking */ }
                        })();

                        // Collect late member for coordinator digest
                        if (daysLate > 0 && membership.creator_user_id) {
                            const gid = membership.group_id;
                            if (!lateByGroup[gid]) {
                                lateByGroup[gid] = {
                                    groupName: membership.group_name,
                                    creatorUserId: membership.creator_user_id,
                                    members: []
                                };
                            }
                            lateByGroup[gid].members.push({
                                memberName: membership.member_name || membership.user_id,
                                user_id: membership.user_id,
                                daysLate: daysLate,
                                amountOwed: parseFloat(membership.contribution_amount) * requiredContributions
                            });
                        }
                    }
                }


                // v4.10.6: Send coordinator daily digest for groups with late members
                for (const gid of Object.keys(lateByGroup)) {
                    (async function(groupData) {
                        try {
                            const coordInfo = await dbPostgres.pool.query(
                                "SELECT u.email, u.name FROM users u WHERE u.user_id = $1",
                                [groupData.creatorUserId]
                            );
                            if (!coordInfo.rows[0] || !coordInfo.rows[0].email) return;
                            const prefResult = await dbPostgres.pool.query(
                                "SELECT email_enabled FROM notification_preferences WHERE user_id = $1",
                                [groupData.creatorUserId]
                            );
                            const emailOk = !prefResult.rows.length || prefResult.rows[0].email_enabled !== false;
                            if (!emailOk) return;
                            const tpl = emailTemplates.coordinatorLateAlertEmail({
                                coordinatorName: coordInfo.rows[0].name || 'Coordinador',
                                coordinatorEmail: coordInfo.rows[0].email,
                                groupName: groupData.groupName,
                                lateMembers: groupData.members
                            });
                            sendEmail(coordInfo.rows[0].email, tpl.subject, tpl.html, 'pagos');
                        } catch (digestErr) { /* non-blocking */ }
                    })(lateByGroup[gid]);
                }
                sendSuccess(res, {
                    message: 'Payment status check completed',
                    notifications_sent: notifications,
                    total: notifications.due_soon + notifications.late + notifications.suspension_warning + notifications.suspension_recommended
                });
            } catch (error) {
                log('error', 'Payment cron error', { error: error.message });
                sendError(res, 500, 'Error checking payment status');
            }
            return;
        }


        // =============================================
        // LOTTERY AUTO-EXECUTION CRON
        // POST /api/cron/execute-scheduled-lotteries
        // Called every minute by cron to auto-execute scheduled lotteries
        // =============================================
        if (pathname === '/api/cron/execute-scheduled-lotteries' && method === 'POST') {
            const cronKey = req.headers['x-cron-key'];
            if (!safeCompare(String(cronKey || ''), String(process.env.CRON_SECRET_KEY || ''))) {
                sendError(res, 401, 'Cron key invalida');
                return;
            }

            try {
                log('info', 'Running lottery auto-execution cron job');
                const now = new Date();
                
                // Find all tandas with scheduled lottery that should have executed by now
                const pendingLotteries = await dbPostgres.pool.query(`
                    SELECT 
                        t.tanda_id,
                        t.group_id,
                        t.name as tanda_name,
                        t.lottery_scheduled_at,
                        t.lottery_countdown_seconds,
                        g.name as group_name,
                        g.max_members,
                        
                        (SELECT COUNT(*) FROM group_members gm 
                         WHERE gm.group_id = t.group_id AND gm.status = 'active') as member_count,
                        (SELECT SUM(COALESCE(num_positions, 1)) FROM group_members gm 
                         WHERE gm.group_id = t.group_id AND gm.status = 'active') as total_positions
                    FROM tandas t
                    JOIN groups g ON t.group_id = g.group_id
                    WHERE t.lottery_scheduled_at IS NOT NULL
                    AND t.lottery_scheduled_at <= $1
                    AND t.lottery_executed_at IS NULL
                    AND g.status = 'active'
                `, [now]);

                const results = {
                    checked: pendingLotteries.rows.length,
                    executed: 0,
                    skipped: 0,
                    failed: 0,
                    details: []
                };

                for (const lottery of pendingLotteries.rows) {
                    const groupId = lottery.group_id;
                    const memberCount = parseInt(lottery.member_count) || 0;
                    const totalPositions = parseInt(lottery.total_positions) || memberCount;
                    const minMembers = 2; // Minimum members required

                    // Validation: Check minimum members
                    if (memberCount < 2) {
                        // Not enough members - notify admin and skip
                        const creatorResult = await dbPostgres.pool.query(
                            'SELECT user_id FROM group_members WHERE group_id = $1 AND role = \'creator\'',
                            [groupId]
                        );
                        
                        if (creatorResult.rows.length > 0) {
                            await dbPostgres.pool.query(
                                'INSERT INTO notifications (user_id, type, title, message, data, created_at) VALUES ($1, $2, $3, $4, $5, NOW())',
                                [
                                    creatorResult.rows[0].user_id,
                                    'lottery_skipped',
                                    '⚠️ Tómbola no ejecutada',
                                    `La tómbola de ${lottery.group_name} no se pudo ejecutar: solo hay ${memberCount} miembro(s). Se necesitan mínimo 2.`,
                                    JSON.stringify({ group_id: groupId, reason: 'insufficient_members', member_count: memberCount })
                                ]
                            );
                        }

                        // Clear the scheduled time so it doesn't keep trying
                        await dbPostgres.pool.query(
                            'UPDATE tandas SET lottery_scheduled_at = NULL, updated_at = NOW() WHERE tanda_id = $1',
                            [lottery.tanda_id]
                        );

                        results.skipped++;
                        results.details.push({
                            group: lottery.group_name,
                            status: 'skipped',
                            reason: `Solo ${memberCount} miembro(s), mínimo 2`
                        });
                        continue;
                    }

                    // Execute the lottery
                    try {
                        // Get all active members WITH lock status and num_positions
                        const membersResult = await dbPostgres.pool.query(
                            'SELECT gm.user_id, u.name, gm.turn_locked, gm.turn_position, COALESCE(gm.num_positions, 1) as num_positions FROM group_members gm JOIN users u ON gm.user_id = u.user_id WHERE gm.group_id = $1 AND gm.status = \'active\'',
                            [groupId]
                        );

                        // Expand members into individual position entries
                        const allEntries = [];
                        const lockedEntries = [];
                        
                        for (const member of membersResult.rows) {
                            const numPos = parseInt(member.num_positions) || 1;
                            
                            for (let i = 0; i < numPos; i++) {
                                const entry = {
                                    user_id: member.user_id,
                                    name: member.name,
                                    position_number: i + 1,
                                    total_positions: numPos
                                };
                                
                                if (i === 0 && member.turn_locked && member.turn_position) {
                                    lockedEntries.push({
                                        index: member.turn_position - 1,
                                        entry: entry
                                    });
                                } else {
                                    allEntries.push(entry);
                                }
                            }
                        }

                        // Shuffle non-locked entries (Fisher-Yates)
                        for (let i = allEntries.length - 1; i > 0; i--) {
                            const j = crypto.randomInt(0, i + 1);
                            [allEntries[i], allEntries[j]] = [allEntries[j], allEntries[i]];
                        }

                        // Build final array respecting locked positions
                        const members = new Array(totalPositions).fill(null);
                        
                        for (const locked of lockedEntries) {
                            if (locked.index >= 0 && locked.index < totalPositions && !members[locked.index]) {
                                members[locked.index] = locked.entry;
                            }
                        }
                        
                        let shuffleIndex = 0;
                        for (let i = 0; i < totalPositions; i++) {
                            if (!members[i] && shuffleIndex < allEntries.length) {
                                members[i] = allEntries[shuffleIndex++];
                            }
                        }

                        // Filter out any nulls (shouldn't happen but safety check)
                        const finalMembers = members.filter(m => m !== null);
                        const turnsOrder = finalMembers.map(m => m.user_id);

                        // Update tanda with results
                        await dbPostgres.pool.query(
                            'UPDATE tandas SET turns_order = $1, lottery_executed_at = NOW(), updated_at = NOW() WHERE tanda_id = $2',
                            [turnsOrder, lottery.tanda_id]
                        );

                        // Update group_members turn positions (bulk UPDATE)
                        const positions = finalMembers.map((m, i) => i + 1);
                        const userIds = finalMembers.map(m => m.user_id);
                        await dbPostgres.pool.query(
                            `UPDATE group_members AS gm SET turn_position = v.pos
                             FROM (SELECT unnest($1::int[]) AS pos, unnest($2::int[]) AS uid) AS v
                             WHERE gm.group_id = $3 AND gm.user_id = v.uid`,
                            [positions, userIds, groupId]
                        );

                        // Notify all members about their turn
                        for (let i = 0; i < finalMembers.length; i++) {
                            const member = finalMembers[i];
                            const position = i + 1;
                            const positionLabel = member.total_positions > 1 
                                ? ` (${member.position_number}/${member.total_positions})`
                                : '';
                            
                            await dbPostgres.pool.query(
                                'INSERT INTO notifications (user_id, type, title, message, data, created_at) VALUES ($1, $2, $3, $4, $5, NOW())',
                                [
                                    member.user_id,
                                    'lottery_turn_assigned',
                                    '🎯 Turno asignado',
                                    `¡La tómbola de ${lottery.group_name} se ha ejecutado! Tu turno${positionLabel} es el #${position} de ${finalMembers.length}.`,
                                    JSON.stringify({ group_id: groupId, turn: position, total: finalMembers.length })
                                ]
                            );
                        }

                        // Broadcast via WebSocket if available
                        if (wsLottery && typeof wsLottery.broadcastLotteryComplete === 'function') {
                            wsLottery.broadcastLotteryComplete(groupId, lottery.group_name, finalMembers);
                        }

                        results.executed++;
                        results.details.push({
                            group: lottery.group_name,
                            status: 'executed',
                            members: finalMembers.length
                        });

                        log('info', 'Auto-executed lottery', { groupId, groupName: lottery.group_name, members: finalMembers.length });

                    } catch (execError) {
                        log('error', 'Failed to auto-execute lottery', { groupId, error: execError.message });
                        
                        // Notify admin of failure
                        const creatorResult = await dbPostgres.pool.query(
                            'SELECT user_id FROM group_members WHERE group_id = $1 AND role = \'creator\'',
                            [groupId]
                        );
                        
                        if (creatorResult.rows.length > 0) {
                            await dbPostgres.pool.query(
                                'INSERT INTO notifications (user_id, type, title, message, data, created_at) VALUES ($1, $2, $3, $4, $5, NOW())',
                                [
                                    creatorResult.rows[0].user_id,
                                    'lottery_failed',
                                    '❌ Error en tómbola',
                                    `Hubo un error al ejecutar la tómbola de ${lottery.group_name}. Por favor, ejecútala manualmente.`,
                                    JSON.stringify({ group_id: groupId, error: execError.message })
                                ]
                            );
                        }

                        results.failed++;
                        results.details.push({
                            group: lottery.group_name,
                            status: 'failed',
                            error: execError.message
                        });
                    }
                }

                sendSuccess(res, {
                    message: 'Lottery auto-execution completed',
                    results: results
                });
            } catch (error) {
                log('error', 'Lottery cron error', { error: error.message });
                sendError(res, 500, 'Error in lottery cron');
            }
            return;
        }


        // =============================================
        // RECRUITMENT INCENTIVE NOTIFICATIONS CRON
        // POST /api/cron/send-recruitment-reminders
        // Encourages members to invite others when group is not full
        // =============================================
        if (pathname === '/api/cron/send-recruitment-reminders' && method === 'POST') {
            const cronKey = req.headers['x-cron-key'];
            if (!safeCompare(String(cronKey || ''), String(process.env.CRON_SECRET_KEY || ''))) {
                sendError(res, 401, 'Cron key invalida');
                return;
            }

            try {
                log('info', 'Running recruitment reminder cron job');
                
                // Find groups that are recruiting and less than 80% full
                const groupsResult = await dbPostgres.pool.query(`
                    SELECT 
                        g.group_id,
                        g.name,
                        g.max_members,
                        g.contribution_amount,
                        g.frequency,
                        g.last_recruitment_notification_at,
                        COUNT(gm.user_id) as current_members,
                        g.max_members - COUNT(gm.user_id) as spots_left
                    FROM groups g
                    LEFT JOIN group_members gm ON g.group_id = gm.group_id AND gm.status = 'active'
                    WHERE g.status = 'active'
                    GROUP BY g.group_id, g.name, g.max_members, g.contribution_amount, g.frequency, g.last_recruitment_notification_at
                    HAVING COUNT(gm.user_id) < g.max_members * 0.8
                    AND COUNT(gm.user_id) >= 1
                `);

                const results = {
                    groups_checked: groupsResult.rows.length,
                    notifications_sent: 0,
                    groups_notified: [],
                    skipped: 0
                };

                for (const group of groupsResult.rows) {
                    // Check if we already sent a notification in the last 3 days
                    if (group.last_recruitment_notification_at) {
                        const daysSinceLastNotification = (Date.now() - new Date(group.last_recruitment_notification_at).getTime()) / (1000 * 60 * 60 * 24);
                        if (daysSinceLastNotification < 3) {
                            results.skipped++;
                            continue;
                        }
                    }

                    const spotsLeft = parseInt(group.spots_left);
                    const currentMembers = parseInt(group.current_members);
                    const percentFull = Math.round((currentMembers / group.max_members) * 100);

                    // Get all active members to notify
                    const membersResult = await dbPostgres.pool.query(`
                        SELECT gm.user_id, u.name
                        FROM group_members gm
                        JOIN users u ON gm.user_id = u.user_id
                        WHERE gm.group_id = $1 AND gm.status = 'active'
                    `, [group.group_id]);

                    // Determine urgency message
                    let urgencyMessage = '';
                    let notificationType = 'recruitment_reminder';
                    
                    if (percentFull <= 30) {
                        urgencyMessage = '¡Tu grupo está comenzando! Invita amigos para completarlo más rápido.';
                        notificationType = 'recruitment_starting';
                    } else if (percentFull <= 50) {
                        urgencyMessage = 'Ya van ' + currentMembers + ' miembros. ¡Faltan ' + spotsLeft + ' para completar el grupo!';
                        notificationType = 'recruitment_halfway';
                    } else if (percentFull <= 70) {
                        urgencyMessage = '¡Casi completo! Solo faltan ' + spotsLeft + ' miembros para iniciar la tanda.';
                        notificationType = 'recruitment_almost_full';
                    } else {
                        urgencyMessage = '¡Últimos ' + spotsLeft + ' espacios! Invita ahora antes de que se llene.';
                        notificationType = 'recruitment_urgent';
                    }

                    const frequencyLabel = {
                        'weekly': 'semanal',
                        'biweekly': 'quincenal', 
                        'monthly': 'mensual'
                    }[group.frequency] || group.frequency;

                    // Send notification to each member
                    for (const member of membersResult.rows) {
                        await dbPostgres.pool.query(
                            'INSERT INTO notifications (user_id, type, title, message, data, created_at) VALUES ($1, $2, $3, $4, $5, NOW())',
                            [
                                member.user_id,
                                notificationType,
                                '📢 ¡' + group.name + ' necesita más miembros!',
                                urgencyMessage + ' Aporte ' + frequencyLabel + ': L. ' + group.contribution_amount,
                                JSON.stringify({ 
                                    group_id: group.group_id, 
                                    group_name: group.name,
                                    spots_left: spotsLeft,
                                    percent_full: percentFull,
                                    action: 'open_invite_modal'
                                })
                            ]
                        );
                        results.notifications_sent++;
                    }

                    // Update last notification time for this group
                    await dbPostgres.pool.query(
                        'UPDATE groups SET last_recruitment_notification_at = NOW() WHERE group_id = $1',
                        [group.group_id]
                    );

                    results.groups_notified.push({
                        name: group.name,
                        members_notified: membersResult.rows.length,
                        spots_left: spotsLeft,
                        percent_full: percentFull
                    });
                }

                log('info', 'Recruitment reminders completed', results);

                sendSuccess(res, {
                    message: 'Recruitment reminders sent',
                    results: results
                });
            } catch (error) {
                log('error', 'Recruitment cron error', { error: error.message });
                sendError(res, 500, 'Error sending recruitment reminders');
            }
            return;
        }




        // =============================================

        // =============================================
        // GLOBAL SEARCH ENDPOINT
        // Added: 2025-12-12
        // =============================================
        
        // GET /api/search - Global search across groups, tandas, users, transactions
        if (pathname === "/api/search" && method === "GET") {
            const urlParams = new URL(req.url, "http://localhost").searchParams;
            const query = urlParams.get("q") || urlParams.get("query") || "";
            const userId = urlParams.get("user_id") || "";
            const limit = parseInt(urlParams.get("limit")) || 10;
            
            if (!query || query.length < 2) {
                sendError(res, 400, "Query must be at least 2 characters");
                return;
            }
            
            try {
                log("info", "Global search", { query, userId, limit });
                const searchPattern = "%" + query.toLowerCase() + "%";
                const results = { groups: [], tandas: [], users: [], transactions: [] };
                
                // Search groups
                const groupsResult = await dbPostgres.pool.query(
                    `SELECT group_id as id, name, description, status, member_count, contribution_amount, category
                     FROM groups 
                     WHERE LOWER(name) LIKE $1 OR LOWER(description) LIKE $1
                     ORDER BY created_at DESC LIMIT $2`,
                    [searchPattern, Math.min(limit, 5)]
                );
                results.groups = groupsResult.rows.map(g => ({
                    id: g.id,
                    type: "group",
                    title: g.name,
                    subtitle: g.description || g.category || "Grupo",
                    status: g.status,
                    members: g.member_count,
                    contribution: g.contribution_amount
                }));
                
                // Search tandas
                const tandasResult = await dbPostgres.pool.query(
                    `SELECT t.tanda_id as id, t.name, t.status, t.contribution_amount, t.frequency, g.name as group_name
                     FROM tandas t
                     LEFT JOIN groups g ON t.group_id = g.group_id
                     WHERE LOWER(t.name) LIKE $1
                     ORDER BY t.created_at DESC LIMIT $2`,
                    [searchPattern, Math.min(limit, 5)]
                );
                results.tandas = tandasResult.rows.map(t => ({
                    id: t.id,
                    type: "tanda",
                    title: t.name,
                    subtitle: t.group_name || t.frequency || "Tanda",
                    status: t.status,
                    contribution: t.contribution_amount
                }));
                
                // Search users (only if admin or searching own profile)
                const usersResult = await dbPostgres.pool.query(
                    `SELECT user_id as id, name, email, verification_level, status
                     FROM users 
                     WHERE (LOWER(name) LIKE $1 OR LOWER(email) LIKE $1)
                     AND status != 'deleted'
                     ORDER BY created_at DESC LIMIT $2`,
                    [searchPattern, Math.min(limit, 5)]
                );
                results.users = usersResult.rows.map(u => ({
                    id: u.id,
                    type: "user",
                    title: u.name,
                    subtitle: u.email,
                    trustScore: u.verification_level,
                    status: u.status
                }));
                
                // Search transactions (for specific user)
                if (userId) {
                    const txResult = await dbPostgres.pool.query(
                        `SELECT id, type, amount, status, currency, created_at, reference_number
                         FROM deposits WHERE user_id = $1 AND (LOWER(reference_number) LIKE $2 OR CAST(amount AS TEXT) LIKE $2)
                         UNION ALL
                         SELECT id, withdrawal as type, amount, status, currency, created_at, reference_number
                         FROM withdrawals WHERE user_id = $1 AND (LOWER(reference_number) LIKE $2 OR CAST(amount AS TEXT) LIKE $2)
                         ORDER BY created_at DESC LIMIT $3`,
                        [userId, searchPattern, Math.min(limit, 5)]
                    );
                    results.transactions = txResult.rows.map(tx => ({
                        id: tx.id,
                        type: "transaction",
                        title: (tx.type === "deposit" ? "Depósito" : "Retiro") + " " + tx.currency + " " + tx.amount,
                        subtitle: tx.status + " - " + (tx.reference_number || new Date(tx.created_at).toLocaleDateString()),
                        status: tx.status,
                        amount: tx.amount
                    }));
                }
                
                const totalResults = results.groups.length + results.tandas.length + results.users.length + results.transactions.length;
                
                sendSuccess(res, {
                    query: query,
                    total: totalResults,
                    results: results
                });
            } catch (error) {
                log("error", "Search error", { error: error.message });
                log("error", "Error en busqueda", { error: error.message }); sendError(res, 500, "Error interno del servidor");
            }
            return;
        }

        // STATISTICS/DASHBOARD ENDPOINTS
        // Added: 2025-11-25
        // =============================================
        

        // =============================================
        // CALENDAR/SCHEDULE ENDPOINTS
        // Added: 2025-11-25
        // =============================================
        
        // GET /api/groups/:groupId/calendar - Get payment calendar/schedule
        if (pathname.match(/^\/api\/groups\/[^\/]+\/calendar$/) && method === 'GET') {
            // SECURITY: Require authentication (v4.10.1)
            const authUserCal = requireAuth(req, res);
            if (!authUserCal) return;

            const groupId = pathname.split('/')[3];
            const urlParts = parseUrl(req.url);
            const month = urlParts.query.month; // Format: YYYY-MM
            
            log('info', 'Getting payment calendar', { groupId, month });
            
            try {
                // Get group info
                const groupResult = await dbPostgres.pool.query(
                    `SELECT g.group_id, g.name, g.contribution_amount, g.frequency, g.member_count, g.max_members, g.total_amount_collected, g.admin_id, g.status, g.created_at, g.location, g.description, g.image_url, g.category, g.meeting_schedule, g.updated_at, g.is_demo, g.start_date, g.grace_period, g.penalty_amount, g.current_cycle, g.lottery_executed, g.lottery_executed_at, g.lottery_scheduled_at, g.deleted_at, g.deleted_by, g.approval_settings, g.last_recruitment_notification_at, COALESCE((SELECT SUM(COALESCE(num_positions, 1)) FROM group_members WHERE group_id = g.group_id AND status = 'active'), 0) as total_positions FROM groups g WHERE g.group_id = $1`,
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                
                const groupData = groupResult.rows[0];
                
                // Get the tanda associated with this group to use real turns_order
                const tandaResult = await dbPostgres.pool.query(
                    'SELECT tanda_id, name, status, turns_order, total_per_turn, contribution_amount, frequency, total_turns, current_turn FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1',
                    [groupId]
                );
                
                const tanda = tandaResult.rows[0];
                const turnsOrder = tanda && tanda.turns_order ? tanda.turns_order : [];
                // Calculate dynamically from group data: contribution * max_members (total designed positions)
                const totalPerTurn = (tanda ? parseFloat(tanda.contribution_amount) || parseFloat(groupData.contribution_amount) || 0 : parseFloat(groupData.contribution_amount) || 0) * (parseInt(groupData.max_members) || parseInt(groupData.total_positions) || 1);
                let expandedOrder = [];
                const contributionAmount = tanda ? parseFloat(tanda.contribution_amount) || parseFloat(groupData.contribution_amount) || 0 : parseFloat(groupData.contribution_amount) || 0;
                const frequency = tanda ? tanda.frequency || groupData.frequency || 'monthly' : groupData.frequency || 'monthly';
                const totalTurns = tanda ? tanda.total_turns || 8 : 8;
                const currentTurn = tanda ? tanda.current_turn || 0 : 0;
                
                // Get user names for users in turns_order
                let membersInOrder = [];
                if (turnsOrder.length > 0) {
                    const usersResult = await dbPostgres.pool.query(
                        'SELECT user_id, name FROM users WHERE user_id = ANY($1)',
                        [turnsOrder]
                    );
                    
                    // Create a map for quick lookup
                    const userMap = {};
                    usersResult.rows.forEach(function(u) {
                        userMap[u.user_id] = u.name;
                    });
                    
                    // Maintain the order from turns_order
                    membersInOrder = turnsOrder.map(function(userId, index) {
                        return {
                            user_id: userId,
                            name: userMap[userId] || 'Miembro ' + (index + 1),
                            position: index + 1
                        };
                    });
                }
                
                // Generate schedule based on turns_order
                const upcomingDates = [];
                const startDate = groupData.start_date ? new Date(groupData.start_date) : new Date(groupData.created_at);
                const graceDays = parseInt(groupData.grace_period) || 5;
                
                                // Date helpers now use centralized getPaymentDueDate()
                // Generate dates for each turn
                const turnsToShow = Math.max(membersInOrder.length, totalTurns);
                
                // Use centralized helper for all frequency types
                for (var i = 0; i < turnsToShow; i++) {
                    var dueDateInfo = getPaymentDueDate(frequency, startDate, i + 1, graceDays);
                    var member = membersInOrder[i] || null;
                    upcomingDates.push({
                        date: dueDateInfo.dueDate,
                        payment_date: dueDateInfo.dueDate,
                        deadline_date: dueDateInfo.graceDeadline,
                        grace_days: (frequency === 'weekly') ? 0 : graceDays,
                        position: i + 1,
                        beneficiary: member ? {
                            user_id: member.user_id,
                            name: member.name
                        } : null,
                        amount: totalPerTurn,
                        status: i === currentTurn ? 'current' : (i < currentTurn ? 'completed' : 'upcoming'),
                        label: dueDateInfo.label
                    });
                }
                // Translate frequency to Spanish
                const frequencyMap = {
                    'weekly': 'Semanal',
                    'biweekly': 'Quincenal',
                    'monthly': 'Mensual'
                };
                
                const calendar = {
                    group: {
                        id: groupData.group_id,
                        name: groupData.name,
                        frequency: frequencyMap[frequency] || frequency,
                        contribution_amount: contributionAmount
                    },
                    tanda: tanda ? {
                        id: tanda.tanda_id,
                        name: tanda.name,
                        status: tanda.status,
                        total_per_turn: totalPerTurn,
                        total_turns: totalTurns,
                        current_turn: currentTurn,
                        turns_assigned: turnsOrder.length,
                    expanded_order: expandedOrder
                    } : null,
                    schedule: upcomingDates,
                    payment_rules: frequency === "biweekly" ? { type: "quincenal", payment_dates: "15 y ultimo dia de cada mes", grace_period: graceDays + " dias", deadlines: "20 y 5 de cada mes", description: "Las fechas de pago son los 15 y ultimo de cada mes. Periodo de gracia: " + graceDays + " dias (puede pagar hasta el 20 y 5)." } : frequency === "weekly" ? { type: "semanal", payment_dates: "Cada 7 dias desde fecha de inicio", grace_period: "Sin periodo de gracia", deadlines: "Mismo dia de pago", description: "Pago semanal cada 7 dias. Sin periodo de gracia." } : { type: "mensual", payment_dates: "Mismo dia cada mes (desde fecha de inicio)", grace_period: graceDays + " dias", deadlines: "" + graceDays + " dias despues de la fecha de pago", description: "Pago mensual el dia " + startDate.getDate() + " de cada mes. Periodo de gracia: " + graceDays + " dias." },
                    total_members: parseInt(groupData.total_positions) || membersInOrder.length,
                    currency: 'L.'
                };
                
                sendSuccess(res, calendar);
            } catch (error) {
                log("error", 'Calendar ERROR:', error); log('error', 'Error getting calendar', { error: error.message, groupId });
                sendError(res, 500, 'Error al obtener calendario');
            }
            return;
        }
        // GET /api/groups/:groupId/stats - Get group statistics dashboard
        if (pathname.match(/^\/api\/groups\/[^\/]+\/stats$/) && method === 'GET') {
            // SECURITY: Require authentication (v4.10.1)
            const authUserStats = requireAuth(req, res);
            if (!authUserStats) return;

            const groupId = pathname.split('/')[3];
            
            log('info', 'Getting group statistics', { groupId });
            
            try {
                // Get group info
                const groupResult = await dbPostgres.pool.query(
                    'SELECT g.group_id, g.name, g.contribution_amount, g.frequency, g.member_count, g.max_members, g.total_amount_collected, g.admin_id, g.status, g.created_at, g.location, g.description, g.image_url, g.category, g.meeting_schedule, g.updated_at, g.is_demo, g.start_date, g.grace_period, g.penalty_amount, g.current_cycle, g.lottery_executed, g.lottery_executed_at, g.lottery_scheduled_at, g.deleted_at, g.deleted_by, g.approval_settings, g.last_recruitment_notification_at, t.status as tanda_status FROM groups g LEFT JOIN (SELECT DISTINCT ON (group_id) group_id, status FROM tandas ORDER BY group_id, created_at DESC) t ON g.group_id = t.group_id WHERE g.group_id = $1',
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                // SECURITY: Check membership (group member, group admin, or platform admin)
                const statsMemberCheck = await dbPostgres.pool.query(
                "SELECT 1 FROM group_members WHERE group_id = $1 AND user_id = $2 AND status NOT IN ('removed', 'rejected') UNION SELECT 1 FROM groups WHERE group_id = $1 AND admin_id = $2",
                [groupId, authUserStats.userId]
            );
                if (statsMemberCheck.rows.length === 0 && authUserStats.role !== 'admin') {
                    sendError(res, 403, 'No tienes acceso a este grupo');
                    return;
                }

                
                const groupData = groupResult.rows[0];
                
                // Get member statistics
                const memberStats = await dbPostgres.pool.query(`
                    SELECT 
                        COUNT(*) as total_members,
                        COUNT(CASE WHEN status = 'active' THEN 1 END) as active_members,
                        COUNT(CASE WHEN role = 'admin' THEN 1 END) as admins
                    FROM group_members 
                    WHERE group_id = $1 AND status = 'active'
                `, [groupId]);
                
                // Get payment statistics
                const paymentStats = await dbPostgres.pool.query(`
                    SELECT 
                        COUNT(*) as total_payments,
                        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_payments,
                        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_payments,
                        COALESCE(SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END), 0) as total_collected,
                        COALESCE(SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END), 0) as pending_amount,
                        COALESCE(AVG(CASE WHEN status = 'completed' THEN amount END), 0) as avg_payment
                    FROM contributions 
                    WHERE group_id = $1
                `, [groupId]);
                
                // Get payments by month (last 6 months)
                const monthlyStats = await dbPostgres.pool.query(`
                    SELECT 
                        TO_CHAR(created_at, 'YYYY-MM') as month,
                        COUNT(*) as payments,
                        COALESCE(SUM(amount), 0) as amount
                    FROM contributions 
                    WHERE group_id = $1 
                        AND status = 'completed'
                        AND created_at >= NOW() - INTERVAL '6 months'
                    GROUP BY TO_CHAR(created_at, 'YYYY-MM')
                    ORDER BY month DESC
                `, [groupId]);
                
                // Get top contributors
                const topContributors = await dbPostgres.pool.query(`
                    SELECT 
                        c.user_id,
                        u.name,
                        COUNT(*) as payment_count,
                        COALESCE(SUM(c.amount), 0) as total_contributed
                    FROM contributions c
                    LEFT JOIN users u ON c.user_id = u.user_id
                    WHERE c.group_id = $1 AND c.status = 'completed'
                    GROUP BY c.user_id, u.name
                    ORDER BY total_contributed DESC
                    LIMIT 5
                `, [groupId]);
                
                const ms = memberStats.rows[0];
                const ps = paymentStats.rows[0];
                const expectedTotal = parseFloat(groupData.contribution_amount || 0) * parseInt(groupData.total_members || ms.total_members);
                const collectedTotal = parseFloat(ps.total_collected) || 0;
                const completionRate = expectedTotal > 0 ? Math.round((collectedTotal / expectedTotal) * 100) : 0;
                
                const stats = {
                    group: {
                        id: groupData.group_id,
                        name: groupData.name,
                        contribution_amount: parseFloat(groupData.contribution_amount) || 0,
                        frequency: groupData.frequency,
                        status: groupData.tanda_status || groupData.status
                    },
                    members: {
                        total: parseInt(ms.total_members) || 0,
                        active: parseInt(ms.active_members) || 0,
                        admins: parseInt(ms.admins) || 0
                    },
                    payments: {
                        total: parseInt(ps.total_payments) || 0,
                        completed: parseInt(ps.completed_payments) || 0,
                        pending: parseInt(ps.pending_payments) || 0,
                        total_collected: collectedTotal,
                        pending_amount: parseFloat(ps.pending_amount) || 0,
                        average: parseFloat(ps.avg_payment) || 0,
                        completion_rate: completionRate
                    },
                    monthly: monthlyStats.rows.map(function(m) {
                        return {
                            month: m.month,
                            payments: parseInt(m.payments),
                            amount: parseFloat(m.amount)
                        };
                    }),
                    top_contributors: topContributors.rows.map(function(c) {
                        return {
                            user_id: c.user_id,
                            name: c.name || 'Usuario',
                            payment_count: parseInt(c.payment_count),
                            total: parseFloat(c.total_contributed)
                        };
                    })
                };
                
                sendSuccess(res, stats);
            } catch (error) {
                log('error', 'Error getting group stats', { error: error.message, groupId });
                sendError(res, 500, 'Error al obtener estadisticas');
            }
            return;
        }
        
        // GET /api/user/:userId/stats - Get user statistics across all groups
        if (pathname.match(/^\/api\/user\/[^\/]+\/stats$/) && method === 'GET') {
            const userId = pathname.split('/')[3];
            
            log('info', 'Getting user statistics', { userId });
            
            try {
                // Get user groups count
                const groupStats = await dbPostgres.pool.query(`
                    SELECT 
                        COUNT(*) as total_groups,
                        COUNT(CASE WHEN role = 'admin' THEN 1 END) as admin_groups
                    FROM group_members 
                    WHERE user_id = $1 AND status = 'active'
                `, [userId]);
                
                // Get user payment statistics
                const paymentStats = await dbPostgres.pool.query(`
                    SELECT 
                        COUNT(*) as total_payments,
                        COALESCE(SUM(amount), 0) as total_paid,
                        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed,
                        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending
                    FROM contributions 
                    WHERE user_id = $1
                `, [userId]);
                
                // Get recent activity
                const recentActivity = await dbPostgres.pool.query(`
                    SELECT 
                        c.id,
                        c.amount,
                        c.status,
                        c.created_at,
                        g.name as group_name
                    FROM contributions c
                    LEFT JOIN groups g ON c.group_id = g.group_id
                    WHERE c.user_id = $1
                    ORDER BY c.created_at DESC
                    LIMIT 10
                `, [userId]);
                
                const gs = groupStats.rows[0];
                const ps = paymentStats.rows[0];
                
                const stats = {
                    groups: {
                        total: parseInt(gs.total_groups) || 0,
                        as_admin: parseInt(gs.admin_groups) || 0
                    },
                    payments: {
                        total: parseInt(ps.total_payments) || 0,
                        completed: parseInt(ps.completed) || 0,
                        pending: parseInt(ps.pending) || 0,
                        total_paid: parseFloat(ps.total_paid) || 0
                    },
                    recent_activity: recentActivity.rows.map(function(a) {
                        return {
                            id: a.id,
                            amount: parseFloat(a.amount),
                            status: a.status,
                            group_name: a.group_name,
                            date: a.created_at
                        };
                    })
                };
                
                sendSuccess(res, stats);
            } catch (error) {
                log('error', 'Error getting user stats', { error: error.message, userId });
                sendError(res, 500, 'Error al obtener estadisticas del usuario');
            }
            return;
        }

        // Get group contributions/payments (PostgreSQL)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/contributions$/) && method === "GET") {
            // SECURITY: Require authentication (v4.10.1)
            const authUserContrib = requireAuth(req, res);
            if (!authUserContrib) return;

            const groupId = pathname.split("/")[3];
            log("info", "Fetching contributions for group: " + groupId);

            try {
                // Get group info first
                const group = await db.getGroupById(groupId);
                if (!group) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                // SECURITY: Check membership (group member, group admin, or platform admin)
                const contribMemberCheck = await dbPostgres.pool.query(
                    "SELECT 1 FROM group_members WHERE group_id = $1 AND user_id = $2 AND status NOT IN ('removed', 'rejected') UNION SELECT 1 FROM groups WHERE group_id = $1 AND admin_id = $2",
                    [groupId, authUserContrib.userId]
                );
                if (contribMemberCheck.rows.length === 0 && authUserContrib.role !== 'admin') {
                    sendError(res, 403, "No tienes acceso a este grupo");
                    return;
                }

                // Parse query params for filtering
                const urlParts = parseUrl(req.url);
                const options = {
                    status: urlParts.query.status || null,
                    limit: Math.min(parseInt(urlParts.query.limit) || 50, 100),
                    offset: parseInt(urlParts.query.offset) || 0
                };

                // Get contributions from PostgreSQL
                const result = await db.getGroupContributions(groupId, options);

                sendSuccess(res, {
                    group_id: groupId,
                    group_name: group.name || group.group_name,
                    contributions: result.contributions.map(c => ({
                        id: c.id,
                        user_id: c.user_id,
                        user_name: c.user_name,
                        user_email: c.user_email,
                        user_avatar: c.user_avatar,
                        amount: parseFloat(c.amount),
                        payment_method: c.payment_method,
                        status: c.status,
                        transaction_id: c.transaction_id,
                        confirmation_code: c.confirmation_code,
                        notes: c.notes,
                        due_date: c.due_date,
                        paid_date: c.paid_date,
                        cycle_number: c.cycle_number,
                        created_at: c.created_at,
                        verified_by: c.verified_by || null,
                        verified_by_name: c.verified_by_name || null,
                        verification_method: c.verification_method || null
                    })),
                    totals: {
                        total_count: parseInt(result.totals.total_count),
                        total_completed: parseFloat(result.totals.total_completed),
                        total_pending: parseFloat(result.totals.total_pending),
                        completed_count: parseInt(result.totals.completed_count),
                        pending_count: parseInt(result.totals.pending_count)
                    }
                });
            } catch (error) {
                log("error", "Error fetching group contributions", { groupId, error: error.message });
                sendError(res, 500, "Error al obtener historial de pagos");
            }
            return;
        }


        // ===== Contribution History (timeline + matrix) =====
        if (pathname.match(/^\/api\/groups\/[^\/]+\/contribution-history$/) && method === "GET") {
            const authUserHist = requireAuth(req, res);
            if (!authUserHist) return;

            const groupId = pathname.split("/")[3];
            const urlPartsHist = parseUrl(req.url);
            const view = urlPartsHist.query.view || 'timeline';
            const targetUserId = urlPartsHist.query.user_id || null;

            try {
                // Membership + role check
                const memberCheck = await dbPostgres.pool.query(
                    `SELECT gm.role, gm.status, gm.user_id,
                            g.admin_id, g.name AS group_name, g.current_cycle, g.max_members,
                            g.contribution_amount, g.frequency, g.start_date
                     FROM group_members gm
                     JOIN groups g ON g.group_id = gm.group_id
                     WHERE gm.group_id = $1 AND gm.user_id = $2
                       AND gm.status NOT IN ('removed','rejected')`,
                    [groupId, authUserHist.userId]
                );
                if (memberCheck.rows.length === 0 && authUserHist.role !== 'admin') {
                    sendError(res, 403, "No tienes acceso a este grupo");
                    return;
                }

                const memberRow = memberCheck.rows[0] || {};
                const isAdmin = ['creator','coordinator','admin'].includes(memberRow.role) ||
                                memberRow.admin_id === authUserHist.userId ||
                                authUserHist.role === 'admin';
                const currentCycle = parseInt(memberRow.current_cycle) || 1;
                const maxMembers = parseInt(memberRow.max_members) || 1;
                const contributionAmount = parseFloat(memberRow.contribution_amount) || 0;

                // Authorization: matrix or viewing another user requires coordinator/creator
                if (view === 'matrix' && !isAdmin) {
                    sendError(res, 403, "Solo coordinadores pueden ver la matriz de pagos");
                    return;
                }
                if (targetUserId && targetUserId !== authUserHist.userId && !isAdmin) {
                    sendError(res, 403, "No puedes ver el historial de otro miembro");
                    return;
                }

                if (view === 'matrix') {
                    // ---- MATRIX VIEW (coordinator) ----
                    const [contribResult, membersResult] = await Promise.all([
                        dbPostgres.pool.query(
                            `SELECT c.user_id, c.cycle_number, c.status, c.id AS contribution_id,
                                    c.amount, c.paid_date, c.verification_method
                             FROM contributions c
                             WHERE c.group_id = $1
                             ORDER BY c.cycle_number, c.user_id`,
                            [groupId]
                        ),
                        dbPostgres.pool.query(
                            `SELECT gm.user_id, u.name, u.email,
                                    COALESCE(gm.num_positions, 1) AS num_positions,
                                    gm.role
                             FROM group_members gm
                             JOIN users u ON u.user_id = gm.user_id
                             WHERE gm.group_id = $1
                               AND gm.status NOT IN ('removed','rejected')
                             ORDER BY u.name`,
                            [groupId]
                        )
                    ]);

                    // Build contributions map: { user_id: { cycle: { status, contribution_id } } }
                    const contribMap = {};
                    for (const row of contribResult.rows) {
                        if (!contribMap[row.user_id]) contribMap[row.user_id] = {};
                        contribMap[row.user_id][row.cycle_number] = {
                            status: row.status,
                            contribution_id: row.contribution_id,
                            amount: parseFloat(row.amount),
                            paid_date: row.paid_date,
                            verification_method: row.verification_method
                        };
                    }

                    // Cycle totals
                    const cycleTotals = [];
                    for (let cy = 1; cy <= currentCycle; cy++) {
                        let paid = 0, total = membersResult.rows.length;
                        for (const m of membersResult.rows) {
                            const entry = (contribMap[m.user_id] || {})[cy];
                            if (entry && ['completed','coordinator_approved','archived'].includes(entry.status)) {
                                paid++;
                            }
                            // refunded entries not counted as paid
                        }
                        cycleTotals.push({ cycle: cy, paid, total, percent: total > 0 ? Math.round((paid / total) * 100) : 0 });
                    }

                    sendSuccess(res, {
                        view: 'matrix',
                        group_id: groupId,
                        group_name: memberRow.group_name,
                        current_cycle: currentCycle,
                        max_members: maxMembers,
                        contribution_amount: contributionAmount,
                        members: membersResult.rows.map(m => ({
                            user_id: m.user_id,
                            name: m.name,
                            email: m.email,
                            num_positions: parseInt(m.num_positions),
                            role: m.role
                        })),
                        contributions: contribMap,
                        cycle_totals: cycleTotals
                    });
                } else {
                    // ---- TIMELINE VIEW (single member) ----
                    const userId = targetUserId || authUserHist.userId;

                    const contribResult = await dbPostgres.pool.query(
                        `SELECT c.id, c.cycle_number, c.amount, c.status, c.payment_method,
                                c.transaction_id, c.confirmation_code, c.notes,
                                c.due_date, c.paid_date, c.proof_url,
                                c.verified_by, c.verified_at, c.verification_method,
                                c.rejection_reason, c.created_at,
                                c.reversed_by, c.reversed_at, c.reversal_reason,
                                v.name AS verified_by_name,
                                rv.name AS reversed_by_name
                         FROM contributions c
                         LEFT JOIN users v ON v.user_id = c.verified_by
                         LEFT JOIN users rv ON rv.user_id = c.reversed_by
                         WHERE c.group_id = $1 AND c.user_id = $2
                         ORDER BY c.cycle_number ASC, c.created_at ASC`,
                        [groupId, userId]
                    );

                    // Get member name
                    const memberNameResult = await dbPostgres.pool.query(
                        `SELECT u.name, COALESCE(gm.num_positions, 1) AS num_positions
                         FROM users u
                         LEFT JOIN group_members gm ON gm.user_id = u.user_id AND gm.group_id = $2
                         WHERE u.user_id = $1`,
                        [userId, groupId]
                    );
                    const memberName = memberNameResult.rows[0]?.name || 'Miembro';
                    const numPositions = parseInt(memberNameResult.rows[0]?.num_positions) || 1;

                    // Summary
                    let cyclesPaid = 0, totalPaid = 0, cyclesPending = 0;
                    const paidStatuses = ['completed','coordinator_approved','archived'];
                    for (const c of contribResult.rows) {
                        if (paidStatuses.includes(c.status)) {
                            cyclesPaid++;
                            totalPaid += parseFloat(c.amount);
                        } else if (c.status === 'pending' || c.status === 'pending_verification' || c.status === 'awaiting_payment') {
                            cyclesPending++;
                        }
                    }

                    sendSuccess(res, {
                        view: 'timeline',
                        group_id: groupId,
                        group_name: memberRow.group_name,
                        current_cycle: currentCycle,
                        max_members: maxMembers,
                        contribution_amount: contributionAmount,
                        member_name: memberName,
                        member_user_id: userId,
                        num_positions: numPositions,
                        contributions: contribResult.rows.map(c => ({
                            id: c.id,
                            cycle_number: c.cycle_number,
                            amount: parseFloat(c.amount),
                            status: c.status,
                            payment_method: c.payment_method,
                            transaction_id: c.transaction_id,
                            confirmation_code: c.confirmation_code,
                            notes: c.notes,
                            due_date: c.due_date,
                            paid_date: c.paid_date,
                            proof_url: c.proof_url,
                            verified_by: c.verified_by,
                            verified_by_name: c.verified_by_name,
                            verified_at: c.verified_at,
                            verification_method: c.verification_method,
                            rejection_reason: c.rejection_reason,
                            reversed_by: c.reversed_by,
                            reversed_at: c.reversed_at,
                            reversal_reason: c.reversal_reason,
                            reversed_by_name: c.reversed_by_name,
                            created_at: c.created_at
                        })),
                        summary: {
                            cycles_paid: cyclesPaid,
                            cycles_pending: cyclesPending,
                            cycles_total: currentCycle,
                            total_paid: totalPaid,
                            num_positions: numPositions
                        }
                    });
                }
            } catch (error) {
                log("error", "Error fetching contribution history", { groupId, error: error.message });
                sendError(res, 500, "Error al obtener historial de contribuciones");
            }
            return;
        }

        // ===== Reverse Contribution (v4.11.2) =====
        if (pathname.match(/^\/api\/contributions\/[^\/]+\/reverse$/) && method === "POST") {
            const authUserRev = requireAuth(req, res);
            if (!authUserRev) return;

            const contributionId = pathname.split("/")[3];

            try {
                // Fetch contribution
                const contribResult = await dbPostgres.pool.query(
                    `SELECT c.id, c.user_id, c.group_id, c.amount, c.status, c.payment_method, c.cycle_number,
                            g.admin_id, g.name AS group_name
                     FROM contributions c
                     JOIN groups g ON g.group_id = c.group_id
                     WHERE c.id = $1`,
                    [contributionId]
                );
                if (contribResult.rows.length === 0) {
                    sendError(res, 404, "Contribucion no encontrada");
                    return;
                }

                const contrib = contribResult.rows[0];

                // Already refunded?
                if (contrib.status === 'refunded') {
                    sendError(res, 400, "Esta contribucion ya fue revertida");
                    return;
                }

                // Only reversible statuses
                const reversibleStatuses = ['completed', 'coordinator_approved', 'archived'];
                if (!reversibleStatuses.includes(contrib.status)) {
                    sendError(res, 400, "Solo se pueden revertir pagos completados");
                    return;
                }

                // Authorization: must be coordinator/creator of the group or platform admin
                const memberAuth = await dbPostgres.pool.query(
                    `SELECT role FROM group_members
                     WHERE group_id = $1 AND user_id = $2
                       AND status NOT IN ('removed','rejected')`,
                    [contrib.group_id, authUserRev.userId]
                );
                const callerRole = memberAuth.rows[0]?.role;
                const isAuthorized = ['creator', 'coordinator'].includes(callerRole) ||
                                     contrib.admin_id === authUserRev.userId ||
                                     authUserRev.role === 'admin';

                if (!isAuthorized) {
                    sendError(res, 403, "Solo coordinadores pueden revertir pagos");
                    return;
                }

                const reason = (body.reason || '').trim().slice(0, 500) || 'Sin motivo especificado';
                const amount = parseFloat(contrib.amount);

                // Transaction block
                const client = await dbPostgres.pool.connect();
                try {
                    await client.query('BEGIN');

                    // Lock contribution row
                    const locked = await client.query(
                        'SELECT id, status FROM contributions WHERE id = $1 FOR UPDATE',
                        [contributionId]
                    );
                    if (locked.rows[0]?.status === 'refunded') {
                        await client.query('ROLLBACK');
                        client.release();
                        sendError(res, 400, "Esta contribucion ya fue revertida");
                        return;
                    }

                    // If wallet payment, re-credit user's balance
                    if (contrib.payment_method === 'wallet') {
                        await client.query(
                            `UPDATE user_wallets SET balance = balance + $1, updated_at = NOW()
                             WHERE user_id = $2`,
                            [amount, contrib.user_id]
                        );
                        log("info", "Wallet re-credited on reversal", {
                            user_id: contrib.user_id, amount, contribution_id: contributionId
                        });
                    }

                    // Update contribution status
                    await client.query(
                        `UPDATE contributions
                         SET status = 'refunded',
                             reversed_by = $1,
                             reversed_at = NOW(),
                             reversal_reason = $2,
                             updated_at = NOW()
                         WHERE id = $3`,
                        [authUserRev.userId, reason, contributionId]
                    );

                    await client.query('COMMIT');
                    client.release();

                    log("info", "Contribution reversed", {
                        contribution_id: contributionId,
                        group_id: contrib.group_id,
                        user_id: contrib.user_id,
                        reversed_by: authUserRev.userId,
                        amount,
                        payment_method: contrib.payment_method,
                        reason
                    });

                    sendSuccess(res, {
                        message: "Pago revertido exitosamente",
                        contribution_id: contributionId,
                        user_id: contrib.user_id,
                        amount,
                        wallet_refunded: contrib.payment_method === 'wallet'
                    });
                } catch (txErr) {
                    try { await client.query('ROLLBACK'); } catch (_) {}
                    client.release();
                    throw txErr;
                }
            } catch (error) {
                log("error", "Error reversing contribution", { contributionId, error: error.message });
                sendError(res, 500, "Error al revertir la contribucion");
            }
            return;
        }
        // // Update group (PostgreSQL-only)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/update-pg$/) && method === 'PATCH') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            const groupId = pathname.split('/')[3];
            const { name, description, contribution_amount, max_members, frequency, location, status } = body;

            log('info', 'Updating group (PostgreSQL)', { groupId, name });

            try {
                // v4.3.0: Authorization check — only admin/coordinator can update
                const groupAuth = await dbPostgres.pool.query(
                    "SELECT admin_id FROM groups WHERE group_id = $1", [groupId]);
                if (!groupAuth.rows.length) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                // SECURITY: Check membership (group member, group admin, or platform admin)
                const statsMemberCheck = await dbPostgres.pool.query(
                "SELECT 1 FROM group_members WHERE group_id = $1 AND user_id = $2 AND status NOT IN ('removed', 'rejected') UNION SELECT 1 FROM groups WHERE group_id = $1 AND admin_id = $2",
                [groupId, authUser.userId]
            );
                if (statsMemberCheck.rows.length === 0 && authUser.role !== 'admin') {
                    sendError(res, 403, 'No tienes acceso a este grupo');
                    return;
                }

                if (groupAuth.rows[0].admin_id !== authUser.userId) {
                    const coordCheck = await dbPostgres.pool.query(
                        "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND role IN ('creator','coordinator','admin')",
                        [groupId, authUser.userId]);
                    if (!coordCheck.rows.length) {
                        sendError(res, 403, 'No tienes permisos para editar este grupo');
                        return;
                    }
                }

                // Build update data — v4.3.0: status whitelist
                const allowedStatuses = ['active', 'inactive', 'paused', 'completed'];
                const updateData = {};
                if (name) updateData.name = name;
                if (description !== undefined) updateData.description = description;
                if (contribution_amount) updateData.contribution_amount = parseFloat(contribution_amount);
                if (max_members) updateData.max_members = parseInt(max_members);
                if (frequency) updateData.frequency = frequency;
                if (location) updateData.location = location;
                if (status && allowedStatuses.includes(status)) updateData.status = status;
                updateData.updated_at = new Date().toISOString();

                // Update in PostgreSQL
                const updated = await db.updateGroup(groupId, updateData);

                if (!updated) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                sendSuccess(res, {
                    message: 'Grupo actualizado exitosamente',
                    group: updated
                });

            } catch (error) {
                log('error', 'Error updating group', { error: error.message });
                sendError(res, 500, 'Error al actualizar el grupo');
            }
            return;
        }


        // ========== CONTRIBUTION REQUEST - Generate payment code and instructions ==========
        if (pathname === '/api/contributions/request' && method === 'POST') {
            // REQUIRE JWT authentication for contributions
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const { group_id, amount, payment_method } = body;
            const user_id = authUser.userId;

            // Validate required fields
            if (!user_id || !group_id || !amount || !payment_method) {
                sendError(res, 400, 'Campos requeridos: user_id, group_id, amount, payment_method');
                return;
            }

            // Validate payment method
            const validMethods = ['cash', 'bank_transfer', 'mobile_money', 'card', 'crypto', 'wallet'];
            if (!validMethods.includes(payment_method)) {
                sendError(res, 400, 'Método de pago no válido');
                return;
            }

            try {
                // ============================================
                // VALIDATION: Check tanda status before accepting payment
                // Added 2025-12-31 - Prevent payments before tanda starts
                // ============================================
                
                // 1. Check if tanda exists and is active (not recruiting)
                const tandaCheck = await dbPostgres.pool.query(`
                    SELECT t.tanda_id, t.status, t.lottery_executed_at, t.current_turn
                    FROM tandas t
                    WHERE t.group_id = $1
                    ORDER BY t.created_at DESC
                    LIMIT 1
                `, [group_id]);
                
                if (tandaCheck.rows.length === 0) {
                    sendError(res, 400, 'No hay una tanda activa en este grupo');
                    return;
                }
                
                const tanda = tandaCheck.rows[0];
                
                // 2. Check tanda is not in recruiting status
                if (tanda.status === 'recruiting') {
                    sendError(res, 400, 'La tanda aún está en reclutamiento. No se pueden registrar pagos hasta que inicie.');
                    return;
                }
                
                // 3. Check lottery has been executed (positions assigned)
                if (!tanda.lottery_executed_at) {
                    sendError(res, 400, 'La tómbola no ha sido ejecutada. Las posiciones deben ser asignadas antes de registrar pagos.');
                    return;
                }
                
                // 4. Check user is a member with assigned position (active or suspended — suspended can pay to reactivate)
                const memberCheck = await dbPostgres.pool.query(`
                    SELECT gm.turn_position, gm.status
                    FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2
                `, [group_id, user_id]);

                if (memberCheck.rows.length === 0 || !['active', 'suspended'].includes(memberCheck.rows[0].status)) {
                    sendError(res, 400, 'No eres un miembro de este grupo');
                    return;
                }
                
                if (!memberCheck.rows[0].turn_position) {
                    sendError(res, 400, 'No tienes una posición asignada. Espera a que se ejecute la tómbola.');
                    return;
                }
                
                log('info', 'Contribution validation passed', { 
                    user_id, group_id, 
                    tanda_status: tanda.status, 
                    lottery_executed: !!tanda.lottery_executed_at,
                    turn_position: memberCheck.rows[0].turn_position
                });
                // Generate unique reference code
                const timestamp = Date.now();
                const groupShort = group_id.substring(0, 8).toUpperCase();
                const userShort = user_id.substring(user_id.length - 4).toUpperCase();
                const referenceCode = `LT-CNT-${groupShort}-${userShort}-${timestamp}`;

                // Calculate expiration (48 hours)
                const expiresAt = new Date(timestamp + 48 * 60 * 60 * 1000);

                // Get group info for instructions
                const groupResult = await dbPostgres.pool.query(
                    'SELECT name, admin_id FROM groups WHERE group_id = $1',
                    [group_id]
                );
                const group = groupResult.rows[0];

                // Get coordinator info
                let coordinatorInfo = null;
                if (group && group.admin_id) {
                    const coordResult = await dbPostgres.pool.query(
                        'SELECT name, phone FROM users WHERE user_id = $1',
                        [group.admin_id]
                    );
                    coordinatorInfo = coordResult.rows[0];
                }

                // Generate instructions based on payment method
                let instructions = {};
                
                if (payment_method === 'bank_transfer') {
                    instructions = {
                        title: 'Transferencia Bancaria',
                        steps: [
                            'Accede a tu banca en línea o app móvil',
                            'Realiza transferencia a: La Tanda Chain S.A.',
                            'Banco: Banco Atlántida',
                            'Cuenta: 30613012837 (Corriente)',
                            `Monto exacto: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            `IMPORTANTE - En descripción/referencia incluir: ${referenceCode}`,
                            'Guarda tu comprobante y súbelo aquí'
                        ],
                        bank_details: {
                            bank_name: 'Banco Atlántida',
                            account_number: '30613012837',
                            account_holder: 'La Tanda Chain S.A.',
                            account_type: 'Cuenta Corriente'
                        },
                        verification_time: '2-4 horas',
                        proof_required: true
                    };
                } else if (payment_method === 'mobile_money') {
                    const fee = toMoney(parseFloat(amount) * 0.025);
                    instructions = {
                        title: 'Tigo Money',
                        steps: [
                            'Abre tu app Tigo Money',
                            'Selecciona "Enviar Dinero"',
                            'Enviar a: +50494485859',
                            'Nombre destinatario: Narjell Ramon Ebanks Martinez',
                            `Monto exacto: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            `Comisión aproximada: L. ${fee.toLocaleString('es-HN', {minimumFractionDigits: 2})} (2.5%)`,
                            `IMPORTANTE - En mensaje/nota incluir: ${referenceCode}`,
                            'Captura pantalla del comprobante y súbelo aquí'
                        ],
                        recipient_phone: '+50494485859',
                        recipient_name: 'Narjell Ramon Ebanks Martinez',
                        recipient_email: 'ebanksnigel@gmail.com',
                        fee_rate: 0.025,
                        verification_time: 'Inmediata',
                        proof_required: true
                    };
                } else if (payment_method === 'cash') {
                    instructions = {
                        title: 'Pago en Efectivo',
                        steps: [
                            'PASO 1: Toma una foto del efectivo que vas a entregar',
                            'PASO 2: Sube la foto aquí para generar tu código',
                            `PASO 3: Tu código de pago: ${referenceCode}`,
                            coordinatorInfo ? `PASO 4: Contacta al coordinador: ${coordinatorInfo.name} - ${coordinatorInfo.phone || 'Sin teléfono'}` : 'PASO 4: Contacta al coordinador del grupo',
                            `PASO 5: Entrega el monto exacto: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            'PASO 6: Muestra tu código al coordinador para que confirme'
                        ],
                        coordinator: coordinatorInfo,
                        verification_time: 'Cuando coordinador confirme',
                        proof_required: true,
                        proof_before_delivery: true
                    };
                } else if (payment_method === 'crypto') {
                    instructions = {
                        title: 'Criptomoneda (Ethereum/USDT)',
                        steps: [
                            'Envía USDT, ETH o stablecoins a la siguiente dirección:',
                            'Dirección: 0x58EA31ceba1B3DeFacB06A5B7fc7408656b91bf7',
                            'Redes soportadas: Ethereum (ERC-20) o Polygon',
                            `Monto equivalente en HNL: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            `IMPORTANTE - En memo incluir: ${referenceCode}`,
                            'Copia el hash/TXID de la transacción como comprobante'
                        ],
                        wallet_address: '0x58EA31ceba1B3DeFacB06A5B7fc7408656b91bf7',
                        networks: ['Ethereum', 'Polygon'],
                        verification_time: 'Variable según red (5-30 min)',
                        proof_required: true
                    };
                } else if (payment_method === 'card') {
                    instructions = {
                        title: 'Tarjeta de Crédito/Débito',
                        steps: [
                            'El pago será procesado automáticamente',
                            `Monto: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            'Recibirás confirmación por email',
                            'Guarda el comprobante de la transacción'
                        ],
                        verification_time: 'Inmediata',
                        proof_required: true
                    };
                } else if (payment_method === 'wallet') {
                    instructions = {
                        title: 'Wallet La Tanda',
                        steps: [
                            'El monto será descontado de tu wallet',
                            `Monto: L. ${parseFloat(amount).toLocaleString('es-HN', {minimumFractionDigits: 2})}`,
                            'Verificación automática'
                        ],
                        verification_time: 'Inmediata',
                        proof_required: false
                    };
                }

                // Insert contribution request to database
                const insertResult = await dbPostgres.pool.query(`
                    INSERT INTO contributions (
                        user_id, group_id, amount, payment_method, status,
                        reference_code, expires_at, created_at
                    ) VALUES ($1, $2, $3, $4, 'awaiting_payment', $5, $6, NOW())
                    RETURNING id, reference_code, status, created_at
                `, [user_id, group_id, amount, payment_method, referenceCode, expiresAt]);

                const contribution = insertResult.rows[0];

                log('info', 'Contribution request created', { 
                    contribution_id: contribution.id, 
                    reference_code: referenceCode,
                    payment_method,
                    amount
// Audit log for contribution                const contribClientInfo = getClientInfo(req);                auditLog("CONTRIBUTION_CREATED", {                    userId: user_id,                    resource: "contributions",                    resourceId: contribution.id,                    ip: contribClientInfo.ip,                    userAgent: contribClientInfo.userAgent,                    extra: { amount: amount, group_id: group_id, payment_method: payment_method }                });
                });

                sendSuccess(res, {
                    contribution_id: contribution.id,
                    reference_code: referenceCode,
                    amount: parseFloat(amount),
                    payment_method,
                    instructions,
                    expires_at: expiresAt.toISOString(),
                    status: 'awaiting_payment',
                    group_name: group?.name || 'Grupo'
                });
            } catch (error) {
                log("error", 'FULL ERROR:', error); log('error', 'Error creating contribution request', { error: error.message });
                sendError(res, 500, 'Error al crear solicitud de pago');
            }
            return;
        }

        // Get pending contributions for a group (coordinator verification)
        if (pathname.match(/^\/api\/groups\/[^/]+\/contributions\/pending$/) && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const groupId = pathname.split('/')[3];

            try {
                // v4.10.3: Membership check — creator/coordinator/admin only
                // Allow suspended creators/coordinators (group suspension suspends all members)
                const permCheck = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, authUser.userId]
                );
                if (permCheck.rows.length === 0 && authUser.role !== 'admin') {
                    sendError(res, 403, 'No tienes acceso a este grupo');
                    return;
                }
                const memberRole = permCheck.rows[0]?.role;
                if (!['creator', 'coordinator', 'admin'].includes(memberRole) && authUser.role !== 'admin') {
                    sendError(res, 403, 'Solo coordinadores pueden verificar pagos');
                    return;
                }

                const result = await dbPostgres.pool.query(`
                    SELECT
                        c.id,
                        c.user_id,
                        c.amount,
                        c.payment_method,
                        c.status,
                        c.reference_code,
                        c.proof_url,
                        c.created_at,
                        c.verified_at,
                        c.verified_by,
                        c.verification_method,
                        c.cycle_number,
                        u.name as user_name,
                        u.email as user_email,
                        u.phone as user_phone,
                        u.avatar_url as user_avatar,
                        COALESCE(v.name, 'Sistema') as verified_by_name
                    FROM contributions c
                    LEFT JOIN users u ON c.user_id = u.user_id
                    LEFT JOIN users v ON c.verified_by = v.user_id
                    WHERE c.group_id = $1
                    AND c.status IN ('pending', 'pending_verification', 'awaiting_payment')
                    ORDER BY c.created_at DESC
                `, [groupId]);

                sendSuccess(res, {
                    contributions: result.rows,
                    total: result.rows.length
                });
            } catch (error) {
                log("error", 'Error fetching pending contributions:', error);
                sendError(res, 500, 'Error al obtener contribuciones pendientes');
            }
            return;
        }

        // v4.10.3: Record contribution on behalf of a member (coordinator/creator only)
        if (pathname.match(/^\/api\/groups\/[^/]+\/contributions\/record-for-member$/) && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const groupId = pathname.split('/')[3];
            const { member_user_id, amount, payment_method, notes } = body;

            try {
                if (!member_user_id || !amount) {
                    sendError(res, 400, 'member_user_id y amount son requeridos');
                    return;
                }
                const parsedAmount = parseFloat(amount);
                if (!Number.isFinite(parsedAmount) || parsedAmount <= 0) {
                    sendError(res, 400, 'Monto invalido');
                    return;
                }

                // Permission check: creator/coordinator/admin only
                // Allow suspended creators/coordinators (group suspension suspends all members)
                const permCheck = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, authUser.userId]
                );
                if (permCheck.rows.length === 0 && authUser.role !== 'admin') {
                    sendError(res, 403, 'No tienes acceso a este grupo');
                    return;
                }
                const recorderRole = permCheck.rows[0]?.role;
                if (!['creator', 'coordinator', 'admin'].includes(recorderRole) && authUser.role !== 'admin') {
                    sendError(res, 403, 'Solo coordinadores pueden registrar pagos');
                    return;
                }

                // Verify the member is in the group (active or suspended)
                const memberCheck = await dbPostgres.pool.query(
                    "SELECT user_id, COALESCE(num_positions, 1) as num_positions FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, member_user_id]
                );
                if (memberCheck.rows.length === 0) {
                    sendError(res, 404, 'El miembro no pertenece a este grupo');
                    return;
                }

                // Get current cycle
                const groupResult = await dbPostgres.pool.query(
                    "SELECT current_cycle, contribution_amount, name FROM groups WHERE group_id = $1",
                    [groupId]
                );
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                const currentCycle = groupResult.rows[0].current_cycle || 1;

                // Find next unpaid cycle for this member (1..currentCycle)
                // Members with num_positions > 1 need that many contributions per cycle
                const memberPositions = memberCheck.rows[0].num_positions || 1;
                const unpaidCycleResult = await dbPostgres.pool.query(`
                    SELECT s.num AS cycle_num FROM generate_series(1, $3) s(num)
                    WHERE (
                        SELECT COUNT(*) FROM contributions
                        WHERE user_id = $1 AND group_id = $2 AND cycle_number = s.num
                        AND status IN ('completed', 'coordinator_approved', 'archived')
                    ) < $4
                    ORDER BY s.num ASC LIMIT 1
                `, [member_user_id, groupId, currentCycle, memberPositions]);
                const targetCycle = unpaidCycleResult.rows.length > 0 ? unpaidCycleResult.rows[0].cycle_num : currentCycle;

                // Generate confirmation code
                const confirmCode = 'RFM-' + crypto.randomInt(100000, 999999);

                // Insert contribution as verified (pre-approved since admin is recording)
                const insertResult = await dbPostgres.pool.query(`
                    INSERT INTO contributions (id, user_id, group_id, amount, payment_method, status, confirmation_code, notes, cycle_number, verified_by, verified_at, verification_method, created_at, updated_at)
                    VALUES (gen_random_uuid(), $1, $2, $3, $4, 'completed', $5, $6, $7, $8, NOW(), 'coordinator_manual', NOW(), NOW())
                    RETURNING id, user_id, amount, status, confirmation_code, cycle_number, created_at
                `, [member_user_id, groupId, parsedAmount, payment_method || 'cash', confirmCode, notes || 'Registrado por coordinador - Ciclo ' + targetCycle, targetCycle, authUser.userId]);

                log("info", "Contribution recorded for member", { groupId, member_user_id, amount: parsedAmount, by: authUser.userId });

                // v4.11.0: Resolve any active mora/extension for this user+group+cycle
                try {
                    await dbPostgres.pool.query(
                        "UPDATE payment_deferrals SET status = 'resolved', resolved_at = NOW(), updated_at = NOW() WHERE group_id = $1 AND user_id = $2 AND cycle_number = $3 AND status IN ('active', 'approved')",
                        [groupId, member_user_id, targetCycle]
                    );
                } catch (resolveErr) {
                    log('warn', 'Could not resolve deferral on payment', { groupId, userId: member_user_id, error: resolveErr.message });
                }

                // v4.11.0: Auto-advance with threshold + mora
                await checkCycleAdvanceWithMora(groupId, targetCycle, currentCycle, parsedAmount);

                // v4.10.3: Auto-reactivate suspended member when coordinator records their payment
                try {
                    const reactivateResult = await dbPostgres.pool.query(
                        "UPDATE group_members SET status = 'active', updated_at = NOW() WHERE group_id = $1 AND user_id = $2 AND status = 'suspended' RETURNING user_id",
                        [groupId, member_user_id]
                    );
                    if (reactivateResult.rows.length > 0) {
                        log("info", "Member auto-reactivated after coordinator payment recording", { groupId, userId: member_user_id });
                        await notificationsUtils.createNotification(dbPostgres.pool, member_user_id, 'membership_reactivated',
                            '✅ Membresia Reactivada',
                            'Tu coordinador registro tu pago y tu membresia ha sido reactivada.',
                            { group_id: groupId }
                        );
                    }
                } catch (reactErr) {
                    log("warn", "Could not auto-reactivate member after record-for-member", { error: reactErr.message });
                }


                // v4.10.6: Send payment confirmation email (async, non-blocking)
                (async function() {
                    try {
                        const prefResult = await dbPostgres.pool.query(
                            "SELECT email_enabled, payment_reminders FROM notification_preferences WHERE user_id = $1",
                            [member_user_id]
                        );
                        const emailOk = !prefResult.rows.length || prefResult.rows[0].email_enabled !== false;
                        if (emailOk) {
                            const memberInfo = await dbPostgres.pool.query("SELECT email, name FROM users WHERE user_id = $1", [member_user_id]);
                            if (memberInfo.rows[0] && memberInfo.rows[0].email) {
                                const tpl = emailTemplates.paymentRecordedEmail({
                                    memberName: memberInfo.rows[0].name || 'Miembro',
                                    memberEmail: memberInfo.rows[0].email,
                                    groupName: groupResult.rows[0].name || 'Grupo',
                                    amount: parsedAmount,
                                    cycle: targetCycle,
                                    paymentMethod: payment_method || 'cash',
                                    confirmationCode: confirmCode,
                                    coordinatorName: authUser.name || 'Coordinador',
                                    date: new Date()
                                });
                                sendEmail(memberInfo.rows[0].email, tpl.subject, tpl.html, 'pagos');
                            }
                        }
                    } catch (emailErr) { /* non-blocking */ }
                })();
                sendSuccess(res, {
                    message: 'Pago registrado exitosamente',
                    contribution: insertResult.rows[0]
                });
            } catch (error) {
                log("error", "Error recording contribution for member", { error: error.message, groupId });
                sendError(res, 500, 'Error al registrar el pago');
            }
            return;
        }

        // v4.10.5: Get members with payment status for current cycle (coordinator view)
        if (pathname.match(/^\/api\/groups\/[^/]+\/members\/payment-status$/) && method === 'GET') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const groupId = pathname.split('/')[3];

            try {
                // Permission check: creator/coordinator/admin only
                const permCheck = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, authUser.userId]
                );
                if (permCheck.rows.length === 0 && authUser.role !== 'admin') {
                    sendError(res, 403, 'No tienes acceso a este grupo');
                    return;
                }
                const recorderRole = permCheck.rows[0]?.role;
                if (!['creator', 'coordinator', 'admin'].includes(recorderRole) && authUser.role !== 'admin') {
                    sendError(res, 403, 'Solo coordinadores pueden ver estado de pagos');
                    return;
                }

                // Get group info
                const groupResult = await dbPostgres.pool.query(
                    "SELECT group_id, name, contribution_amount, current_cycle, frequency FROM groups WHERE group_id = $1",
                    [groupId]
                );
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                const group = groupResult.rows[0];
                const cycleParam = query.cycle ? parseInt(query.cycle) : null;
                const cycleNumber = (cycleParam && Number.isFinite(cycleParam) && cycleParam > 0) ? cycleParam : (group.current_cycle || 1);

                // Get all members with paid cycle count (cycles 1..currentCycle)
                const membersResult = await dbPostgres.pool.query(`
                    SELECT
                        gm.user_id,
                        u.name,
                        u.avatar_url,
                        gm.turn_position,
                        gm.status AS member_status,
                        gm.role AS member_role,
                        COALESCE(gm.num_positions, 1) AS num_positions,
                        COALESCE(paid.cnt, 0) AS cycles_paid,
                        paid.last_paid_date,
                        paid.last_payment_method
                    FROM group_members gm
                    JOIN users u ON u.user_id = gm.user_id
                    LEFT JOIN LATERAL (
                        SELECT
                            c_agg.user_id,
                            COUNT(*) FILTER (WHERE c_agg.cycle_paid) AS cnt,
                            c_agg.total_contributions,
                            MAX(c_agg.last_date) AS last_paid_date,
                            c_agg.last_method AS last_payment_method
                        FROM (
                            SELECT
                                c.user_id,
                                c.cycle_number,
                                COUNT(*) >= COALESCE(gm.num_positions, 1) AS cycle_paid,
                                COUNT(*) AS total_contributions,
                                MAX(c.created_at) AS last_date,
                                (SELECT c2.payment_method FROM contributions c2
                                 WHERE c2.user_id = gm.user_id AND c2.group_id = $1
                                 AND c2.status IN ('completed','coordinator_approved','archived')
                                 ORDER BY c2.created_at DESC LIMIT 1) AS last_method
                            FROM contributions c
                            WHERE c.group_id = $1 AND c.user_id = gm.user_id
                            AND c.cycle_number BETWEEN 1 AND $2
                            AND c.status IN ('completed','coordinator_approved','archived')
                            GROUP BY c.user_id, c.cycle_number
                        ) c_agg
                        GROUP BY c_agg.user_id, c_agg.total_contributions, c_agg.last_method
                    ) paid ON true
                    WHERE gm.group_id = $1 AND gm.status IN ('active', 'suspended')
                    ORDER BY gm.turn_position ASC NULLS LAST, u.name ASC
                `, [groupId, cycleNumber]);

                const contributionAmt = parseFloat(group.contribution_amount) || 0;
                let allCaughtUp = 0;
                let someDebt = 0;
                const members = membersResult.rows.map(function(m) {
                    const cyclesPaid = parseInt(m.cycles_paid) || 0;
                    const memberPositions = parseInt(m.num_positions) || 1;
                    const cyclesPending = Math.max(0, cycleNumber - cyclesPaid);
                    const amountPending = cyclesPending * contributionAmt * memberPositions;

                    let paymentStatus = 'pending';
                    if (cyclesPending === 0) {
                        paymentStatus = 'paid';
                        allCaughtUp++;
                    } else if (m.member_status === 'suspended') {
                        paymentStatus = 'suspended';
                        someDebt++;
                    } else if (m.member_status === 'late' || cyclesPending > 1) {
                        paymentStatus = 'late';
                        someDebt++;
                    } else {
                        someDebt++;
                    }

                    return {
                        user_id: m.user_id,
                        name: m.name,
                        avatar: m.avatar_url,
                        turn_position: m.turn_position,
                        member_status: m.member_status,
                        member_role: m.member_role,
                        payment_status: paymentStatus,
                        contribution_amount: contributionAmt,
                        cycles_paid: cyclesPaid,
                        cycles_pending: cyclesPending,
                        amount_pending: amountPending,
                        last_paid_date: m.last_paid_date || null,
                        last_payment_method: m.last_payment_method || null,
                        num_positions: memberPositions,
                    };
                });

                sendSuccess(res, {
                    members: members,
                    cycle_number: cycleNumber,
                    group_contribution_amount: contributionAmt,
                    total_members: members.length,
                    paid_count: allCaughtUp,
                    pending_count: someDebt
                });
            } catch (error) {
                log("error", "Error fetching payment status", { error: error.message, groupId });
                sendError(res, 500, 'Error al obtener estado de pagos');
            }
            return;
        }

        // v4.10.5: Bulk record contributions for multiple members (coordinator/creator only)
        if (pathname.match(/^\/api\/groups\/[^/]+\/contributions\/record-bulk$/) && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const groupId = pathname.split('/')[3];

            try {
                const { members: membersList, payment_method } = body;

                // Validate input
                if (!Array.isArray(membersList) || membersList.length === 0) {
                    sendError(res, 400, 'Se requiere un array de miembros');
                    return;
                }
                if (membersList.length > 50) {
                    sendError(res, 400, 'Maximo 50 pagos por lote');
                    return;
                }
                const validMethods = ['cash', 'bank_transfer', 'mobile_money', 'card', 'crypto', 'wallet'];
                if (!payment_method || !validMethods.includes(payment_method)) {
                    sendError(res, 400, 'Metodo de pago invalido');
                    return;
                }

                // Check for duplicate user IDs
                const userIds = membersList.map(function(m) { return m.member_user_id; });
                const uniqueIds = new Set(userIds);
                if (uniqueIds.size !== userIds.length) {
                    sendError(res, 400, 'IDs de miembros duplicados en el lote');
                    return;
                }

                // Permission check: creator/coordinator/admin only
                const permCheck = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, authUser.userId]
                );
                if (permCheck.rows.length === 0 && authUser.role !== 'admin') {
                    sendError(res, 403, 'No tienes acceso a este grupo');
                    return;
                }
                const recorderRole = permCheck.rows[0]?.role;
                if (!['creator', 'coordinator', 'admin'].includes(recorderRole) && authUser.role !== 'admin') {
                    sendError(res, 403, 'Solo coordinadores pueden registrar pagos');
                    return;
                }

                // Get group info
                const groupResult = await dbPostgres.pool.query(
                    "SELECT current_cycle, contribution_amount, name FROM groups WHERE group_id = $1",
                    [groupId]
                );
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }
                const currentCycle = groupResult.rows[0].current_cycle || 1;

                // Validate all members belong to the group
                const memberCheck = await dbPostgres.pool.query(
                    "SELECT user_id, COALESCE(num_positions, 1) as num_positions FROM group_members WHERE group_id = $1 AND user_id = ANY($2) AND status IN ('active', 'suspended')",
                    [groupId, userIds]
                );
                const validMembers = new Set(memberCheck.rows.map(function(r) { return r.user_id; }));
                const memberPositionsMap = {};
                memberCheck.rows.forEach(function(r) { memberPositionsMap[r.user_id] = r.num_positions || 1; });

                // Validate amounts
                for (let i = 0; i < membersList.length; i++) {
                    const item = membersList[i];
                    if (!item.member_user_id || typeof item.member_user_id !== 'string') {
                        sendError(res, 400, 'member_user_id invalido en posicion ' + i);
                        return;
                    }
                    const amt = parseFloat(item.amount);
                    if (!Number.isFinite(amt) || amt <= 0 || amt > 100000) {
                        sendError(res, 400, 'Monto invalido en posicion ' + i);
                        return;
                    }
                }

                // Execute in transaction
                const client = await dbPostgres.pool.connect();
                const results = [];
                let recordedCount = 0;
                let failedCount = 0;

                try {
                    await client.query('BEGIN');

                    for (const item of membersList) {
                        if (!validMembers.has(item.member_user_id)) {
                            results.push({ user_id: item.member_user_id, status: 'failed', reason: 'No es miembro del grupo' });
                            failedCount++;
                            continue;
                        }

                        const parsedAmount = parseFloat(item.amount);

                        // Find next unpaid cycle for this member (considers num_positions)
                        const itemPositions = memberPositionsMap[item.member_user_id] || 1;
                        const unpaidResult = await client.query(`
                            SELECT s.num AS cycle_num FROM generate_series(1, $3) s(num)
                            WHERE (
                                SELECT COUNT(*) FROM contributions
                                WHERE user_id = $1 AND group_id = $2 AND cycle_number = s.num
                                AND status IN ('completed', 'coordinator_approved', 'archived')
                            ) < $4
                            ORDER BY s.num ASC LIMIT 1
                        `, [item.member_user_id, groupId, currentCycle, itemPositions]);
                        const targetCycle = unpaidResult.rows.length > 0 ? unpaidResult.rows[0].cycle_num : currentCycle;
                        const confirmCode = 'BLK-' + crypto.randomInt(100000, 999999);

                        const insertResult = await client.query(`
                            INSERT INTO contributions (id, user_id, group_id, amount, payment_method, status, confirmation_code, notes, cycle_number, verified_by, verified_at, verification_method, created_at, updated_at)
                            VALUES (gen_random_uuid(), $1, $2, $3, $4, 'completed', $5, $6, $7, $8, NOW(), 'coordinator_bulk', NOW(), NOW())
                            RETURNING id, confirmation_code
                        `, [item.member_user_id, groupId, parsedAmount, payment_method, confirmCode, item.notes || 'Registrado en lote por coordinador - Ciclo ' + targetCycle, targetCycle, authUser.userId]);

                        // Auto-reactivate suspended member
                        await client.query(
                            "UPDATE group_members SET status = 'active', updated_at = NOW() WHERE group_id = $1 AND user_id = $2 AND status = 'suspended'",
                            [groupId, item.member_user_id]
                        );


                        // v4.11.0: Resolve mora/extension on payment
                        await client.query(
                            "UPDATE payment_deferrals SET status = 'resolved', resolved_at = NOW(), updated_at = NOW() WHERE group_id = $1 AND user_id = $2 AND cycle_number = $3 AND status IN ('active', 'approved')",
                            [groupId, item.member_user_id, targetCycle]
                        );
                        results.push({
                            user_id: item.member_user_id,
                            status: 'recorded',
                            confirmation_code: insertResult.rows[0].confirmation_code
                        });
                        recordedCount++;
                    }

                    await client.query('COMMIT');
                } catch (txError) {
                    await client.query('ROLLBACK');
                    throw txError;
                } finally {
                    client.release();
                }
                // v4.11.0: Auto-advance with threshold + mora
                if (recordedCount > 0) {
                    await checkCycleAdvanceWithMora(groupId, currentCycle, currentCycle, parseFloat(groupResult.rows[0].contribution_amount) || 0);
                }
                // Send notifications asynchronously (outside transaction)
                for (const result of results) {
                    if (result.status === 'recorded') {
                        try {
                            await notificationsUtils.createNotification(dbPostgres.pool, result.user_id, 'payment_recorded',
                                'Pago Registrado',
                                'Tu coordinador ha registrado tu pago para este ciclo.',
                                { group_id: groupId, confirmation_code: result.confirmation_code }
                            );
                        } catch (notifErr) {
                            log("warn", "Notification failed for bulk payment", { userId: result.user_id, error: notifErr.message });
                        }
                    }
                }


                // v4.10.6: Send payment confirmation emails for bulk recordings (async, non-blocking)
                const groupNameForEmail = groupResult.rows[0].name || 'Grupo';
                (async function() {
                    try {
                        for (const r of results) {
                            if (r.status !== 'recorded') continue;
                            try {
                                const prefResult = await dbPostgres.pool.query(
                                    "SELECT email_enabled FROM notification_preferences WHERE user_id = $1",
                                    [r.user_id]
                                );
                                const emailOk = !prefResult.rows.length || prefResult.rows[0].email_enabled !== false;
                                if (!emailOk) continue;
                                const memberInfo = await dbPostgres.pool.query("SELECT email, name FROM users WHERE user_id = $1", [r.user_id]);
                                if (!memberInfo.rows[0] || !memberInfo.rows[0].email) continue;
                                const matchedItem = membersList.find(function(m) { return m.member_user_id === r.user_id; });
                                const tpl = emailTemplates.paymentRecordedEmail({
                                    memberName: memberInfo.rows[0].name || 'Miembro',
                                    memberEmail: memberInfo.rows[0].email,
                                    groupName: groupNameForEmail,
                                    amount: matchedItem ? parseFloat(matchedItem.amount) : 0,
                                    cycle: r.cycle || currentCycle,
                                    paymentMethod: payment_method || 'cash',
                                    confirmationCode: r.confirmation_code,
                                    coordinatorName: authUser.name || 'Coordinador',
                                    date: new Date()
                                });
                                sendEmail(memberInfo.rows[0].email, tpl.subject, tpl.html, 'pagos');
                            } catch (innerErr) { /* skip this member */ }
                        }
                    } catch (emailErr) { /* non-blocking */ }
                })();
                log("info", "Bulk contributions recorded", { groupId, recorded: recordedCount, failed: failedCount, by: authUser.userId });

                sendSuccess(res, {
                    message: recordedCount + ' pagos registrados exitosamente',
                    recorded: recordedCount,
                    failed: failedCount,
                    results: results
                });
            } catch (error) {
                log("error", "Error recording bulk contributions", { error: error.message, groupId });
                sendError(res, 500, 'Error al registrar pagos en lote');
            }
            return;
        }

        // Verify a contribution (coordinator action)
        if (pathname.match(/^\/api\/contributions\/[^/]+\/verify$/) && method === 'POST') {
            // SECURITY: Require JWT authentication (Added 2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const contributionId = pathname.split('/')[3];
            const { action, rejection_reason } = body;
            const verified_by = authUser.userId;

            if (!action || !['approve', 'reject'].includes(action)) {
                sendError(res, 400, 'Accion requerida: approve o reject');
                return;
            }

            try {
                const checkResult = await dbPostgres.pool.query(
                    'SELECT id, status, amount, user_id, group_id FROM contributions WHERE id = $1',
                    [contributionId]
                );

                if (checkResult.rows.length === 0) {
                    sendError(res, 404, 'Contribucion no encontrada');
                    return;
                }

                const contribution = checkResult.rows[0];

                // SECURITY: Verify user has coordinator/admin permission (Added 2025-12-31)
                // v4.10.3: Allow suspended creators/coordinators to manage
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status IN ('active', 'suspended')
                `, [contribution.group_id, verified_by]);

                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para verificar pagos en este grupo');
                    return;
                }

                // VALIDATION: Check tanda is active (Added 2025-12-31)
                const tandaCheck = await dbPostgres.pool.query(`
                    SELECT status, lottery_executed_at FROM tandas
                    WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
                `, [contribution.group_id]);

                if (tandaCheck.rows.length === 0 || tandaCheck.rows[0].status === 'recruiting') {
                    sendError(res, 400, 'La tanda aún no ha iniciado. No se pueden verificar pagos.');
                    return;
                }

                if (!tandaCheck.rows[0].lottery_executed_at) {
                    sendError(res, 400, 'La tómbola no ha sido ejecutada. Las posiciones deben ser asignadas primero.');
                    return;
                }

                if (contribution.status !== 'pending_verification') {
                    sendError(res, 400, 'Solo se pueden verificar contribuciones pendientes de verificacion');
                    return;
                }

                if (action === 'approve') {
                    await dbPostgres.pool.query(`
                        UPDATE contributions
                        SET status = 'completed',
                            verified_at = NOW(),
                            verified_by = $1,
                            updated_at = NOW()
                        WHERE id = $2
                    `, [verified_by || 'coordinator', contributionId]);

                    log('info', 'Contribution approved', { contribution_id: contributionId, verified_by });
                    const appCI = getClientInfo(req); auditLog("CONTRIBUTION_APPROVED", { userId: verified_by, resource: "contributions", resourceId: contributionId, ip: appCI.ip, userAgent: appCI.userAgent });

                    // Send notification for approved deposit
                    try {
                        await notificationsUtils.createNotification(dbPostgres.pool, contribution.user_id, 'deposit_confirmed', 
                            '✅ Depósito Confirmado',
                            'Tu depósito de L. ' + parseFloat(contribution.amount).toFixed(2) + ' ha sido verificado y acreditado a tu cuenta.',
                            { contribution_id: contributionId, amount: contribution.amount }
                        );
                    } catch (notifErr) { 
                        log('error', 'Failed to send deposit notification', { error: notifErr.message }); 
                    }

                    // Send email for approved deposit
                    try {
                        const userResult = await dbPostgres.pool.query(
                            'SELECT email, name FROM users WHERE user_id = $1',
                            [contribution.user_id]
                        );
                        if (userResult.rows[0]?.email) {
                            const userEmail = userResult.rows[0].email;
                            const userName = userResult.rows[0].name || 'Usuario';
                            const emailHtml = `
                                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background: #0f172a; color: #f8fafc; padding: 20px; border-radius: 10px;">
                                    <div style="text-align: center; margin-bottom: 20px;">
                                        <h1 style="color: #10b981;">✅ Depósito Confirmado</h1>
                                    </div>
                                    <p>Hola ${userName},</p>
                                    <p>¡Buenas noticias! Tu depósito ha sido verificado y acreditado:</p>
                                    <div style="background: rgba(16,185,129,0.1); padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #10b981;">
                                        <p><strong>Monto:</strong> L. ${parseFloat(contribution.amount).toFixed(2)}</p>
                                        <p><strong>Estado:</strong> Completado</p>
                                        <p><strong>ID:</strong> ${contributionId}</p>
                                    </div>
                                    <p>El monto ya está disponible en tu wallet.</p>
                                </div>
                            `;
                            await sendEmail(userEmail, '✅ Depósito Confirmado - La Tanda', emailHtml, 'pagos');
                        }
                    } catch (emailErr) {
                        log('error', 'Failed to send deposit approval email', { error: emailErr.message });
                    }

                    // v4.10.3: Auto-reactivate suspended members on approved payment
                    try {
                        const reactivateResult = await dbPostgres.pool.query(
                            "UPDATE group_members SET status = 'active', updated_at = NOW() WHERE group_id = $1 AND user_id = $2 AND status = 'suspended' RETURNING user_id",
                            [contribution.group_id, contribution.user_id]
                        );
                        if (reactivateResult.rows.length > 0) {
                            log("info", "Member auto-reactivated after payment approval", { groupId: contribution.group_id, userId: contribution.user_id });
                            await notificationsUtils.createNotification(dbPostgres.pool, contribution.user_id, 'membership_reactivated',
                                '✅ Membresia Reactivada',
                                'Tu pago fue aprobado y tu membresia ha sido reactivada automaticamente.',
                                { group_id: contribution.group_id }
                            );
                        }
                    } catch (reactErr) {
                        log("warn", "Could not auto-reactivate member", { error: reactErr.message });
                    }

                    sendSuccess(res, {
                        contribution_id: contributionId,
                        status: 'completed',
                        message: 'Pago verificado exitosamente'
                    });
                } else {
                    await dbPostgres.pool.query(`
                        UPDATE contributions
                        SET status = 'rejected',
                            verified_at = NOW(),
                            verified_by = $1,
                            notes = $2,
                            updated_at = NOW()
                        WHERE id = $3
                    `, [verified_by || 'coordinator', rejection_reason || 'Rechazado por coordinador', contributionId]);

                    log('info', 'Contribution rejected', { contribution_id: contributionId, verified_by, reason: rejection_reason });
                    const rejCI = getClientInfo(req); auditLog("CONTRIBUTION_REJECTED", { userId: verified_by, resource: "contributions", resourceId: contributionId, ip: rejCI.ip, userAgent: rejCI.userAgent, status: "failure" });

                    // Send notification for rejected deposit
                    try {
                        await notificationsUtils.createNotification(dbPostgres.pool, contribution.user_id, 'deposit_rejected', 
                            '❌ Depósito Rechazado',
                            'Tu depósito de L. ' + parseFloat(contribution.amount).toFixed(2) + ' no pudo ser verificado. Razón: ' + (rejection_reason || 'Verificación fallida'),
                            { contribution_id: contributionId, amount: contribution.amount, reason: rejection_reason }
                        );
                    } catch (notifErr) { 
                        log('error', 'Failed to send rejection notification', { error: notifErr.message }); 
                    }

                    // Send email for rejected deposit
                    try {
                        const userResult = await dbPostgres.pool.query(
                            'SELECT email, name FROM users WHERE user_id = $1',
                            [contribution.user_id]
                        );
                        if (userResult.rows[0]?.email) {
                            const userEmail = userResult.rows[0].email;
                            const userName = userResult.rows[0].name || 'Usuario';
                            const emailHtml = `
                                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background: #0f172a; color: #f8fafc; padding: 20px; border-radius: 10px;">
                                    <div style="text-align: center; margin-bottom: 20px;">
                                        <h1 style="color: #ef4444;">❌ Depósito Rechazado</h1>
                                    </div>
                                    <p>Hola ${userName},</p>
                                    <p>Lamentamos informarte que tu depósito no pudo ser verificado:</p>
                                    <div style="background: rgba(239,68,68,0.1); padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #ef4444;">
                                        <p><strong>Monto:</strong> L. ${parseFloat(contribution.amount).toFixed(2)}</p>
                                        <p><strong>Razón:</strong> ${rejection_reason || 'Verificación fallida'}</p>
                                        <p><strong>ID:</strong> ${contributionId}</p>
                                    </div>
                                    <p>Si crees que esto es un error, contacta a soporte con tu comprobante.</p>
                                </div>
                            `;
                            await sendEmail(userEmail, '❌ Depósito Rechazado - La Tanda', emailHtml, 'pagos');
                        }
                    } catch (emailErr) {
                        log('error', 'Failed to send deposit rejection email', { error: emailErr.message });
                    }

                    sendSuccess(res, {
                        contribution_id: contributionId,
                        status: 'rejected',
                        message: 'Pago rechazado'
                    });
                }
            } catch (error) {
                log("error", 'Error verifying contribution:', error);
                sendError(res, 500, 'Error al verificar contribucion');
            }
            return;
        }

        // OCR Verification endpoint - auto-verify payment proof
        if (pathname.match(/^\/api\/contributions\/[^/]+\/verify-ocr$/) && method === 'POST') {
            const contributionId = pathname.split('/')[3];
            
            try {
                // Get contribution details
                const contribResult = await dbPostgres.pool.query(
                    `SELECT c.id, c.amount, c.payment_method, c.reference_code, c.status, c.proof_image_url,
                            c.user_id, c.group_id
                     FROM contributions c
                     WHERE c.id = $1`,
                    [contributionId]
                );
                
                if (contribResult.rows.length === 0) {
                    sendError(res, 404, 'Contribucion no encontrada');
                    return;
                }
                
                const contribution = contribResult.rows[0];
                
                if (!contribution.proof_image_url) {
                    sendError(res, 400, 'No hay comprobante subido para verificar');
                    return;
                }
                
                // Read the image file
                const imagePath = contribution.proof_image_url.startsWith('/uploads/')
                    ? path.join(__dirname, contribution.proof_image_url)
                    : contribution.proof_image_url;
                
                if (!fs.existsSync(imagePath)) {
                    sendError(res, 404, 'Archivo de comprobante no encontrado');
                    return;
                }
                
                log('info', 'Starting OCR verification', { contribution_id: contributionId, image_path: imagePath });
                
                // Perform OCR
                const { data: { text } } = await Tesseract.recognize(imagePath, 'spa', {
                    logger: m => log('debug', 'Tesseract', { status: m })
                });
                
                const extractedText = text.toUpperCase();
                log('info', 'OCR extracted text', { contribution_id: contributionId, text_length: extractedText.length });
                
                // Verification results
                let verification = {
                    account_match: false,
                    name_match: false,
                    reference_match: false,
                    amount_match: false,
                    extracted_text: extractedText.substring(0, 500), // Limit for response
                    confidence: 0,
                    matches: [],
                    mismatches: []
                };
                
                const paymentMethod = contribution.payment_method;
                const expectedAmount = parseFloat(contribution.amount);
                const referenceCode = contribution.reference_code;
                
                // Check based on payment method
                if (paymentMethod === 'bank_transfer') {
                    // Check account number
                    for (const variant of PAYMENT_ACCOUNTS.bank_transfer.account_variants) {
                        if (extractedText.includes(variant.replace(/-/g, '').replace(/ /g, ''))) {
                            verification.account_match = true;
                            verification.matches.push('Cuenta bancaria: ' + variant);
                            break;
                        }
                    }
                    if (!verification.account_match) verification.mismatches.push('Cuenta bancaria no encontrada');
                    
                    // Check holder name
                    for (const variant of PAYMENT_ACCOUNTS.bank_transfer.holder_variants) {
                        if (extractedText.includes(variant)) {
                            verification.name_match = true;
                            verification.matches.push('Titular: ' + variant);
                            break;
                        }
                    }
                    if (!verification.name_match) verification.mismatches.push('Nombre de titular no encontrado');
                    
                } else if (paymentMethod === 'mobile_money') {
                    // Check phone number
                    for (const variant of PAYMENT_ACCOUNTS.mobile_money.phone_variants) {
                        const cleanVariant = variant.replace(/[^0-9]/g, '');
                        if (extractedText.replace(/[^0-9]/g, '').includes(cleanVariant)) {
                            verification.account_match = true;
                            verification.matches.push('Teléfono: ' + variant);
                            break;
                        }
                    }
                    if (!verification.account_match) verification.mismatches.push('Número de teléfono no encontrado');
                    
                    // Check recipient name
                    for (const variant of PAYMENT_ACCOUNTS.mobile_money.name_variants) {
                        if (extractedText.includes(variant)) {
                            verification.name_match = true;
                            verification.matches.push('Nombre: ' + variant);
                            break;
                        }
                    }
                    if (!verification.name_match) verification.mismatches.push('Nombre de destinatario no encontrado');
                    
                } else if (paymentMethod === 'crypto') {
                    // Check wallet address (partial match)
                    if (extractedText.includes(PAYMENT_ACCOUNTS.crypto.address_short) ||
                        extractedText.includes(PAYMENT_ACCOUNTS.crypto.address_end) ||
                        extractedText.includes(PAYMENT_ACCOUNTS.crypto.address)) {
                        verification.account_match = true;
                        verification.name_match = true;
                        verification.matches.push('Dirección crypto verificada');
                    } else {
                        verification.mismatches.push('Dirección de wallet no encontrada');
                    }
                }
                
                // Check reference code
                if (referenceCode && extractedText.includes(referenceCode.replace(/-/g, '').toUpperCase())) {
                    verification.reference_match = true;
                    verification.matches.push('Referencia: ' + referenceCode);
                } else if (referenceCode) {
                    // Try partial match
                    const refParts = referenceCode.split('-');
                    const lastPart = refParts[refParts.length - 1];
                    if (extractedText.includes(lastPart)) {
                        verification.reference_match = true;
                        verification.matches.push('Referencia parcial: ' + lastPart);
                    } else {
                        verification.mismatches.push('Código de referencia no encontrado');
                    }
                }
                
                // Check amount (with 5% tolerance)
                const amountRegex = /L\.?\s*([0-9,]+\.?[0-9]*)|([0-9,]+\.?[0-9]*)\s*L/g;
                let amountMatch;
                while ((amountMatch = amountRegex.exec(extractedText)) !== null) {
                    const foundAmount = parseFloat((amountMatch[1] || amountMatch[2]).replace(/,/g, ''));
                    if (!isNaN(foundAmount)) {
                        const tolerance = expectedAmount * 0.05;
                        if (Math.abs(foundAmount - expectedAmount) <= tolerance) {
                            verification.amount_match = true;
                            verification.matches.push('Monto: L. ' + foundAmount.toFixed(2));
                            break;
                        }
                    }
                }
                if (!verification.amount_match) verification.mismatches.push('Monto exacto no encontrado');
                
                // Calculate confidence score
                let matchCount = 0;
                if (verification.account_match) matchCount++;
                if (verification.name_match) matchCount++;
                if (verification.reference_match) matchCount++;
                if (verification.amount_match) matchCount++;
                verification.confidence = matchCount / 4;
                
                // Determine if auto-approve
                verification.auto_approved = verification.confidence >= 0.75;
                
                // If high confidence, auto-approve
                if (verification.auto_approved) {
                    await dbPostgres.pool.query(`
                        UPDATE contributions
                        SET status = 'completed',
                            verified_at = NOW(),
                            verified_by = 'ocr_auto',
                            notes = $1,
                            updated_at = NOW()
                        WHERE id = $2
                    `, ['Verificado automáticamente por OCR. Confianza: ' + (verification.confidence * 100).toFixed(0) + '%', contributionId]);
                    
                    log('info', 'Contribution auto-approved by OCR', { contribution_id: contributionId, confidence: verification.confidence });

                    // Send notification for OCR auto-approved deposit
                    try {
                        await notificationsUtils.createNotification(dbPostgres.pool, contribution.user_id, 'deposit_confirmed', 
                            '✅ Depósito Verificado Automáticamente',
                            'Tu depósito de L. ' + parseFloat(contribution.amount).toFixed(2) + ' ha sido verificado automáticamente y acreditado a tu cuenta.',
                            { contribution_id: contributionId, amount: contribution.amount, verification_type: 'ocr_auto' }
                        );
                    } catch (notifErr) { 
                        log('error', 'Failed to send OCR approval notification', { error: notifErr.message }); 
                    }
                }
                
                sendSuccess(res, {
                    contribution_id: contributionId,
                    verification,
                    message: verification.auto_approved 
                        ? 'Pago verificado automáticamente' 
                        : 'Verificación requiere revisión manual'
                });
                
            } catch (error) {
                log("error", 'Error in OCR verification:', error);
                log('info', 'error', 'Error en verificacion OCR', { error: error.message }); sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        






// ============================================

// ============================================
// KYC VERIFICATION SYSTEM
// OCR with Tesseract.js + Face Comparison
// Date: 2025-12-12
// ============================================

// Blocked names list for AML (sample - should be loaded from database in production)
// Face Comparison Setup (after line ~6850)
const faceapi = require('@vladmandic/face-api');
const canvas = require('canvas');
const { Canvas, Image, ImageData } = canvas;

// Patch canvas for face-api
faceapi.env.monkeyPatch({ Canvas, Image, ImageData });

let faceModelsLoaded = false;

let faceModelsAttempted = false;
async function loadFaceModels() {
    if (faceModelsLoaded || faceModelsAttempted) return;
    faceModelsAttempted = true;
    const MODEL_PATH = '/var/www/latanda.online/face-models';
    try {
        await faceapi.nets.ssdMobilenetv1.loadFromDisk(MODEL_PATH);
        await faceapi.nets.faceLandmark68Net.loadFromDisk(MODEL_PATH);
        await faceapi.nets.faceRecognitionNet.loadFromDisk(MODEL_PATH);
        faceModelsLoaded = true;
        log("info", "Face models loaded successfully");
    } catch (err) {
        log("warn", "Face models not available - face detection disabled");
    }
}

// Load models on startup (single attempt)
loadFaceModels().catch(() => {});

async function getFaceDescriptor(imagePath) {
    const img = await canvas.loadImage(imagePath);
    const detection = await faceapi.detectSingleFace(img)
        .withFaceLandmarks()
        .withFaceDescriptor();
    return detection ? detection.descriptor : null;
}

function euclideanDistance(arr1, arr2) {
    return Math.sqrt(arr1.reduce((sum, val, i) => sum + Math.pow(val - arr2[i], 2), 0));
}
const AML_BLOCKED_NAMES = [
    'JUAN ORLANDO HERNANDEZ',
    'TONY HERNANDEZ',
    // Add more as needed
];

// Validate Honduran ID format (0801-1990-12345)
function validateHonduranId(idNumber) {
    const pattern = /^\d{4}-\d{4}-\d{5}$/;
    return pattern.test(idNumber);
}

// Calculate age from birth date
function calculateAge(birthDate) {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
        age--;
    }
    return age;
}

// Extract data from Honduran ID using OCR text
function extractHonduranIdData(ocrText) {
    const result = {
        full_name: null,
        id_number: null,
        birth_date: null,
        gender: null,
        nationality: 'Hondureña',
        confidence: 0,
        raw_text: ocrText
    };
    
    const text = ocrText.toUpperCase();
    const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
    
    // Try to find ID number (format: 0801-1990-12345)
    const idPattern = /\d{4}[\s-]?\d{4}[\s-]?\d{5}/g;
    const idMatches = text.match(idPattern);
    if (idMatches && idMatches.length > 0) {
        result.id_number = idMatches[0].replace(/\s/g, '-').replace(/--/g, '-');
        result.confidence += 0.3;
    }
    
    // Try to find birth date (various formats)
    const datePatterns = [
        /NACIMIENTO[:\s]*([\d]{1,2})[\/-]([\d]{1,2})[\/-]([\d]{4})/i,
        /([\d]{1,2})[\/-]([\d]{1,2})[\/-](19[5-9]\d|20[0-2]\d)/,
        /FECHA[:\s]*([\d]{1,2})[\/-]([\d]{1,2})[\/-]([\d]{4})/i
    ];
    
    for (const pattern of datePatterns) {
        const match = text.match(pattern);
        if (match) {
            const day = match[1].padStart(2, '0');
            const month = match[2].padStart(2, '0');
            const year = match[3];
            result.birth_date = `${year}-${month}-${day}`;
            result.confidence += 0.2;
            break;
        }
    }
    
    // Try to find name (look for common patterns)
    const namePatterns = [
        /NOMBRE[:\s]*([A-ZÁÉÍÓÚÑ\s]+)/i,
        /APELLIDOS?[:\s]*([A-ZÁÉÍÓÚÑ\s]+)/i
    ];
    
    // Look for lines that look like names (all caps, multiple words)
    for (const line of lines) {
        if (line.length > 10 && line.length < 60 && 
            /^[A-ZÁÉÍÓÚÑ\s]+$/.test(line) &&
            !line.includes('HONDURAS') && 
            !line.includes('IDENTIDAD') &&
            !line.includes('REGISTRO') &&
            line.split(' ').length >= 2) {
            result.full_name = line;
            result.confidence += 0.3;
            break;
        }
    }
    
    // Try to detect gender
    if (text.includes('MASCULINO') || text.includes('SEXO: M') || text.includes('SEXO M')) {
        result.gender = 'M';
        result.confidence += 0.1;
    } else if (text.includes('FEMENINO') || text.includes('SEXO: F') || text.includes('SEXO F')) {
        result.gender = 'F';
        result.confidence += 0.1;
    }
    
    // Check for HONDURAS mentions to confirm it's a Honduran ID
    if (text.includes('HONDURAS') || text.includes('REPUBLICA')) {
        result.confidence += 0.1;
    }
    
    return result;
}

// POST /api/kyc/upload-document - Upload identity document
if (pathname === '/api/kyc/upload-document' && method === 'POST') {
    // ============================================
    // SECURITY FIX: Require JWT auth (2025-12-31)
    // ============================================
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    const user_id = authUser.userId; // Always use authenticated user
    
    const { document_type, document_image_base64, document_number } = body;
    
    if (!document_type || !document_image_base64) {
        sendError(res, 400, 'document_type y document_image_base64 son requeridos');
        return;
    }
    
    try {
        // Check if user already has pending or approved KYC
        const existingKyc = await dbPostgres.pool.query(
            'SELECT id, verification_status FROM kyc_documents WHERE user_id = $1 AND document_type = $2 ORDER BY created_at DESC LIMIT 1',
            [user_id, document_type]
        );
        
        if (existingKyc.rows[0]?.verification_status === 'approved') {
            sendError(res, 400, 'Ya tienes un documento aprobado de este tipo');
            return;
        }
        
        // Save document image to disk for face comparison
        const docDir = '/var/www/latanda.online/kyc-images';
        const fs = require('fs');
        if (!fs.existsSync(docDir)) fs.mkdirSync(docDir, { recursive: true });

        const docFilename = `doc_${user_id}_${document_type}_${Date.now()}.jpg`;
        const docPath = `${docDir}/${docFilename}`;
        const imageBuffer = Buffer.from(document_image_base64, 'base64');
        fs.writeFileSync(docPath, imageBuffer);

        const documentUrl = `kyc-images/${docFilename}`; // Relative URL
        
        // Create KYC record
        const kycResult = await dbPostgres.pool.query(
            `INSERT INTO kyc_documents (user_id, document_type, document_number, document_url, verification_status, metadata)
             VALUES ($1, $2, $3, $4, 'pending', $5)
             RETURNING id, verification_status`,
            [user_id, document_type, document_number || null, documentUrl, JSON.stringify({ uploaded_at: new Date().toISOString(), document_image_path: docPath })]
        );
        
        auditLog('KYC_DOCUMENT_UPLOADED', { user_id, document_type, kyc_id: kycResult.rows[0].id });
        
        sendSuccess(res, {
            kyc_id: kycResult.rows[0].id,
            status: 'pending',
            message: 'Documento subido exitosamente. Procesando verificación...'
        });
        return;
    } catch (error) {
        log('error', 'KYC document upload failed', { user_id, error: error.message });
        sendError(res, 500, 'Error subiendo documento');
        return;
    }
}

// POST /api/kyc/process-ocr - Process document with Tesseract OCR
if (pathname === '/api/kyc/process-ocr' && method === 'POST') {
    // ============================================
    // SECURITY FIX: Require JWT auth (2025-12-31)
    // ============================================
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    const user_id = authUser.userId; // Always use authenticated user
    
    const { document_image_base64, document_type } = body;
    
    if (!document_image_base64) {
        sendError(res, 400, 'document_image_base64 es requerido');
        return;
    }
    
    try {
        log('info', 'Starting OCR processing for KYC', { user_id, document_type });
        
        // Process with Tesseract
        const { data: { text, confidence } } = await Tesseract.recognize(
            'data:image/jpeg;base64,' + document_image_base64,
            'spa', // Spanish language
            {
                logger: m => log('debug', 'Tesseract progress', { status: m.status, progress: m.progress })
            }
        );
        
        // Extract data based on document type
        let extractedData = {};
        let amlCheck = { passed: true, flags: [] };
        
        if (document_type === 'id_card') {
            extractedData = extractHonduranIdData(text);
            
            // AML Check - blocked names
            if (extractedData.full_name) {
                const nameUpper = extractedData.full_name.toUpperCase();
                for (const blocked of AML_BLOCKED_NAMES) {
                    if (nameUpper.includes(blocked)) {
                        amlCheck.passed = false;
                        amlCheck.flags.push('BLOCKED_NAME_MATCH');
                        break;
                    }
                }
            }
            
            // Age verification (must be 18+)
            if (extractedData.birth_date) {
                const age = calculateAge(extractedData.birth_date);
                extractedData.age = age;
                if (age < 18) {
                    amlCheck.passed = false;
                    amlCheck.flags.push('UNDERAGE');
                }
            }
            
            // Validate ID format
            if (extractedData.id_number && !validateHonduranId(extractedData.id_number)) {
                extractedData.id_format_valid = false;
            } else {
                extractedData.id_format_valid = true;
            }
        }
        
        // Determine verification result
        const autoApproved = extractedData.confidence >= 0.6 && amlCheck.passed && 
                            extractedData.id_number && extractedData.full_name;
        
        // Update or create KYC record
        const kycResult = await dbPostgres.pool.query(
            `INSERT INTO kyc_documents (user_id, document_type, document_number, verification_status, metadata)
             VALUES ($1, $2, $3, $4, $5)
             ON CONFLICT (user_id, document_type) 
             DO UPDATE SET 
                document_number = EXCLUDED.document_number,
                verification_status = EXCLUDED.verification_status,
                metadata = EXCLUDED.metadata,
                updated_at = NOW()
             RETURNING id`,
            [
                user_id, 
                document_type || 'id_card',
                extractedData.id_number,
                autoApproved ? 'approved' : 'under_review',
                JSON.stringify({
                    ocr_data: extractedData,
                    ocr_confidence: confidence,
                    aml_check: amlCheck,
                    processed_at: new Date().toISOString()
                })
            ]
        );
        
        // Create notification
        await notificationsUtils.createNotification(dbPostgres.pool, user_id, 
            autoApproved ? 'kyc_approved' : 'kyc_pending_review',
            autoApproved ? '✅ Identidad Verificada' : '🔍 Documento en Revisión',
            autoApproved 
                ? 'Tu documento de identidad ha sido verificado exitosamente.'
                : 'Tu documento está siendo revisado. Te notificaremos pronto.',
            { kyc_id: kycResult.rows[0].id }
        );
        
        auditLog('KYC_OCR_PROCESSED', { 
            user_id, 
            auto_approved: autoApproved, 
            confidence: extractedData.confidence,
            aml_passed: amlCheck.passed 
        });
        
        sendSuccess(res, {
            status: autoApproved ? 'approved' : 'under_review',
            extracted_data: {
                full_name: extractedData.full_name,
                id_number: extractedData.id_number ? extractedData.id_number.slice(0, 4) + '-****-*****' : null,
                birth_date: extractedData.birth_date,
                age: extractedData.age,
                gender: extractedData.gender,
                id_format_valid: extractedData.id_format_valid
            },
            confidence: (extractedData.confidence * 100).toFixed(0) + '%',
            aml_check: {
                passed: amlCheck.passed,
                flags: amlCheck.flags
            },
            message: autoApproved 
                ? '¡Verificación exitosa! Tu identidad ha sido confirmada.'
                : 'Documento recibido. Será revisado manualmente.'
        });
        return;
    } catch (error) {
        log('error', 'KYC OCR processing failed', { user_id, error: error.message });
        log('info', 'error', 'Error procesando documento', { error: error.message }); sendError(res, 500, 'Error interno del servidor');
        return;
    }
}

// GET /api/kyc/status - Get user's KYC status
if (pathname === '/api/kyc/status' && method === 'GET') {
    // ============================================
    // SECURITY FIX: Require JWT auth (2025-12-31)
    // ============================================
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    const user_id = authUser.userId; // Always use authenticated user
    
    try {
        const kycDocs = await dbPostgres.pool.query(
            `SELECT id, document_type, verification_status, metadata, created_at, updated_at
             FROM kyc_documents 
             WHERE user_id = $1
             ORDER BY created_at DESC`,
            [user_id]
        );
        
        // Determine overall KYC level
        let kycLevel = 'none';
        let verifiedDocuments = [];
        
        for (const doc of kycDocs.rows) {
            if (doc.verification_status === 'approved') {
                verifiedDocuments.push(doc.document_type);
            }
        }
        
        if (verifiedDocuments.includes('id_card') || verifiedDocuments.includes('passport')) {
            kycLevel = 'basic';
        }
        if (verifiedDocuments.includes('utility_bill') || verifiedDocuments.includes('bank_statement')) {
            kycLevel = 'enhanced';
        }
        if (verifiedDocuments.length >= 3) {
            kycLevel = 'full';
        }
        
        // Get limits based on KYC level
        const limits = {
            none: { daily: 500, monthly: 2000, single_tx: 200 },
            basic: { daily: 5000, monthly: 20000, single_tx: 2000 },
            enhanced: { daily: 20000, monthly: 100000, single_tx: 10000 },
            full: { daily: 100000, monthly: 500000, single_tx: 50000 }
        };
        
        sendSuccess(res, {
            kyc_level: kycLevel,
            verified_documents: verifiedDocuments,
            documents: kycDocs.rows.map(d => ({
                id: d.id,
                type: d.document_type,
                status: d.verification_status,
                submitted_at: d.created_at,
                updated_at: d.updated_at
            })),
            limits: limits[kycLevel],
            next_level: kycLevel === 'full' ? null : {
                level: kycLevel === 'none' ? 'basic' : (kycLevel === 'basic' ? 'enhanced' : 'full'),
                requirements: kycLevel === 'none' 
                    ? ['Documento de identidad'] 
                    : (kycLevel === 'basic' 
                        ? ['Comprobante de domicilio'] 
                        : ['Verificación adicional'])
            }
        });
        return;
    } catch (error) {
        log('error', 'Failed to get KYC status', { user_id, error: error.message });
        sendError(res, 500, 'Error obteniendo estado KYC');
        return;
    }
}

// POST /api/kyc/upload-selfie - Upload selfie for face comparison
if (pathname === '/api/kyc/upload-selfie' && method === 'POST') {
    // ============================================
    // SECURITY FIX: Require JWT auth (2025-12-31)
    // ============================================
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    const user_id = authUser.userId; // Always use authenticated user
    
    const { selfie_image_base64 } = body;
    
    if (!selfie_image_base64) {
        sendError(res, 400, 'selfie_image_base64 es requerido');
        return;
    }
    
    try {
        // Get user's ID document to compare
        const docResult = await dbPostgres.pool.query(
            `SELECT id, metadata, document_type FROM kyc_documents 
             WHERE user_id = $1 AND document_type = 'id_card'`,
            [user_id]
        );
        
        if (docResult.rows.length === 0) {
            sendError(res, 400, 'Primero debe subir su documento de identidad');
            return;
        }
        
        const kycDoc = docResult.rows[0];
        
        // Save selfie image temporarily
        const selfieBuffer = Buffer.from(selfie_image_base64, 'base64');
        const selfieDir = '/var/www/latanda.online/kyc-images';
        const fs = require('fs');
        if (!fs.existsSync(selfieDir)) fs.mkdirSync(selfieDir, { recursive: true });
        
        const selfieFilename = `selfie_${user_id}_${Date.now()}.jpg`;
        const selfiePath = `${selfieDir}/${selfieFilename}`;
        fs.writeFileSync(selfiePath, selfieBuffer);
        
        let faceMatchResult = { matched: false, confidence: 0, error: null };
        
        // Check if we have document image to compare
        const docImagePath = kycDoc.metadata?.document_image_path;
        
        if (docImagePath && fs.existsSync(docImagePath)) {
            try {
                // Perform face comparison
                const docDescriptor = await getFaceDescriptor(docImagePath);
                const selfieDescriptor = await getFaceDescriptor(selfiePath);
                
                if (docDescriptor && selfieDescriptor) {
                    const distance = euclideanDistance(Array.from(docDescriptor), Array.from(selfieDescriptor));
                    const similarity = Math.max(0, 1 - distance);
                    const threshold = 0.5; // Adjust based on needs
                    
                    faceMatchResult = {
                        matched: distance < 0.6,
                        confidence: Math.round(similarity * 100),
                        distance: distance.toFixed(4)
                    };
                } else {
                    faceMatchResult.error = docDescriptor ? 'No se detectó rostro en selfie' : 'No se detectó rostro en documento';
                }
            } catch (faceErr) {
                log('error', 'Face comparison error', { error: faceErr.message });
                faceMatchResult.error = 'Error en comparación facial';
            }
        } else {
            faceMatchResult.error = 'Imagen de documento no disponible';
        }
        
        // Update KYC record with selfie info and face match result
        const updateStatus = faceMatchResult.matched ? 'verified' : 
                           faceMatchResult.confidence >= 40 ? 'pending_manual_review' : 'face_mismatch';
        
        await dbPostgres.pool.query(
            `UPDATE kyc_documents 
             SET metadata = metadata || $1::jsonb, 
                 verification_status = CASE 
                     WHEN $2 THEN 'verified' 
                     ELSE verification_status 
                 END,
                 updated_at = NOW()
             WHERE user_id = $3 AND document_type = 'id_card'`,
            [JSON.stringify({ 
                selfie_uploaded: true, 
                selfie_date: new Date().toISOString(),
                selfie_path: selfiePath,
                face_match: faceMatchResult
            }), faceMatchResult.matched, user_id]
        );
        
        auditLog('KYC_SELFIE_UPLOADED', { 
            user_id, 
            face_matched: faceMatchResult.matched,
            confidence: faceMatchResult.confidence 
        });
        
        sendSuccess(res, {
            status: faceMatchResult.matched ? 'verified' : 'pending_review',
            face_match: faceMatchResult,
            message: faceMatchResult.matched 
                ? '✅ Verificación facial exitosa! Su identidad ha sido verificada.'
                : faceMatchResult.error 
                    ? `⚠️ ${faceMatchResult.error}. Revisión manual pendiente.`
                    : '⚠️ La coincidencia facial es baja. Un agente revisará su solicitud.'
        });
        return;
    } catch (error) {
        log('error', 'Selfie upload failed', { user_id, error: error.message });
        sendError(res, 500, 'Error subiendo selfie');
        return;
    }
}
// =====================================
// TRANSACTION MONITORING SYSTEM - AML/Fraud Detection
// =====================================

// Risk thresholds
const RISK_THRESHOLDS = {
    HIGH_VALUE_SINGLE: 50000,        // L. 50,000 single transaction
    HIGH_VALUE_DAILY: 100000,        // L. 100,000 daily total
    RAPID_TRANSACTIONS: 5,           // 5+ transactions in 1 hour
    STRUCTURING_AMOUNT: 9500,        // Near reporting threshold
    STRUCTURING_COUNT: 3,            // 3+ transactions near threshold in 24h
    NEW_USER_HIGH_VALUE: 10000,      // New user (<7 days) high value
    UNUSUAL_HOURS_START: 1,          // 1 AM
    UNUSUAL_HOURS_END: 5,            // 5 AM
};

// Risk scoring function
function calculateTransactionRisk(transaction, userHistory, userProfile) {
    let riskScore = 0;
    const flags = [];

    // 1. High value single transaction
    if (transaction.amount >= RISK_THRESHOLDS.HIGH_VALUE_SINGLE) {
        riskScore += 30;
        flags.push('HIGH_VALUE_TRANSACTION');
    }

    // 2. Transaction near reporting threshold (structuring detection)
    if (transaction.amount >= RISK_THRESHOLDS.STRUCTURING_AMOUNT &&
        transaction.amount < RISK_THRESHOLDS.HIGH_VALUE_SINGLE) {
        riskScore += 20;
        flags.push('POSSIBLE_STRUCTURING');
    }

    // 3. Multiple transactions near threshold in 24h
    if (userHistory.nearThresholdCount >= RISK_THRESHOLDS.STRUCTURING_COUNT) {
        riskScore += 35;
        flags.push('STRUCTURING_PATTERN');
    }

    // 4. Rapid transactions (velocity check)
    if (userHistory.hourlyCount >= RISK_THRESHOLDS.RAPID_TRANSACTIONS) {
        riskScore += 25;
        flags.push('RAPID_TRANSACTIONS');
    }

    // 5. High daily total
    if (userHistory.dailyTotal >= RISK_THRESHOLDS.HIGH_VALUE_DAILY) {
        riskScore += 30;
        flags.push('HIGH_DAILY_VOLUME');
    }

    // 6. New user with high value
    const accountAgeDays = Math.floor((Date.now() - new Date(userProfile.created_at).getTime()) / (1000 * 60 * 60 * 24));
    if (accountAgeDays < 7 && transaction.amount >= RISK_THRESHOLDS.NEW_USER_HIGH_VALUE) {
        riskScore += 20;
        flags.push('NEW_USER_HIGH_VALUE');
    }

    // 7. Unusual hours
    const hour = new Date().getHours();
    if (hour >= RISK_THRESHOLDS.UNUSUAL_HOURS_START && hour <= RISK_THRESHOLDS.UNUSUAL_HOURS_END) {
        riskScore += 10;
        flags.push('UNUSUAL_HOURS');
    }

    // 8. First withdrawal to new recipient
    if (transaction.type === 'withdrawal' && !userHistory.knownRecipients.includes(transaction.recipient)) {
        riskScore += 15;
        flags.push('NEW_RECIPIENT');
    }

    // 9. Different device/IP
    if (userHistory.lastDeviceFingerprint && userHistory.lastDeviceFingerprint !== transaction.deviceFingerprint) {
        riskScore += 15;
        flags.push('NEW_DEVICE');
    }

    // Risk level determination
    let riskLevel = 'low';
    if (riskScore >= 70) riskLevel = 'critical';
    else if (riskScore >= 50) riskLevel = 'high';
    else if (riskScore >= 30) riskLevel = 'medium';

    return { riskScore, riskLevel, flags };
}

// POST /api/monitoring/analyze-transaction - Analyze transaction for risk
if (pathname === '/api/monitoring/analyze-transaction' && method === 'POST') {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser || authUser.role !== 'admin') { sendError(res, 403, "Acceso de administrador requerido"); return; }
    const admin_id = authUser.userId;

    const { transaction_id, user_id, amount, type, recipient, deviceFingerprint } = body;

    if (!user_id || !amount || !type) {
        sendError(res, 400, 'user_id, amount y type son requeridos');
        return;
    }

    try {
        // Get user profile
        const userResult = await dbPostgres.pool.query(
            'SELECT registration_date as created_at FROM users WHERE user_id = $1',
            [user_id]
        );

        const userProfile = userResult.rows[0] || { created_at: new Date() };

        // Get user transaction history (last 24h)
        const historyResult = await dbPostgres.pool.query(`
            SELECT
                COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '1 hour') as hourly_count,
                COALESCE(SUM(amount) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours'), 0) as daily_total,
                COUNT(*) FILTER (WHERE amount >= 9500 AND amount < 10000 AND created_at > NOW() - INTERVAL '24 hours') as near_threshold_count,
                array_agg(DISTINCT recipient) as known_recipients
            FROM (SELECT amount, created_at, user_id, NULL as recipient FROM contributions UNION ALL SELECT amount, created_at, user_id, bank_name as recipient FROM withdrawals) tx
            WHERE user_id = $1
        `, [user_id]);

        const history = historyResult.rows[0] || {
            hourly_count: 0,
            daily_total: 0,
            near_threshold_count: 0,
            known_recipients: []
        };

        const userHistory = {
            hourlyCount: parseInt(history.hourly_count || 0),
            dailyTotal: parseFloat(history.daily_total || 0),
            nearThresholdCount: parseInt(history.near_threshold_count || 0),
            knownRecipients: history.known_recipients || [],
            lastDeviceFingerprint: null // TODO: Implement device tracking
        };

        const transaction = {
            id: transaction_id,
            amount: parseFloat(amount),
            type,
            recipient: recipient || 'self',
            deviceFingerprint
        };

        // Calculate risk
        const risk = calculateTransactionRisk(transaction, userHistory, userProfile);

        // If high or critical risk, create alert
        if (risk.riskLevel === 'high' || risk.riskLevel === 'critical') {
            // Insert alert
            await dbPostgres.pool.query(`
                INSERT INTO compliance_alerts (user_id, alert_type, severity, details, status)
                VALUES ($1, 'suspicious_transaction', $2, $3, 'pending')
            `, [user_id, risk.riskLevel, JSON.stringify({
                transaction_id,
                amount,
                type,
                risk_score: risk.riskScore,
                flags: risk.flags,
                created_at: new Date().toISOString()
            })]);

            // Notify compliance team
            await dbPostgres.pool.query(`
                INSERT INTO notifications (user_id, type, title, message, data)
                VALUES ($1, 'compliance_alert', '🚨 Alerta AML', $2, $3)
            `, [
                'admin_compliance',
                `Transacción sospechosa detectada: ${risk.flags.join(', ')}`,
                JSON.stringify({ user_id, transaction_id, risk_score: risk.riskScore, flags: risk.flags })
            ]);

            auditLog('AML_ALERT_CREATED', {
                user_id,
                transaction_id,
                risk_score: risk.riskScore,
                risk_level: risk.riskLevel,
                flags: risk.flags
            });
        }

        sendSuccess(res, {
            risk_score: risk.riskScore,
            risk_level: risk.riskLevel,
            flags: risk.flags,
            action: risk.riskLevel === 'critical' ? 'BLOCK' :
                   risk.riskLevel === 'high' ? 'REVIEW_REQUIRED' : 'ALLOW',
            message: risk.riskLevel === 'critical'
                ? 'Transacción bloqueada. Requiere revisión de compliance.'
                : risk.riskLevel === 'high'
                    ? 'Transacción marcada para revisión.'
                    : 'Transacción aprobada.'
        });
        return;
    } catch (error) {
        log('error', 'Transaction risk analysis failed', { error: error.message }); 
        sendError(res, 500, 'Error analizando transacción');
        return;
    }
}

// GET /api/monitoring/alerts - Get compliance alerts
if (pathname === '/api/monitoring/alerts' && method === 'GET') {
    const authUser = getAuthenticatedUser(req, query);
    const { status, severity, user_id, limit = 50 } = parseUrl(req.url).query;

    try {
        let whereClause = '1=1';
        const params = [];
        let paramIndex = 1;

        if (status) {
            whereClause += ` AND status = $${paramIndex++}`;
            params.push(status);
        }
        if (severity) {
            whereClause += ` AND severity = $${paramIndex++}`;
            params.push(severity);
        }
        if (user_id) {
            whereClause += ` AND user_id = $${paramIndex++}`;
            params.push(user_id);
        }

        params.push(parseInt(limit));

        const result = await dbPostgres.pool.query(`
            SELECT id, user_id, alert_type, severity, details, status, resolution, resolved_by, resolution_notes, resolved_at, created_at, updated_at FROM compliance_alerts
            WHERE ${whereClause}
            ORDER BY created_at DESC
            LIMIT $${paramIndex}
        `, params);

        sendSuccess(res, {
            alerts: result.rows,
            count: result.rows.length
        });
        return;
    } catch (error) {
        log('error', 'Failed to get alerts', { error: error.message });
        sendError(res, 500, 'Error obteniendo alertas');
        return;
    }
}

// POST /api/monitoring/alerts/:id/resolve - Resolve an alert
if (pathname.match(/^\/api\/monitoring\/alerts\/\d+\/resolve$/) && method === 'POST') {
    const alertId = pathname.split('/')[4];
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser || authUser.role !== 'admin') { sendError(res, 403, "Acceso de administrador requerido"); return; }
    const { resolution, notes } = body;

    if (!resolution) {
        sendError(res, 400, 'resolution es requerido (approved, rejected, escalated)');
        return;
    }

    try {
        const result = await dbPostgres.pool.query(`
            UPDATE compliance_alerts
            SET status = 'resolved',
                resolution = $1,
                resolved_by = $2,
                resolution_notes = $3,
                resolved_at = NOW()
            WHERE id = $4
            RETURNING id, user_id, alert_type, severity, status, resolution, resolved_by, resolved_at
        `, [resolution, authUser.userId, notes || '', alertId]);

        if (result.rows.length === 0) {
            sendError(res, 404, 'Alerta no encontrada');
            return;
        }

        auditLog('AML_ALERT_RESOLVED', {
            alert_id: alertId,
            resolution,
            resolved_by: authUser.userId,
            notes
        });

        sendSuccess(res, {
            alert: result.rows[0],
            message: `Alerta resuelta como: ${resolution}`
        });
        return;
    } catch (error) {
        log('error', 'Failed to resolve alert', { error: error.message });
        sendError(res, 500, 'Error resolviendo alerta');
        return;
    }
}

// GET /api/monitoring/dashboard - Compliance dashboard stats
if (pathname === '/api/monitoring/dashboard' && method === 'GET') {

            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }
    try {
        const [alertsStats, transactionStats, kycStats] = await Promise.all([
            // Alerts summary
            dbPostgres.pool.query(`
                SELECT
                    COUNT(*) FILTER (WHERE status = 'pending') as pending_alerts,
                    COUNT(*) FILTER (WHERE severity = 'critical' AND status = 'pending') as critical_alerts,
                    COUNT(*) FILTER (WHERE severity = 'high' AND status = 'pending') as high_alerts,
                    COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as alerts_24h,
                    COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '7 days') as alerts_7d
                FROM compliance_alerts
            `),
            // Transaction monitoring stats (last 24h)
            dbPostgres.pool.query(`
                SELECT
                    COUNT(*) as total_transactions,
                    COALESCE(SUM(amount), 0) as total_volume,
                    COUNT(*) FILTER (WHERE amount >= 50000) as high_value_count,
                    AVG(amount) as avg_transaction
                FROM (SELECT amount, created_at, user_id, NULL as recipient FROM contributions UNION ALL SELECT amount, created_at, user_id, bank_name as recipient FROM withdrawals) tx
                WHERE created_at > NOW() - INTERVAL '24 hours'
            `),
            // KYC pending
            dbPostgres.pool.query(`
                SELECT
                    COUNT(*) FILTER (WHERE verification_status = 'pending') as pending_kyc,
                    COUNT(*) FILTER (WHERE verification_status = 'pending_manual_review') as manual_review_kyc
                FROM kyc_documents
            `)
        ]);

        sendSuccess(res, {
            alerts: alertsStats.rows[0],
            transactions_24h: transactionStats.rows[0],
            kyc: kycStats.rows[0],
            timestamp: new Date().toISOString()
        });
        return;
    } catch (error) {
        log('error', 'Dashboard stats failed', { error: error.message });
        sendError(res, 500, 'Error obteniendo estadísticas');
        return;
    }
}
// =====================================
// TRANSACTION PIN SYSTEM
// =====================================

const PIN_THRESHOLD = 1000; // Require PIN for amounts >= L. 1,000
const MAX_PIN_ATTEMPTS = 3;
const PIN_LOCKOUT_MINUTES = 30;

// POST /api/wallet/pin/set - Set transaction PIN
if (pathname === '/api/wallet/pin/set' && method === 'POST') {
    // SECURITY FIX: Require JWT auth (2025-12-31)
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    const user_id = authUser.userId;
    const { pin, current_password } = body;

    if (!pin || pin.length < 4 || pin.length > 6 || !/^\d+$/.test(pin)) {
        sendError(res, 400, 'PIN debe ser de 4-6 dígitos numéricos');
        return;
    }

    try {
        // Verify user exists and optionally verify password
        const userResult = await dbPostgres.pool.query(
            'SELECT user_id, password_hash FROM users WHERE user_id = $1',
            [user_id]
        );

        if (userResult.rows.length === 0) {
            sendError(res, 404, 'Usuario no encontrado');
            return;
        }

        // If user has password and current_password provided, verify it
        if (current_password && userResult.rows[0].password_hash) {
            const validPassword = await bcrypt.compare(current_password, userResult.rows[0].password_hash);
            if (!validPassword) {
                sendError(res, 401, 'Contraseña actual incorrecta');
                return;
            }
        }

        // Hash the PIN
        const pinHash = await bcrypt.hash(pin, 12);

        // Upsert PIN
        await dbPostgres.pool.query(`
            INSERT INTO user_transaction_pins (user_id, pin_hash, failed_attempts, updated_at)
            VALUES ($1, $2, 0, NOW())
            ON CONFLICT (user_id)
            DO UPDATE SET pin_hash = $2, failed_attempts = 0, locked_until = NULL, updated_at = NOW()
        `, [user_id, pinHash]);

        auditLog('PIN_SET', { user_id });

        sendSuccess(res, {
            message: 'PIN de transacción configurado exitosamente',
            pin_required_for: `Transacciones >= L. ${PIN_THRESHOLD.toLocaleString()}`
        });
        return;
    } catch (error) {
        log('error', 'PIN set failed', { user_id, error: error.message });
        sendError(res, 500, 'Error configurando PIN');
        return;
    }
}

// POST /api/wallet/pin/verify - Verify transaction PIN
if (pathname === '/api/wallet/pin/verify' && method === 'POST') {
    // SECURITY FIX: Require JWT auth (2025-12-31)
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    const user_id = authUser.userId;
    const { pin } = body;

    if (!pin) {
        sendError(res, 400, 'PIN es requerido');
        return;
    }

    try {
        const pinResult = await dbPostgres.pool.query(
            'SELECT pin_hash, failed_attempts, locked_until FROM user_transaction_pins WHERE user_id = $1',
            [user_id]
        );

        if (pinResult.rows.length === 0) {
            sendError(res, 404, 'PIN no configurado. Configure su PIN primero.');
            return;
        }

        const pinData = pinResult.rows[0];

        // Check if locked
        if (pinData.locked_until && new Date(pinData.locked_until) > new Date()) {
            const remainingMinutes = Math.ceil((new Date(pinData.locked_until) - new Date()) / 60000);
            sendError(res, 423, `PIN bloqueado. Intente en ${remainingMinutes} minutos.`);
            return;
        }

        // Verify PIN
        const validPin = await bcrypt.compare(pin, pinData.pin_hash);

        if (!validPin) {
            const newAttempts = pinData.failed_attempts + 1;

            if (newAttempts >= MAX_PIN_ATTEMPTS) {
                // Lock the PIN
                await dbPostgres.pool.query(`
                    UPDATE user_transaction_pins
                    SET failed_attempts = $1, locked_until = NOW() + INTERVAL '${PIN_LOCKOUT_MINUTES} minutes'
                    WHERE user_id = $2
                `, [newAttempts, user_id]);

                auditLog('PIN_LOCKED', { user_id, reason: 'max_attempts' });
                sendError(res, 423, `PIN bloqueado por ${PIN_LOCKOUT_MINUTES} minutos debido a múltiples intentos fallidos.`);
            } else {
                await dbPostgres.pool.query(
                    'UPDATE user_transaction_pins SET failed_attempts = $1 WHERE user_id = $2',
                    [newAttempts, user_id]
                );
                sendError(res, 401, `PIN incorrecto. ${MAX_PIN_ATTEMPTS - newAttempts} intentos restantes.`);
            }
            return;
        }

        // Reset failed attempts on success
        await dbPostgres.pool.query(
            'UPDATE user_transaction_pins SET failed_attempts = 0, locked_until = NULL WHERE user_id = $1',
            [user_id]
        );

        sendSuccess(res, {
            verified: true,
            message: 'PIN verificado correctamente'
        });
        return;
    } catch (error) {
        log('error', 'PIN verify failed', { user_id, error: error.message });
        sendError(res, 500, 'Error verificando PIN');
        return;
    }
}

// GET /api/wallet/pin/status - Check if user has PIN set
if (pathname === '/api/wallet/pin/status' && method === 'GET') {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const user_id = authUser.userId;

    try {
        const pinResult = await dbPostgres.pool.query(
            'SELECT failed_attempts, locked_until, created_at FROM user_transaction_pins WHERE user_id = $1',
            [user_id]
        );

        const hasPin = pinResult.rows.length > 0;
        const isLocked = hasPin && pinResult.rows[0].locked_until && new Date(pinResult.rows[0].locked_until) > new Date();

        sendSuccess(res, {
            has_pin: hasPin,
            is_locked: isLocked,
            pin_required_threshold: PIN_THRESHOLD,
            locked_until: isLocked ? pinResult.rows[0].locked_until : null,
            created_at: hasPin ? pinResult.rows[0].created_at : null
        });
        return;
    } catch (error) {
        log('error', 'PIN status failed', { user_id, error: error.message });
        sendError(res, 500, 'Error obteniendo estado del PIN');
        return;
    }
}

// =====================================
// ACCOUNT RECOVERY SYSTEM
// =====================================

// POST /api/recovery/backup-codes/generate - Generate 10 backup codes
if (pathname === "/api/recovery/backup-codes/generate" && method === "POST") {
    // SECURITY FIX: Require JWT auth (2025-12-31)
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    const user_id = authUser.userId;
    const { current_password } = body;

    try {
        const userResult = await dbPostgres.pool.query(
            "SELECT password_hash FROM users WHERE user_id = $1",
            [user_id]
        );

        if (userResult.rows.length === 0) {
            sendError(res, 401, "Credenciales inválidas"); // SECURITY: Generic error to prevent user enumeration
            return;
        }

        if (current_password && userResult.rows[0].password_hash) {
            const validPassword = await bcrypt.compare(current_password, userResult.rows[0].password_hash);
            if (!validPassword) {
                sendError(res, 401, "Contraseña incorrecta");
                return;
            }
        }

        await dbPostgres.pool.query("DELETE FROM user_backup_codes WHERE user_id = $1", [user_id]);

        const codes = [];
        for (let i = 0; i < 10; i++) {
            const code = crypto.randomBytes(6).toString('hex').toUpperCase();
            const codeHash = await bcrypt.hash(code, 12);

            await dbPostgres.pool.query(
                "INSERT INTO user_backup_codes (user_id, code_hash) VALUES ($1, $2)",
                [user_id, codeHash]
            );
            codes.push(code);
        }

        auditLog("BACKUP_CODES_GENERATED", { user_id, count: 10 });

        sendSuccess(res, {
            message: "Códigos de respaldo generados. Guárdalos en un lugar seguro.",
            codes: codes,
            warning: "⚠️ Estos códigos solo se mostrarán una vez. Cada código solo puede usarse una vez."
        });
        return;
    } catch (error) {
        log("error", "Backup codes generation failed", { user_id, error: error.message });
        sendError(res, 500, "Error generando códigos de respaldo");
        return;
    }
}

// POST /api/recovery/backup-codes/verify - Verify and use a backup code
if (pathname === "/api/recovery/backup-codes/verify" && method === "POST") {
    const { user_id, email, backup_code } = body;
    const identifier = user_id || email;

    if (!identifier || !backup_code) {
        sendError(res, 400, "user_id/email y backup_code son requeridos");
        return;
    }

    try {
        let finalUserId = user_id;
        if (!user_id && email) {
            const userResult = await dbPostgres.pool.query(
                "SELECT user_id FROM users WHERE email = $1",
                [email]
            );
            if (userResult.rows.length === 0) {
                sendError(res, 401, "Credenciales inválidas"); // SECURITY: Generic error to prevent user enumeration
                return;
            }
            finalUserId = userResult.rows[0].user_id;
        }

        const codesResult = await dbPostgres.pool.query(
            "SELECT id, code_hash FROM user_backup_codes WHERE user_id = $1 AND used = FALSE",
            [finalUserId]
        );

        if (codesResult.rows.length === 0) {
            sendError(res, 400, "No tienes códigos de respaldo disponibles");
            return;
        }

        let validCode = null;
        for (const row of codesResult.rows) {
            const isValid = await bcrypt.compare(backup_code.toUpperCase(), row.code_hash);
            if (isValid) {
                validCode = row;
                break;
            }
        }

        if (!validCode) {
            auditLog("BACKUP_CODE_FAILED", { user_id: finalUserId });
            sendError(res, 401, "Código de respaldo inválido");
            return;
        }

        await dbPostgres.pool.query(
            "UPDATE user_backup_codes SET used = TRUE, used_at = NOW() WHERE id = $1",
            [validCode.id]
        );

        const remainingResult = await dbPostgres.pool.query(
            "SELECT COUNT(*) as remaining FROM user_backup_codes WHERE user_id = $1 AND used = FALSE",
            [finalUserId]
        );

        auditLog("BACKUP_CODE_USED", { user_id: finalUserId, remaining: remainingResult.rows[0].remaining });

        sendSuccess(res, {
            verified: true,
            message: "Código de respaldo verificado",
            remaining_codes: parseInt(remainingResult.rows[0].remaining),
            warning: remainingResult.rows[0].remaining <= 2 ? "⚠️ Te quedan pocos códigos de respaldo. Genera nuevos pronto." : null
        });
        return;
    } catch (error) {
        log("error", "Backup code verification failed", { error: error.message });
        sendError(res, 500, "Error verificando código");
        return;
    }
}

// GET /api/recovery/backup-codes/status - Check backup codes status
if (pathname === "/api/recovery/backup-codes/status" && method === "GET") {
    // SECURITY FIX: Require JWT auth (2025-12-31)
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    const user_id = authUser.userId;

    try {
        const result = await dbPostgres.pool.query(`
            SELECT
                COUNT(*) FILTER (WHERE used = FALSE) as available,
                COUNT(*) FILTER (WHERE used = TRUE) as used,
                COUNT(*) as total,
                MAX(created_at) as generated_at
            FROM user_backup_codes
            WHERE user_id = $1
        `, [user_id]);

        const data = result.rows[0];

        sendSuccess(res, {
            has_codes: parseInt(data.total) > 0,
            available: parseInt(data.available) || 0,
            used: parseInt(data.used) || 0,
            total: parseInt(data.total) || 0,
            generated_at: data.generated_at,
            needs_regeneration: parseInt(data.available) <= 2
        });
        return;
    } catch (error) {
        log("error", "Backup codes status failed", { user_id, error: error.message });
        sendError(res, 500, "Error obteniendo estado");
        return;
    }
}

// POST /api/recovery/security-questions/set - Set security questions
if (pathname === "/api/recovery/security-questions/set" && method === "POST") {
    // SECURITY FIX: Require JWT auth (2025-12-31)
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    const user_id = authUser.userId;
    const { questions, current_password } = body;

    if (!user_id) {
        sendError(res, 401, "Autenticación requerida");
        return;
    }

    if (!questions || !Array.isArray(questions) || questions.length < 1) {
        sendError(res, 400, "Se requiere al menos 1 pregunta de seguridad");
        return;
    }

    try {
        const userResult = await dbPostgres.pool.query(
            "SELECT password_hash FROM users WHERE user_id = $1",
            [user_id]
        );

        if (current_password && userResult.rows[0]?.password_hash) {
            const validPassword = await bcrypt.compare(current_password, userResult.rows[0].password_hash);
            if (!validPassword) {
                sendError(res, 401, "Contraseña incorrecta");
                return;
            }
        }

        const q1 = questions[0] || {};
        const q2 = questions[1] || {};
        const q3 = questions[2] || {};

        const answer1Hash = q1.answer ? await bcrypt.hash(q1.answer.toLowerCase().trim(), 12) : null;
        const answer2Hash = q2.answer ? await bcrypt.hash(q2.answer.toLowerCase().trim(), 12) : null;
        const answer3Hash = q3.answer ? await bcrypt.hash(q3.answer.toLowerCase().trim(), 12) : null;

        await dbPostgres.pool.query(`
            INSERT INTO user_security_questions
            (user_id, question1, answer1_hash, question2, answer2_hash, question3, answer3_hash, updated_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
            ON CONFLICT (user_id)
            DO UPDATE SET
                question1 = $2, answer1_hash = $3,
                question2 = $4, answer2_hash = $5,
                question3 = $6, answer3_hash = $7,
                updated_at = NOW()
        `, [user_id, q1.question, answer1Hash, q2.question || null, answer2Hash, q3.question || null, answer3Hash]);

        auditLog("SECURITY_QUESTIONS_SET", { user_id, count: questions.filter(q => q.question).length });

        sendSuccess(res, {
            message: "Preguntas de seguridad configuradas",
            questions_set: questions.filter(q => q.question).length
        });
        return;
    } catch (error) {
        log("error", "Security questions set failed", { user_id, error: error.message });
        sendError(res, 500, "Error configurando preguntas");
        return;
    }
}

// POST /api/recovery/security-questions/verify - Verify security question answers
if (pathname === "/api/recovery/security-questions/verify" && method === "POST") {
    const { email, answers } = body;

    if (!email || !answers || !Array.isArray(answers)) {
        sendError(res, 400, "email y answers son requeridos");
        return;
    }

    try {
        const userResult = await dbPostgres.pool.query(
            "SELECT user_id FROM users WHERE email = $1",
            [email]
        );

        if (userResult.rows.length === 0) {
            sendError(res, 401, "Credenciales inválidas"); // SECURITY: Generic error to prevent user enumeration
            return;
        }

        const user_id = userResult.rows[0].user_id;

        const questionsResult = await dbPostgres.pool.query(
            "SELECT id, user_id, question, created_at FROM user_security_questions WHERE user_id = $1",
            [user_id]
        );

        if (questionsResult.rows.length === 0) {
            sendError(res, 400, "No tienes preguntas de seguridad configuradas");
            return;
        }

        const sq = questionsResult.rows[0];
        let correctAnswers = 0;
        const totalQuestions = [sq.question1, sq.question2, sq.question3].filter(q => q).length;

        for (let i = 0; i < answers.length && i < 3; i++) {
            const answerHash = sq[`answer${i + 1}_hash`];
            if (answerHash && answers[i]) {
                const isCorrect = await bcrypt.compare(answers[i].toLowerCase().trim(), answerHash);
                if (isCorrect) correctAnswers++;
            }
        }

        const requiredCorrect = Math.min(2, totalQuestions);
        const verified = correctAnswers >= requiredCorrect;

        if (verified) {
            auditLog("SECURITY_QUESTIONS_VERIFIED", { user_id, correct: correctAnswers, total: totalQuestions });
        } else {
            auditLog("SECURITY_QUESTIONS_FAILED", { user_id, correct: correctAnswers, total: totalQuestions });
        }

        sendSuccess(res, {
            verified,
            correct_answers: correctAnswers,
            required: requiredCorrect,
            message: verified
                ? "Identidad verificada. Puedes proceder a restablecer tu contraseña."
                : "Respuestas incorrectas. Intenta de nuevo."
        });
        return;
    } catch (error) {
        log("error", "Security questions verify failed", { email, error: error.message });
        sendError(res, 500, "Error verificando respuestas");
        return;
    }
}

// GET /api/recovery/security-questions/get - Get user security questions (without answers)
if (pathname === "/api/recovery/security-questions/get" && method === "GET") {
    const email = parseUrl(req.url).query.email;

    if (!email) {
        sendError(res, 400, "email es requerido");
        return;
    }

    try {
        const userResult = await dbPostgres.pool.query(
            "SELECT user_id FROM users WHERE email = $1",
            [email]
        );

        if (userResult.rows.length === 0) {
            sendSuccess(res, { questions: [] });
            return;
        }

        const questionsResult = await dbPostgres.pool.query(
            "SELECT question1, question2, question3 FROM user_security_questions WHERE user_id = $1",
            [userResult.rows[0].user_id]
        );

        if (questionsResult.rows.length === 0) {
            sendSuccess(res, { questions: [], has_questions: false });
            return;
        }

        const sq = questionsResult.rows[0];
        const questions = [sq.question1, sq.question2, sq.question3].filter(q => q);

        sendSuccess(res, {
            questions,
            has_questions: questions.length > 0
        });
        return;
    } catch (error) {
        log("error", "Get security questions failed", { email, error: error.message });
        sendError(res, 500, "Error obteniendo preguntas");
        return;
    }
}


// =====================================
// PHASE 7: ADVANCED FEATURES
// =====================================

// ========== WEBAUTHN / BIOMETRICS ==========

// POST /api/auth/webauthn/register-options - Get registration options
if (pathname === "/api/auth/webauthn/register-options" && method === "POST") {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }
    const user_id = authUser.userId;

    if (!user_id) {
        sendError(res, 401, "Autenticación requerida");
        return;
    }

    try {
        const userResult = await dbPostgres.pool.query(
            "SELECT user_id, email, name FROM users WHERE user_id = $1",
            [user_id]
        );

        if (userResult.rows.length === 0) {
            sendError(res, 401, "Credenciales inválidas"); // SECURITY: Generic error to prevent user enumeration
            return;
        }

        const user = userResult.rows[0];
        const challenge = crypto.randomBytes(32).toString("base64url");

        // Store challenge temporarily (in production, use Redis with TTL)
        // Cleanup expired WebAuthn challenges (older than 60 seconds)
        if (global.webauthnChallenges) {
            const now = Date.now();
            for (const uid of Object.keys(global.webauthnChallenges)) {
                if (now - global.webauthnChallenges[uid].timestamp > 60000) {
                    delete global.webauthnChallenges[uid];
                }
            }
        }
        global.webauthnChallenges = global.webauthnChallenges || {};
        global.webauthnChallenges[user_id] = { challenge, timestamp: Date.now() };

        sendSuccess(res, {
            challenge,
            rp: {
                name: "La Tanda Fintech",
                id: "latanda.online"
            },
            user: {
                id: Buffer.from(user_id).toString("base64url"),
                name: user.email,
                displayName: user.name || user.email
            },
            pubKeyCredParams: [
                { type: "public-key", alg: -7 },  // ES256
                { type: "public-key", alg: -257 } // RS256
            ],
            timeout: 60000,
            attestation: "none",
            authenticatorSelection: {
                authenticatorAttachment: "platform",
                userVerification: "preferred",
                residentKey: "preferred"
            }
        });
        return;
    } catch (error) {
        log("error", "WebAuthn register options failed", { error: error.message });
        sendError(res, 500, "Error generando opciones de registro");
        return;
    }
}

// POST /api/auth/webauthn/register - Complete registration
if (pathname === "/api/auth/webauthn/register" && method === "POST") {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }
    const user_id = authUser.userId;
    const { credential, device_name } = body;

    if (!user_id || !credential) {
        sendError(res, 400, "user_id y credential son requeridos");
        return;
    }

    try {
        // Verify challenge exists
        const storedChallenge = global.webauthnChallenges?.[user_id];
        if (!storedChallenge || Date.now() - storedChallenge.timestamp > 60000) {
            sendError(res, 400, "Challenge expirado. Intente de nuevo.");
            return;
        }

        // Store credential
        await dbPostgres.pool.query(`
            INSERT INTO user_webauthn_credentials 
            (user_id, credential_id, public_key, device_name, counter)
            VALUES ($1, $2, $3, $4, $5)
        `, [user_id, credential.id, JSON.stringify(credential.response), device_name || "Dispositivo biométrico", 0]);

        delete global.webauthnChallenges[user_id];

        auditLog("WEBAUTHN_REGISTERED", { user_id, device_name });

        sendSuccess(res, {
            message: "Autenticación biométrica registrada exitosamente",
            device_name: device_name || "Dispositivo biométrico"
        });
        return;
    } catch (error) {
        log("error", "WebAuthn register failed", { error: error.message });
        sendError(res, 500, "Error registrando credencial");
        return;
    }
}

// POST /api/auth/webauthn/authenticate-options - Get authentication options
if (pathname === "/api/auth/webauthn/authenticate-options" && method === "POST") {
    const { user_id, email } = body;

    if (!user_id && !email) {
        sendError(res, 400, "user_id o email requerido");
        return;
    }

    try {
        let finalUserId = user_id;
        if (!user_id && email) {
            const userResult = await dbPostgres.pool.query(
                "SELECT user_id FROM users WHERE email = $1",
                [email]
            );
            if (userResult.rows.length === 0) {
                sendError(res, 401, "Credenciales inválidas"); // SECURITY: Generic error to prevent user enumeration
                return;
            }
            finalUserId = userResult.rows[0].user_id;
        }

        const credentials = await dbPostgres.pool.query(
            "SELECT credential_id FROM user_webauthn_credentials WHERE user_id = $1",
            [finalUserId]
        );

        if (credentials.rows.length === 0) {
            sendError(res, 400, "No tiene autenticación biométrica configurada");
            return;
        }

        const challenge = crypto.randomBytes(32).toString("base64url");
        global.webauthnChallenges = global.webauthnChallenges || {};
        global.webauthnChallenges[finalUserId] = { challenge, timestamp: Date.now() };

        sendSuccess(res, {
            challenge,
            timeout: 60000,
            rpId: "latanda.online",
            allowCredentials: credentials.rows.map(c => ({
                type: "public-key",
                id: c.credential_id
            })),
            userVerification: "preferred"
        });
        return;
    } catch (error) {
        log("error", "WebAuthn auth options failed", { error: error.message });
        sendError(res, 500, "Error generando opciones de autenticación");
        return;
    }
}

// POST /api/auth/webauthn/authenticate - Complete authentication
if (pathname === "/api/auth/webauthn/authenticate" && method === "POST") {
    const { user_id, credential } = body;

    if (!user_id || !credential) {
        sendError(res, 400, "user_id y credential son requeridos");
        return;
    }

    try {
        const storedChallenge = global.webauthnChallenges?.[user_id];
        if (!storedChallenge || Date.now() - storedChallenge.timestamp > 60000) {
            sendError(res, 400, "Challenge expirado");
            return;
        }

        const credResult = await dbPostgres.pool.query(
            "SELECT id, user_id, credential_id, public_key, sign_count, created_at FROM user_webauthn_credentials WHERE user_id = $1 AND credential_id = $2",
            [user_id, credential.id]
        );

        if (credResult.rows.length === 0) {
            sendError(res, 401, "Credencial no reconocida");
            return;
        }

        // Update last used
        await dbPostgres.pool.query(
            "UPDATE user_webauthn_credentials SET last_used_at = NOW(), counter = counter + 1 WHERE id = $1",
            [credResult.rows[0].id]
        );

        delete global.webauthnChallenges[user_id];

        auditLog("WEBAUTHN_AUTH_SUCCESS", { user_id });

        sendSuccess(res, {
            authenticated: true,
            message: "Autenticación biométrica exitosa"
        });
        return;
    } catch (error) {
        log("error", "WebAuthn authenticate failed", { error: error.message });
        sendError(res, 500, "Error autenticando");
        return;
    }
}

// GET /api/auth/webauthn/credentials - List user biometric credentials
if (pathname === "/api/auth/webauthn/credentials" && method === "GET") {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticación requerida");
                return;
            }

    const user_id = authUser.userId;

    try {
        const result = await dbPostgres.pool.query(
            "SELECT id, device_name, created_at, last_used_at FROM user_webauthn_credentials WHERE user_id = $1 ORDER BY created_at DESC",
            [user_id]
        );

        sendSuccess(res, {
            credentials: result.rows,
            count: result.rows.length,
            has_biometrics: result.rows.length > 0
        });
        return;
    } catch (error) {
        log("error", "Get WebAuthn credentials failed", { error: error.message });
        sendError(res, 500, "Error obteniendo credenciales");
        return;
    }
}

// DELETE /api/auth/webauthn/credentials/:id - Remove biometric credential
if (pathname.match(/^\/api\/auth\/webauthn\/credentials\/\d+$/) && method === "DELETE") {
    const credentialId = pathname.split("/").pop();
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }
    const user_id = authUser.userId;

    if (!user_id) {
        sendError(res, 401, "Autenticación requerida");
        return;
    }

    try {
        const result = await dbPostgres.pool.query(
            "DELETE FROM user_webauthn_credentials WHERE id = $1 AND user_id = $2 RETURNING device_name",
            [credentialId, user_id]
        );

        if (result.rows.length === 0) {
            sendError(res, 404, "Credencial no encontrada");
            return;
        }

        auditLog("WEBAUTHN_CREDENTIAL_REMOVED", { user_id, credential_id: credentialId });

        sendSuccess(res, {
            message: "Credencial biométrica eliminada",
            device_name: result.rows[0].device_name
        });
        return;
    } catch (error) {
        log("error", "Delete WebAuthn credential failed", { error: error.message });
        sendError(res, 500, "Error eliminando credencial");
        return;
    }
}

// ========== CUSTOM LIMITS ==========

// GET /api/wallet/limits - Get user limits
if (pathname === "/api/wallet/limits" && method === "GET") {

            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }
    const user_id = authUser.userId;

    try {
        const result = await dbPostgres.pool.query(
            "SELECT id, user_id, daily_withdrawal_limit, single_transaction_limit, monthly_limit, require_pin_threshold, limit_increase_request_status, limit_increase_requested_at, created_at, updated_at FROM user_custom_limits WHERE user_id = $1",
            [user_id]
        );

        const defaultLimits = {
            daily_withdrawal_limit: 50000.00,
            single_transaction_limit: 25000.00,
            monthly_limit: 500000.00,
            require_pin_threshold: 1000.00
        };

        const limits = result.rows.length > 0 ? result.rows[0] : defaultLimits;

        // Get today usage
        const usageResult = await dbPostgres.pool.query(`
            SELECT COALESCE(SUM(amount), 0) as daily_used
            FROM withdrawals 
            WHERE user_id = $1 
            AND created_at > CURRENT_DATE 
            AND status != 'rejected'
        `, [user_id]);

        sendSuccess(res, {
            limits: {
                daily_withdrawal: parseFloat(limits.daily_withdrawal_limit),
                single_transaction: parseFloat(limits.single_transaction_limit),
                monthly: parseFloat(limits.monthly_limit),
                pin_threshold: parseFloat(limits.require_pin_threshold)
            },
            usage: {
                daily_used: parseFloat(usageResult.rows[0].daily_used),
                daily_remaining: parseFloat(limits.daily_withdrawal_limit) - parseFloat(usageResult.rows[0].daily_used)
            },
            increase_request: limits.limit_increase_request_status
        });
        return;
    } catch (error) {
        log("error", "Get limits failed", { error: error.message });
        sendError(res, 500, "Error obteniendo límites");
        return;
    }
}

// PUT /api/wallet/limits - Update user limits (reduce only)
if (pathname === "/api/wallet/limits" && method === "PUT") {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }
    const user_id = authUser.userId;
    const { daily_withdrawal_limit, single_transaction_limit, monthly_limit, require_pin_threshold } = body;

    if (!user_id) {
        sendError(res, 401, "Autenticación requerida");
        return;
    }

    try {
        // Get current limits
        const currentResult = await dbPostgres.pool.query(
            "SELECT id, user_id, daily_withdrawal_limit, single_transaction_limit, monthly_limit, require_pin_threshold, limit_increase_request_status, limit_increase_requested_at, created_at, updated_at FROM user_custom_limits WHERE user_id = $1",
            [user_id]
        );

        const currentLimits = currentResult.rows.length > 0 ? currentResult.rows[0] : {
            daily_withdrawal_limit: 50000,
            single_transaction_limit: 25000,
            monthly_limit: 500000,
            require_pin_threshold: 1000
        };

        // Users can only REDUCE limits, not increase
        const newLimits = {
            daily: Math.min(daily_withdrawal_limit || currentLimits.daily_withdrawal_limit, currentLimits.daily_withdrawal_limit),
            single: Math.min(single_transaction_limit || currentLimits.single_transaction_limit, currentLimits.single_transaction_limit),
            monthly: Math.min(monthly_limit || currentLimits.monthly_limit, currentLimits.monthly_limit),
            pin_threshold: require_pin_threshold || currentLimits.require_pin_threshold
        };

        await dbPostgres.pool.query(`
            INSERT INTO user_custom_limits 
            (user_id, daily_withdrawal_limit, single_transaction_limit, monthly_limit, require_pin_threshold, updated_at)
            VALUES ($1, $2, $3, $4, $5, NOW())
            ON CONFLICT (user_id)
            DO UPDATE SET 
                daily_withdrawal_limit = $2,
                single_transaction_limit = $3,
                monthly_limit = $4,
                require_pin_threshold = $5,
                updated_at = NOW()
        `, [user_id, newLimits.daily, newLimits.single, newLimits.monthly, newLimits.pin_threshold]);

        auditLog("LIMITS_UPDATED", { user_id, new_limits: newLimits });

        sendSuccess(res, {
            message: "Límites actualizados",
            limits: newLimits
        });
        return;
    } catch (error) {
        log("error", "Update limits failed", { error: error.message });
        sendError(res, 500, "Error actualizando límites");
        return;
    }
}

// POST /api/wallet/limits/request-increase - Request limit increase
if (pathname === "/api/wallet/limits/request-increase" && method === "POST") {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }
    const user_id = authUser.userId;
    const { requested_daily_limit, reason } = body;

    if (!user_id || !requested_daily_limit) {
        sendError(res, 400, "user_id y requested_daily_limit requeridos");
        return;
    }

    try {
        await dbPostgres.pool.query(`
            INSERT INTO user_custom_limits (user_id, limit_increase_request_status, limit_increase_requested_at)
            VALUES ($1, 'pending', NOW())
            ON CONFLICT (user_id)
            DO UPDATE SET 
                limit_increase_request_status = 'pending',
                limit_increase_requested_at = NOW()
        `, [user_id]);

        // Create notification for compliance
        await dbPostgres.pool.query(`
            INSERT INTO compliance_alerts (user_id, alert_type, severity, details, status)
            VALUES ($1, 'limit_increase_request', 'low', $2, 'pending')
        `, [user_id, JSON.stringify({ requested_daily_limit, reason, requested_at: new Date().toISOString() })]);

        auditLog("LIMIT_INCREASE_REQUESTED", { user_id, requested_daily_limit, reason });

        sendSuccess(res, {
            message: "Solicitud enviada. Será revisada por el equipo de compliance.",
            status: "pending"
        });
        return;
    } catch (error) {
        log("error", "Limit increase request failed", { error: error.message });
        sendError(res, 500, "Error enviando solicitud");
        return;
    }
}

// ========== WITHDRAWAL WHITELIST ==========

// GET /api/wallet/whitelist - Get user whitelist
if (pathname === "/api/wallet/whitelist" && method === "GET") {

            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }
    const user_id = authUser.userId;

    try {
        let query = "SELECT id, user_id, address_type, address_label, bank_name, account_number, account_holder, phone_number, provider, wallet_address, network, is_verified, verification_code, verified_at, created_at FROM user_withdrawal_whitelist WHERE user_id = $1";
        const params = [user_id];

        if (address_type) {
            query += " AND address_type = $2";
            params.push(address_type);
        }

        query += " ORDER BY created_at DESC";

        const result = await dbPostgres.pool.query(query, params);

        sendSuccess(res, {
            addresses: result.rows.map(r => ({
                id: r.id,
                type: r.address_type,
                label: r.address_label,
                is_verified: r.is_verified,
                details: r.address_type === "bank" 
                    ? { bank_name: r.bank_name, account_number: r.account_number, account_holder: r.account_holder }
                    : r.address_type === "mobile"
                        ? { phone_number: r.phone_number, provider: r.provider }
                        : { wallet_address: r.wallet_address, network: r.network },
                created_at: r.created_at
            })),
            count: result.rows.length
        });
        return;
    } catch (error) {
        log("error", "Get whitelist failed", { error: error.message });
        sendError(res, 500, "Error obteniendo whitelist");
        return;
    }
}

// POST /api/wallet/whitelist - Add address to whitelist
if (pathname === "/api/wallet/whitelist" && method === "POST") {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }
    const user_id = authUser.userId;
    const { address_type, address_label, bank_name, account_number, account_holder, phone_number, provider, wallet_address, network } = body;

    if (!user_id || !address_type) {
        sendError(res, 400, "user_id y address_type requeridos");
        return;
    }

    // v3.99.0: Validate address_type against whitelist
    if (!["bank", "mobile", "crypto"].includes(address_type)) {
        sendError(res, 400, "Tipo de direccion invalido. Debe ser: bank, mobile, o crypto");
        return;
    }

    // Validate required fields based on type
    if (address_type === "bank" && (!bank_name || !account_number || !account_holder)) {
        sendError(res, 400, "Para cuenta bancaria: bank_name, account_number y account_holder son requeridos");
        return;
    }
    if (address_type === "mobile" && (!phone_number || !provider)) {
        sendError(res, 400, "Para mobile money: phone_number y provider son requeridos");
        return;
    }
    if (address_type === "crypto" && (!wallet_address || !network)) {
        sendError(res, 400, "Para crypto: wallet_address y network son requeridos");
        return;
    }

    try {
        const verificationCode = crypto.randomBytes(4).toString('hex').toUpperCase();

        const result = await dbPostgres.pool.query(`
            INSERT INTO user_withdrawal_whitelist 
            (user_id, address_type, address_label, bank_name, account_number, account_holder, 
             phone_number, provider, wallet_address, network, verification_code, is_verified)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, FALSE)
            RETURNING id
        `, [user_id, address_type, address_label, bank_name, account_number, account_holder,
            phone_number, provider, wallet_address, network, verificationCode]);

        auditLog("WHITELIST_ADDRESS_ADDED", { user_id, address_type, id: result.rows[0].id });

        sendSuccess(res, {
            message: "Dirección agregada. Debe verificarla antes de usarla.",
            id: result.rows[0].id,
            verification_required: true,
            verification_code: verificationCode // In production, send via email/SMS
        });
        return;
    } catch (error) {
        if (error.code === "23505") {
            sendError(res, 400, "Esta dirección ya está en tu whitelist");
            return;
        }
        log("error", "Add to whitelist failed", { error: error.message });
        sendError(res, 500, "Error agregando dirección");
        return;
    }
}

// POST /api/wallet/whitelist/:id/verify - Verify whitelist address
if (pathname.match(/^\/api\/wallet\/whitelist\/\d+\/verify$/) && method === "POST") {
    const addressId = pathname.split("/")[4];
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }
    const user_id = authUser.userId;
    const { verification_code } = body;

    if (!user_id || !verification_code) {
        sendError(res, 400, "user_id y verification_code requeridos");
        return;
    }

    try {
        const result = await dbPostgres.pool.query(`
            UPDATE user_withdrawal_whitelist 
            SET is_verified = TRUE, verified_at = NOW(), verification_code = NULL
            WHERE id = $1 AND user_id = $2 AND verification_code = $3 AND is_verified = FALSE
            RETURNING id, user_id, is_verified, verified_at
        `, [addressId, user_id, verification_code]);

        if (result.rows.length === 0) {
            sendError(res, 400, "Código de verificación inválido o dirección ya verificada");
            return;
        }

        auditLog("WHITELIST_ADDRESS_VERIFIED", { user_id, address_id: addressId });

        sendSuccess(res, {
            message: "Dirección verificada exitosamente",
            address: result.rows[0]
        });
        return;
    } catch (error) {
        log("error", "Verify whitelist failed", { error: error.message });
        sendError(res, 500, "Error verificando dirección");
        return;
    }
}

// DELETE /api/wallet/whitelist/:id - Remove from whitelist
if (pathname.match(/^\/api\/wallet\/whitelist\/\d+$/) && method === "DELETE") {
    const addressId = pathname.split("/").pop();
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }
    const user_id = authUser.userId;

    if (!user_id) {
        sendError(res, 401, "Autenticación requerida");
        return;
    }

    try {
        const result = await dbPostgres.pool.query(
            "DELETE FROM user_withdrawal_whitelist WHERE id = $1 AND user_id = $2 RETURNING address_label, address_type",
            [addressId, user_id]
        );

        if (result.rows.length === 0) {
            sendError(res, 404, "Dirección no encontrada");
            return;
        }

        auditLog("WHITELIST_ADDRESS_REMOVED", { user_id, address_id: addressId });

        sendSuccess(res, {
            message: "Dirección eliminada del whitelist",
            removed: result.rows[0]
        });
        return;
    } catch (error) {
        log("error", "Delete from whitelist failed", { error: error.message });
        sendError(res, 500, "Error eliminando dirección");
        return;
    }
}

// PAYOUT SYSTEM ENDPOINTS
// Sistema de Cobro de Tandas para Beneficiarios
// ============================================

// ========== USER PAYOUT METHODS ==========

// GET /api/users/payout-methods - List user's payout methods
if (pathname === '/api/users/payout-methods' && method === 'GET') {

            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }
    const user_id = authUser.userId;
    
    try {
        const result = await dbPostgres.pool.query(
            `SELECT id, user_id, method_type, bank_name, bank_account_number, bank_account_type, bank_account_holder, tigo_phone, tigo_name, crypto_address, crypto_network, is_default, is_verified, created_at 
             FROM user_payout_methods WHERE user_id = $1 
             ORDER BY is_default DESC, created_at DESC`,
            [user_id]
        );
        
        sendSuccess(res, {
            payout_methods: result.rows,
            count: result.rows.length
        });
    } catch (error) {
        log("error", 'Error fetching payout methods:', error);
        sendError(res, 500, 'Error al obtener métodos de pago');
    }
    return;
}

// POST /api/users/payout-methods - Add new payout method
if (pathname === '/api/users/payout-methods' && method === 'POST') {
    // SECURITY: Require JWT authentication (added 2025-12-14)
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticación requerida');
        return;
    }

    const {
        method_type,
        is_default,
        bank_name,
        bank_account_number,
        bank_account_type,
        bank_account_holder,
        tigo_phone,
        tigo_name,
        crypto_address,
        crypto_network
    } = body;
    const user_id = authUser.userId;
    if (!method_type) {
        sendError(res, 400, 'method_type es requerido');
        return;
    }
    
    if (!['bank_transfer', 'mobile_money', 'crypto'].includes(method_type)) {
        sendError(res, 400, 'method_type debe ser: bank_transfer, mobile_money, o crypto');
        return;
    }
    
    try {
        if (is_default) {
            await dbPostgres.pool.query(
                'UPDATE user_payout_methods SET is_default = false WHERE user_id = $1',
                [user_id]
            );
        }
        
        const result = await dbPostgres.pool.query(
            `INSERT INTO user_payout_methods (
                user_id, method_type, is_default,
                bank_name, bank_account_number, bank_account_type, bank_account_holder,
                tigo_phone, tigo_name, crypto_address, crypto_network
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
            RETURNING id, user_id, method_type, is_default, bank_name, bank_account_number, bank_account_type, bank_account_holder, tigo_phone, tigo_name, crypto_address, crypto_network, created_at`,
            [user_id, method_type, is_default || false,
             bank_name, bank_account_number, bank_account_type, bank_account_holder,
             tigo_phone, tigo_name, crypto_address, crypto_network]
        );
        
        log('info', 'Payout method added', { user_id, method_type });
        sendSuccess(res, { payout_method: result.rows[0], message: 'Método de cobro agregado' });
    } catch (error) {
        log("error", 'Error adding payout method:', error);
        sendError(res, 500, 'Error al agregar método de pago');
    }
    return;
}

// PUT /api/users/payout-methods/:id - Update payout method
if (pathname.match(/^\/api\/users\/payout-methods\/[^/]+$/) && (method === 'PUT' || method === 'PATCH') && !pathname.includes('/default')) {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }

    const methodId = pathname.split('/')[4];
    const { bank_name, bank_account_number, bank_account_type, bank_account_holder,
            tigo_phone, tigo_name, crypto_address, crypto_network } = body;
    
    try {
        const result = await dbPostgres.pool.query(
            `UPDATE user_payout_methods SET
                bank_name = COALESCE($1, bank_name),
                bank_account_number = COALESCE($2, bank_account_number),
                bank_account_type = COALESCE($3, bank_account_type),
                bank_account_holder = COALESCE($4, bank_account_holder),
                tigo_phone = COALESCE($5, tigo_phone),
                tigo_name = COALESCE($6, tigo_name),
                crypto_address = COALESCE($7, crypto_address),
                crypto_network = COALESCE($8, crypto_network),
                updated_at = NOW()
            WHERE id = $9 AND user_id = $10 RETURNING id, user_id, method_type, is_default, bank_name, bank_account_number, bank_account_type, bank_account_holder, tigo_phone, tigo_name, crypto_address, crypto_network, updated_at`,
            [bank_name, bank_account_number, bank_account_type, bank_account_holder,
             tigo_phone, tigo_name, crypto_address, crypto_network, methodId, authUser.userId]
        );
        
        if (result.rows.length === 0) {
            sendError(res, 404, 'Método de pago no encontrado');
            return;
        }
        sendSuccess(res, { payout_method: result.rows[0], message: 'Método actualizado' });
    } catch (error) {
        log("error", 'Error updating payout method:', error);
        sendError(res, 500, 'Error al actualizar método');
    }
    return;
}

// PUT /api/users/payout-methods/:id/default - Set as default
if (pathname.match(/^\/api\/users\/payout-methods\/[^/]+\/default$/) && (method === 'PUT' || method === 'PATCH')) {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }

    const methodId = pathname.split('/')[4];
    
    try {
        const methodResult = await dbPostgres.pool.query(
            'SELECT user_id FROM user_payout_methods WHERE id = $1 AND user_id = $2', [methodId, authUser.userId]
        );
        
        if (methodResult.rows.length === 0) {
            sendError(res, 404, 'Método no encontrado');
            return;
        }
        
        const user_id = authUser.userId;
        await dbPostgres.pool.query(
            'UPDATE user_payout_methods SET is_default = false WHERE user_id = $1', [user_id]
        );
        
        const result = await dbPostgres.pool.query(
            'UPDATE user_payout_methods SET is_default = true, updated_at = NOW() WHERE id = $1 AND user_id = $2 RETURNING id, user_id, method_type, is_default, updated_at',
            [methodId, authUser.userId]
        );
        
        sendSuccess(res, { payout_method: result.rows[0], message: 'Método predeterminado actualizado' });
    } catch (error) {
        log("error", 'Error setting default:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// DELETE /api/users/payout-methods/:id
if (pathname.match(/^\/api\/users\/payout-methods\/[^/]+$/) && method === 'DELETE') {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }

    const methodId = pathname.split('/')[4];
    
    try {
        const result = await dbPostgres.pool.query(
            'DELETE FROM user_payout_methods WHERE id = $1 AND user_id = $2 RETURNING id', [methodId, authUser.userId]
        );
        
        if (result.rows.length === 0) {
            sendError(res, 404, 'Método no encontrado');
            return;
        }
        sendSuccess(res, { message: 'Método eliminado' });
    } catch (error) {
        log("error", 'Error deleting:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// ========== PAYOUT REQUESTS ==========

// GET /api/groups/:id/payout/eligibility
if (pathname.match(/^\/api\/groups\/[^/]+\/payout\/eligibility$/) && method === 'GET') {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }

    const groupId = pathname.split('/')[3];
    const user_id = authUser.userId;
    
    try {
        const groupResult = await dbPostgres.pool.query(
            'SELECT g.group_id, g.name, g.contribution_amount, g.frequency, g.member_count, g.max_members, g.total_amount_collected, g.admin_id, g.status, g.created_at, g.location, g.description, g.image_url, g.category, g.meeting_schedule, g.updated_at, g.is_demo, g.start_date, g.grace_period, g.penalty_amount, g.current_cycle, g.lottery_executed, g.lottery_executed_at, g.lottery_scheduled_at, g.deleted_at, g.deleted_by, g.approval_settings, g.last_recruitment_notification_at, t.status as tanda_status FROM groups g LEFT JOIN (SELECT DISTINCT ON (group_id) group_id, status FROM tandas ORDER BY group_id, created_at DESC) t ON g.group_id = t.group_id WHERE g.group_id = $1', [groupId]
        );
        
        if (groupResult.rows.length === 0) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }
        
        const group = groupResult.rows[0];
        const currentCycle = group.current_cycle || 1;
        
        // ============================================
        // VALIDATION: Check tanda is active and lottery executed
        // Added 2025-12-31
        // ============================================
        const tandaCheck = await dbPostgres.pool.query(`
            SELECT status, lottery_executed_at FROM tandas 
            WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
        `, [groupId]);
        
        if (tandaCheck.rows.length === 0 || tandaCheck.rows[0].status === 'recruiting') {
            sendSuccess(res, {
                eligible: false,
                reason: 'La tanda aún no ha iniciado',
                is_beneficiary: false,
                cycle_complete: false
            });
            return;
        }
        
        if (!tandaCheck.rows[0].lottery_executed_at) {
            sendSuccess(res, {
                eligible: false,
                reason: 'La tómbola no ha sido ejecutada',
                is_beneficiary: false,
                cycle_complete: false
            });
            return;
        }
        
        // Check member and turn
        const memberResult = await dbPostgres.pool.query(
            'SELECT id, group_id, user_id, role, status, joined_at, left_at, invited_by, notes, created_at, updated_at, turn_position, is_anonymous, display_name, approved_by, approved_at, removed_by, removed_at, removal_reason, position, turn_locked, turn_locked_by, turn_locked_at, num_positions, rejected_by, rejected_at, rejection_reason, position_locks, last_notified_payment_status, last_payment_notification_at FROM group_members WHERE group_id = $1 AND user_id = $2',
            [groupId, user_id]
        );
        
        if (memberResult.rows.length === 0) {
            sendError(res, 403, 'No eres miembro de este grupo');
            return;
        }
        
        const member = memberResult.rows[0];
        const isBeneficiary = (member.turn_position === currentCycle) ||
                              (group.current_beneficiary_id === user_id);
        
        // Check cycle completion
        const contribResult = await dbPostgres.pool.query(
            `SELECT COUNT(*) as count, COALESCE(SUM(amount), 0) as total 
             FROM contributions 
             WHERE group_id = $1 AND cycle_number = $2 AND status IN ('completed', 'coordinator_approved', 'archived')`,
            [groupId, currentCycle]
        );
        
        const memberCountResult = await dbPostgres.pool.query(
            `SELECT COUNT(*) as count FROM group_members WHERE group_id = \$1 AND status = 'active'`, [groupId]
        );
        
        const contributionsCount = parseInt(contribResult.rows[0].count);
        const memberCount = parseInt(memberCountResult.rows[0].count);
        const cycleComplete = contributionsCount >= memberCount;
        
        // Check existing payout request
        const existingPayout = await dbPostgres.pool.query(
            'SELECT id, group_id, user_id, cycle_number, gross_amount, status, requested_at FROM payout_requests WHERE group_id = $1 AND cycle_number = $2',
            [groupId, currentCycle]
        );
        
        // Check payout method
        const payoutMethodResult = await dbPostgres.pool.query(
            'SELECT id, user_id, method_type, bank_name, bank_account_number, bank_account_type, bank_account_holder, tigo_phone, tigo_name, crypto_address, crypto_network, is_default, is_verified, created_at FROM user_payout_methods WHERE user_id = $1 ORDER BY is_default DESC LIMIT 1',
            [user_id]
        );
        
        // Calculate amounts
        const grossAmount = parseFloat(contribResult.rows[0].total) || 0;
        const coordinatorFee = grossAmount * 0.03;
        const platformFee = coordinatorFee * 0.10;
        const netAmount = grossAmount - coordinatorFee - platformFee;
        
        sendSuccess(res, {
            eligible: isBeneficiary && cycleComplete && existingPayout.rows.length === 0,
            is_beneficiary: isBeneficiary,
            cycle_complete: cycleComplete,
            already_requested: existingPayout.rows.length > 0,
            has_payout_method: payoutMethodResult.rows.length > 0,
            default_payout_method: payoutMethodResult.rows[0] || null,
            current_cycle: currentCycle,
            contributions_received: contributionsCount,
            members_count: memberCount,
            amounts: { gross: grossAmount, coordinator_fee: coordinatorFee, platform_fee: platformFee, net: netAmount },
            existing_request: existingPayout.rows[0] || null
        });
    } catch (error) {
        log("error", "Error checking eligibility: " + error.message);
        sendError(res, 500, 'Error al verificar elegibilidad');
    }
    return;
}

// POST /api/groups/:id/payout/request
if (pathname.match(/^\/api\/groups\/[^/]+\/payout\/request$/) && method === 'POST') {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }

    const groupId = pathname.split('/')[3];
    const { payout_method_id } = body;
    const user_id = authUser.userId;
    
    if (!payout_method_id) {
        sendError(res, 400, 'payout_method_id es requerido');
        return;
    }
    
    try {
        const groupResult = await dbPostgres.pool.query('SELECT g.group_id, g.name, g.contribution_amount, g.frequency, g.member_count, g.max_members, g.total_amount_collected, g.admin_id, g.status, g.created_at, g.location, g.description, g.image_url, g.category, g.meeting_schedule, g.updated_at, g.is_demo, g.start_date, g.grace_period, g.penalty_amount, g.current_cycle, g.lottery_executed, g.lottery_executed_at, g.lottery_scheduled_at, g.deleted_at, g.deleted_by, g.approval_settings, g.last_recruitment_notification_at, g.commission_rate, t.status as tanda_status FROM groups g LEFT JOIN (SELECT DISTINCT ON (group_id) group_id, status FROM tandas ORDER BY group_id, created_at DESC) t ON g.group_id = t.group_id WHERE g.group_id = $1', [groupId]);
        if (groupResult.rows.length === 0) {
            sendError(res, 404, 'Grupo no encontrado');
            return;
        }

        const group = groupResult.rows[0];
        const currentCycle = group.current_cycle || 1;
        
        // ============================================
        // VALIDATION: Check tanda is active and lottery executed
        // Added 2025-12-31
        // ============================================
        const tandaCheck = await dbPostgres.pool.query(`
            SELECT status, lottery_executed_at FROM tandas 
            WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
        `, [groupId]);
        
        if (tandaCheck.rows.length === 0 || tandaCheck.rows[0].status === 'recruiting') {
            sendError(res, 400, 'La tanda aún no ha iniciado. No se pueden solicitar pagos.');
            return;
        }
        
        if (!tandaCheck.rows[0].lottery_executed_at) {
            sendError(res, 400, 'La tómbola no ha sido ejecutada. Las posiciones deben ser asignadas primero.');
            return;
        }
        
        // Verify beneficiary
        const memberResult = await dbPostgres.pool.query(
            'SELECT turn_position FROM group_members WHERE group_id = $1 AND user_id = $2',
            [groupId, user_id]
        );
        
        if (memberResult.rows.length === 0) {
            sendError(res, 403, 'No eres miembro');
            return;
        }
        
        const isBeneficiary = memberResult.rows[0].turn_position === currentCycle ||
                              group.current_beneficiary_id === user_id;
        
        if (!isBeneficiary) {
            sendError(res, 403, 'No eres el beneficiario de este ciclo');
            return;
        }
        
        await dbPostgres.pool.query("BEGIN");
        // Check completion
        const contribResult = await dbPostgres.pool.query(
            `SELECT COUNT(*) as count, COALESCE(SUM(amount), 0) as total 
             FROM contributions WHERE group_id = $1 AND cycle_number = $2 AND status IN ('completed', 'coordinator_approved', 'archived')`,
            [groupId, currentCycle]
        );
        
        const memberCountResult = await dbPostgres.pool.query(
            `SELECT COUNT(*) as count FROM group_members WHERE group_id = \$1 AND status = 'active'`, [groupId]
        );
        
        if (parseInt(contribResult.rows[0].count) < parseInt(memberCountResult.rows[0].count)) {
            sendError(res, 400, 'El ciclo aún no está completo');
            return;
        }
        
        // Check existing
        const existingResult = await dbPostgres.pool.query(
            'SELECT id FROM payout_requests WHERE group_id = $1 AND cycle_number = $2 FOR UPDATE',
            [groupId, currentCycle]
        );
        
        if (existingResult.rows.length > 0) {
            sendError(res, 400, 'Ya existe una solicitud para este ciclo');
            return;
        }
        
        // Get payout method
        const methodResult = await dbPostgres.pool.query(
            'SELECT id, user_id, method_type, bank_name, bank_account_number, bank_account_type, bank_account_holder, tigo_phone, tigo_name, crypto_address, crypto_network, is_default, is_verified, created_at FROM user_payout_methods WHERE id = $1 AND user_id = $2',
            [payout_method_id, user_id]
        );
        
        if (methodResult.rows.length === 0) {
            sendError(res, 404, 'Método de pago no encontrado');
            return;
        }
        
        const payoutMethod = methodResult.rows[0];
        const grossAmount = parseFloat(contribResult.rows[0].total) || 0;

        // v4.10.4: Per-group commission rate (fix hardcoded 3% bug)
        // Check if beneficiary accepted commission (democratic per-member)
        const beneficiaryCommResult = await dbPostgres.pool.query(
            'SELECT commission_accepted FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = \'active\'',
            [groupId, user_id]
        );
        const beneficiaryAcceptedCommission = beneficiaryCommResult.rows.length > 0 && beneficiaryCommResult.rows[0].commission_accepted === true;

        let payoutCommissionRate;
        if (!beneficiaryAcceptedCommission) {
            // Member did NOT accept commission — no commission deducted
            payoutCommissionRate = 0;
        } else if (group.commission_rate !== null && group.commission_rate !== undefined) {
            payoutCommissionRate = parseFloat(group.commission_rate) / 100;
        } else {
            // Platform default tiered
            if (grossAmount >= 100000) payoutCommissionRate = 0.01;
            else if (grossAmount >= 50000) payoutCommissionRate = 0.02;
            else payoutCommissionRate = 0.03;
        }

        const coordinatorFee = grossAmount * payoutCommissionRate;
        const platformFee = coordinatorFee * 0.10;
        const netAmount = grossAmount - coordinatorFee - platformFee;
        
        // Auto-approve since all checks passed
        const status = 'auto_approved';
        
        const result = await dbPostgres.pool.query(
            `INSERT INTO payout_requests (
                group_id, user_id, cycle_number, gross_amount, platform_fee, coordinator_fee, net_amount,
                payout_method_id, payout_method_snapshot, status, approved_at
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
            RETURNING id, user_id, group_id, cycle_number, gross_amount, platform_fee, coordinator_fee, net_amount, payout_method_id, status, approved_at, created_at`,
            [groupId, user_id, currentCycle, grossAmount, platformFee, coordinatorFee, netAmount,
             payout_method_id, JSON.stringify(payoutMethod), status]
        );
        
        await dbPostgres.pool.query("COMMIT");
        
        // v4.1.0: Fixed undefined variables (autoApproved, payoutRequest)
        const payoutRow = result.rows[0];
        const isAutoApproved = (status === 'auto_approved');
        try {
            await notificationsUtils.createNotification(
                dbPostgres.pool,
                user_id,
                isAutoApproved ? 'payout_approved' : 'payout_requested',
                isAutoApproved ? 'Tu solicitud de cobro fue aprobada' : 'Solicitud de cobro recibida',
                isAutoApproved
                    ? 'Tu solicitud de L. ' + netAmount.toFixed(2) + ' fue aprobada. Pronto recibiras tu pago.'
                    : 'Tu solicitud de cobro de L. ' + netAmount.toFixed(2) + ' esta en revision.',
                { payout_request_id: payoutRow.id, amount: netAmount, group_id: groupId }
            );
        } catch (notifError) {
            log("error", 'Error sending payout notification:', notifError);
        }

        log('info', 'Payout request created', { group_id: groupId, user_id, cycle: currentCycle, amount: netAmount });
        
        sendSuccess(res, {
            payout_request: result.rows[0],
            message: 'Solicitud aprobada automáticamente',
            auto_approved: true
        });
    } catch (error) {
        await dbPostgres.pool.query("ROLLBACK").catch(function(){});
        log("error", 'Error creating payout request:', error);
        sendError(res, 500, 'Error al crear solicitud');
    }
    return;
}

// GET /api/groups/:id/payout/status
if (pathname.match(/^\/api\/groups\/[^/]+\/payout\/status$/) && method === 'GET') {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, "Autenticacion requerida");
        return;
    }

    const groupId = pathname.split('/')[3];
    const user_id = authUser.userId;
    
    try {
        const query = user_id 
            ? 'SELECT id, group_id, user_id, cycle_number, amount, status, requested_at, completed_at FROM payout_requests WHERE group_id = $1 AND user_id = $2 ORDER BY requested_at DESC LIMIT 100'
            : 'SELECT id, group_id, user_id, cycle_number, amount, status, requested_at, completed_at FROM payout_requests WHERE group_id = $1 ORDER BY requested_at DESC LIMIT 100';
        const params = user_id ? [groupId, user_id] : [groupId];
        
        const result = await dbPostgres.pool.query(query, params);
        sendSuccess(res, { payout_requests: result.rows, count: result.rows.length });
    } catch (error) {
        log("error", 'Error fetching status:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// POST /api/groups/:id/payout/confirm
if (pathname.match(/^\/api\/groups\/[^/]+\/payout\/confirm$/) && method === 'POST') {
    const authUser = getAuthenticatedUser(req, query);
    if (!authUser) {
        sendError(res, 401, 'Autenticacion requerida');
        return;
    }

    const groupId = pathname.split('/')[3];
    const { payout_request_id, confirmation_url } = body;
    const user_id = authUser.userId;
    
    if (!payout_request_id) {
        sendError(res, 400, 'payout_request_id es requerido');
        return;
    }
    
    try {
        const payoutResult = await dbPostgres.pool.query(
            'SELECT id, group_id, user_id, cycle_number, amount, status, requested_at, completed_at FROM payout_requests WHERE id = $1 AND user_id = $2 AND group_id = $3',
            [payout_request_id, user_id, groupId]
        );
        
        if (payoutResult.rows.length === 0) {
            sendError(res, 404, 'Solicitud no encontrada');
            return;
        }
        
        if (payoutResult.rows[0].status !== 'awaiting_confirmation') {
            sendError(res, 400, 'Esta solicitud no está esperando confirmación');
            return;
        }
        
        const result = await dbPostgres.pool.query(
            `UPDATE payout_requests SET 
                status = 'completed', user_confirmation_url = $1, confirmed_at = NOW()
             WHERE id = $2 RETURNING id, user_id, status, confirmed_at`,
            [confirmation_url || null, payout_request_id]
        );
        
        // Cycle advance removed — handled by checkCycleAdvanceWithMora() in record-for-member/record-bulk (v4.11.0)
        log('info', 'Payout confirmed', { payout_request_id, group_id: groupId });
        
        // Notify completion
        try {
            const confirmedPayout = result.rows[0];
            await notificationsUtils.createNotification(
                dbPostgres.pool,
                confirmedPayout.user_id,
                'payout_confirmed',
                '¡Pago completado!',
                'Tu cobro de L. ' + parseFloat(confirmedPayout.net_amount).toFixed(2) + ' ha sido completado exitosamente.',
                { payout_request_id: confirmedPayout.id }
            );
        } catch (notifError) {
            log("error", 'Error sending confirmation notification:', notifError);
        }

        sendSuccess(res, { payout_request: result.rows[0], message: 'Recepción confirmada. Ciclo cerrado.' });
    } catch (error) {
        log("error", 'Error confirming:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// ========== ADMIN ENDPOINTS ==========


        // ============================================
        // GET /api/admin/groups/deleted - List soft-deleted groups
        // ============================================
        if (pathname === '/api/admin/groups/deleted' && (method === 'GET' || method === 'HEAD')) {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticación requerida");
                return;
            }
            
            // Check super-admin
            const SUPER_ADMIN_EMAIL = process.env.SUPER_ADMIN_EMAIL;
            if (authUser.email !== SUPER_ADMIN_EMAIL) {
                sendError(res, 403, "Solo el super-administrador puede ver grupos eliminados");
                return;
            }
            
            try {
                const result = await dbPostgres.pool.query(`
                    SELECT 
                        g.group_id, g.name, g.admin_id, g.status, g.deleted_at, g.deleted_by,
                        g.contribution_amount, g.frequency,
                        (SELECT COUNT(*) FROM contributions WHERE group_id = g.group_id) as contribution_count,
                        (SELECT COUNT(*) FROM group_members WHERE group_id = g.group_id) as member_count
                    FROM groups g
                    WHERE g.status = 'deleted'
                    ORDER BY g.deleted_at DESC
                `);
                
                sendSuccess(res, { groups: result.rows, total: result.rows.length });
            } catch (error) {
                log('error', 'Error loading deleted groups', { error: error.message });
                log("error", "Error al cargar grupos eliminados", { error: error.message }); sendError(res, 500, "Error interno del servidor");
            }
            return;
        }

        // ============================================
        // POST /api/admin/groups/:groupId/restore - Restore soft-deleted group
        // ============================================
        if (pathname.match(/^\/api\/admin\/groups\/[^\/]+\/restore$/) && method === 'POST') {
            const groupId = pathname.split('/')[4];
            
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticación requerida");
                return;
            }
            
            // Check super-admin
            const SUPER_ADMIN_EMAIL = process.env.SUPER_ADMIN_EMAIL;
            if (authUser.email !== SUPER_ADMIN_EMAIL) {
                sendError(res, 403, "Solo el super-administrador puede restaurar grupos");
                return;
            }
            
            try {
                // Check if group exists and is deleted
                const groupResult = await dbPostgres.pool.query(
                    "SELECT group_id, name, contribution_amount, frequency, member_count, max_members, total_amount_collected, admin_id, status, created_at, location, description, image_url, category, meeting_schedule, updated_at, is_demo, start_date, grace_period, penalty_amount, current_cycle, lottery_executed, lottery_executed_at, lottery_scheduled_at, deleted_at, deleted_by, approval_settings, last_recruitment_notification_at FROM groups WHERE group_id = $1",
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }
                
                const group = groupResult.rows[0];
                
                if (group.status !== 'deleted') {
                    sendError(res, 400, "El grupo no está eliminado");
                    return;
                }
                
                // Restore the group
                await dbPostgres.pool.query(
                    "UPDATE groups SET status = 'active', deleted_at = NULL, deleted_by = NULL WHERE group_id = $1",
                    [groupId]
                );
                
                // Audit log
                await dbPostgres.pool.query(
                    `INSERT INTO audit_logs (user_id, user_email, action, resource, resource_id, details, ip_address, status)
                     VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
                    [authUser.userId, authUser.email, 'GROUP_RESTORE', 'group', groupId,
                     JSON.stringify({ group_name: group.name, restored_by: authUser.email }),
                     req.headers['x-forwarded-for'] || req.socket?.remoteAddress, 'success']
                );
                
                log('info', 'Group restored', { groupId, by: authUser.email });
                
                sendSuccess(res, {
                    message: "Grupo restaurado exitosamente",
                    group_id: groupId,
                    group_name: group.name
                });
            } catch (error) {
                log('error', 'Error restoring group', { groupId, error: error.message });
                log("error", "Error al restaurar grupo", { error: error.message }); sendError(res, 500, "Error interno del servidor");
            }
            return;
        }
// GET /api/admin/payouts/pending
if (pathname === '/api/admin/payouts/pending' && method === 'GET') {

            // SECURITY: Require admin JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            if (authUser.role !== 'admin') { sendError(res, 403, 'Solo administradores'); return; }
    try {
        const result = await dbPostgres.pool.query(
            `SELECT pr.id, pr.group_id, pr.user_id, pr.cycle_number, pr.gross_amount, pr.platform_fee, pr.coordinator_fee, pr.net_amount, pr.payout_method_id, pr.status, pr.admin_proof_url, pr.user_confirmation_url, pr.requested_at, pr.approved_at, pr.approved_by, pr.processed_at, pr.processed_by, pr.confirmed_at, pr.rejection_reason, pr.notes, u.name as user_name, u.email as user_email, u.phone as user_phone,
                    g.name as group_name
             FROM payout_requests pr
             LEFT JOIN users u ON pr.user_id = u.user_id
             LEFT JOIN groups g ON pr.group_id = g.group_id
             WHERE pr.status IN ('pending', 'auto_approved', 'needs_review', 'processing')
             ORDER BY pr.requested_at ASC`
        );
        
        sendSuccess(res, { payouts: result.rows, count: result.rows.length });
    } catch (error) {
        log("error", 'Error fetching pending payouts:', error);
        sendError(res, 500, 'Error al obtener pagos pendientes');
    }
    return;
}

// POST /api/admin/payouts/:id/approve
if (pathname.match(/^\/api\/admin\/payouts\/[^/]+\/approve$/) && method === 'POST') {
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    if (authUser.role !== 'admin') {
        sendError(res, 403, 'Solo administradores pueden aprobar pagos');
        return;
    }

    const payoutId = pathname.split('/')[4];
    const admin_id = authUser.userId;
    
    try {
        const result = await dbPostgres.pool.query(
            `UPDATE payout_requests SET status = 'auto_approved', approved_at = NOW(), approved_by = $1
             WHERE id = $2 AND status IN ('pending', 'needs_review') RETURNING id, user_id, group_id, cycle_number, gross_amount, platform_fee, coordinator_fee, net_amount, payout_method_id, status, approved_at, approved_by, created_at`,
            [admin_id, payoutId]
        );
        
        if (result.rows.length === 0) {
            sendError(res, 404, 'Solicitud no encontrada o ya procesada');
            return;
        }
        
        // Notify user of approval
        try {
            const approvedPayout = result.rows[0];
            await notificationsUtils.createNotification(
                dbPostgres.pool,
                approvedPayout.user_id,
                'payout_approved',
                '¡Tu solicitud de cobro fue aprobada!',
                'Tu solicitud de L. ' + parseFloat(approvedPayout.net_amount).toFixed(2) + ' fue aprobada. El pago será procesado pronto.',
                { payout_request_id: approvedPayout.id }
            );
        } catch (notifError) {
            log("error", 'Error sending approval notification:', notifError);
        }

        sendSuccess(res, { payout: result.rows[0], message: 'Solicitud aprobada' });
    } catch (error) {
        log("error", 'Error approving:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// OCR Verification for Outgoing Payouts
// This code should replace the existing process endpoint

// POST /api/admin/payouts/:id/process (with OCR verification)
if (pathname.match(/^\/api\/admin\/payouts\/[^/]+\/process$/) && method === 'POST') {
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    if (authUser.role !== 'admin') {
        sendError(res, 403, 'Solo administradores pueden procesar pagos');
        return;
    }

    const payoutId = pathname.split('/')[4];

    try {
        // Handle multipart form data for file upload
        let formData = body;
        let imageBuffer = null;
        let imageBase64 = null;

        // Check if it's base64 image in body
        if (body.proof_image) {
            const base64Data = body.proof_image.replace(/^data:image\/\w+;base64,/, '');
            imageBuffer = Buffer.from(base64Data, 'base64');
            imageBase64 = body.proof_image;
        } else if (body.proof_url && body.proof_url.startsWith('data:image')) {
            const base64Data = body.proof_url.replace(/^data:image\/\w+;base64,/, '');
            imageBuffer = Buffer.from(base64Data, 'base64');
            imageBase64 = body.proof_url;
        }

        const admin_id = authUser.userId;
        const notes = (body.notes || '').trim().slice(0, 1000);

        if (!imageBuffer && !body.proof_url) {
            sendError(res, 400, 'Comprobante de transferencia es requerido');
            return;
        }

        // Get payout request with method snapshot
        const payoutResult = await dbPostgres.pool.query(
            `SELECT pr.id, pr.group_id, pr.user_id, pr.cycle_number, pr.gross_amount, pr.platform_fee, pr.coordinator_fee, pr.net_amount, pr.payout_method_id, pr.status, pr.admin_proof_url, pr.user_confirmation_url, pr.requested_at, pr.approved_at, pr.approved_by, pr.processed_at, pr.processed_by, pr.confirmed_at, pr.rejection_reason, pr.notes, u.name as user_name
             FROM payout_requests pr
             LEFT JOIN users u ON pr.user_id = u.user_id
             WHERE pr.id = $1 AND pr.status IN ('auto_approved', 'approved')`,
            [payoutId]
        );

        if (payoutResult.rows.length === 0) {
            sendError(res, 404, 'Solicitud no encontrada o no lista para procesar');
            return;
        }

        const payout = payoutResult.rows[0];
        const methodSnapshot = payout.payout_method_snapshot || {};

        // Save proof image
        let proofUrl = body.proof_url;
        if (imageBuffer) {
            const proofFilename = `payout_proof_${payoutId}_${Date.now()}.jpg`;
            const proofPath = path.join('/var/www/uploads/payout_proofs', proofFilename);

            // Ensure directory exists
            const proofDir = path.dirname(proofPath);
            if (!fs.existsSync(proofDir)) {
                fs.mkdirSync(proofDir, { recursive: true });
            }

            fs.writeFileSync(proofPath, imageBuffer);
            proofUrl = `/uploads/payout_proofs/${proofFilename}`;
        }

        // ========== OCR VERIFICATION OF OUTGOING PAYMENT ==========
        let ocrVerification = {
            performed: false,
            destination_match: false,
            amount_match: false,
            name_match: false,
            confidence: 0,
            matches: [],
            mismatches: [],
            warning: null
        };

        if (imageBuffer) {
            try {
                log('info', 'Starting OCR verification of payout proof', { payout_id: payoutId });

                // Perform OCR
                const { data: { text } } = await Tesseract.recognize(imageBuffer, 'spa', {
                    logger: m => {} // Suppress logs
                });

                const extractedText = text.toUpperCase();
                log('info', 'OCR extracted text from payout proof', {
                    payout_id: payoutId,
                    text_length: extractedText.length
                });

                ocrVerification.performed = true;
                const methodType = methodSnapshot.method_type;
                const expectedAmount = parseFloat(payout.net_amount);
                const userName = (payout.user_name || '').toUpperCase();

                // Verify based on payment method type
                if (methodType === 'bank_transfer') {
                    // Check account number
                    const accountNumber = (methodSnapshot.bank_account_number || '').replace(/[^0-9]/g, '');
                    if (accountNumber) {
                        // Check for last 4 digits (often shown in receipts)
                        const last4 = accountNumber.slice(-4);
                        const last6 = accountNumber.slice(-6);
                        if (extractedText.includes(accountNumber) ||
                            extractedText.includes(last6) ||
                            extractedText.replace(/[^0-9]/g, '').includes(accountNumber)) {
                            ocrVerification.destination_match = true;
                            ocrVerification.matches.push('Cuenta: ****' + last4);
                        } else {
                            ocrVerification.mismatches.push('Cuenta no encontrada');
                        }
                    }

                    // Check holder name
                    const holderName = (methodSnapshot.bank_account_holder || '').toUpperCase();
                    if (holderName) {
                        const nameParts = holderName.split(' ').filter(p => p.length > 2);
                        const matchedParts = nameParts.filter(part => extractedText.includes(part));
                        if (matchedParts.length >= 2 || (matchedParts.length === 1 && nameParts.length === 1)) {
                            ocrVerification.name_match = true;
                            ocrVerification.matches.push('Titular: ' + holderName);
                        }
                    }

                } else if (methodType === 'mobile_money') {
                    // Check Tigo phone number
                    const phone = (methodSnapshot.tigo_phone || '').replace(/[^0-9]/g, '');
                    if (phone) {
                        const phoneLast8 = phone.slice(-8);
                        const phoneLast4 = phone.slice(-4);
                        if (extractedText.replace(/[^0-9]/g, '').includes(phoneLast8) ||
                            extractedText.replace(/[^0-9]/g, '').includes(phone)) {
                            ocrVerification.destination_match = true;
                            ocrVerification.matches.push('Tigo: ****' + phoneLast4);
                        } else {
                            ocrVerification.mismatches.push('Telefono Tigo no encontrado');
                        }
                    }

                    // Check name
                    const tigoName = (methodSnapshot.tigo_name || '').toUpperCase();
                    if (tigoName) {
                        const nameParts = tigoName.split(' ').filter(p => p.length > 2);
                        const matchedParts = nameParts.filter(part => extractedText.includes(part));
                        if (matchedParts.length >= 1) {
                            ocrVerification.name_match = true;
                            ocrVerification.matches.push('Nombre: ' + tigoName);
                        }
                    }

                } else if (methodType === 'crypto') {
                    // Check wallet address (partial match is fine for crypto)
                    const address = (methodSnapshot.crypto_address || '').toUpperCase();
                    if (address) {
                        const addressStart = address.slice(0, 10);
                        const addressEnd = address.slice(-8);
                        if (extractedText.includes(addressStart) || extractedText.includes(addressEnd)) {
                            ocrVerification.destination_match = true;
                            ocrVerification.name_match = true; // Crypto doesn't have names
                            ocrVerification.matches.push('Direccion: ' + address.slice(0,6) + '...' + address.slice(-4));
                        } else {
                            ocrVerification.mismatches.push('Direccion crypto no encontrada');
                        }
                    }
                }

                // Check amount in the receipt
                const amountRegex = /L\.?\s*([0-9,]+\.?[0-9]*)|([0-9,]+\.?[0-9]*)\s*(?:LEMPIRAS?|HNL|L\.?)/gi;
                let amountMatch;
                while ((amountMatch = amountRegex.exec(extractedText)) !== null) {
                    const foundAmount = parseFloat((amountMatch[1] || amountMatch[2]).replace(/,/g, ''));
                    if (!isNaN(foundAmount)) {
                        const tolerance = expectedAmount * 0.05; // 5% tolerance
                        if (Math.abs(foundAmount - expectedAmount) <= tolerance) {
                            ocrVerification.amount_match = true;
                            ocrVerification.matches.push('Monto: L. ' + foundAmount.toFixed(2));
                            break;
                        }
                    }
                }

                if (!ocrVerification.amount_match) {
                    ocrVerification.mismatches.push('Monto esperado L. ' + expectedAmount.toFixed(2) + ' no encontrado');
                }

                // Calculate confidence
                let matchCount = 0;
                if (ocrVerification.destination_match) matchCount++;
                if (ocrVerification.amount_match) matchCount++;
                if (ocrVerification.name_match) matchCount++;
                ocrVerification.confidence = matchCount / 3;

                // Set warning if verification failed
                if (ocrVerification.confidence < 0.67) {
                    ocrVerification.warning = 'El comprobante no coincide completamente con los datos del beneficiario. Verificar manualmente.';
                    log('warn', 'Payout proof OCR verification incomplete', {
                        payout_id: payoutId,
                        confidence: ocrVerification.confidence,
                        matches: ocrVerification.matches,
                        mismatches: ocrVerification.mismatches
                    });
                } else {
                    log('info', 'Payout proof OCR verification passed', {
                        payout_id: payoutId,
                        confidence: ocrVerification.confidence,
                        matches: ocrVerification.matches
                    });
                }

            } catch (ocrError) {
                log('error', 'OCR verification of payout proof failed', {
                    payout_id: payoutId,
                    error: ocrError.message
                });
                ocrVerification.warning = 'OCR no pudo procesar la imagen. Verificar manualmente.';
            }
        }
        // ========== END OCR VERIFICATION ==========

        // Update payout request with proof and OCR results
        const updateResult = await dbPostgres.pool.query(
            `UPDATE payout_requests SET
                status = 'awaiting_confirmation',
                admin_proof_url = $1,
                processed_at = NOW(),
                processed_by = $2,
                notes = COALESCE(notes, '') || $3
             WHERE id = $4 RETURNING id, user_id, group_id, cycle_number, gross_amount, net_amount, payout_method_id, status, admin_proof_url, processed_at, processed_by, notes, created_at`,
            [
                proofUrl,
                admin_id,
                notes + (ocrVerification.warning ? '\n[OCR] ' + ocrVerification.warning : ''),
                payoutId
            ]
        );

        log('info', 'Payout processed', {
            payout_id: payoutId,
            admin_id,
            ocr_confidence: ocrVerification.confidence
        });

        
        // Notify user that payment was sent
        try {
            await notificationsUtils.createNotification(
                dbPostgres.pool,
                payout.user_id,
                'payout_processed',
                '¡Tu pago ha sido enviado!',
                'Hemos enviado L. ' + parseFloat(payout.net_amount).toFixed(2) + ' a tu cuenta. Por favor confirma cuando lo recibas.',
                { payout_request_id: payoutId, proof_url: proofUrl }
            );

            // Also send email notification
            const userResult = await dbPostgres.pool.query('SELECT email, name FROM users WHERE user_id = $1', [payout.user_id]);
            if (userResult.rows.length > 0 && userResult.rows[0].email) {
                const userEmail = userResult.rows[0].email;
                const userName = userResult.rows[0].name || 'Usuario';
                await sendEmail(userEmail, '¡Tu pago de La Tanda ha sido enviado!',
                    '<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">' +
                    '<h2 style="color: #16a34a;">¡Hola ' + userName + '!</h2>' +
                    '<p>Te informamos que hemos procesado tu pago de <strong>L. ' + parseFloat(payout.net_amount).toFixed(2) + '</strong>.</p>' +
                    '<p>Por favor ingresa a tu cuenta de La Tanda para confirmar que recibiste el pago.</p>' +
                    '<a href="https://latanda.online" style="display: inline-block; background: #16a34a; color: white; padding: 12px 24px; border-radius: 8px; text-decoration: none; margin-top: 16px;">Confirmar Recepción</a>' +
                    '<p style="color: #6b7280; margin-top: 24px; font-size: 0.9rem;">Si tienes algún problema, contáctanos.</p>' +
                    '</div>', 'pagos'
                );
            }
        } catch (notifError) {
            log("error", 'Error sending processed notification:', notifError);
        }

        sendSuccess(res, {
            payout: updateResult.rows[0],
            message: 'Pago procesado. Esperando confirmación del usuario.',
            ocr_verification: ocrVerification
        });

    } catch (error) {
        log("error", 'Error processing payout:', error);
        sendError(res, 500, 'Error procesando el desembolso');
    }
    return;
}


// POST /api/admin/payouts/:id/reject
if (pathname.match(/^\/api\/admin\/payouts\/[^/]+\/reject$/) && method === 'POST') {
    const authUser = requireAuth(req, res);
    if (!authUser) return;
    if (authUser.role !== 'admin') {
        sendError(res, 403, 'Solo administradores pueden rechazar pagos');
        return;
    }

    const payoutId = pathname.split('/')[4];
    const { rejection_reason } = body;
    
    if (!rejection_reason) {
        sendError(res, 400, 'Razón de rechazo es requerida');
        return;
    }
    
    try {
        const result = await dbPostgres.pool.query(
            `UPDATE payout_requests SET status = 'rejected', rejection_reason = $1,
             approved_by = $2, approved_at = NOW()
             WHERE id = $3 AND status NOT IN ('completed', 'rejected') RETURNING id, user_id, group_id, cycle_number, gross_amount, net_amount, status, rejection_reason, approved_by, approved_at, created_at`,
            [rejection_reason, authUser.userId, payoutId]
        );
        
        if (result.rows.length === 0) {
            sendError(res, 404, 'Solicitud no encontrada o ya finalizada');
            return;
        }
        
        // Notify user of rejection
        try {
            const rejectedPayout = result.rows[0];
            await notificationsUtils.createNotification(
                dbPostgres.pool,
                rejectedPayout.user_id,
                'payout_rejected',
                'Solicitud de cobro rechazada',
                'Tu solicitud fue rechazada. Razón: ' + rejection_reason,
                { payout_request_id: rejectedPayout.id, reason: rejection_reason }
            );
        } catch (notifError) {
            log("error", 'Error sending rejection notification:', notifError);
        }

        sendSuccess(res, { payout: result.rows[0], message: 'Solicitud rechazada' });
    } catch (error) {
        log("error", 'Error rejecting:', error);
        sendError(res, 500, 'Error');
    }
    return;
}

// GET /api/admin/payouts/history
if (pathname === '/api/admin/payouts/history' && method === 'GET') {

            // SECURITY: Require admin JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            if (authUser.role !== 'admin') { sendError(res, 403, 'Solo administradores'); return; }
    const queryParams = parseUrl(req.url).query;
    const status = queryParams.status;
    const limit = parseInt(queryParams.limit) || 50;
    
    try {
        let query = `SELECT pr.id, pr.group_id, pr.user_id, pr.cycle_number, pr.gross_amount, pr.platform_fee, pr.coordinator_fee, pr.net_amount, pr.payout_method_id, pr.status, pr.admin_proof_url, pr.user_confirmation_url, pr.requested_at, pr.approved_at, pr.approved_by, pr.processed_at, pr.processed_by, pr.confirmed_at, pr.rejection_reason, pr.notes, u.name as user_name, u.email as user_email, g.name as group_name
                     FROM payout_requests pr
                     LEFT JOIN users u ON pr.user_id = u.user_id
                     LEFT JOIN groups g ON pr.group_id = g.group_id`;
        const params = [];
        
        if (status) {
            query += ' WHERE pr.status = $1';
            params.push(status);
        }
        query += ' ORDER BY pr.requested_at DESC LIMIT $' + (params.length + 1);
        params.push(limit);
        
        const result = await dbPostgres.pool.query(query, params);
        sendSuccess(res, { payouts: result.rows, count: result.rows.length });
    } catch (error) {
        log("error", 'Error fetching history:', error);
        sendError(res, 500, 'Error');
    }
    return;
}


                // Create new contribution/payment (PostgreSQL)
        if (pathname === '/api/contributions' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            // SECURITY FIX: Always use authenticated user (2025-12-31)
            const user_id = authUser.userId;

            const {
                group_id,
                amount,
                payment_method,
                status = 'pending',
                transaction_id,
                confirmation_code,
                notes,
                due_date,
                cycle_number = 1
            } = body;

            log('info', 'Creating contribution', { user_id, group_id, amount, payment_method });

            // Validation
            if (!group_id || !amount || !payment_method) {
                sendError(res, 400, 'Faltan campos requeridos: group_id, amount, payment_method');
                return;
            }

            if (amount <= 0) {
                sendError(res, 400, 'El monto debe ser mayor a 0');
                return;
            }

            const validMethods = ['cash', 'bank_transfer', 'crypto', 'mobile_money', 'card'];
            if (!validMethods.includes(payment_method)) {
                sendError(res, 400, 'Metodo de pago invalido. Use: ' + validMethods.join(', '));
                return;
            }

            try {
                const contribution = await db.createContribution({
                    user_id,
                    group_id,
                    amount: parseFloat(amount),
                    payment_method,
                    status,
                    transaction_id: transaction_id || null,
                    confirmation_code: confirmation_code || null,
                    notes: notes || null,
                    due_date: due_date || null,
                    cycle_number: parseInt(cycle_number) || 1
                });

                sendSuccess(res, {
                    message: 'Contribucion registrada exitosamente',
                    contribution: {
                        id: contribution.id,
                        user_id: contribution.user_id,
                        group_id: contribution.group_id,
                        amount: parseFloat(contribution.amount),
                        payment_method: contribution.payment_method,
                        status: contribution.status,
                        created_at: contribution.created_at
                    }
                });
            } catch (error) {
                log('error', 'Error creating contribution', { error: error.message });
                sendError(res, 500, 'Error al registrar contribucion');
            }
            return;
        }

        // Mark member payment as received
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/payment$/) && method === "PATCH") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const memberId = parts[5];
            const { amount, payment_date, payment_method = "efectivo", notes = "" } = body;
            
            // SECURITY FIX: Require JWT authentication (2025-12-31)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticacion requerida");
                return;
            }
            const requesterId = authUser.userId || authUser.user_id || authUser.id;
            
            log("info", "Recording payment for member: " + memberId + " in group: " + groupId);
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            
            // SECURITY FIX: Verify requester is admin/coordinator of the group
            const isAuthorized = group.admin_id === requesterId || 
                (group.members && group.members.some(m => 
                    m.user_id === requesterId && 
                    ["coordinator", "admin", "creator"].includes(m.role)
                ));
            if (!isAuthorized) {
                sendError(res, 403, "No tienes permisos para registrar pagos");
                return;
            }
            if (!database.groupMembers) {
                database.groupMembers = [];
            }
            const member = database.groupMembers.find(m => m.id === memberId && m.group_id === groupId);
            if (!member) {
                sendError(res, 404, "Miembro no encontrado");
                return;
            }
            const paymentAmount = parseFloat(amount) || group.contribution_amount;
            member.payment_status = "paid";
            member.total_paid = (member.total_paid || 0) + paymentAmount;
            member.last_payment_date = payment_date || new Date().toISOString();
            member.payment_method = payment_method;
            if (!member.payment_history) {
                member.payment_history = [];
            }
            const paymentRecord = {
                id: generateId("payment"),
                amount: paymentAmount,
                date: payment_date || new Date().toISOString(),
                method: payment_method,
                notes: notes,
                recorded_by: body.recorded_by || group.admin_id,
                recorded_at: new Date().toISOString()
            };
            member.payment_history.push(paymentRecord);
            group.total_amount_collected = (group.total_amount_collected || 0) + paymentAmount;
            saveDatabase();
            log("info", "Payment recorded: " + paymentAmount + " for member " + memberId);
            sendSuccess(res, {
                message: "Pago de L. " + paymentAmount + " registrado exitosamente",
                data: {
                    member: {
                        id: member.id,
                        user_name: member.user_name,
                        payment_status: member.payment_status,
                        total_paid: member.total_paid,
                        last_payment_date: member.last_payment_date
                    },
                    payment: paymentRecord,
                    group_total: group.total_amount_collected
                }
            });
            return;
        }
        // Add member manually (coordinador only)
        // Edit group (coordinador only)
        if (pathname.startsWith("/api/groups/") && pathname.endsWith("/edit") && method === "PATCH") {
            const groupId = pathname.split("/")[3];
            const { name, description, contribution_amount, max_members, frequency, location, meeting_schedule } = body;
            
            // SECURITY FIX: Require JWT authentication (2025-12-31)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticacion requerida");
                return;
            }
            const requesterId = authUser.userId || authUser.user_id || authUser.id;
            
            log("info", "Editing group: " + groupId + " by user: " + requesterId);
            const group = database.groups.find(g => g.id === groupId);
            log("info", "Received body:", body);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            
            // SECURITY FIX: Verify requester is admin/coordinator of the group
            const isAuthorized = group.admin_id === requesterId || 
                (group.members && group.members.some(m => 
                    m.user_id === requesterId && 
                    ["coordinator", "admin", "creator"].includes(m.role)
                ));
            if (!isAuthorized) {
                sendError(res, 403, "No tienes permisos para editar este grupo");
                return;
            }
            if (name !== undefined) group.name = name;
            if (description !== undefined) group.description = description;
            if (contribution_amount !== undefined) {
                group.contribution_amount = parseFloat(contribution_amount);
            }
            if (max_members !== undefined) {
                const newMax = parseInt(max_members);
                if (newMax < group.member_count) {
                    sendError(res, 400, "No puedes reducir max_members por debajo del número actual de miembros");
                    return;
                }
                group.max_members = newMax;
            }
            if (frequency !== undefined) group.frequency = frequency;
            if (location !== undefined) group.location = location;
            if (meeting_schedule !== undefined) group.meeting_schedule = meeting_schedule;
            group.updated_at = new Date().toISOString();
            group.updated_by = requesterId;
            saveDatabase();
            log("info", "Group " + groupId + " updated successfully");
            sendSuccess(res, {
                message: "Grupo actualizado exitosamente",
                data: {
                    group: {
                        id: group.id,
                        name: group.name,
                        description: group.description,
                        contribution_amount: group.contribution_amount,
                        max_members: group.max_members,
                        member_count: group.member_count,
                        frequency: group.frequency,
                        location: group.location,
                        meeting_schedule: group.meeting_schedule,
                        updated_at: group.updated_at
                    }
                }
            });
            return;
        }
        // Group members management endpoints (NUEVOS)
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/add$/) && method === "POST") {
            // ============================================
            // SECURITY: Require JWT authentication (Added 2025-12-31)
            // ============================================
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const groupId = pathname.split("/")[3];
            const { userId, userName, userEmail } = body;

            // ============================================
            // SECURITY: Verify user has permission to add members (Added 2025-12-31)
            // ============================================
            const permCheck = await dbPostgres.pool.query(`
                SELECT gm.role FROM group_members gm
                WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status = 'active'
            `, [groupId, authUser.userId]);

            if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                sendError(res, 403, 'No tienes permisos para agregar miembros');
                return;
            }

            // ============================================
            // VALIDATION: Check if tanda has started (Added 2025-12-31)
            // ============================================
            const tandaCheck = await dbPostgres.pool.query(`
                SELECT lottery_executed_at FROM tandas
                WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
            `, [groupId]);

            if (tandaCheck.rows.length > 0 && tandaCheck.rows[0].lottery_executed_at) {
                sendError(res, 400, 'No se pueden agregar miembros después de que la tanda ha iniciado');
                return;
            }

            const addedBy = authUser.userId;
            log("info", "Manually adding member to group: " + groupId + " by: " + addedBy);
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            if (group.member_count >= group.max_members) {
                sendError(res, 400, "El grupo está lleno");
                return;
            }
            if (group.status !== "active") {
                sendError(res, 400, "El grupo no está activo");
                return;
            }
            if (!database.groupMembers) {
                database.groupMembers = [];
            }
            const existingMember = database.groupMembers.find(
                m => m.group_id === groupId && m.user_id === userId
            );
            if (existingMember) {
                sendError(res, 400, "Este usuario ya es miembro del grupo");
                return;
            }
            const newMember = {
                id: generateId("member"),
                group_id: groupId,
                id: userId,  // Changed from user_id to id
                user_name: userName,
                user_email: userEmail,
                joined_at: new Date().toISOString(),
                status: "active",
                payment_status: "pending",
                total_paid: 0,
                added_manually: true,
                added_by: addedBy || group.admin_id
            };
            database.groupMembers.push(newMember);
            group.member_count = (group.member_count || 1) + 1;
            saveDatabase();
            log("info", "Member " + userId + " added manually to group " + groupId);
            sendSuccess(res, {
                message: "Miembro agregado exitosamente",
                data: {
                    membership: newMember,
                    group: {
                        id: group.id,
                        name: group.name,
                        member_count: group.member_count,
                        max_members: group.max_members
                    }
                }
            });
            return;
        // Get group members list
        if (pathname.startsWith("/api/groups/") && pathname.endsWith("/members") && method === "GET") {
            // SECURITY: Require authentication (v4.10.1 - dead code handler, defense-in-depth)
            const authUserGM2 = requireAuth(req, res);
            if (!authUserGM2) return;

            const groupId = pathname.split("/")[3];
            log("info", "Fetching members for group: " + groupId);
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            const members = (database.groupMembers || []).filter(m => m.group_id === groupId);
            sendSuccess(res, {
                group_id: groupId,
                group_name: group.name,
                members: members,
                total_members: members.length
            });
            return;
        }
        // Mark member payment as received
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/payment$/) && method === "PATCH") {
            const parts = pathname.split("/");
            const groupId = parts[3];
            const memberId = parts[5];
            const { amount, payment_date, payment_method = "efectivo", notes = "" } = body;
            
            // SECURITY FIX: Require JWT authentication (2025-12-31)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticacion requerida");
                return;
            }
            const requesterId = authUser.userId || authUser.user_id || authUser.id;
            
            log("info", "Recording payment for member: " + memberId + " in group: " + groupId);
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }
            
            // SECURITY FIX: Verify requester is admin/coordinator of the group
            const isAuthorized = group.admin_id === requesterId || 
                (group.members && group.members.some(m => 
                    m.user_id === requesterId && 
                    ["coordinator", "admin", "creator"].includes(m.role)
                ));
            if (!isAuthorized) {
                sendError(res, 403, "No tienes permisos para registrar pagos");
                return;
            }
            if (!database.groupMembers) {
                database.groupMembers = [];
            }
            const member = database.groupMembers.find(m => m.id === memberId && m.group_id === groupId);
            if (!member) {
                sendError(res, 404, "Miembro no encontrado");
                return;
            }
            const paymentAmount = parseFloat(amount) || group.contribution_amount;
            member.payment_status = "paid";
            member.total_paid = (member.total_paid || 0) + paymentAmount;
            member.last_payment_date = payment_date || new Date().toISOString();
            member.payment_method = payment_method;
            if (!member.payment_history) {
                member.payment_history = [];
            }
            const paymentRecord = {
                id: generateId("payment"),
                amount: paymentAmount,
                date: payment_date || new Date().toISOString(),
                method: payment_method,
                notes: notes,
                recorded_by: body.recorded_by || group.admin_id,
                recorded_at: new Date().toISOString()
            };
            member.payment_history.push(paymentRecord);
            group.total_amount_collected = (group.total_amount_collected || 0) + paymentAmount;
            saveDatabase();
            log("info", "Payment recorded: " + paymentAmount + " for member " + memberId);
            sendSuccess(res, {
                message: "Pago de L. " + paymentAmount + " registrado exitosamente",
                data: {
                    member: {
                        id: member.id,
                        user_name: member.user_name,
                        payment_status: member.payment_status,
                        total_paid: member.total_paid,
                        last_payment_date: member.last_payment_date
                    },
                    payment: paymentRecord,
                    group_total: group.total_amount_collected
                }
            });
            return;
        }

        }
        if (pathname.startsWith('/api/groups/') && pathname.includes('/notifications/payment-reminders') && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticacion requerida");
                return;
            }

            const groupId = pathname.split('/')[3];
            
            log('info', `Sending payment reminders for group: ${groupId}`);
            
            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, 'Group not found');
                return;
            }
            
            sendSuccess(res, { 
                message: `Recordatorios enviados a ${group.member_count} miembros`,
                reminders_sent: group.member_count,
                group_name: group.name
            });
            return;
        }

        if (pathname.startsWith('/api/groups/') && pathname.includes('/finances/summary') && (method === 'GET' || method === 'HEAD')) {
            // v4.10.3: Require auth + membership check (was fully unauthenticated)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const groupId = pathname.split('/')[3];

            const group = database.groups.find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, 'Grupo no encontrado');
                return;
            }
            
            // Detect if it's a new group (no financial history)
            const createdDate = new Date(group.created_at);
            const daysSinceCreation = (Date.now() - createdDate.getTime()) / (1000 * 60 * 60 * 24);
            const isNewGroup = daysSinceCreation <= 7 || group.total_amount_collected === 0 || group.member_count <= 1;
            
            // Generate financial summary based on group age
            const financialSummary = {
                group_id: groupId,
                group_name: group.name,
                total_collected: group.total_amount_collected || 0,
                expected_per_cycle: group.contribution_amount * group.member_count,
                // New groups: 0% payment rate, older groups: realistic rates
                payment_rate: 0,
                pending_payments: 0,
                next_payout_amount: group.contribution_amount * group.member_count,
                cycle_progress: 0,
                is_mock: true, // TODO: Replace with real DB queries
                member_stats: {
                    active: group.member_count,
                    pending: isNewGroup ? 0 : Math.floor(crypto.randomInt(0, 2)),
                    total: group.member_count
                },
                is_new_group: isNewGroup
            };
            
            sendSuccess(res, financialSummary);
            return;
        }

        // Payment endpoints
        if (pathname === '/api/payments/methods/available' && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticacion requerida");
                return;
            }

            const { user_id, amount } = body;
            // Validate amount is a positive number
            if (amount !== undefined && (typeof amount !== 'number' || amount < 0)) {
                sendError(res, 400, "Monto debe ser un numero positivo");
                return;
            }
            const methods = [
                {
                    id: 'bank_transfer',
                    name: 'Transferencia Bancaria',
                    fee: 0,
                    processing_time: '1-2 horas',
                    available: true,
                    icon: '🏦'
                },
                {
                    id: 'tigo_money',
                    name: 'Tigo Money',
                    fee: (amount || 100) * 0.025,
                    processing_time: 'Inmediato',
                    available: true,
                    icon: '📱'
                },
                {
                    id: 'claro_money',
                    name: 'Claro Money',
                    fee: (amount || 100) * 0.02,
                    processing_time: 'Inmediato',
                    available: true,
                    icon: '📲'
                },
                {
                    id: 'cash',
                    name: 'Efectivo',
                    fee: 0,
                    processing_time: 'Manual',
                    available: true,
                    icon: '💵'
                }
            ];
            sendSuccess(res, { methods });
            return;
        }

        if (pathname === '/api/payments/process' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { group_id, amount, method: paymentMethod } = body;
            const user_id = authUser.userId;
            const paymentId = generateId('payment');
            const payment = {
                id: paymentId,
                user_id,
                group_id,
                amount,
                method: paymentMethod,
                status: 'processing',
                transaction_date: new Date().toISOString(),
                confirmation_code: `CONF${Date.now()}`,
                estimated_completion: new Date(Date.now() + 300000).toISOString()
            };
            database.payments.push(payment);
            sendSuccess(res, payment);
            return;
        }

        // ===== WALLET DEPOSIT ENDPOINTS (4) =====
        
        // 1. Bank Transfer Deposit for Honduras Banks
        
        // Get pending payments for coordinator approval
        if (pathname.startsWith("/api/payments/pending/") && method === "GET") {
            const groupId = pathname.split("/")[4];
            const pendingPayments = (database.payments || []).filter(
                p => p.group_id === groupId && p.status === "processing"
            );
            sendSuccess(res, { group_id: groupId, pending_count: pendingPayments.length, payments: pendingPayments });
            return;
        }
        
        // Coordinator approves payment
        if (pathname === "/api/payments/approve" && method === "POST") {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { payment_id } = body;
            const coordinator_id = authUser.userId;
            const payment = (database.payments || []).find(p => p.id === payment_id);
            if (!payment) {
                sendError(res, 404, "Pago no encontrado");
                return;
            }

            // SECURITY: Verify coordinator permissions (Added 2025-12-31)
            // v4.10.3: Allow suspended creators/coordinators to manage
            try {
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status IN ('active', 'suspended')
                `, [payment.group_id, coordinator_id]);

                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    sendError(res, 403, "No tienes permisos para aprobar pagos en este grupo");
                    return;
                }

                // VALIDATION: Check tanda status
                const tandaCheck = await dbPostgres.pool.query(`
                    SELECT status, lottery_executed_at FROM tandas
                    WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
                `, [payment.group_id]);

                if (tandaCheck.rows.length > 0 && tandaCheck.rows[0].status === 'recruiting') {
                    sendError(res, 400, "La tanda aún no ha iniciado");
                    return;
                }
            } catch (permError) {
                log("error", 'Error checking permissions:', permError);
            }

            payment.status = "completed";
            payment.approved_by = coordinator_id;
            payment.approved_at = new Date().toISOString();
            saveDatabase();
            sendSuccess(res, { message: "Pago aprobado", payment });
            return;
        }
        
        // Coordinator rejects payment
        if (pathname === "/api/payments/reject" && method === "POST") {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { payment_id, reason } = body;
            const coordinator_id = authUser.userId;
            const payment = (database.payments || []).find(p => p.id === payment_id);
            if (!payment) {
                sendError(res, 404, "Pago no encontrado");
                return;
            }

            // SECURITY: Verify coordinator permissions (Added 2025-12-31)
            // v4.10.3: Allow suspended creators/coordinators to manage
            try {
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status IN ('active', 'suspended')
                `, [payment.group_id, coordinator_id]);

                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    sendError(res, 403, "No tienes permisos para rechazar pagos en este grupo");
                    return;
                }
            } catch (permError) {
                log("error", 'Error checking permissions:', permError);
            }

            payment.status = "rejected";
            payment.rejected_by = coordinator_id;
            payment.rejection_reason = reason;
            payment.rejected_at = new Date().toISOString();
            saveDatabase();
            sendSuccess(res, { message: "Pago rechazado", payment });
            return;
        }
        if (pathname === '/api/wallet/deposit/bank-transfer' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { amount, bank_code, account_number } = body;
            const user_id = authUser.userId;

            // Honduras banks validation with La Tanda receptor accounts
            const honduras_banks = {
                'BAH': {
                    name: 'Banco Atlántida',
                    account: '30613012837',
                    account_holder: 'La Tanda Chain S.A.',
                    account_type: 'Cuenta Corriente',
                    swift: 'BAHNHNTE',
                    routing: '200101',
                    available: true
                },
                'BDO': { name: 'Banco de Occidente', available: false },
                'BFI': { name: 'Banco Ficohsa', available: false },
                'BAC': { name: 'BAC Honduras', available: false },
                'BAN': { name: 'Banpais', available: false },
                'BCE': { name: 'Banco Central de Honduras', available: false }
            };

            if (!honduras_banks[bank_code]) {
                sendError(res, 400, 'Código de banco no válido para Honduras');
                return;
            }

            if (!honduras_banks[bank_code].available) {
                sendError(res, 400, `${honduras_banks[bank_code].name} aún no está disponible para depósitos. Solo Banco Atlántida está habilitado.`);
                return;
            }

            const parsedAmount = parseFloat(amount);
            if (!Number.isFinite(parsedAmount) || parsedAmount < 10 || parsedAmount > 250000) {
                sendError(res, 400, 'Monto debe estar entre L. 10 y L. 250,000');
                return;
            }

            if (!account_number || typeof account_number !== 'string') {
                sendError(res, 400, 'Número de cuenta es requerido');
                return;
            }

            const bank_info = honduras_banks[bank_code];
            const depositId = generateId('deposit');
            const referenceNumber = `BT${Date.now()}`;
            const transaction_fee = parsedAmount * 0.02;
            const net_amount = parsedAmount - transaction_fee;

            const depositData = {
                id: depositId,
                user_id,
                type: 'bank_transfer',
                status: 'pending_transfer',
                amount: parsedAmount,
                net_amount,
                transaction_fee,
                currency: 'HNL',
                reference_number: referenceNumber,
                bank_name: bank_info.name,
                bank_code,
                user_account_number: account_number.replace(/\d(?=\d{4})/g, '*'),
                instructions: {
                    step1: `Accede a tu ${bank_info.name} (banca en línea, app móvil o sucursal)`,
                    step2: `Realiza transferencia a: ${bank_info.account_holder}`,
                    step3: `Cuenta destino: ${bank_info.account} (${bank_info.account_type})`,
                    step4: `Monto exacto: L.${parsedAmount} | Referencia obligatoria: ${referenceNumber}`,
                    step5: 'Guarda tu comprobante - Verificación automática en 2-4 horas',
                    additional_info: {
                        bank_name: bank_info.name,
                        routing_number: bank_info.routing,
                        swift_code: bank_info.swift,
                        important_note: 'La referencia es obligatoria para identificar tu depósito'
                    }
                },
                receptor_bank_details: {
                    bank_name: bank_info.name,
                    account_number: bank_info.account,
                    account_holder: bank_info.account_holder,
                    account_type: bank_info.account_type,
                    swift_code: bank_info.swift,
                    routing_number: bank_info.routing,
                    reference_required: referenceNumber
                },
                estimated_completion: new Date(Date.now() + 4 * 3600000).toISOString(),
                expires_at: new Date(Date.now() + 24 * 3600000).toISOString()
            };

            try {
                await dbPostgres.createDeposit(depositData);
            } catch (dbErr) {
                log('error', 'Failed to create bank deposit', { error: dbErr.message });
                sendError(res, 500, 'Error interno del servidor');
                return;
            }

            sendDepositNotification({ type: 'new_deposit', deposit: depositData, user_id });

            sendSuccess(res, {
                deposit_id: depositId,
                status: 'pending_transfer',
                bank_name: bank_info.name,
                amount: parsedAmount,
                net_amount,
                transaction_fee,
                reference_number: referenceNumber,
                processing_time: '2-4 horas laborales',
                instructions: depositData.instructions,
                tracking_url: `https://latanda.online/api/deposit/track/${depositId}`
            });
            return;
        }

        // 2. Cryptocurrency Deposit — PostgreSQL (v4.7.0)
        if (pathname === '/api/wallet/deposit/crypto' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { currency } = body;
            const user_id = authUser.userId;

            const supported_crypto = {
                'BTC': { name: 'Bitcoin', network: 'mainnet', confirmations: 6 },
                'ETH': { name: 'Ethereum', network: 'mainnet', confirmations: 12 },
                'USDT': { name: 'Tether USD', network: 'ethereum', confirmations: 12 },
                'USDC': { name: 'USD Coin', network: 'ethereum', confirmations: 12 }
            };

            if (!supported_crypto[currency]) {
                sendError(res, 400, 'Criptomoneda no soportada');
                return;
            }

            const cryptoInfo = supported_crypto[currency];
            const deposit_address = `${currency}${generateId('addr')}${user_id.slice(0,6)}`;
            const depositId = generateId('crypto_deposit');
            const qr_code = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${deposit_address}`;

            const depositData = {
                id: depositId,
                user_id,
                type: 'crypto',
                status: 'pending_transfer',
                crypto_currency: currency,
                deposit_address,
                network: cryptoInfo.network,
                confirmations_required: cryptoInfo.confirmations,
                current_confirmations: 0,
                monitoring_active: true,
                qr_code,
                expires_at: new Date(Date.now() + 24 * 3600000).toISOString(),
                instructions: {
                    step1: `Envía tu ${currency} a la dirección generada`,
                    step2: 'Escanea el código QR o copia la dirección',
                    step3: `Se requieren ${cryptoInfo.confirmations} confirmaciones`,
                    step4: 'El depósito se reflejará automáticamente tras las confirmaciones'
                }
            };

            try {
                await dbPostgres.createDeposit(depositData);
            } catch (dbErr) {
                log('error', 'Failed to create crypto deposit', { error: dbErr.message });
                sendError(res, 500, 'Error interno del servidor');
                return;
            }

            sendSuccess(res, {
                deposit_id: depositId,
                currency,
                currency_name: cryptoInfo.name,
                deposit_address,
                qr_code,
                network: cryptoInfo.network,
                confirmations_required: cryptoInfo.confirmations,
                expires_in: 24 * 3600,
                instructions: depositData.instructions,
                monitoring_url: `https://latanda.online/api/crypto/monitor/${depositId}`
            });
            return;
        }

        // 3. Mobile Payment Deposit (Tigo Money, Claro Pay) — PostgreSQL (v4.7.0)
        if (pathname === '/api/wallet/deposit/mobile' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { amount, carrier, phone_number } = body;
            const user_id = authUser.userId;

            const honduras_carriers = {
                'tigo': { name: 'Tigo Money', fee_rate: 0.025, min: 20, max: 2000 },
                'claro': { name: 'Claro Money', fee_rate: 0.03, min: 25, max: 1500 }
            };

            if (!honduras_carriers[carrier]) {
                sendError(res, 400, 'Operadora no soportada en Honduras');
                return;
            }

            const carrier_info = honduras_carriers[carrier];
            const parsedAmount = parseFloat(amount);

            if (!Number.isFinite(parsedAmount) || parsedAmount < carrier_info.min || parsedAmount > carrier_info.max) {
                sendError(res, 400, `Monto debe estar entre L.${carrier_info.min} y L.${carrier_info.max} para ${carrier_info.name}`);
                return;
            }

            if (!phone_number || typeof phone_number !== 'string') {
                sendError(res, 400, 'Número de teléfono es requerido');
                return;
            }

            const depositId = generateId('mobile_deposit');
            const transaction_fee = parsedAmount * carrier_info.fee_rate;
            const net_amount = parsedAmount - transaction_fee;
            const sms_code = crypto.randomInt(100000, 999999);

            const depositData = {
                id: depositId,
                user_id,
                type: 'mobile_payment',
                status: 'pending_transfer',
                amount: parsedAmount,
                net_amount,
                transaction_fee,
                currency: 'HNL',
                reference_number: `MP${Date.now()}`,
                carrier: carrier_info.name,
                phone_number: phone_number.replace(/\d(?=\d{4})/g, '*'),
                sms_code,
                expires_at: new Date(Date.now() + 15 * 60000).toISOString(),
                instructions: {
                    step1: `Envía el código ${sms_code} al 7777`,
                    step2: `Confirma el pago de L.${parsedAmount} desde tu ${carrier_info.name}`,
                    step3: 'Recibirás confirmación por SMS',
                    step4: 'El depósito se reflejará inmediatamente tras confirmación'
                }
            };

            try {
                await dbPostgres.createDeposit(depositData);
            } catch (dbErr) {
                log('error', 'Failed to create mobile deposit', { error: dbErr.message });
                sendError(res, 500, 'Error interno del servidor');
                return;
            }

            sendSuccess(res, {
                deposit_id: depositId,
                carrier: carrier_info.name,
                amount: parsedAmount,
                net_amount,
                transaction_fee,
                sms_confirmation_required: true,
                expires_in: 15 * 60,
                instructions: depositData.instructions,
                reference_number: depositData.reference_number
            });
            return;
        }
        
        // 4. Get Wallet Balance and Transaction History
        // 4. Get Wallet Balance and Transaction History - USING POSTGRESQL
        if (pathname === '/api/wallet/balance' && (method === 'GET' || method === 'HEAD')) {
            // SECURITY FIX: Require JWT auth - removed legacy user_id fallback (2026-01-23)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const user_id = authUser.userId;
            
            try {
                // Check if user exists in PostgreSQL
                const userResult = await dbPostgres.pool.query(
                    'SELECT user_id, name, email, status FROM users WHERE user_id = $1',
                    [user_id]
                );
                
                if (userResult.rows.length === 0) {
                    sendSuccess(res, { 
                            balance: 0, 
                            ltd_balance: 0, 
                            balances: { available_usd: 0, locked_usd: 0, pending_deposits_usd: 0, total_usd: 0, ltd_tokens: 0 }, 
                            restrictions: { max_withdrawal: 0, can_withdraw: false }, 
                            recent_transactions: [], 
                            message: 'Usuario no encontrado' 
                    });
                    return;
                }
                
                // Get completed contributions (money user has saved)
                const completedContribs = await dbPostgres.pool.query(
                    'SELECT COALESCE(SUM(amount), 0) as total, COUNT(*) as completed_count FROM contributions WHERE user_id = $1 AND status = $2',
                    [user_id, 'completed']
                );
                const totalSaved = parseFloat(completedContribs.rows[0].total) || 0;
                
                // Get pending contributions
                const pendingContribs = await dbPostgres.pool.query(
                    'SELECT COALESCE(SUM(amount), 0) as total, COUNT(*) as completed_count FROM contributions WHERE user_id = $1 AND status IN ($2, $3)',
                    [user_id, 'pending', 'awaiting_payment']
                );
                const pendingAmount = parseFloat(pendingContribs.rows[0].total) || 0;
                
                // Get recent transactions (contributions)
                const recentTxResult = await dbPostgres.pool.query(
                    `SELECT c.id, c.amount, c.status, c.payment_method, c.created_at, g.name as group_name
                     FROM contributions c
                     LEFT JOIN groups g ON c.group_id = g.group_id
                     WHERE c.user_id = $1
                     ORDER BY c.created_at DESC
                     LIMIT 10`,
                    [user_id]
                );
                
                const recentTransactions = recentTxResult.rows.map(tx => ({
                    id: tx.id,
                    type: 'contribution',
                    amount: parseFloat(tx.amount),
                    status: tx.status,
                    method: tx.payment_method || 'cash',
                    date: tx.created_at,
                    description: `Contribucion - ${tx.group_name || 'Tanda'}`
                }));
                
                // Get active tandas count
                const tandasResult = await dbPostgres.pool.query(
                    'SELECT COUNT(*) as count FROM group_members WHERE user_id = $1 AND status = $2',
                    [user_id, 'active']
                );
                const activeTandas = parseInt(tandasResult.rows[0].count) || 0;
                
                // Get LTD tokens from user_wallets
                const walletResult = await dbPostgres.pool.query(
                    'SELECT crypto_balances FROM user_wallets WHERE user_id = $1',
                    [user_id]
                );
                const cryptoBalances = walletResult.rows[0]?.crypto_balances || {};
                const ltdFromWallet = parseFloat(cryptoBalances.LTD) || 0;
                
                // Calculate available balance
                const availableBalance = totalSaved;
                const ltdBalance = ltdFromWallet; // Use actual LTD from wallet
                
                sendSuccess(res, {
                        balance: availableBalance,
                        ltd_balance: ltdBalance,
                        balances: {
                            available_usd: availableBalance,
                            locked_usd: 0,
                            pending_deposits_usd: pendingAmount,
                            total_usd: availableBalance + pendingAmount,
                            ltd_tokens: ltdBalance,
                            usd_to_ltd_rate: 1.0
                        },
                        restrictions: {
                            max_withdrawal: availableBalance,
                            can_withdraw: availableBalance > 0
                        },
                        recent_transactions: recentTransactions,
                        stats: {
                            total_saved: totalSaved,
                            pending_contributions: pendingAmount,
                            active_tandas: activeTandas,
                            completed_contributions: recentTransactions.filter(t => t.status === 'completed').length
                        },
                        last_updated: new Date().toISOString()
                });
                return;
                
            } catch (dbError) {
                log('error', 'Error fetching wallet balance from PostgreSQL', { user_id, error: dbError.message });
                sendError(res, 500, 'Error al obtener balance');
                return;
            }
        }
        // ===== WALLET WITHDRAWAL ENDPOINTS =====
        
        // POST /api/wallet/withdraw/bank - Bank transfer withdrawal
        if (pathname === '/api/wallet/withdraw/bank' && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }
            const user_id = authUser.userId;
            
            const { amount, bank_name, account_number, account_type, account_holder_name, notes } = body;
            
            // v3.99.0: Validate amount as number with cap
            const parsedAmount = parseFloat(amount);
            if (!parsedAmount || isNaN(parsedAmount) || !isFinite(parsedAmount) || parsedAmount <= 0 || parsedAmount > 100000) {
                sendError(res, 400, 'Monto invalido (debe ser entre 0.01 y 100,000)');
                return;
            }
            // v3.99.0: Validate string fields type and length
            if (typeof bank_name !== 'string' || typeof account_number !== 'string' || typeof account_holder_name !== 'string') {
                sendError(res, 400, 'Datos bancarios deben ser texto');
                return;
            }
            if (!bank_name.trim() || !account_number.trim() || !account_holder_name.trim()) {
                sendError(res, 400, 'Datos bancarios incompletos: bank_name, account_number, account_holder_name son requeridos');
                return;
            }
            
            try {

            // PIN verification for amounts >= L. 1,000
            if (parsedAmount >= 1000) {
                const { transaction_pin } = body;
                if (!transaction_pin) {
                    sendError(res, 400, 'PIN de transacción requerido para montos >= L. 1,000', {
                        pin_required: true,
                        threshold: 1000
                    });
                    return;
                }

                // Verify PIN
                const pinResult = await dbPostgres.pool.query(
                    'SELECT pin_hash, failed_attempts, locked_until FROM user_transaction_pins WHERE user_id = $1',
                    [user_id]
                );

                if (pinResult.rows.length === 0) {
                    sendError(res, 400, 'Debe configurar un PIN de transacción primero', {
                        pin_required: true,
                        pin_not_set: true
                    });
                    return;
                }

                const pinData = pinResult.rows[0];
                if (pinData.locked_until && new Date(pinData.locked_until) > new Date()) {
                    const remainingMinutes = Math.ceil((new Date(pinData.locked_until) - new Date()) / 60000);
                    sendError(res, 423, `PIN bloqueado. Intente en ${remainingMinutes} minutos.`);
                    return;
                }

                const validPin = await bcrypt.compare(transaction_pin, pinData.pin_hash);
                if (!validPin) {
                    const newAttempts = pinData.failed_attempts + 1;
                    if (newAttempts >= 3) {
                        await dbPostgres.pool.query(
                            `UPDATE user_transaction_pins SET failed_attempts = $1, locked_until = NOW() + INTERVAL '30 minutes' WHERE user_id = $2`,
                            [newAttempts, user_id]
                        );
                        sendError(res, 423, 'PIN bloqueado por 30 minutos debido a múltiples intentos fallidos.');
                    } else {
                        await dbPostgres.pool.query(
                            'UPDATE user_transaction_pins SET failed_attempts = $1 WHERE user_id = $2',
                            [newAttempts, user_id]
                        );
                        sendError(res, 401, `PIN incorrecto. ${3 - newAttempts} intentos restantes.`);
                    }
                    return;
                }

                // Reset attempts on success
                await dbPostgres.pool.query(
                    'UPDATE user_transaction_pins SET failed_attempts = 0, locked_until = NULL WHERE user_id = $1',
                    [user_id]
                );
            }

                // v3.99.0: Transaction to prevent withdrawal race condition (double-spend)
                const txClient = await dbPostgres.pool.connect();
                let withdrawalId;
                try {
                    await txClient.query('BEGIN');
                    const balanceResult = await txClient.query(
                        'SELECT COALESCE(SUM(amount), 0) as total FROM contributions WHERE user_id = $1 AND status = $2',
                        [user_id, 'completed']
                    );
                    const pendingWithdrawals = await txClient.query(
                        "SELECT COALESCE(SUM(amount), 0) as total FROM withdrawals WHERE user_id = $1 AND status IN ('pending', 'processing') FOR UPDATE",
                        [user_id]
                    );
                    const availableBalance = toMoney((parseFloat(balanceResult.rows[0].total) || 0) - (parseFloat(pendingWithdrawals.rows[0].total) || 0));

                    if (parsedAmount > availableBalance) {
                        await txClient.query('ROLLBACK');
                        txClient.release();
                        sendError(res, 400, 'Saldo insuficiente', { requested: parsedAmount, available: availableBalance });
                        return;
                    }

                    withdrawalId = 'wd_' + Date.now() + '_' + crypto.randomBytes(8).toString('hex');

                    await txClient.query(
                        'INSERT INTO withdrawals (id, user_id, amount, method, status, bank_name, account_number, account_type, account_holder_name, notes, created_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, CURRENT_TIMESTAMP)',
                        [withdrawalId, user_id, parsedAmount, 'bank_transfer', 'pending', String(bank_name).trim().substring(0, 100), String(account_number).trim().substring(0, 30), String(account_type || 'savings').trim().substring(0, 20), String(account_holder_name).trim().substring(0, 150), String(notes || '').trim().substring(0, 500)]
                    );
                    await txClient.query('COMMIT');
                } catch (txErr) {
                    await txClient.query('ROLLBACK').catch(() => {});
                    throw txErr;
                } finally {
                    txClient.release();
                }
                
                auditLog('WITHDRAWAL_REQUESTED', { user_id, withdrawal_id: withdrawalId, amount, method: 'bank_transfer', bank_name });

                // Send notification for bank withdrawal
                try {
                    await notificationsUtils.createNotification(dbPostgres.pool, user_id, 'withdrawal_requested', 
                        '💸 Solicitud de Retiro Bancario',
                        'Tu solicitud de retiro por L. ' + parsedAmount.toFixed(2) + ' a ' + bank_name + ' ha sido recibida. Tiempo estimado: 1-3 días hábiles.',
                        { withdrawal_id: withdrawalId, amount, method: 'bank_transfer', bank_name }
                    );
                } catch (notifErr) { 
                    log('error', 'Failed to send withdrawal notification', { error: notifErr.message }); 
                }

                // Send email notification for withdrawal
                try {
                    const userResult = await dbPostgres.pool.query(
                        'SELECT email, name FROM users WHERE user_id = $1',
                        [user_id]
                    );
                    if (userResult.rows[0]?.email) {
                        const userEmail = userResult.rows[0].email;
                        const userName = userResult.rows[0].name || 'Usuario';
                        const emailHtml = `
                            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background: #0f172a; color: #f8fafc; padding: 20px; border-radius: 10px;">
                                <div style="text-align: center; margin-bottom: 20px;">
                                    <h1 style="color: #00FFFF;">💸 Solicitud de Retiro</h1>
                                </div>
                                <p>Hola ${userName},</p>
                                <p>Hemos recibido tu solicitud de retiro:</p>
                                <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 8px; margin: 20px 0;">
                                    <p><strong>Monto:</strong> L. ${parsedAmount.toFixed(2)}</p>
                                    <p><strong>Método:</strong> Transferencia Bancaria</p>
                                    <p><strong>Banco:</strong> ${bank_name}</p>
                                    <p><strong>Cuenta:</strong> ****${account_number.slice(-4)}</p>
                                    <p><strong>ID:</strong> ${withdrawalId}</p>
                                </div>
                                <p>Tu retiro está siendo procesado. Tiempo estimado: 1-3 días hábiles.</p>
                                <p style="color: #94a3b8; font-size: 12px; margin-top: 30px;">Si no solicitaste este retiro, contacta a soporte inmediatamente.</p>
                            </div>
                        `;
                        await sendEmail(userEmail, '💸 Solicitud de Retiro Recibida - La Tanda', emailHtml, 'pagos');
                    }
                } catch (emailErr) {
                    log('error', 'Failed to send withdrawal email', { error: emailErr.message });
                }
                
                sendSuccess(res, {
                    message: 'Solicitud de retiro recibida',
                    withdrawal_id: withdrawalId,
                    amount,
                    method: 'bank_transfer',
                    status: 'pending',
                    estimated_time: '1-3 días hábiles',
                    details: { bank_name, account_number: account_number.slice(-4).padStart(account_number.length, '*'), account_holder_name }
                });
                return;
            } catch (error) {
                log('error', 'Bank withdrawal failed', { user_id, error: error.message });
                sendError(res, 500, 'Error procesando retiro bancario');
                return;
            }
        }
        
        // POST /api/wallet/withdraw/mobile - Mobile money withdrawal
        if (pathname === '/api/wallet/withdraw/mobile' && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }
            const user_id = authUser.userId;
            
            const { amount, provider, phone_number, notes } = body;
            
            // v4.0.0: Validate amount as number with cap
            const parsedAmount = parseFloat(amount);
            if (!parsedAmount || isNaN(parsedAmount) || !isFinite(parsedAmount) || parsedAmount <= 0 || parsedAmount > 100000) {
                sendError(res, 400, 'Monto invalido (debe ser entre 0.01 y 100,000)');
                return;
            }
            // v4.0.0: Validate string types
            if (typeof phone_number !== 'string') {
                sendError(res, 400, 'Numero de telefono debe ser texto');
                return;
            }
            if (!provider || !['tigo_money', 'claro_money'].includes(provider)) {
                sendError(res, 400, 'Proveedor inválido. Use: tigo_money o claro_money');
                return;
            }
            if (!phone_number) {
                sendError(res, 400, 'Número de teléfono requerido');
                return;
            }
            
            try {

            // PIN verification for amounts >= L. 1,000
            if (parsedAmount >= 1000) {
                const { transaction_pin } = body;
                if (!transaction_pin) {
                    sendError(res, 400, 'PIN de transacción requerido para montos >= L. 1,000', {
                        pin_required: true,
                        threshold: 1000
                    });
                    return;
                }

                // Verify PIN
                const pinResult = await dbPostgres.pool.query(
                    'SELECT pin_hash, failed_attempts, locked_until FROM user_transaction_pins WHERE user_id = $1',
                    [user_id]
                );

                if (pinResult.rows.length === 0) {
                    sendError(res, 400, 'Debe configurar un PIN de transacción primero', {
                        pin_required: true,
                        pin_not_set: true
                    });
                    return;
                }

                const pinData = pinResult.rows[0];
                if (pinData.locked_until && new Date(pinData.locked_until) > new Date()) {
                    const remainingMinutes = Math.ceil((new Date(pinData.locked_until) - new Date()) / 60000);
                    sendError(res, 423, `PIN bloqueado. Intente en ${remainingMinutes} minutos.`);
                    return;
                }

                const validPin = await bcrypt.compare(transaction_pin, pinData.pin_hash);
                if (!validPin) {
                    const newAttempts = pinData.failed_attempts + 1;
                    if (newAttempts >= 3) {
                        await dbPostgres.pool.query(
                            `UPDATE user_transaction_pins SET failed_attempts = $1, locked_until = NOW() + INTERVAL '30 minutes' WHERE user_id = $2`,
                            [newAttempts, user_id]
                        );
                        sendError(res, 423, 'PIN bloqueado por 30 minutos debido a múltiples intentos fallidos.');
                    } else {
                        await dbPostgres.pool.query(
                            'UPDATE user_transaction_pins SET failed_attempts = $1 WHERE user_id = $2',
                            [newAttempts, user_id]
                        );
                        sendError(res, 401, `PIN incorrecto. ${3 - newAttempts} intentos restantes.`);
                    }
                    return;
                }

                // Reset attempts on success
                await dbPostgres.pool.query(
                    'UPDATE user_transaction_pins SET failed_attempts = 0, locked_until = NULL WHERE user_id = $1',
                    [user_id]
                );
            }

                // v4.0.0: Transaction to prevent withdrawal race condition (double-spend)
                const txClient = await dbPostgres.pool.connect();
                let withdrawalId;
                try {
                    await txClient.query('BEGIN');
                    const balanceResult = await txClient.query(
                        'SELECT COALESCE(SUM(amount), 0) as total FROM contributions WHERE user_id = $1 AND status = $2',
                        [user_id, 'completed']
                    );
                    const pendingWithdrawals = await txClient.query(
                        "SELECT COALESCE(SUM(amount), 0) as total FROM withdrawals WHERE user_id = $1 AND status IN ('pending', 'processing') FOR UPDATE",
                        [user_id]
                    );
                    const availableBalance = toMoney((parseFloat(balanceResult.rows[0].total) || 0) - (parseFloat(pendingWithdrawals.rows[0].total) || 0));

                    if (parsedAmount > availableBalance) {
                        await txClient.query('ROLLBACK');
                        txClient.release();
                        sendError(res, 400, 'Saldo insuficiente', { requested: parsedAmount, available: availableBalance });
                        return;
                    }

                    withdrawalId = 'wd_' + Date.now() + '_' + crypto.randomBytes(8).toString('hex');

                    await txClient.query(
                        'INSERT INTO withdrawals (id, user_id, amount, method, status, provider, phone_number, notes, created_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP)',
                        [withdrawalId, user_id, parsedAmount, 'mobile_money', 'pending', String(provider).trim().substring(0, 50), String(phone_number).trim().substring(0, 20), String(notes || '').trim().substring(0, 500)]
                    );
                    await txClient.query('COMMIT');
                } catch (txErr) {
                    await txClient.query('ROLLBACK').catch(() => {});
                    throw txErr;
                } finally {
                    txClient.release();
                }
                
                auditLog('WITHDRAWAL_REQUESTED', { user_id, withdrawal_id: withdrawalId, amount, method: 'mobile_money', provider });

                // Send notification for mobile money withdrawal
                try {
                    await notificationsUtils.createNotification(dbPostgres.pool, user_id, 'withdrawal_requested', 
                        '📱 Retiro a Billetera Móvil',
                        'Tu solicitud de retiro por L. ' + parsedAmount.toFixed(2) + ' a ' + provider + ' (' + phone_number + ') ha sido recibida.',
                        { withdrawal_id: withdrawalId, amount, method: 'mobile_money', provider, phone_number }
                    );
                } catch (notifErr) { 
                    log('error', 'Failed to send withdrawal notification', { error: notifErr.message }); 
                }

                // Send email notification for mobile money withdrawal
                try {
                    const userResult = await dbPostgres.pool.query(
                        'SELECT email, name FROM users WHERE user_id = $1',
                        [user_id]
                    );
                    if (userResult.rows[0]?.email) {
                        const userEmail = userResult.rows[0].email;
                        const userName = userResult.rows[0].name || 'Usuario';
                        const emailHtml = `
                            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background: #0f172a; color: #f8fafc; padding: 20px; border-radius: 10px;">
                                <div style="text-align: center; margin-bottom: 20px;">
                                    <h1 style="color: #00FFFF;">📱 Retiro a Billetera Móvil</h1>
                                </div>
                                <p>Hola ${userName},</p>
                                <p>Hemos recibido tu solicitud de retiro:</p>
                                <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 8px; margin: 20px 0;">
                                    <p><strong>Monto:</strong> L. ${parsedAmount.toFixed(2)}</p>
                                    <p><strong>Método:</strong> ${provider}</p>
                                    <p><strong>Teléfono:</strong> ${phone_number}</p>
                                    <p><strong>ID:</strong> ${withdrawalId}</p>
                                </div>
                                <p>Tu retiro está siendo procesado.</p>
                            </div>
                        `;
                        await sendEmail(userEmail, '📱 Retiro a Billetera Móvil - La Tanda', emailHtml, 'pagos');
                    }
                } catch (emailErr) {
                    log('error', 'Failed to send mobile withdrawal email', { error: emailErr.message });
                }
                
                sendSuccess(res, {
                    message: 'Solicitud de retiro recibida',
                    withdrawal_id: withdrawalId,
                    amount,
                    method: 'mobile_money',
                    provider,
                    status: 'pending',
                    estimated_time: '5-30 minutos',
                    details: { provider, phone_number: phone_number.slice(-4).padStart(phone_number.length, '*') }
                });
                return;
            } catch (error) {
                log('error', 'Mobile withdrawal failed', { user_id, error: error.message });
                sendError(res, 500, 'Error procesando retiro móvil');
                return;
            }
        }
        
        // POST /api/wallet/withdraw/crypto - Cryptocurrency withdrawal
        if (pathname === '/api/wallet/withdraw/crypto' && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }
            const user_id = authUser.userId;
            
            const { amount, network, wallet_address, currency, notes } = body;
            // Default currency based on network
            const networkCurrencies = { ethereum: "ETH", polygon: "MATIC", bsc: "BNB", bitcoin: "BTC", tron: "TRX" };
            const effectiveCurrency = currency || networkCurrencies[network?.toLowerCase()] || "CRYPTO";
            
            // v4.0.0: Validate amount as number with cap
            const parsedAmount = parseFloat(amount);
            if (!parsedAmount || isNaN(parsedAmount) || !isFinite(parsedAmount) || parsedAmount <= 0 || parsedAmount > 100000) {
                sendError(res, 400, 'Monto invalido (debe ser entre 0.01 y 100,000)');
                return;
            }
            // v4.0.0: Validate string types
            if (typeof wallet_address !== 'string') {
                sendError(res, 400, 'Direccion de wallet debe ser texto');
                return;
            }
            if (!network || !['ethereum', 'polygon', 'bsc', 'bitcoin', 'tron'].includes(network.toLowerCase())) {
                sendError(res, 400, 'Red inválida. Use: ethereum, polygon, bsc, bitcoin, o tron');
                return;
            }
            if (!wallet_address) {
                sendError(res, 400, 'Dirección de wallet requerida');
                return;
            }
            
            try {

            // PIN verification for amounts >= L. 1,000
            if (parsedAmount >= 1000) {
                const { transaction_pin } = body;
                if (!transaction_pin) {
                    sendError(res, 400, 'PIN de transacción requerido para montos >= L. 1,000', {
                        pin_required: true,
                        threshold: 1000
                    });
                    return;
                }

                // Verify PIN
                const pinResult = await dbPostgres.pool.query(
                    'SELECT pin_hash, failed_attempts, locked_until FROM user_transaction_pins WHERE user_id = $1',
                    [user_id]
                );

                if (pinResult.rows.length === 0) {
                    sendError(res, 400, 'Debe configurar un PIN de transacción primero', {
                        pin_required: true,
                        pin_not_set: true
                    });
                    return;
                }

                const pinData = pinResult.rows[0];
                if (pinData.locked_until && new Date(pinData.locked_until) > new Date()) {
                    const remainingMinutes = Math.ceil((new Date(pinData.locked_until) - new Date()) / 60000);
                    sendError(res, 423, `PIN bloqueado. Intente en ${remainingMinutes} minutos.`);
                    return;
                }

                const validPin = await bcrypt.compare(transaction_pin, pinData.pin_hash);
                if (!validPin) {
                    const newAttempts = pinData.failed_attempts + 1;
                    if (newAttempts >= 3) {
                        await dbPostgres.pool.query(
                            `UPDATE user_transaction_pins SET failed_attempts = $1, locked_until = NOW() + INTERVAL '30 minutes' WHERE user_id = $2`,
                            [newAttempts, user_id]
                        );
                        sendError(res, 423, 'PIN bloqueado por 30 minutos debido a múltiples intentos fallidos.');
                    } else {
                        await dbPostgres.pool.query(
                            'UPDATE user_transaction_pins SET failed_attempts = $1 WHERE user_id = $2',
                            [newAttempts, user_id]
                        );
                        sendError(res, 401, `PIN incorrecto. ${3 - newAttempts} intentos restantes.`);
                    }
                    return;
                }

                // Reset attempts on success
                await dbPostgres.pool.query(
                    'UPDATE user_transaction_pins SET failed_attempts = 0, locked_until = NULL WHERE user_id = $1',
                    [user_id]
                );
            }

                // v4.0.0: Transaction to prevent withdrawal race condition (double-spend)
                const txClient = await dbPostgres.pool.connect();
                let withdrawalId;
                try {
                    await txClient.query('BEGIN');
                    const balanceResult = await txClient.query(
                        'SELECT COALESCE(SUM(amount), 0) as total FROM contributions WHERE user_id = $1 AND status = $2',
                        [user_id, 'completed']
                    );
                    const pendingWithdrawals = await txClient.query(
                        "SELECT COALESCE(SUM(amount), 0) as total FROM withdrawals WHERE user_id = $1 AND status IN ('pending', 'processing') FOR UPDATE",
                        [user_id]
                    );
                    const availableBalance = toMoney((parseFloat(balanceResult.rows[0].total) || 0) - (parseFloat(pendingWithdrawals.rows[0].total) || 0));

                    if (parsedAmount > availableBalance) {
                        await txClient.query('ROLLBACK');
                        txClient.release();
                        sendError(res, 400, 'Saldo insuficiente', { requested: parsedAmount, available: availableBalance });
                        return;
                    }

                    withdrawalId = 'wd_' + Date.now() + '_' + crypto.randomBytes(8).toString('hex');

                    await txClient.query(
                        'INSERT INTO withdrawals (id, user_id, amount, method, status, network, wallet_address, currency, notes, created_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, CURRENT_TIMESTAMP)',
                        [withdrawalId, user_id, parsedAmount, 'crypto', 'pending', String(network).toLowerCase().substring(0, 30), String(wallet_address).trim().substring(0, 200), String(currency || 'USDT').trim().substring(0, 10), String(notes || '').trim().substring(0, 500)]
                    );
                    await txClient.query('COMMIT');
                } catch (txErr) {
                    await txClient.query('ROLLBACK').catch(() => {});
                    throw txErr;
                } finally {
                    txClient.release();
                }
                
                auditLog('WITHDRAWAL_REQUESTED', { user_id, withdrawal_id: withdrawalId, amount, method: 'crypto', network });

                // Send notification for crypto withdrawal
                try {
                    await notificationsUtils.createNotification(dbPostgres.pool, user_id, 'withdrawal_requested', 
                        '₿ Retiro Crypto Solicitado',
                        'Tu solicitud de retiro de ' + amount + ' ' + effectiveCurrency + ' a la red ' + network + ' ha sido recibida.',
                        { withdrawal_id: withdrawalId, amount, method: 'crypto', network, wallet_address, effectiveCurrency }
                    );
                } catch (notifErr) { 
                    log('error', 'Failed to send withdrawal notification', { error: notifErr.message }); 
                }

                // Send email notification for crypto withdrawal
                try {
                    const userResult = await dbPostgres.pool.query(
                        'SELECT email, name FROM users WHERE user_id = $1',
                        [user_id]
                    );
                    if (userResult.rows[0]?.email) {
                        const userEmail = userResult.rows[0].email;
                        const userName = userResult.rows[0].name || 'Usuario';
                        const emailHtml = `
                            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background: #0f172a; color: #f8fafc; padding: 20px; border-radius: 10px;">
                                <div style="text-align: center; margin-bottom: 20px;">
                                    <h1 style="color: #00FFFF;">₿ Retiro Crypto</h1>
                                </div>
                                <p>Hola ${userName},</p>
                                <p>Hemos recibido tu solicitud de retiro:</p>
                                <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 8px; margin: 20px 0;">
                                    <p><strong>Monto:</strong> ${amount} ${effectiveCurrency}</p>
                                    <p><strong>Red:</strong> ${network}</p>
                                    <p><strong>Wallet:</strong> ${wallet_address.slice(0,8)}...${wallet_address.slice(-6)}</p>
                                    <p><strong>ID:</strong> ${withdrawalId}</p>
                                </div>
                                <p>Tu retiro está siendo procesado. Verifica que la dirección sea correcta.</p>
                                <p style="color: #f87171; font-size: 12px;">⚠️ Las transacciones crypto son irreversibles.</p>
                            </div>
                        `;
                        await sendEmail(userEmail, '₿ Retiro Crypto Solicitado - La Tanda', emailHtml, 'pagos');
                    }
                } catch (emailErr) {
                    log('error', 'Failed to send crypto withdrawal email', { error: emailErr.message });
                }
                
                sendSuccess(res, {
                    message: 'Solicitud de retiro crypto recibida',
                    withdrawal_id: withdrawalId,
                    amount,
                    method: 'crypto',
                    network: network.toLowerCase(),
                    currency: currency || 'USDT',
                    status: 'pending',
                    estimated_time: '10-60 minutos',
                    details: { network: network.toLowerCase(), wallet_address: wallet_address.slice(0, 10) + '...' + wallet_address.slice(-6) }
                });
                return;
            } catch (error) {
                log('error', 'Crypto withdrawal failed', { user_id, error: error.message });
                sendError(res, 500, 'Error procesando retiro crypto');
                return;
            }
        }
        
        // GET /api/wallet/withdraw/fees - Get withdrawal fees
        if (pathname === '/api/wallet/withdraw/fees' && (method === 'GET' || method === 'HEAD')) {

            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }
            sendSuccess(res, {
                fees: {
                    bank_transfer: { fixed: 0, percentage: 0, minimum: 100, maximum: 50000, currency: 'HNL', estimated_time: '1-3 días hábiles' },
                    mobile_money: {
                        tigo_money: { fixed: 5, percentage: 1.5, minimum: 50, maximum: 10000, currency: 'HNL', estimated_time: '5-30 minutos' },
                        claro_money: { fixed: 5, percentage: 1.5, minimum: 50, maximum: 10000, currency: 'HNL', estimated_time: '5-30 minutos' }
                    },
                    crypto: {
                        ethereum: { network_fee: 5, minimum: 20, currency: 'USD' },
                        polygon: { network_fee: 0.5, minimum: 5, currency: 'USD' },
                        bsc: { network_fee: 0.5, minimum: 5, currency: 'USD' },
                        bitcoin: { network_fee: 10, minimum: 50, currency: 'USD' },
                        tron: { network_fee: 1, minimum: 10, currency: 'USD' }
                    }
                },
                message: 'Las comisiones pueden variar según condiciones del mercado'
            });
            return;
        }
        
        // GET /api/wallet/withdrawals - Get user withdrawal history
        if (pathname === '/api/wallet/withdrawals' && (method === 'GET' || method === 'HEAD')) {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) { sendError(res, 401, 'Autenticacion requerida'); return; }
            const user_id = authUser.userId;
            
            if (!user_id) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }
            
            try {
                const result = await dbPostgres.pool.query(
                    'SELECT id, amount, method, status, provider, bank_name, network, created_at, updated_at, notes FROM withdrawals WHERE user_id = $1 ORDER BY created_at DESC LIMIT 50',
                    [user_id]
                );
                
                sendSuccess(res, { withdrawals: result.rows, total: result.rows.length });
                return;
            } catch (error) {
                log('error', 'Failed to fetch withdrawals', { user_id, error: error.message });
                sendError(res, 500, 'Error obteniendo historial de retiros');
                return;
            }
        }
        
        // ===== BALANCE HISTORY ENDPOINT =====
        
        // GET /api/wallet/balance-history - Get balance history and statistics for charts
        if (pathname === '/api/wallet/balance-history' && (method === 'GET' || method === 'HEAD')) {
            // SECURITY FIX: Require JWT auth - removed legacy user_id fallback (2026-01-23)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const user_id = authUser.userId;
            const period = query.period || '30d';
            
            try {
                // Calculate date range based on period
                let daysBack = 30;
                if (period === '7d') daysBack = 7;
                else if (period === '30d') daysBack = 30;
                else if (period === '90d') daysBack = 90;
                else if (period === 'todo' || period === 'all') daysBack = 365;
                
                const startDate = new Date();
                startDate.setDate(startDate.getDate() - daysBack);
                const startDateStr = startDate.toISOString();
                
                // Get current balance (same method as /api/wallet/balance)
                // Balance is sum of completed contributions
                const balanceResult = await dbPostgres.pool.query(
                    'SELECT COALESCE(SUM(amount), 0) as total FROM contributions WHERE user_id = $1 AND status = $2',
                    [user_id, 'completed']
                );
                const currentBalance = parseFloat(balanceResult.rows[0]?.total) || 0;
                
                // Get total deposits in period
                const depositsResult = await dbPostgres.pool.query(
                    `SELECT COALESCE(SUM(amount), 0) as total, COUNT(*) as count
                     FROM contributions 
                     WHERE user_id = $1 AND status = 'completed' AND created_at >= $2`,
                    [user_id, startDateStr]
                );
                
                // Get withdrawals in period
                const withdrawalsResult = await dbPostgres.pool.query(
                    `SELECT COALESCE(SUM(amount), 0) as total, COUNT(*) as count
                     FROM withdrawals 
                     WHERE user_id = $1 AND status = 'completed' AND created_at >= $2`,
                    [user_id, startDateStr]
                );
                
                // Get all completed contributions for history
                const contribResult = await dbPostgres.pool.query(
                    `SELECT id::text, 'deposit' as type, amount, created_at 
                     FROM contributions 
                     WHERE user_id = $1 AND status = 'completed' AND created_at >= $2
                     ORDER BY created_at ASC`,
                    [user_id, startDateStr]
                );
                
                // Get all completed withdrawals for history
                const withdrawResult = await dbPostgres.pool.query(
                    `SELECT id::text, 'withdrawal' as type, amount, created_at
                     FROM withdrawals
                     WHERE user_id = $1 AND status = 'completed' AND created_at >= $2
                     ORDER BY created_at ASC`,
                    [user_id, startDateStr]
                );
                
                // Combine and sort transactions
                const transactions = [...contribResult.rows, ...withdrawResult.rows]
                    .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                
                const totalDeposits = parseFloat(depositsResult.rows[0]?.total) || 0;
                const totalWithdrawals = parseFloat(withdrawalsResult.rows[0]?.total) || 0;
                const totalCount = parseInt(depositsResult.rows[0]?.count || 0) + parseInt(withdrawalsResult.rows[0]?.count || 0);
                
                // Build balance history by reconstructing from transactions
                let runningBalance = currentBalance;
                
                // Calculate what balance was at start by going backwards
                for (let i = transactions.length - 1; i >= 0; i--) {
                    const tx = transactions[i];
                    const amount = parseFloat(tx.amount) || 0;
                    if (tx.type === 'deposit') {
                        runningBalance -= amount;
                    } else {
                        runningBalance += amount;
                    }
                }
                
                // Starting balance at beginning of period
                let startingBalance = Math.max(0, runningBalance);
                let minBalance = startingBalance;
                let maxBalance = startingBalance;
                
                // Build forward history
                runningBalance = startingBalance;
                let txIndex = 0;
                const historyPoints = [];
                
                for (let d = 0; d <= daysBack; d++) {
                    const date = new Date(startDate);
                    date.setDate(date.getDate() + d);
                    const dateStr = date.toISOString().split('T')[0];
                    
                    // Apply all transactions for this day
                    while (txIndex < transactions.length) {
                        const txDate = new Date(transactions[txIndex].created_at).toISOString().split('T')[0];
                        if (txDate > dateStr) break;
                        
                        const tx = transactions[txIndex];
                        const amount = parseFloat(tx.amount) || 0;
                        if (tx.type === 'deposit') {
                            runningBalance += amount;
                        } else {
                            runningBalance -= amount;
                        }
                        txIndex++;
                    }
                    
                    minBalance = Math.min(minBalance, runningBalance);
                    maxBalance = Math.max(maxBalance, runningBalance);
                    
                    historyPoints.push({
                        date: dateStr,
                        balance: runningBalance,
                        label: date.toLocaleDateString('es-HN', { month: 'short', day: 'numeric' })
                    });
                }
                
                // If no history points, create with current balance
                if (historyPoints.length === 0) {
                    for (let d = 0; d <= daysBack; d++) {
                        const date = new Date(startDate);
                        date.setDate(date.getDate() + d);
                        historyPoints.push({
                            date: date.toISOString().split('T')[0],
                            balance: currentBalance,
                            label: date.toLocaleDateString('es-HN', { month: 'short', day: 'numeric' })
                        });
                    }
                    minBalance = currentBalance;
                    maxBalance = currentBalance;
                }
                
                const response = {
                    history: historyPoints,
                    stats: {
                        current_balance: currentBalance,
                        max_balance: maxBalance,
                        min_balance: minBalance,
                        total_deposits: totalDeposits,
                        total_withdrawals: totalWithdrawals,
                        transaction_count: totalCount
                    },
                    period: period,
                    currency: 'LTD'
                };
                
                sendSuccess(res, response);
                log('info', 'Balance history fetched', { user_id, period, points: historyPoints.length });
                return;
            } catch (error) {
                log('error', 'Failed to fetch balance history', { user_id, error: error.message });
                log('info', 'error', 'Error obteniendo historial', { error: error.message }); sendError(res, 500, 'Error interno del servidor');
                return;
            }
        }
        
        // ===== TRANSACTION TRACKING ENDPOINTS =====
        
        // Get user transaction history
        if (pathname.startsWith("/api/wallet/transactions/") && (method === "GET" || method === "HEAD")) {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            const userId = authUser.userId;
            
            if (!userId) {
                sendError(res, 400, "user_id es requerido");
                return;
            }
            
            try {
                const contribResult = await dbPostgres.pool.query(
                    `SELECT c.id, c.amount, c.status, c.payment_method, c.created_at, c.updated_at,
                            c.reference_code, g.name as group_name
                     FROM contributions c
                     LEFT JOIN groups g ON c.group_id = g.group_id
                     WHERE c.user_id = $1 ORDER BY c.created_at DESC
                     LIMIT 50`,
                    [userId]
                );
                
                const transactions = contribResult.rows.map(c => ({
                    id: c.id,
                    type: "contribution",
                    amount: parseFloat(c.amount),
                    status: c.status,
                    method: c.payment_method || "cash",
                    description: "Contribucion - " + (c.group_name || "Tanda"),
                    reference: c.reference_code,
                    created_at: c.created_at,
                    updated_at: c.updated_at
                }));
                
                sendSuccess(res, {
                    id: userId,
                    transactions: transactions,
                    total: transactions.length,
                    page: 1,
                    total_pages: 1
                });
                return;
                
            } catch (dbError) {
                log("error", "TRANSACTIONS ERROR:", dbError);
                sendError(res, 500, "Error al obtener transacciones");
                return;
            }
        }
        
        // 1.
        // 1. Track specific deposit transaction
        if (pathname.startsWith('/api/deposit/track/') && (method === 'GET' || method === 'HEAD')) {
            // SECURITY: Require auth + ownership check (was unauthenticated)
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const depositId = pathname.split('/').pop();
            const deposit = await dbPostgres.getDepositByIdAndUser(depositId, authUser.userId);

            if (!deposit) {
                sendError(res, 404, 'Transacción no encontrada');
                return;
            }

            sendSuccess(res, {
                transaction_id: deposit.id,
                current_status: deposit.status,
                status_description: transactionManager.getStateDescription(deposit.status),
                amount: deposit.amount,
                bank_name: deposit.bank_name,
                reference_number: deposit.reference_number,
                created_at: deposit.created_at,
                expires_at: deposit.expires_at,
                status_history: deposit.status_history || [],
                next_actions: getNextActionsForStatus(deposit.status)
            });
            return;
        }

        // 2. Update transaction status (admin only) — PostgreSQL (v4.7.0)
        if (pathname === '/api/deposit/update-status' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            if (authUser.role !== 'admin') {
                sendError(res, 403, 'Solo administradores pueden actualizar el estado de depósitos');
                return;
            }

            const { transaction_id, new_status, reason } = body;
            if (!transaction_id || !new_status) {
                sendError(res, 400, 'transaction_id y new_status son requeridos');
                return;
            }

            // Fetch deposit to validate transition
            const deposit = await dbPostgres.getDepositById(transaction_id);
            if (!deposit) { sendError(res, 404, 'Depósito no encontrado'); return; }

            if (!transactionManager.isValidTransition(deposit.status, new_status)) {
                sendError(res, 400, `Transición inválida de ${deposit.status} a ${new_status}`);
                return;
            }

            // If confirming, use the transactional wallet credit
            if (new_status === 'confirmed') {
                const confirmResult = await dbPostgres.confirmDepositWithWalletCredit(
                    transaction_id,
                    { confirmed_by: authUser.userId, admin_notes: reason || '' },
                    parseFloat(deposit.net_amount),
                    deposit.user_id
                );
                if (!confirmResult.success) { sendError(res, 400, confirmResult.error); return; }
            } else {
                await dbPostgres.updateDepositStatus(transaction_id, new_status, {
                    reason: reason || '',
                    updated_by: authUser.userId
                });
            }

            sendSuccess(res, {
                transaction_id,
                old_status: deposit.status,
                new_status,
                status_description: transactionManager.getStateDescription(new_status),
                updated_by: authUser.userId,
                timestamp: new Date().toISOString()
            });
            return;
        }
        

        // Serve contribution proof images
        if (pathname.startsWith('/api/proof/') && (method === 'GET' || method === 'HEAD')) {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            const filename = pathname.split('/').pop();
            const proofPath = path.join(__dirname, 'proofs', filename);
            
            // Security: prefix check + path traversal defense-in-depth
            if (!filename.startsWith('proof_') || filename.includes('..')) {
                sendError(res, 400, 'Nombre de archivo invalido');
                return;
            }
            const resolvedProof = path.resolve(proofPath);
            if (!resolvedProof.startsWith(path.resolve(__dirname, 'proofs'))) {
                sendError(res, 400, 'Nombre de archivo invalido');
                return;
            }
            
            if (!fs.existsSync(proofPath)) {
                sendError(res, 404, 'Comprobante no encontrado');
                return;
            }
            
            try {
                const fileContent = fs.readFileSync(proofPath);
                
                // Determine content type based on extension
                const ext = path.extname(filename).toLowerCase();
                let contentType = 'image/jpeg';
                if (ext === '.png') contentType = 'image/png';
                if (ext === '.gif') contentType = 'image/gif';
                if (ext === '.webp') contentType = 'image/webp';
                
                res.writeHead(200, {
                    'Content-Type': contentType,
                    'Content-Length': fileContent.length,
                    'Cache-Control': 'public, max-age=86400'
                });
                res.end(fileContent);
            } catch (error) {
                log("error", 'Error serving proof:', error);
                sendError(res, 500, 'Error al servir comprobante');
            }
            return;
        }

        // RECEIPT: Serve receipt images (admin only)
        if (pathname.startsWith('/api/receipt/') && (method === 'GET' || method === 'HEAD')) {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            const filename = pathname.split('/').pop();
            const receiptPath = path.join(__dirname, 'receipts', filename);
            
            // Security: prefix check + path traversal defense-in-depth
            if (!filename.startsWith('receipt_') || filename.includes('..')) {
                sendError(res, 400, 'Nombre de archivo inválido');
                return;
            }
            const resolvedReceipt = path.resolve(receiptPath);
            if (!resolvedReceipt.startsWith(path.resolve(__dirname, 'receipts'))) {
                sendError(res, 400, 'Nombre de archivo inválido');
                return;
            }
            
            if (!fs.existsSync(receiptPath)) {
                sendError(res, 404, 'Comprobante no encontrado');
                return;
            }
            
            try {
                const fileStats = fs.statSync(receiptPath);
                const fileContent = fs.readFileSync(receiptPath);
                
                // Determine content type based on extension
                const ext = path.extname(filename).toLowerCase();
                let contentType = 'application/octet-stream';
                
                switch (ext) {
                    case '.jpg':
                    case '.jpeg':
                        contentType = 'image/jpeg';
                        break;
                    case '.png':
                        contentType = 'image/png';
                        break;
                    case '.webp':
                        contentType = 'image/webp';
                        break;
                    case '.pdf':
                        contentType = 'application/pdf';
                        break;
                }
                
                res.writeHead(200, {                    "Content-Type": contentType,                    "Content-Length": fileStats.size,                    "Content-Disposition": `inline; filename="${filename.replace(/"/g, '_')}"`,                    "Access-Control-Allow-Origin": "https://latanda.online",                    "Access-Control-Allow-Methods": "GET, OPTIONS",                    "Access-Control-Allow-Headers": "Authorization"                });
                res.end(fileContent);
                
            } catch (error) {
                log('error', 'Error serving receipt', { error: error.message });
                sendError(res, 500, 'Error al cargar comprobante');
            }
            return;
        }
        


        // ADMIN: Login endpoint
        if (pathname === '/api/admin/login' && method === 'POST') {
            const { username, password } = body;
            
            if (!username || !password) {
                sendError(res, 400, 'Usuario y contraseña son requeridos');
                return;
            }
            

            // Admin credentials from environment variables (bcrypt hashed)
            const adminUsers = {
                [process.env.ADMIN_SUPER_USERNAME]: {
                    passwordHash: process.env.ADMIN_SUPER_PASSWORD_HASH,
                    role: "super_admin",
                    name: "Administrador Principal",
                    permissions: ["confirm_deposits", "reject_deposits", "view_all_transactions", "manage_users"]
                },
                [process.env.ADMIN_FINANCE_USERNAME]: {
                    passwordHash: process.env.ADMIN_FINANCE_PASSWORD_HASH,
                    role: "finance_manager",
                    name: "Manager Financiero",
                    permissions: ["confirm_deposits", "reject_deposits", "view_all_transactions"]
                },
                [process.env.ADMIN_SUPPORT_USERNAME]: {
                    passwordHash: process.env.ADMIN_SUPPORT_PASSWORD_HASH,
                    role: "support_agent",
                    name: "Agente de Soporte",
                    permissions: ["view_all_transactions"]
                }
            };

            // Get admin user and verify password with bcrypt
            const user = adminUsers[username];
            if (!user || !user.passwordHash) {
                sendError(res, 401, "Credenciales invalidas");
                return;
            }
            
            // Async bcrypt comparison
            const passwordValid = await bcrypt.compare(password, user.passwordHash);
            if (!passwordValid) {
                sendError(res, 401, "Credenciales invalidas");
                return;
            }

            // Check if 2FA is enabled for this admin
            const twoFactorConfig = database.admin_2fa?.[username];
            if (twoFactorConfig?.enabled) {
                // 2FA is required - create pending login token
                const pendingToken = crypto.randomBytes(32).toString("hex");
                database.admin_2fa_pending_login = database.admin_2fa_pending_login || {};
                database.admin_2fa_pending_login[pendingToken] = {
                    username: username,
                    role: user.role,
                    name: user.name,
                    permissions: user.permissions,
                    created_at: new Date().toISOString(),
                    expires_at: new Date(Date.now() + 5 * 60 * 1000).toISOString()
                };
                saveDatabase();
                
                log("info", "Admin login requires 2FA", { username, role: user.role });
                
                sendSuccess(res, {
                    requires_2fa: true,
                    pending_token: pendingToken,
                    message: "Se requiere verificación 2FA"
                });
                return;
            }

            // Generate session token (in production, use JWT or proper session management)
            const sessionToken = crypto.randomBytes(32).toString('hex');
            const expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000); // 8 hours
            
            // Store session (in production, use Redis or database)
            database.admin_sessions = database.admin_sessions || {};
            database.admin_sessions[sessionToken] = {
                username: username,
                role: user.role,
                name: user.name,
                permissions: user.permissions,
                created_at: new Date().toISOString(),
                expires_at: expiresAt.toISOString(),
                last_activity: new Date().toISOString()
            };
            
            saveDatabase();
            
            log('info', 'Admin login successful', { username, role: user.role });
            const adminCI = getClientInfo(req); auditLog("ADMIN_LOGIN", { userId: username, resource: "admin", ip: adminCI.ip, userAgent: adminCI.userAgent });
            
            sendSuccess(res, {
                token: sessionToken,
                user: {
                    username: username,
                    role: user.role,
                    name: user.name,
                    permissions: user.permissions
                },
                expires_at: expiresAt.toISOString(),
                message: 'Login exitoso'
            });
            return;
        }
        

        // ============================================
        // ADMIN 2FA (TOTP) ENDPOINTS - Added 2025-12-15
        // ============================================
        
        // ADMIN: Setup 2FA - Generate QR code
        if (pathname === "/api/admin/2fa/setup" && method === "POST") {
            const adminSession = requireAdminSession(req, res);
            if (!adminSession) return;
            const { admin_username } = body;
            
            if (!admin_username) {
                sendError(res, 400, "Nombre de usuario requerido");
                return;
            }
            
            const secret = speakeasy.generateSecret({
                name: `La Tanda Admin (${admin_username})`,
                issuer: "La Tanda"
            });
            
            try {
                const qrCodeDataUrl = await QRCode.toDataURL(secret.otpauth_url);
                
                database.admin_2fa_pending = database.admin_2fa_pending || {};
                database.admin_2fa_pending[admin_username] = {
                    secret: secret.base32,
                    created_at: new Date().toISOString(),
                    expires_at: new Date(Date.now() + 10 * 60 * 1000).toISOString()
                };
                saveDatabase();
                
                log("info", "2FA setup initiated", { username: admin_username });
                
                sendSuccess(res, {
                    qr_code: qrCodeDataUrl,
                    secret: secret.base32,
                    message: "Escanea el código QR con tu app de autenticación",
                    expires_in: "10 minutos"
                });
            } catch (err) {
                log("error", "2FA QR generation failed", { error: err.message });
                sendError(res, 500, "Error al generar código QR");
            }
            return;
        }
        
        // ADMIN: Verify and Enable 2FA
        if (pathname === "/api/admin/2fa/verify" && method === "POST") {
            const adminSession = requireAdminSession(req, res);
            if (!adminSession) return;
            const { admin_username, totp_code } = body;
            
            if (!admin_username || !totp_code) {
                sendError(res, 400, "Usuario y código TOTP requeridos");
                return;
            }
            
            const pending = database.admin_2fa_pending?.[admin_username];
            if (!pending) {
                sendError(res, 400, "No hay configuración 2FA pendiente");
                return;
            }
            
            if (new Date() > new Date(pending.expires_at)) {
                delete database.admin_2fa_pending[admin_username];
                saveDatabase();
                sendError(res, 400, "La configuración 2FA ha expirado");
                return;
            }
            
            const verified = speakeasy.totp.verify({
                secret: pending.secret,
                encoding: "base32",
                token: totp_code,
                window: 1
            });
            
            if (!verified) {
                sendError(res, 401, "Código TOTP inválido");
                return;
            }
            
            const backupCodes = [];
            for (let i = 0; i < 8; i++) {
                backupCodes.push(crypto.randomBytes(4).toString("hex").toUpperCase());
            }
            
            database.admin_2fa = database.admin_2fa || {};
            database.admin_2fa[admin_username] = {
                secret: pending.secret,
                enabled: true,
                enabled_at: new Date().toISOString(),
                backup_codes: backupCodes.map(code => bcrypt.hashSync(code, 12))
            };
            
            delete database.admin_2fa_pending[admin_username];
            saveDatabase();
            
            log("info", "2FA enabled for admin", { username: admin_username });
            const ci2fa = getClientInfo(req); 
            auditLog("ADMIN_2FA_ENABLED", { userId: admin_username, resource: "2fa", ip: ci2fa.ip, userAgent: ci2fa.userAgent });
            
            sendSuccess(res, {
                enabled: true,
                backup_codes: backupCodes,
                message: "2FA habilitado. GUARDA estos códigos de respaldo."
            });
            return;
        }
        
        // ADMIN: Validate TOTP (for login completion)
        if (pathname === "/api/admin/2fa/validate" && method === "POST") {
            const { admin_username, totp_code, backup_code, pending_token } = body;
            
            if (!admin_username || (!totp_code && !backup_code)) {
                sendError(res, 400, "Usuario y código requeridos");
                return;
            }
            
            const config = database.admin_2fa?.[admin_username];
            if (!config || !config.enabled) {
                sendError(res, 400, "2FA no está habilitado");
                return;
            }
            
            let validated = false;
            let usedBackup = false;
            
            if (totp_code) {
                validated = speakeasy.totp.verify({
                    secret: config.secret,
                    encoding: "base32",
                    token: totp_code,
                    window: 1
                });
            } else if (backup_code) {
                const codeUpper = backup_code.toUpperCase().replace(/[^A-Z0-9]/g, "");
                for (let i = 0; i < config.backup_codes.length; i++) {
                    if (bcrypt.compareSync(codeUpper, config.backup_codes[i])) {
                        validated = true;
                        usedBackup = true;
                        config.backup_codes.splice(i, 1);
                        saveDatabase();
                        break;
                    }
                }
            }
            
            if (!validated) {
                const ci = getClientInfo(req);
                auditLog("ADMIN_2FA_FAILED", { userId: admin_username, resource: "2fa", ip: ci.ip, userAgent: ci.userAgent });
                sendError(res, 401, "Código inválido");
                return;
            }
            
            if (pending_token && database.admin_2fa_pending_login?.[pending_token]) {
                const pendingLogin = database.admin_2fa_pending_login[pending_token];
                if (pendingLogin.username === admin_username && new Date() < new Date(pendingLogin.expires_at)) {
                    const sessionToken = crypto.randomBytes(32).toString("hex");
                    const expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);
                    
                    database.admin_sessions = database.admin_sessions || {};
                    database.admin_sessions[sessionToken] = {
                        username: admin_username,
                        role: pendingLogin.role,
                        name: pendingLogin.name,
                        permissions: pendingLogin.permissions,
                        created_at: new Date().toISOString(),
                        expires_at: expiresAt.toISOString(),
                        last_activity: new Date().toISOString(),
                        two_factor_verified: true
                    };
                    
                    delete database.admin_2fa_pending_login[pending_token];
                    saveDatabase();
                    
                    log("info", "Admin login completed with 2FA", { username: admin_username });
                    const ciLogin = getClientInfo(req);
                    auditLog("ADMIN_LOGIN_2FA", { userId: admin_username, resource: "admin", ip: ciLogin.ip, userAgent: ciLogin.userAgent });
                    
                    sendSuccess(res, {
                        token: sessionToken,
                        user: {
                            username: admin_username,
                            role: pendingLogin.role,
                            name: pendingLogin.name,
                            permissions: pendingLogin.permissions
                        },
                        expires_at: expiresAt.toISOString(),
                        message: "Login exitoso con 2FA"
                    });
                    return;
                }
            }
            
            const ci = getClientInfo(req);
            auditLog("ADMIN_2FA_VERIFIED", { userId: admin_username, resource: "2fa", ip: ci.ip, userAgent: ci.userAgent, usedBackup });
            
            sendSuccess(res, {
                valid: true,
                used_backup: usedBackup,
                remaining_backup_codes: config.backup_codes.length,
                message: usedBackup ? `Código de respaldo usado. Te quedan ${config.backup_codes.length} códigos.` : "Código verificado"
            });
            return;
        }
        
        // ADMIN: Check 2FA Status
        if (pathname === "/api/admin/2fa/status" && method === "POST") {
            // v4.3.0: Require admin session
            if (!requireAdminSession(req, res)) return;
            const { admin_username } = body;
            
            if (!admin_username) {
                sendError(res, 400, "Usuario requerido");
                return;
            }
            
            const config = database.admin_2fa?.[admin_username];
            sendSuccess(res, {
                enabled: config?.enabled || false,
                enabled_at: config?.enabled_at || null,
                backup_codes_remaining: config?.backup_codes?.length || 0
            });
            return;
        }
        
        // ADMIN: Disable 2FA
        if (pathname === "/api/admin/2fa/disable" && method === "POST") {
            const { admin_username, totp_code, password } = body;
            
            if (!admin_username || !password) {
                sendError(res, 400, "Usuario y contraseña requeridos");
                return;
            }
            
            const adminUsers = {
                [process.env.ADMIN_SUPER_USERNAME]: process.env.ADMIN_SUPER_PASSWORD_HASH,
                [process.env.ADMIN_FINANCE_USERNAME]: process.env.ADMIN_FINANCE_PASSWORD_HASH,
                [process.env.ADMIN_SUPPORT_USERNAME]: process.env.ADMIN_SUPPORT_PASSWORD_HASH
            };
            
            const passwordHash = adminUsers[admin_username];
            if (!passwordHash) {
                sendError(res, 401, "Usuario no encontrado");
                return;
            }
            
            const passwordValid = await bcrypt.compare(password, passwordHash);
            if (!passwordValid) {
                sendError(res, 401, "Contraseña incorrecta");
                return;
            }
            
            const config = database.admin_2fa?.[admin_username];
            if (config?.enabled && totp_code) {
                const verified = speakeasy.totp.verify({
                    secret: config.secret,
                    encoding: "base32",
                    token: totp_code,
                    window: 1
                });
                if (!verified) {
                    sendError(res, 401, "Código TOTP inválido");
                    return;
                }
            }
            
            if (database.admin_2fa?.[admin_username]) {
                delete database.admin_2fa[admin_username];
                saveDatabase();
            }
            
            log("info", "2FA disabled for admin", { username: admin_username });
            const ciDisable = getClientInfo(req);
            auditLog("ADMIN_2FA_DISABLED", { userId: admin_username, resource: "2fa", ip: ciDisable.ip, userAgent: ciDisable.userAgent });
            
            sendSuccess(res, {
                disabled: true,
                message: "2FA deshabilitado exitosamente"
            });
            return;
        }


        // ADMIN: Verify session endpoint
        if (pathname === '/api/admin/verify' && method === 'POST') {
            // SECURITY: Require admin JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const { token } = body;
            
            if (!token) {
                sendError(res, 400, 'Token es requerido');
                return;
            }
            
            const session = database.admin_sessions?.[token];
            if (!session) {
                sendError(res, 401, 'Sesión inválida');
                return;
            }
            
            // Check if session is expired
            if (new Date() > new Date(session.expires_at)) {
                delete database.admin_sessions[token];
                saveDatabase();
                sendError(res, 401, 'Sesión expirada');
                return;
            }
            
            // Update last activity
            session.last_activity = new Date().toISOString();
            saveDatabase();
            
            sendSuccess(res, {
                user: {
                    username: session.username,
                    role: session.role,
                    name: session.name,
                    permissions: session.permissions
                },
                expires_at: session.expires_at
            });
            return;
        }
        
        // ADMIN: Logout endpoint
        if (pathname === '/api/admin/logout' && method === 'POST') {
            // SECURITY: Require admin JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const { token } = body;
            
            if (token && database.admin_sessions?.[token]) {
                delete database.admin_sessions[token];
                saveDatabase();
                log('info', 'Admin logout', { username: database.admin_sessions[token]?.username });
            }
            
            sendSuccess(res, { message: 'Logout exitoso' });
            return;
        }

        // ADMIN: Get all pending deposits for manual verification

        // ===============================================
        // ADMIN USER MANAGEMENT ENDPOINTS (Added 2025-12-22)
        // ===============================================

        // GET /api/admin/users - List all users with pagination
        if (pathname === "/api/admin/users" && (method === "GET" || method === "HEAD")) {
            const adminSession = requireAdminSession(req, res);
            if (!adminSession) return;

            try {
                const page = parseInt(query.page) || 1;
                const limit = Math.min(parseInt(query.limit) || 20, 100);
                const offset = (page - 1) * limit;
                const search = query.search || "";
                const status = query.status || "";

                let whereClause = "WHERE 1=1";
                const params = [];
                let paramCount = 0;

                if (search) {
                    paramCount++;
                    whereClause += ` AND (LOWER(name) LIKE $${paramCount} OR LOWER(email) LIKE $${paramCount})`;
                    params.push("%" + search.toLowerCase() + "%");
                }
                if (status) {
                    paramCount++;
                    whereClause += ` AND status = $${paramCount}`;
                    params.push(status);
                }

                const countResult = await dbPostgres.pool.query(
                    `SELECT COUNT(*) as total FROM users ${whereClause}`, params
                );
                const total = parseInt(countResult.rows[0].total);

                const usersResult = await dbPostgres.pool.query(
                    `SELECT user_id, name, email, phone, verification_level, status, 
                            total_contributions, avatar_url, email_verified, created_at, last_app_access
                     FROM users ${whereClause}
                     ORDER BY created_at DESC
                     LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}`,
                    [...params, limit, offset]
                );

                sendSuccess(res, {
                    users: usersResult.rows.map(u => ({
                        id: u.user_id, name: u.name, email: u.email, phone: u.phone,
                        verification_level: u.verification_level, status: u.status,
                        total_contributions: parseFloat(u.total_contributions) || 0,
                        avatar_url: u.avatar_url, email_verified: u.email_verified,
                        created_at: u.created_at, last_active: u.last_app_access
                    })),
                    pagination: { page, limit, total, total_pages: Math.ceil(total / limit) }
                });
                return;
            } catch (error) {
                sendError(res, 500, "Error al obtener usuarios");
                return;
            }
        }

        // GET /api/admin/users/stats - User statistics
        if (pathname === "/api/admin/users/stats" && method === "GET") {
            const adminSession = requireAdminSession(req, res);
            if (!adminSession) return;

            try {
                const stats = await dbPostgres.pool.query(`
                    SELECT COUNT(*) as total,
                        COUNT(CASE WHEN status = 'active' THEN 1 END) as active,
                        COUNT(CASE WHEN status = 'suspended' THEN 1 END) as suspended,
                        COUNT(CASE WHEN email_verified = true THEN 1 END) as verified,
                        COUNT(CASE WHEN verification_level = 'full' THEN 1 END) as kyc_complete,
                        COUNT(CASE WHEN created_at > NOW() - INTERVAL '7 days' THEN 1 END) as new_week
                    FROM users
                `);
                const s = stats.rows[0];
                sendSuccess(res, {
                    total: parseInt(s.total), active: parseInt(s.active),
                    suspended: parseInt(s.suspended), verified: parseInt(s.verified),
                    kyc_complete: parseInt(s.kyc_complete), new_this_week: parseInt(s.new_week)
                });
                return;
            } catch (error) {
                sendError(res, 500, "Error stats");
                return;
            }
        }

        // PUT /api/admin/users/:id/status - Update user status
        if (pathname.match(/^\/api\/admin\/users\/[^/]+\/status$/) && method === "PUT") {
            const adminSession = requireAdminSession(req, res);
            if (!adminSession) return;

            const userId = pathname.split("/")[4];
            const { status, reason } = body;

            if (!["active", "suspended", "banned"].includes(status)) {
                sendError(res, 400, "Estado invalido");
                return;
            }

            try {
                await dbPostgres.pool.query(
                    "UPDATE users SET status = $1, updated_at = NOW() WHERE user_id = $2",
                    [status, userId]
                );
                auditLog("ADMIN_USER_STATUS_CHANGE", { userId: "admin", resourceId: userId, extra: { status, reason } });
                sendSuccess(res, { message: "Estado actualizado", user_id: userId, status });
                return;
            } catch (error) {
                sendError(res, 500, "Error al actualizar");
                return;
            }
        }

        if (pathname === '/api/admin/deposits/pending' && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            if (authUser.role !== 'admin') { sendError(res, 403, 'Solo administradores'); return; }

            try {
                const deposits = await dbPostgres.getPendingDeposits();
                const pendingDeposits = deposits.map(deposit => ({
                    id: deposit.id,
                    user_id: deposit.user_id,
                    type: deposit.type,
                    amount: deposit.amount,
                    net_amount: deposit.net_amount,
                    bank_name: deposit.bank_name,
                    reference_number: deposit.reference_number,
                    user_account_number: deposit.user_account_number,
                    status: deposit.status,
                    status_description: transactionManager.getStateDescription(deposit.status),
                    created_at: deposit.created_at,
                    estimated_completion: deposit.estimated_completion,
                    time_remaining: deposit.expires_at ?
                        Math.max(0, new Date(deposit.expires_at) - new Date()) / (1000 * 60 * 60) : null,
                    receipt: deposit.receipt ? {
                        filename: deposit.receipt.filename,
                        original_name: deposit.receipt.original_name,
                        uploaded_at: deposit.receipt.uploaded_at,
                        size: deposit.receipt.file_size,
                        security_flags: deposit.receipt.security_flags || [],
                        requires_manual_review: deposit.receipt.requires_manual_review || false,
                        validation_status: deposit.receipt.validation_status || 'pending'
                    } : null,
                    security_score: deposit.receipt?.security_flags?.length || 0,
                    priority: deposit.receipt?.requires_manual_review ? 'high' : 'normal'
                }));

                sendSuccess(res, {
                    pending_deposits: pendingDeposits,
                    total_pending: pendingDeposits.length,
                    total_amount: pendingDeposits.reduce((sum, d) => sum + parseFloat(d.amount || 0), 0),
                    banks_summary: pendingDeposits.reduce((acc, d) => {
                        if (d.bank_name) acc[d.bank_name] = (acc[d.bank_name] || 0) + 1;
                        return acc;
                    }, {})
                });
            } catch (dbErr) {
                log('error', 'Failed to get pending deposits', { error: dbErr.message });
                sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // ADMIN: Confirm a deposit manually — PostgreSQL transactional (v4.7.0)
        if (pathname === '/api/admin/deposits/confirm' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            if (authUser.role !== 'admin') { sendError(res, 403, 'Solo administradores'); return; }

            const { deposit_id, admin_notes, received_amount } = body;
            if (!deposit_id) { sendError(res, 400, 'deposit_id es requerido'); return; }

            // Fetch deposit first for response data
            const deposit = await dbPostgres.getDepositById(deposit_id);
            if (!deposit) { sendError(res, 404, 'Depósito no encontrado'); return; }

            const netAmount = parseFloat(deposit.net_amount);
            const result = await dbPostgres.confirmDepositWithWalletCredit(
                deposit_id,
                {
                    confirmed_by: authUser.userId,
                    admin_notes: admin_notes || '',
                    received_amount: received_amount || deposit.amount
                },
                netAmount,
                deposit.user_id
            );

            if (!result.success) { sendError(res, 400, result.error); return; }

            sendDepositNotification({
                type: 'deposit_confirmed',
                deposit,
                user_id: deposit.user_id,
                admin_id: authUser.userId
            });

            sendSuccess(res, {
                deposit_id,
                user_id: deposit.user_id,
                old_status: deposit.status,
                new_status: 'confirmed',
                confirmed_by: authUser.userId,
                confirmed_at: new Date().toISOString(),
                amount: deposit.amount,
                net_amount: deposit.net_amount,
                received_amount: received_amount || deposit.amount,
                admin_notes: admin_notes || '',
                message: 'Depósito confirmado exitosamente'
            });
            return;
        }

        // ADMIN: Reject a deposit manually — PostgreSQL (v4.7.0)
        if (pathname === '/api/admin/deposits/reject' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            if (authUser.role !== 'admin') { sendError(res, 403, 'Solo administradores'); return; }

            const { deposit_id, rejection_reason, admin_notes } = body;
            if (!deposit_id || !rejection_reason) {
                sendError(res, 400, 'deposit_id y rejection_reason son requeridos');
                return;
            }

            const result = await dbPostgres.rejectDeposit(deposit_id, {
                rejected_by: authUser.userId,
                rejection_reason,
                admin_notes: admin_notes || ''
            });

            if (!result) { sendError(res, 404, 'Depósito no encontrado o no está pendiente'); return; }

            // Fetch full deposit for notification
            const deposit = await dbPostgres.getDepositById(deposit_id);

            sendDepositNotification({
                type: 'deposit_rejected',
                deposit: deposit || { id: deposit_id, amount: 0, reference_number: '' },
                user_id: result.user_id,
                admin_id: authUser.userId,
                rejection_reason,
                admin_notes: admin_notes || ''
            });

            sendSuccess(res, {
                deposit_id,
                user_id: result.user_id,
                old_status: 'pending',
                new_status: 'failed',
                rejected_by: authUser.userId,
                rejected_at: new Date().toISOString(),
                rejection_reason,
                admin_notes: admin_notes || '',
                message: 'Depósito rechazado exitosamente'
            });
            return;
        }

        // 3. Cancel a pending deposit — PostgreSQL (v4.7.0)
        if (pathname === '/api/deposit/cancel' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { deposit_id, reason = 'cancelled_by_user' } = body;
            if (!deposit_id) { sendError(res, 400, 'deposit_id es requerido'); return; }

            const result = await dbPostgres.cancelDeposit(deposit_id, authUser.userId, reason);
            if (!result) { sendError(res, 404, 'Depósito no encontrado o no está pendiente'); return; }

            sendSuccess(res, {
                deposit_id,
                user_id: authUser.userId,
                old_status: 'pending_transfer',
                new_status: 'cancelled',
                reason,
                cancelled_at: new Date().toISOString(),
                message: 'Depósito cancelado exitosamente'
            });
            return;
        }

        // 4. Modify a pending deposit — PostgreSQL (v4.7.0)
        if (pathname === '/api/deposit/modify' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { deposit_id, new_amount, new_account_number } = body;
            if (!deposit_id || !new_amount) { sendError(res, 400, 'deposit_id y new_amount son requeridos'); return; }

            const parsedAmount = parseFloat(new_amount);
            if (!Number.isFinite(parsedAmount) || parsedAmount < 10 || parsedAmount > 250000) {
                sendError(res, 400, 'El monto debe estar entre L. 10 y L. 250,000');
                return;
            }

            const result = await dbPostgres.modifyDeposit(deposit_id, authUser.userId, {
                new_amount: parsedAmount,
                new_account_number: new_account_number || null
            });

            if (!result) { sendError(res, 404, 'Depósito no encontrado o no está pendiente'); return; }

            sendSuccess(res, {
                deposit_id,
                user_id: authUser.userId,
                old_amount: result.old_amount,
                new_amount: result.new_amount,
                old_reference: result.old_reference,
                new_reference: result.new_reference,
                net_amount: result.net_amount,
                transaction_fee: result.transaction_fee,
                modified_at: new Date().toISOString(),
                message: 'Depósito modificado exitosamente'
            });
            return;
        }

        // 5. Extend deposit expiration time — PostgreSQL (v4.7.0)
        if (pathname === '/api/deposit/extend' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { deposit_id, extension_hours } = body;
            if (!deposit_id || !extension_hours) { sendError(res, 400, 'deposit_id y extension_hours son requeridos'); return; }

            const parsedHours = parseInt(extension_hours, 10);
            if (!Number.isFinite(parsedHours) || parsedHours < 1 || parsedHours > 72) {
                sendError(res, 400, 'extension_hours debe estar entre 1 y 72 horas');
                return;
            }

            const result = await dbPostgres.extendDeposit(deposit_id, authUser.userId, parsedHours);

            if (!result.found) { sendError(res, 404, 'Depósito no encontrado o no está pendiente'); return; }
            if (result.already_extended) { sendError(res, 400, 'Este depósito ya ha sido extendido anteriormente'); return; }

            sendSuccess(res, {
                deposit_id,
                user_id: authUser.userId,
                extension_hours: parsedHours,
                old_expiry_date: result.old_expiry,
                new_expiry_date: result.new_expiry,
                extended_at: new Date().toISOString(),
                extension_count: result.extension_count,
                message: `Tiempo extendido por ${parsedHours} horas`
            });
            return;
        }
        
        // 6. Get all transactions for user with status filtering
        if (pathname === '/api/user/transactions' && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            const userId = authUser.userId;
            const limit = Math.min(parseInt(body.limit) || 20, 50);
            const offset = parseInt(body.offset) || 0;

            try {
                let filterClause = '';
                const params = [userId, limit, offset];

                if (body.status_filter && Array.isArray(body.status_filter) && body.status_filter.length > 0) {
                    const validStatuses = body.status_filter.filter(s => typeof s === 'string').slice(0, 10);
                    if (validStatuses.length > 0) {
                        params.push(validStatuses);
                        filterClause = ' AND wt.status = ANY($' + params.length + ')';
                    }
                }

                const result = await dbPostgres.pool.query(
                    'SELECT wt.id, wt.type, wt.amount, wt.currency, wt.description, wt.status, wt.created_at' +
                    ' FROM wallet_transactions wt WHERE wt.user_id = $1' + filterClause +
                    ' ORDER BY wt.created_at DESC LIMIT $2 OFFSET $3',
                    params
                );

                const countParams = [userId];
                let countFilter = '';
                if (body.status_filter && Array.isArray(body.status_filter) && body.status_filter.length > 0) {
                    const validCountStatuses = body.status_filter.filter(s => typeof s === 'string').slice(0, 10);
                    if (validCountStatuses.length > 0) {
                        countParams.push(validCountStatuses);
                        countFilter = ' AND status = ANY($' + countParams.length + ')';
                    }
                }
                const countResult = await dbPostgres.pool.query(
                    'SELECT COUNT(*) as total FROM wallet_transactions WHERE user_id = $1' + countFilter,
                    countParams
                );

                const total = parseInt(countResult.rows[0]?.total) || 0;

                sendSuccess(res, {
                    transactions: result.rows.map(t => ({
                        id: t.id,
                        type: t.type,
                        status: t.status,
                        amount: t.amount,
                        currency: t.currency,
                        description: t.description,
                        created_at: t.created_at
                    })),
                    pagination: {
                        total,
                        limit,
                        offset,
                        has_more: (offset + limit) < total
                    }
                });
            } catch (error) {
                log('error', '[TRANSACTIONS] Error: ' + error.message);
                sendError(res, 500, 'Error al obtener transacciones');
            }
            return;
        }

        // Verification endpoints
        if (pathname === '/api/verification/phone/send' && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticacion requerida");
                return;
            }

            const { user_id, phone_number } = body;
            const verificationId = generateId('verify');
            sendSuccess(res, {
                message: 'Código de verificación enviado',
                verification_id: verificationId,
                phone_number,
                expires_in: 600 // 10 minutes
            });
            return;
        }

        // ============================================
        // USER PROFILE ENDPOINTS (GET & PUT)
        // ============================================

        // GET user profile from PostgreSQL
        if (pathname === '/api/user/profile' && (method === 'GET' || method === 'HEAD')) {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const userId = authUser.userId;

            try {
                const result = await dbPostgres.pool.query(
                    'SELECT user_id, name, email, phone, location, bio, avatar_url, preferences, birth_date, gender, created_at, last_login, role, verification_level, email_verified FROM users WHERE user_id = $1',
                    [userId]
                );

                if (result.rows.length === 0) {
                    sendError(res, 404, 'Usuario no encontrado');
                    return;
                }

                const user = result.rows[0];
                sendResponse(res, 200, {
                    success: true,
                    user: {
                        id: user.user_id,
                        name: user.name,
                        email: user.email,
                        phone: user.phone || '',
                        location: user.location || '',
                        bio: user.bio || '',
                        avatar_url: user.avatar_url || '',
                        preferences: user.preferences || {},
                        birth_date: user.birth_date || null,
                        gender: user.gender || '',
                        created_at: user.created_at,
                        last_login: user.last_login,
                        role: user.role || "user",
                        verification_level: user.verification_level || "basic",
                        email_verified: user.email_verified || false
                    }
                });
                return;
            } catch (error) {
                log('error', 'Error fetching user profile: ' + error.message);
                sendError(res, 500, 'Error al obtener perfil');
                return;
            }
        }

        // PUT (update) user profile in PostgreSQL
        if (pathname === '/api/user/profile' && (method === 'PUT' || method === 'PATCH')) {
            // REQUIRE JWT authentication for profile changes
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const { name, phone, location, bio, avatar_url, preferences, birth_date, gender } = body;
            const user_id = authUser.userId;
            if (!user_id) {
                sendError(res, 400, 'user_id es requerido');
                return;
            }

            // Validations
            if (name && (name.length < 2 || name.length > 100)) {
                sendError(res, 400, 'El nombre debe tener entre 2 y 100 caracteres');
                return;
            }

            if (phone && !/^[+]?[\d\s-]{7,20}$/.test(phone)) {
                sendError(res, 400, 'Formato de telefono invalido');
                return;
            }

            if (bio && bio.length > 500) {
                sendError(res, 400, 'La biografia no puede exceder 500 caracteres');
                return;
            }

            if (gender && !['male', 'female', 'other', 'prefer_not_say', ''].includes(gender)) {
                sendError(res, 400, 'Genero invalido');
                return;
            }

            try {
                // Build dynamic update query
                const updates = [];
                const values = [];
                let paramIndex = 1;

                if (name !== undefined) { updates.push('name = $' + paramIndex++); values.push(name); }
                if (phone !== undefined) { updates.push('phone = $' + paramIndex++); values.push(phone); }
                if (location !== undefined) { updates.push('location = $' + paramIndex++); values.push(location); }
                if (bio !== undefined) { updates.push('bio = $' + paramIndex++); values.push(bio); }
                if (avatar_url !== undefined) { updates.push('avatar_url = $' + paramIndex++); values.push(avatar_url); }
                if (preferences !== undefined) { updates.push('preferences = $' + paramIndex++); values.push(JSON.stringify(preferences)); }
                if (birth_date !== undefined) { updates.push('birth_date = $' + paramIndex++); values.push(birth_date); }
                if (gender !== undefined) { updates.push('gender = $' + paramIndex++); values.push(gender); }

                // Always update last_login
                updates.push('last_login = NOW()');

                if (updates.length === 1) {
                    sendError(res, 400, 'No hay campos para actualizar');
                    return;
                }

                values.push(user_id);
                const updateQuery = 'UPDATE users SET ' + updates.join(', ') + ' WHERE user_id = $' + paramIndex + ' RETURNING user_id, name, email, phone, location, bio, avatar_url, preferences, birth_date, gender';

                const result = await dbPostgres.pool.query(updateQuery, values);

                if (result.rows.length === 0) {
                    sendError(res, 404, 'Usuario no encontrado');
                    return;
                }

                const updated = result.rows[0];
                log('info', 'Profile updated for user: ' + user_id);

// Audit log for profile update                const profileClientInfo = getClientInfo(req);                auditLog("PROFILE_UPDATED", {                    userId: user_id,                    resource: "users",                    resourceId: user_id,                    ip: profileClientInfo.ip,                    userAgent: profileClientInfo.userAgent,                    extra: { fields: Object.keys(body).filter(k => k !== 'user_id') }                });
                sendResponse(res, 200, {
                    success: true,
                    message: 'Perfil actualizado correctamente',
                    user: {
                        id: updated.user_id,
                        name: updated.name,
                        email: updated.email,
                        phone: updated.phone || '',
                        location: updated.location || '',
                        bio: updated.bio || '',
                        avatar_url: updated.avatar_url || '',
                        preferences: updated.preferences || {},
                        birth_date: updated.birth_date || null,
                        gender: updated.gender || ''
                    }
                });
                return;
            } catch (error) {
                log('error', 'Error updating user profile: ' + error.message);
                sendError(res, 500, 'Error al actualizar perfil');
                return;
            }
        }



        // ============================================

        // ============================================
        // REFERRAL SYSTEM ENDPOINTS
        // ============================================

        // Helper: Generate unique referral code
        function generateReferralCode(userId) {
            const prefix = userId.replace('user_', '').substring(0, 4).toUpperCase();
            const random = crypto.randomBytes(4).toString('hex').substring(0, 4).toUpperCase();
            return `LT${prefix}${random}`;
        }

        // GET /api/referrals/my-code - Get or create user's referral code
        if (pathname === '/api/referrals/my-code' && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                // Check if user already has a referral code
                let userResult = await dbPostgres.pool.query(
                    'SELECT referral_code, referral_count FROM users WHERE user_id = $1',
                    [authUser.userId]
                );

                let referralCode = userResult.rows[0]?.referral_code;

                // Generate code if doesn't exist
                if (!referralCode) {
                    referralCode = generateReferralCode(authUser.userId);
                    await dbPostgres.pool.query(
                        'UPDATE users SET referral_code = $1 WHERE user_id = $2',
                        [referralCode, authUser.userId]
                    );
                }

                // Get referral stats
                const statsResult = await dbPostgres.pool.query(`
                    SELECT
                        COUNT(*) FILTER (WHERE status = 'pending') as pending,
                        COUNT(*) FILTER (WHERE status = 'registered') as registered,
                        COUNT(*) FILTER (WHERE status = 'verified') as verified,
                        COUNT(*) FILTER (WHERE status = 'rewarded') as rewarded,
                        COALESCE(SUM(reward_amount), 0) as total_rewards
                    FROM user_referrals
                    WHERE referrer_id = $1
                `, [authUser.userId]);

                const stats = statsResult.rows[0];

                sendResponse(res, 200, {
                    success: true,
                    referral_code: referralCode,
                    referral_link: `https://latanda.online/auth-enhanced.html?ref=${referralCode}`,
                    stats: {
                        pending: parseInt(stats.pending) || 0,
                        registered: parseInt(stats.registered) || 0,
                        verified: parseInt(stats.verified) || 0,
                        rewarded: parseInt(stats.rewarded) || 0,
                        total_rewards: parseFloat(stats.total_rewards) || 0
                    }
                });
                return;

            } catch (error) {
                log('error', 'Error getting referral code: ' + error.message);
                sendError(res, 500, 'Error al obtener codigo de referido');
                return;
            }
        }

        // GET /api/referrals/list - Get user's referrals list
        if (pathname === '/api/referrals/list' && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                const result = await dbPostgres.pool.query(`
                    SELECT
                        r.id,
                        r.referral_code,
                        r.referred_email,
                        r.status,
                        r.reward_amount,
                        r.created_at,
                        r.registered_at,
                        r.rewarded_at,
                        u.name as referred_name,
                        u.email as referred_user_email
                    FROM user_referrals r
                    LEFT JOIN users u ON r.referred_user_id = u.user_id
                    WHERE r.referrer_id = $1
                    ORDER BY r.created_at DESC
                    LIMIT 50
                `, [authUser.userId]);

                sendResponse(res, 200, {
                    success: true,
                    referrals: result.rows,
                    total: result.rows.length
                });
                return;

            } catch (error) {
                log('error', 'Error listing referrals: ' + error.message);
                sendError(res, 500, 'Error al listar referidos');
                return;
            }
        }

        // POST /api/referrals/send - Send referral invitation (optional email)
        if (pathname === '/api/referrals/send' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                const { email, name, message } = body;

                // Get or create referral code
                let userResult = await dbPostgres.pool.query(
                    'SELECT referral_code FROM users WHERE user_id = $1',
                    [authUser.userId]
                );

                let referralCode = userResult.rows[0]?.referral_code;
                if (!referralCode) {
                    referralCode = generateReferralCode(authUser.userId);
                    await dbPostgres.pool.query(
                        'UPDATE users SET referral_code = $1 WHERE user_id = $2',
                        [referralCode, authUser.userId]
                    );
                }

                // Create referral record
                const referralId = 'ref_' + Date.now() + crypto.randomBytes(6).toString('hex');

                await dbPostgres.pool.query(`
                    INSERT INTO user_referrals (id, referrer_id, referral_code, referred_email, status)
                    VALUES ($1, $2, $3, $4, 'pending')
                `, [referralId, authUser.userId, referralCode, email || null]);

                const referralLink = `https://latanda.online/auth-enhanced.html?ref=${referralCode}`;

                // TODO: Send email if provided
                // if (email) { await sendReferralEmail(email, referralLink, message); }

                // Audit log
                auditLog('REFERRAL_SENT', {
                    referrer_id: authUser.userId,
                    referral_code: referralCode,
                    email: email || 'no email'
                });

                sendResponse(res, 200, {
                    success: true,
                    message: 'Invitacion de referido creada',
                    referral_id: referralId,
                    referral_code: referralCode,
                    referral_link: referralLink
                });
                return;

            } catch (error) {
                log('error', 'Error sending referral: ' + error.message);
                sendError(res, 500, 'Error al enviar referido');
                return;
            }
        }

        // GET /api/referrals/validate/:code - Validate a referral code (public)
        if (pathname.match(/^\/api\/referrals\/validate\/[A-Z0-9]+$/i) && method === 'GET') {
            const code = pathname.split('/').pop().toUpperCase();

            try {
                const result = await dbPostgres.pool.query(`
                    SELECT u.user_id, u.name, u.referral_count
                    FROM users u
                    WHERE u.referral_code = $1
                `, [code]);

                if (result.rows.length === 0) {
                    sendError(res, 404, 'Codigo de referido no valido');
                    return;
                }

                const referrer = result.rows[0];

                sendResponse(res, 200, {
                    success: true,
                    valid: true,
                    referrer_name: referrer.name,
                    referral_count: referrer.referral_count,
                    benefits: {
                        new_user: '50 LTD de bono de bienvenida',
                        referrer: '25 LTD por cada referido verificado'
                    }
                });
                return;

            } catch (error) {
                log('error', 'Error validating referral: ' + error.message);
                sendError(res, 500, 'Error al validar codigo');
                return;
            }
        }

        // POST /api/referrals/apply - Apply referral code during registration (called internally)
        if (pathname === '/api/referrals/apply' && method === 'POST') {
            // Require internal cron key or JWT auth
            const cronKey = req.headers['x-cron-key'];
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser && !safeCompare(String(cronKey || ''), String(process.env.CRON_SECRET_KEY || ''))) {
                sendError(res, 401, "Autenticacion requerida");
                return;
            }

            try {
                const { referral_code, new_user_id, new_user_email } = body;

                // ============================================
                // SECURITY FIX: Verify user created recently (2025-12-31)
                // Prevents referral count manipulation
                // ============================================
                if (new_user_id) {
                    const userCheck = await dbPostgres.pool.query(
                        "SELECT created_at FROM users WHERE user_id = $1 AND created_at > NOW() - INTERVAL '60 seconds'",
                        [new_user_id]
                    );
                    if (userCheck.rows.length === 0) {
                        sendError(res, 403, "Solo se puede aplicar codigo al registrarse");
                        return;
                    }
                }

                if (!referral_code || !new_user_id) {
                    sendError(res, 400, 'Codigo y usuario requeridos');
                    return;
                }

                // Find referrer
                const referrerResult = await dbPostgres.pool.query(
                    'SELECT user_id FROM users WHERE referral_code = $1',
                    [referral_code.toUpperCase()]
                );

                if (referrerResult.rows.length === 0) {
                    sendError(res, 404, 'Codigo de referido no encontrado');
                    return;
                }

                const referrerId = referrerResult.rows[0].user_id;

                // Update or create referral record
                await dbPostgres.pool.query(`
                    INSERT INTO user_referrals (referrer_id, referral_code, referred_user_id, referred_email, status, registered_at)
                    VALUES ($1, $2, $3, $4, 'registered', NOW())
                    ON CONFLICT (referral_code)
                    DO UPDATE SET
                        referred_user_id = $3,
                        status = 'registered',
                        registered_at = NOW()
                `, [referrerId, referral_code.toUpperCase(), new_user_id, new_user_email]);

                // Update new user's referred_by
                await dbPostgres.pool.query(
                    'UPDATE users SET referred_by = $1 WHERE user_id = $2',
                    [referrerId, new_user_id]
                );

                // Increment referrer's count
                await dbPostgres.pool.query(
                    'UPDATE users SET referral_count = COALESCE(referral_count, 0) + 1 WHERE user_id = $1',
                    [referrerId]
                );

                // Audit log
                auditLog('REFERRAL_APPLIED', {
                    referrer_id: referrerId,
                    new_user_id: new_user_id,
                    referral_code: referral_code
                });

                sendResponse(res, 200, {
                    success: true,
                    message: 'Codigo de referido aplicado',
                    referrer_id: referrerId
                });
                return;

            } catch (error) {
                log('error', 'Error applying referral: ' + error.message);
                sendError(res, 500, 'Error al aplicar referido');
                return;
            }
        }



        // ============================================
        // MINING SYSTEM ENDPOINTS
        // ============================================

        // GET /api/platform/state - Get platform state (testnet/mainnet)
        if (pathname === '/api/platform/state' && method === 'GET') {
            try {
                const result = await dbPostgres.pool.query(
                    'SELECT state, testnet_start_date, mainnet_launch_date, conversion_enabled FROM platform_state LIMIT 1'
                );

                const state = result.rows[0] || { state: 'testnet' };

                sendResponse(res, 200, {
                    success: true,
                    platform: {
                        state: state.state,
                        is_testnet: state.state === 'testnet',
                        is_mainnet: state.state === 'mainnet',
                        testnet_start: state.testnet_start_date,
                        mainnet_launch: state.mainnet_launch_date,
                        conversion_enabled: state.conversion_enabled,
                        token_disclaimer: state.state === 'testnet'
                            ? 'Los tokens LTD son tokens de prueba. Seran convertibles 1:1 a tokens mainnet cuando la plataforma lance.'
                            : null
                    }
                });
            } catch (error) {
                log('error', 'Platform state error: ' + error.message);
                sendError(res, 500, 'Error al obtener estado de plataforma');
            }
            return;
        }

        // GET /api/mining/status - Get user mining status
        if (pathname === '/api/mining/status' && method === 'GET') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                // Get platform state
                const platformResult = await dbPostgres.pool.query(
                    'SELECT state FROM platform_state LIMIT 1'
                );
                const platformState = platformResult.rows[0]?.state || 'testnet';

                // Get or create mining status
                let statusResult = await dbPostgres.pool.query(
                    'SELECT id, user_id, current_tier, achievement_points, mining_streak, longest_streak, last_claim_at, next_claim_available_at, total_claims, testnet_ltd_mined, mainnet_ltd_converted, conversion_eligible, fraud_flags, created_at, updated_at FROM user_mining_status WHERE user_id = $1',
                    [authUser.userId]
                );

                if (statusResult.rows.length === 0) {
                    await dbPostgres.pool.query(
                        'INSERT INTO user_mining_status (user_id) VALUES ($1)',
                        [authUser.userId]
                    );
                    statusResult = await dbPostgres.pool.query(
                        'SELECT id, user_id, current_tier, achievement_points, mining_streak, longest_streak, last_claim_at, next_claim_available_at, total_claims, testnet_ltd_mined, mainnet_ltd_converted, conversion_eligible, fraud_flags, created_at, updated_at FROM user_mining_status WHERE user_id = $1',
                        [authUser.userId]
                    );
                }

                const status = statusResult.rows[0];
                const now = new Date();

                // Calculate tier
                const tierInfo = await calculateUserTier(authUser.userId);

                // Get tier config
                const tierConfig = await dbPostgres.pool.query(
                    'SELECT tier_name, min_points, max_points, base_daily_reward, streak_multiplier, max_streak_bonus, display_name, display_color FROM tier_requirements WHERE tier_name = $1',
                    [tierInfo.tier]
                );
                const tier = tierConfig.rows[0];

                // Check if can claim
                let canClaim = true;
                let timeUntilClaim = 0;
                if (status.next_claim_available_at) {
                    const nextClaim = new Date(status.next_claim_available_at);
                    if (nextClaim > now) {
                        canClaim = false;
                        timeUntilClaim = nextClaim - now;
                    }
                }

                // Calculate potential reward
                const baseReward = parseFloat(tier.base_daily_reward);
                const streakBonus = Math.min(
                    status.mining_streak * parseFloat(tier.streak_multiplier) * baseReward,
                    parseFloat(tier.max_streak_bonus)
                );

                sendResponse(res, 200, {
                    success: true,
                    platform_state: platformState,
                    mining: {
                        can_claim: canClaim,
                        time_until_claim_ms: timeUntilClaim,
                        time_formatted: formatTimeRemaining(timeUntilClaim),
                        current_streak: status.mining_streak,
                        longest_streak: status.longest_streak,
                        total_claims: status.total_claims,
                        testnet_ltd_mined: parseFloat(status.testnet_ltd_mined) || 0,
                        mainnet_ltd_converted: parseFloat(status.mainnet_ltd_converted) || 0,
                        conversion_eligible: status.conversion_eligible
                    },
                    tier: {
                        name: tierInfo.tier,
                        display_name: tier.display_name,
                        color: tier.display_color,
                        base_reward: baseReward,
                        potential_reward: baseReward + streakBonus,
                        streak_bonus: streakBonus,
                        points: tierInfo.points,
                        points_to_next: tierInfo.pointsToNextTier,
                        next_tier: tierInfo.nextTier
                    },
                    token_info: {
                        type: platformState === 'testnet' ? 'TEST_LTD' : 'LTD',
                        disclaimer: platformState === 'testnet'
                            ? 'Tokens de prueba - convertibles 1:1 en mainnet'
                            : 'Tokens oficiales en blockchain'
                    }
                });
            } catch (error) {
                log('error', 'Mining status error: ' + error.message);
                sendError(res, 500, 'Error al obtener estado de minado');
            }
            return;
        }

        // POST /api/mining/claim - Claim daily mining reward
        if (pathname === '/api/mining/claim' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                // Get platform state
                const platformResult = await dbPostgres.pool.query(
                    'SELECT state FROM platform_state LIMIT 1'
                );
                const platformState = platformResult.rows[0]?.state || 'testnet';

                // v4.0.0: All reads + cooldown check inside transaction with FOR UPDATE to prevent double-claim
                const client = await dbPostgres.pool.connect();
                try {
                    await client.query('BEGIN');

                    // Get mining status with row lock
                    let statusResult = await client.query(
                        'SELECT id, user_id, current_tier, achievement_points, mining_streak, longest_streak, last_claim_at, next_claim_available_at, total_claims, testnet_ltd_mined, mainnet_ltd_converted, conversion_eligible, fraud_flags, created_at, updated_at FROM user_mining_status WHERE user_id = $1 FOR UPDATE',
                        [authUser.userId]
                    );

                    if (statusResult.rows.length === 0) {
                        await client.query(
                            'INSERT INTO user_mining_status (user_id) VALUES ($1)',
                            [authUser.userId]
                        );
                        statusResult = await client.query(
                            'SELECT id, user_id, current_tier, achievement_points, mining_streak, longest_streak, last_claim_at, next_claim_available_at, total_claims, testnet_ltd_mined, mainnet_ltd_converted, conversion_eligible, fraud_flags, created_at, updated_at FROM user_mining_status WHERE user_id = $1 FOR UPDATE',
                            [authUser.userId]
                        );
                    }

                    const status = statusResult.rows[0];
                    const now = new Date();

                    // Check 24h cooldown (inside transaction with FOR UPDATE -- prevents double-claim race)
                    if (status.next_claim_available_at && new Date(status.next_claim_available_at) > now) {
                        const remaining = new Date(status.next_claim_available_at) - now;
                        await client.query('ROLLBACK');
                        client.release();
                        sendError(res, 429, 'Espera ' + formatTimeRemaining(remaining) + ' para tu siguiente minado');
                        return;
                    }

                    // Calculate tier and rewards
                    const tierInfo = await calculateUserTier(authUser.userId);
                    const tierConfig = await client.query(
                        'SELECT tier_name, min_points, max_points, base_daily_reward, streak_multiplier, max_streak_bonus, display_name, display_color FROM tier_requirements WHERE tier_name = $1',
                        [tierInfo.tier]
                    );
                    const tier = tierConfig.rows[0];

                    // Calculate streak (48h window for continuation)
                    let newStreak = 1;
                    if (status.last_claim_at) {
                        const hoursSinceLast = (now - new Date(status.last_claim_at)) / (1000 * 60 * 60);
                        if (hoursSinceLast <= 48) {
                            newStreak = status.mining_streak + 1;
                        }
                    }

                    // Calculate rewards
                    const baseReward = parseFloat(tier.base_daily_reward);
                    const streakBonus = Math.min(
                        (newStreak - 1) * parseFloat(tier.streak_multiplier) * baseReward,
                        parseFloat(tier.max_streak_bonus)
                    );
                    const totalReward = baseReward + streakBonus;

                    // Get client info for anti-fraud
                    const clientIp = req.headers['x-forwarded-for'] || req.connection?.remoteAddress || 'unknown';
                    const userAgent = req.headers['user-agent'] || 'unknown';

                    // Credit tokens to wallet using existing creditLTDTokens function
                    await creditLTDTokens(authUser.userId, totalReward, 'MINING_DAILY_CLAIM', client);

                    // Update mining status
                    await client.query(`
                        UPDATE user_mining_status SET
                            current_tier = $2,
                            achievement_points = $3,
                            mining_streak = $4,
                            longest_streak = GREATEST(longest_streak, $4),
                            last_claim_at = NOW(),
                            next_claim_available_at = NOW() + INTERVAL '24 hours',
                            total_claims = total_claims + 1,
                            testnet_ltd_mined = testnet_ltd_mined + $5,
                            updated_at = NOW()
                        WHERE user_id = $1
                    `, [authUser.userId, tierInfo.tier, tierInfo.points, newStreak, totalReward]);

                    // Record in history
                    await client.query(`
                        INSERT INTO mining_history
                        (user_id, tier_at_claim, base_reward, streak_bonus, total_reward, streak_count, token_type, ip_address, user_agent)
                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                    `, [authUser.userId, tierInfo.tier, baseReward, streakBonus, totalReward, newStreak,
                        platformState, clientIp, userAgent]);

                    // Check for streak achievements
                    if (newStreak === 7) {
                        await unlockAchievement(client, authUser.userId, 'streak_7');
                    } else if (newStreak === 30) {
                        await unlockAchievement(client, authUser.userId, 'streak_30');
                    }

                    await client.query('COMMIT');

                } catch (txError) {
                    await client.query('ROLLBACK');
                    throw txError;
                } finally {
                    client.release();
                }

                // Audit log
                auditLog('MINING_CLAIM', {
                    userId: authUser.userId,
                    tier: tierInfo.tier,
                    base: baseReward,
                    bonus: streakBonus,
                    total: totalReward,
                    streak: newStreak,
                    platform: platformState
                });

                sendResponse(res, 200, {
                    success: true,
                    message: 'Minado exitoso! +' + totalReward.toFixed(2) + ' LTD',
                    claim: {
                        base_reward: baseReward,
                        streak_bonus: streakBonus,
                        total_reward: totalReward,
                        streak: newStreak,
                        tier: tierInfo.tier,
                        tier_display: tier.display_name
                    },
                    token_type: platformState === 'testnet' ? 'TEST_LTD' : 'LTD',
                    next_claim_at: new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString()
                });

            } catch (error) {
                log('error', 'Mining claim error: ' + error.message);
                sendError(res, 500, 'Error al procesar minado');
            }
            return;
        }

        // POST /api/conversion/request - Request testnet to mainnet conversion
        if (pathname === '/api/conversion/request' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                // Check platform state
                const platformResult = await dbPostgres.pool.query(
                    'SELECT id, state, testnet_start_date, mainnet_launch_date, token_conversion_rate, conversion_enabled, last_snapshot_at, updated_at, updated_by FROM platform_state LIMIT 1'
                );
                const platform = platformResult.rows[0];

                if (!platform || !platform.conversion_enabled) {
                    sendError(res, 400, 'La conversion de tokens aun no esta habilitada');
                    return;
                }

                // v4.1.0: Wrap in transaction with FOR UPDATE to prevent duplicate conversion requests
                const convClient = await dbPostgres.pool.connect();
                try {
                    await convClient.query('BEGIN');

                    // Get user's mining status with row lock
                    const miningResult = await convClient.query(
                        'SELECT id, user_id, current_tier, achievement_points, mining_streak, longest_streak, last_claim_at, next_claim_available_at, total_claims, testnet_ltd_mined, mainnet_ltd_converted, conversion_eligible, fraud_flags, created_at, updated_at FROM user_mining_status WHERE user_id = $1 FOR UPDATE',
                        [authUser.userId]
                    );

                    if (miningResult.rows.length === 0) {
                        await convClient.query('ROLLBACK');
                        convClient.release();
                        sendError(res, 400, 'No tienes tokens para convertir');
                        return;
                    }

                    const mining = miningResult.rows[0];

                    if (!mining.conversion_eligible) {
                        await convClient.query('ROLLBACK');
                        convClient.release();
                        sendError(res, 403, 'Tu cuenta no es elegible para conversion');
                        return;
                    }

                    if (parseFloat(mining.testnet_ltd_mined) <= 0) {
                        await convClient.query('ROLLBACK');
                        convClient.release();
                        sendError(res, 400, 'No tienes tokens testnet para convertir');
                        return;
                    }

                    // Check if already requested (inside transaction — prevents TOCTOU race)
                    const existingRequest = await convClient.query(
                        'SELECT id FROM token_conversion_ledger WHERE user_id = $1 AND verification_status IN ($2, $3)',
                        [authUser.userId, 'pending', 'approved']
                    );

                    if (existingRequest.rows.length > 0) {
                        await convClient.query('ROLLBACK');
                        convClient.release();
                        sendError(res, 400, 'Ya tienes una solicitud de conversion pendiente');
                        return;
                    }

                    // Get user info for fraud check
                    const userResult = await convClient.query(
                        "SELECT u.user_id, u.verification_level, u.referral_count, u.created_at, EXTRACT(DAY FROM NOW() - u.created_at) as account_age_days, (SELECT COALESCE(SUM(amount), 0) FROM contributions WHERE user_id = u.user_id AND status = 'completed') as total_contributions FROM users u WHERE u.user_id = $1",
                        [authUser.userId]
                    );
                    const user = userResult.rows[0];

                    // Calculate fraud score
                    const fraudScore = calculateFraudScore({
                        accountAgeDays: parseInt(user.account_age_days) || 0,
                        kycLevel: user.verification_level,
                        totalContributions: parseFloat(user.total_contributions) || 0,
                        referralCount: user.referral_count || 0,
                        miningStreak: mining.longest_streak || 0,
                        totalClaims: mining.total_claims || 0,
                        testnetBalance: parseFloat(mining.testnet_ltd_mined) || 0
                    });

                    // Generate mining history hash for verification
                    const historyResult = await convClient.query(
                        'SELECT claim_timestamp, total_reward FROM mining_history WHERE user_id = $1 ORDER BY claim_timestamp LIMIT 10000',
                        [authUser.userId]
                    );
                    const historyHash = generateHistoryHash(historyResult.rows);

                    // Create conversion request (inside transaction)
                    await convClient.query(
                        "INSERT INTO token_conversion_ledger (user_id, snapshot_date, testnet_balance, mining_history_hash, account_age_days, kyc_level, total_contributions, referral_count, fraud_score, verification_status) VALUES ($1, NOW(), $2, $3, $4, $5, $6, $7, $8, $9)",
                        [
                            authUser.userId,
                            mining.testnet_ltd_mined,
                            historyHash,
                            parseInt(user.account_age_days) || 0,
                            user.verification_level,
                            parseFloat(user.total_contributions) || 0,
                            user.referral_count || 0,
                            fraudScore,
                            fraudScore > 50 ? 'flagged' : 'pending'
                        ]
                    );

                    await convClient.query('COMMIT');
                    convClient.release();

                } catch (txErr) {
                    await convClient.query('ROLLBACK').catch(() => {});
                    throw txErr;
                } finally {
                    // release is called in early returns above, but ensure cleanup
                }

                auditLog('CONVERSION_REQUESTED', {
                    userId: authUser.userId,
                    testnetBalance: mining.testnet_ltd_mined,
                    fraudScore: fraudScore
                });

                sendResponse(res, 200, {
                    success: true,
                    message: fraudScore > 50
                        ? 'Tu solicitud requiere revision manual'
                        : 'Solicitud de conversion enviada',
                    conversion: {
                        testnet_balance: parseFloat(mining.testnet_ltd_mined),
                        estimated_mainnet: parseFloat(mining.testnet_ltd_mined) * (platform.token_conversion_rate || 1),
                        status: fraudScore > 50 ? 'flagged' : 'pending',
                        review_time: fraudScore > 50 ? '5-7 dias' : '24-48 horas'
                    }
                });

            } catch (error) {
                log('error', 'Conversion request error: ' + error.message);
                sendError(res, 500, 'Error al procesar solicitud');
            }
            return;
        }

        // USER SETTINGS ENDPOINTS
        // ============================================

        // GET /api/user/settings - Get user configuration settings
        if (pathname === '/api/user/settings' && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                const result = await dbPostgres.pool.query(
                    'SELECT preferences FROM users WHERE user_id = $1',
                    [authUser.userId]
                );

                const defaultSettings = {
                    language: 'es',
                    timezone: 'America/Tegucigalpa',
                    currency: 'HNL',
                    theme: 'cyber',
                    expertMode: false,
                    transactionConfirmation: true,
                    animations: true,
                    glassmorphism: true,
                    density: 'normal',
                    notifications: {
                        startTime: '08:00',
                        endTime: '22:00'
                    },
                    blockchain: {
                        network: 'latanda-mainnet',
                        rpcUrl: 'https://rpc.latanda.online',
                        gasLimit: 21000,
                        gasPriceStrategy: 'standard'
                    },
                    advanced: {
                        developerMode: false,
                        logLevel: 'info'
                    }
                };

                const userPrefs = result.rows[0]?.preferences || {};
                const mergedSettings = { ...defaultSettings, ...userPrefs };

                sendResponse(res, 200, {
                    success: true,
                    settings: mergedSettings
                });
                return;

            } catch (error) {
                log('error', 'Error getting user settings: ' + error.message);
                sendError(res, 500, 'Error al obtener configuracion');
                return;
            }
        }

        // PUT /api/user/settings - Update user configuration settings
        if (pathname === '/api/user/settings' && (method === 'PUT' || method === 'PATCH')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                const { settings } = body;
                if (!settings || typeof settings !== 'object') {
                    sendError(res, 400, 'Settings object requerido');
                    return;
                }

                // Get existing preferences
                const existing = await dbPostgres.pool.query(
                    'SELECT preferences FROM users WHERE user_id = $1',
                    [authUser.userId]
                );

                // Merge with existing preferences (deep merge for nested objects)
                const existingPrefs = existing.rows[0]?.preferences || {};
                const merged = {
                    ...existingPrefs,
                    ...settings,
                    notifications: { ...(existingPrefs.notifications || {}), ...(settings.notifications || {}) },
                    blockchain: { ...(existingPrefs.blockchain || {}), ...(settings.blockchain || {}) },
                    advanced: { ...(existingPrefs.advanced || {}), ...(settings.advanced || {}) }
                };

                // Update database
                await dbPostgres.pool.query(
                    'UPDATE users SET preferences = $1, updated_at = NOW() WHERE user_id = $2',
                    [JSON.stringify(merged), authUser.userId]
                );

                // Audit log
                auditLog('SETTINGS_UPDATED', { user_id: authUser.userId, changes: Object.keys(settings) });

                sendResponse(res, 200, {
                    success: true,
                    message: 'Configuracion guardada',
                    settings: merged
                });
                return;

            } catch (error) {
                log('error', 'Error updating user settings: ' + error.message);
                sendError(res, 500, 'Error al guardar configuracion');
                return;
            }
        }

        // POST /api/user/avatar - Upload user avatar
        if (pathname === '/api/user/avatar' && method === 'POST') {
            // Require JWT authentication
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            
            const userId = authUser.userId;
            
            let chunks = [];
            req.on('data', (chunk) => chunks.push(chunk));
            req.on('end', async () => {
                try {
                    const buffer = Buffer.concat(chunks);
                    const bodyString = buffer.toString();
                    
                    // Check content type
                    const contentType = req.headers['content-type'] || '';
                    if (!contentType.includes('multipart/form-data')) {
                        sendError(res, 400, 'Content-Type debe ser multipart/form-data');
                        return;
                    }
                    
                    // Parse filename from Content-Disposition
                    const filenameMatch = bodyString.match(/filename="([^"]+)"/);
                    const originalFilename = filenameMatch ? filenameMatch[1] : 'avatar.jpg';
                    
                    // Validate file extension
                    const ext = originalFilename.split('.').pop().toLowerCase();
                    if (!['jpg', 'jpeg', 'png', 'webp'].includes(ext)) {
                        sendError(res, 400, 'Tipo de archivo no permitido. Use JPG, PNG o WEBP');
                        return;
                    }
                    
                    // Extract image data from multipart
                    const boundaryMatch = bodyString.match(/--[^\r\n]+/);
                    if (!boundaryMatch) {
                        sendError(res, 400, 'Formato de multipart invalido');
                        return;
                    }
                    const boundary = boundaryMatch[0];
                    const boundaryBuffer = Buffer.from(boundary);
                    
                    // Find image content in raw buffer
                    let imageBuffer = null;
                    let start = 0;
                    
                    while (start < buffer.length) {
                        const boundaryPos = buffer.indexOf(boundaryBuffer, start);
                        if (boundaryPos === -1) break;
                        
                        const headersEnd = buffer.indexOf(Buffer.from('\r\n\r\n'), boundaryPos);
                        if (headersEnd === -1) {
                            start = boundaryPos + boundaryBuffer.length;
                            continue;
                        }
                        
                        const headerSection = buffer.slice(boundaryPos, headersEnd).toString();
                        
                        // Check if this part contains an image
                        if (headerSection.includes('Content-Type: image/') || 
                            headerSection.includes('filename=')) {
                            const contentStart = headersEnd + 4;
                            const nextBoundary = buffer.indexOf(boundaryBuffer, contentStart);
                            if (nextBoundary !== -1) {
                                // Remove trailing \r\n before boundary
                                let contentEnd = nextBoundary - 2;
                                if (buffer[contentEnd] === 0x0d && buffer[contentEnd + 1] === 0x0a) {
                                    imageBuffer = buffer.slice(contentStart, contentEnd);
                                } else {
                                    imageBuffer = buffer.slice(contentStart, nextBoundary);
                                }
                                break;
                            }
                        }
                        start = boundaryPos + boundaryBuffer.length;
                    }
                    
                    if (!imageBuffer || imageBuffer.length < 100) {
                        sendError(res, 400, 'No se pudo extraer la imagen del formulario');
                        return;
                    }
                    
                    // Validate file size (max 2MB)
                    if (imageBuffer.length > 2 * 1024 * 1024) {
                        sendError(res, 400, 'Archivo muy grande. Maximo 2MB');
                        return;
                    }
                    
                    // Generate unique filename
                    const timestamp = Date.now();
                    const userIdShort = userId.substring(0, 16);
                    const filename = 'avatar_' + userIdShort + '_' + timestamp + '.' + ext;
                    const filePath = path.join(__dirname, 'avatars', filename);
                    
                    // Save file
                    fs.writeFileSync(filePath, imageBuffer);
                    
                    // Update database with new avatar URL
                    const avatarUrl = 'https://latanda.online/avatars/' + filename;
                    
                    await dbPostgres.pool.query(
                        'UPDATE users SET avatar_url = $1, updated_at = NOW() WHERE user_id = $2',
                        [avatarUrl, userId]
                    );
                    
                    log('info', 'Avatar uploaded for user ' + userId + ': ' + filename);
                    
                    sendResponse(res, 200, {
                        success: true,
                        message: 'Avatar actualizado exitosamente',
                        avatar_url: avatarUrl
                    });
                    
                } catch (error) {
                    log('error', 'Error uploading avatar: ' + error.message);
                    sendError(res, 500, 'Error al subir avatar');
                }
            });
            return;
        }


        // POST /api/user/change-password - Change password for logged-in user
        if (pathname === '/api/user/change-password' && method === 'POST') {
            // Require JWT authentication
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            
            const userId = authUser.userId;
            
            try {
                const { current_password, new_password, confirm_password } = body;
                
                // Validate inputs
                if (!current_password || !new_password || !confirm_password) {
                    sendError(res, 400, 'Todos los campos son requeridos');
                    return;
                }
                
                if (new_password !== confirm_password) {
                    sendError(res, 400, 'Las contrasenas no coinciden');
                    return;
                }
                
                const pwError3 = validatePassword(new_password);
                if (pwError3) {
                    sendError(res, 400, pwError3);
                    return;
                }
                
                // Get current password hash
                const userResult = await dbPostgres.pool.query(
                    'SELECT password_hash FROM users WHERE user_id = $1',
                    [userId]
                );
                
                if (userResult.rows.length === 0) {
                    sendError(res, 404, 'Usuario no encontrado');
                    return;
                }
                
                // Verify current password
                const isValid = await bcrypt.compare(current_password, userResult.rows[0].password_hash);
                if (!isValid) {
                    sendError(res, 401, 'Contrasena actual incorrecta');
                    return;
                }
                
                // Check if new password is same as old
                const isSame = await bcrypt.compare(new_password, userResult.rows[0].password_hash);
                if (isSame) {
                    sendError(res, 400, 'La nueva contrasena debe ser diferente a la actual');
                    return;
                }
                
                // Hash and update
                const newHash = await bcrypt.hash(new_password, 12);
                await dbPostgres.pool.query(
                    'UPDATE users SET password_hash = $1, updated_at = NOW() WHERE user_id = $2',
                    [newHash, userId]
                );
                
                // Audit log
                const clientInfo = getClientInfo(req);
                auditLog('PASSWORD_CHANGED', {
                    userId: userId,
                    resource: 'users',
                    resourceId: userId,
                    ip: clientInfo.ip,
                    userAgent: clientInfo.userAgent,
                    extra: { method: 'profile_settings' }
                });
                
                log('info', 'Password changed for user: ' + userId);
                
                // H3: Invalidate current session token to force re-login with new password
                const currentToken = req.headers.authorization?.replace('Bearer ', '');
                if (currentToken) {
                    try {
                        await securityMiddleware.blacklistToken(currentToken, 86400);
                        log('info', 'Session invalidated after password change for user: ' + userId);
                    } catch (blErr) {
                        log('error', 'Failed to blacklist token after password change: ' + blErr.message);
                    }
                }
                
                sendResponse(res, 200, {
                    success: true,
                    message: 'Contrasena actualizada exitosamente. Por favor inicia sesion nuevamente.',
                    require_relogin: true
                });
                return;
                
            } catch (error) {
                log('error', 'Error changing password: ' + error.message);
                sendError(res, 500, 'Error al cambiar contrasena');
                return;
            }
        }


        // ==========================================
        // USER 2FA ENDPOINTS
        // ==========================================

        // POST /api/user/2fa/setup - Initialize 2FA setup
        if (pathname === '/api/user/2fa/setup' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            
            const userId = authUser.userId;
            
            try {
                // Get user email and check if 2FA already enabled
                const userResult = await dbPostgres.pool.query(
                    'SELECT email, totp_enabled FROM users WHERE user_id = $1',
                    [userId]
                );
                
                if (userResult.rows.length === 0) {
                    sendError(res, 404, 'Usuario no encontrado');
                    return;
                }
                
                if (userResult.rows[0].totp_enabled) {
                    sendError(res, 400, '2FA ya esta habilitado para esta cuenta');
                    return;
                }
                
                const userEmail = userResult.rows[0].email;
                
                // Generate TOTP secret
                const speakeasy = require('speakeasy');
                const QRCode = require('qrcode');
                
                const secret = speakeasy.generateSecret({
                    name: 'La Tanda (' + userEmail + ')',
                    issuer: 'La Tanda'
                });
                
                // Store temp secret (not enabled yet until verified)
                await dbPostgres.pool.query(
                    'UPDATE users SET totp_secret = $1, updated_at = NOW() WHERE user_id = $2',
                    [secret.base32, userId]
                );
                
                // Generate QR code as data URL
                const qrCodeDataUrl = await QRCode.toDataURL(secret.otpauth_url);
                
                log('info', '2FA setup initiated for user: ' + userId);
                
                sendResponse(res, 200, {
                    success: true,
                    secret: secret.base32,
                    qr_code: qrCodeDataUrl,
                    message: 'Escanea el codigo QR con tu app de autenticacion (Google Authenticator, Authy, etc.)'
                });
                return;
                
            } catch (error) {
                log('error', 'Error setting up 2FA: ' + error.message);
                sendError(res, 500, 'Error al configurar 2FA');
                return;
            }
        }

        // POST /api/user/2fa/verify - Verify code and enable 2FA
        if (pathname === '/api/user/2fa/verify' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            
            const userId = authUser.userId;
            
            try {
                const { code } = body;
                
                if (!code || code.length !== 6) {
                    sendError(res, 400, 'Codigo de 6 digitos requerido');
                    return;
                }
                
                // Get stored secret
                const userResult = await dbPostgres.pool.query(
                    'SELECT totp_secret, totp_enabled FROM users WHERE user_id = $1',
                    [userId]
                );
                
                if (!userResult.rows[0]?.totp_secret) {
                    sendError(res, 400, 'Primero inicia la configuracion de 2FA');
                    return;
                }
                
                if (userResult.rows[0].totp_enabled) {
                    sendError(res, 400, '2FA ya esta habilitado');
                    return;
                }
                
                // Verify code
                const speakeasy = require('speakeasy');
                const isValid = speakeasy.totp.verify({
                    secret: userResult.rows[0].totp_secret,
                    encoding: 'base32',
                    token: code,
                    window: 2
                });
                
                if (!isValid) {
                    sendError(res, 400, 'Codigo invalido. Intenta de nuevo');
                    return;
                }
                
                // Generate backup codes
                const crypto = require('crypto');
                const backupCodes = [];
                for (let i = 0; i < 10; i++) {
                    backupCodes.push(crypto.randomBytes(4).toString('hex').toUpperCase());
                }
                
                // Enable 2FA and store backup codes
                await dbPostgres.pool.query(
                    'UPDATE users SET totp_enabled = TRUE, totp_backup_codes = $1, updated_at = NOW() WHERE user_id = $2',
                    [JSON.stringify(backupCodes), userId]
                );
                
                // Audit log
                const clientInfo = getClientInfo(req);
                auditLog('USER_2FA_ENABLED', {
                    userId: userId,
                    resource: 'users',
                    resourceId: userId,
                    ip: clientInfo.ip,
                    userAgent: clientInfo.userAgent
                });
                
                log('info', '2FA enabled for user: ' + userId);
                
                sendResponse(res, 200, {
                    success: true,
                    message: '2FA habilitado exitosamente',
                    backup_codes: backupCodes,
                    warning: 'IMPORTANTE: Guarda estos codigos de respaldo en un lugar seguro. Solo se mostraran una vez.'
                });
                return;
                
            } catch (error) {
                log('error', 'Error verifying 2FA: ' + error.message);
                sendError(res, 500, 'Error al verificar 2FA');
                return;
            }
        }

        // POST /api/user/2fa/disable - Disable 2FA
        if (pathname === '/api/user/2fa/disable' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            
            const userId = authUser.userId;
            
            try {
                const { code, backup_code } = body;
                
                // Get user 2FA info
                const userResult = await dbPostgres.pool.query(
                    'SELECT totp_secret, totp_enabled, totp_backup_codes FROM users WHERE user_id = $1',
                    [userId]
                );
                
                if (!userResult.rows[0]?.totp_enabled) {
                    sendError(res, 400, '2FA no esta habilitado');
                    return;
                }
                
                // Verify with TOTP code or backup code
                let verified = false;
                
                if (code && code.length === 6) {
                    const speakeasy = require('speakeasy');
                    verified = speakeasy.totp.verify({
                        secret: userResult.rows[0].totp_secret,
                        encoding: 'base32',
                        token: code,
                        window: 2
                    });
                }
                
                if (!verified && backup_code) {
                    const storedCodes = JSON.parse(userResult.rows[0].totp_backup_codes || '[]');
                    const upperBackup = backup_code.toUpperCase();
                    if (storedCodes.includes(upperBackup)) {
                        verified = true;
                    }
                }
                
                if (!verified) {
                    sendError(res, 400, 'Codigo invalido');
                    return;
                }
                
                // Disable 2FA
                await dbPostgres.pool.query(
                    'UPDATE users SET totp_enabled = FALSE, totp_secret = NULL, totp_backup_codes = NULL, updated_at = NOW() WHERE user_id = $1',
                    [userId]
                );
                
                // Audit log
                const clientInfo = getClientInfo(req);
                auditLog('USER_2FA_DISABLED', {
                    userId: userId,
                    resource: 'users',
                    resourceId: userId,
                    ip: clientInfo.ip,
                    userAgent: clientInfo.userAgent
                });
                
                log('info', '2FA disabled for user: ' + userId);
                
                sendResponse(res, 200, {
                    success: true,
                    message: '2FA deshabilitado exitosamente'
                });
                return;
                
            } catch (error) {
                log('error', 'Error disabling 2FA: ' + error.message);
                sendError(res, 500, 'Error al deshabilitar 2FA');
                return;
            }
        }

        // GET /api/user/2fa/status - Get 2FA status
        if (pathname === '/api/user/2fa/status' && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            
            const userId = authUser.userId;
            
            try {
                const userResult = await dbPostgres.pool.query(
                    'SELECT totp_enabled, totp_backup_codes FROM users WHERE user_id = $1',
                    [userId]
                );
                
                if (userResult.rows.length === 0) {
                    sendError(res, 404, 'Usuario no encontrado');
                    return;
                }
                
                const backupCodes = JSON.parse(userResult.rows[0].totp_backup_codes || '[]');
                
                sendResponse(res, 200, {
                    success: true,
                    enabled: userResult.rows[0].totp_enabled || false,
                    backup_codes_remaining: backupCodes.length
                });
                return;
                
            } catch (error) {
                log('error', 'Error getting 2FA status: ' + error.message);
                sendError(res, 500, 'Error al obtener estado de 2FA');
                return;
            }
        }

        // ============================================
        // USER ACTIVITY ENDPOINT
        // ============================================
        
        // GET /api/user/activity - Get user's recent activity
        if (pathname === '/api/user/activity' && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            
            const userId = authUser.userId;
            const limit = Math.min(parseInt(query.limit) || 20, 100);
            
            try {
                // Get recent activity from audit_logs
                const activityResult = await dbPostgres.pool.query(`
                    SELECT action, resource, resource_id, details, timestamp, status
                    FROM audit_logs 
                    WHERE user_id = \$1 
                    ORDER BY timestamp DESC 
                    LIMIT \$2
                `, [userId, Math.min(limit, 50)]);
                
                // Map actions to user-friendly format
                const actionMap = {
                    'LOGIN_SUCCESS': { icon: 'fas fa-sign-in-alt', color: '#22d55e', title: 'Inicio de sesion' },
                    'LOGIN_FAILED': { icon: 'fas fa-exclamation-triangle', color: '#ef4444', title: 'Intento de inicio fallido' },
                    'KYC_DOCUMENT_UPLOADED': { icon: 'fas fa-id-card', color: '#3b82f6', title: 'Documento KYC subido' },
                    'KYC_OCR_PROCESSED': { icon: 'fas fa-check-circle', color: '#22d55e', title: 'KYC procesado' },
                    'WITHDRAWAL_REQUESTED': { icon: 'fas fa-money-bill-wave', color: '#f59e0b', title: 'Retiro solicitado' },
                    'PIN_SET': { icon: 'fas fa-lock', color: '#8b5cf6', title: 'PIN configurado' },
                    'SECURITY_QUESTIONS_SET': { icon: 'fas fa-shield-alt', color: '#8b5cf6', title: 'Preguntas de seguridad configuradas' },
                    'WHITELIST_ADDRESS_ADDED': { icon: 'fas fa-plus-circle', color: '#00FFFF', title: 'Direccion agregada a whitelist' },
                    'BACKUP_CODES_GENERATED': { icon: 'fas fa-key', color: '#f59e0b', title: 'Codigos de respaldo generados' },
                    'LIMIT_INCREASE_REQUESTED': { icon: 'fas fa-arrow-up', color: '#3b82f6', title: 'Aumento de limite solicitado' },
                    'MINING_CLAIM': { icon: 'fas fa-hammer', color: '#f59e0b', title: 'Mineria de LTD' },
                    'PROFILE_UPDATED': { icon: 'fas fa-user-edit', color: '#8b5cf6', title: 'Perfil actualizado' },
                    'PASSWORD_CHANGED': { icon: 'fas fa-key', color: '#22d55e', title: 'Contrasena cambiada' },
                    'TANDA_JOINED': { icon: 'fas fa-users', color: '#00FFFF', title: 'Unido a tanda' },
                    'CONTRIBUTION_MADE': { icon: 'fas fa-hand-holding-usd', color: '#22d55e', title: 'Contribucion realizada' }
                };
                
                const activities = activityResult.rows.map(row => {
                    const mapped = actionMap[row.action] || { 
                        icon: 'fas fa-circle', 
                        color: '#6b7280', 
                        title: row.action.replace(/_/g, ' ').toLowerCase() 
                    };
                    
                    // Calculate relative time
                    const timestamp = new Date(row.timestamp);
                    const now = new Date();
                    const diffMs = now - timestamp;
                    const diffMins = Math.floor(diffMs / 60000);
                    const diffHours = Math.floor(diffMs / 3600000);
                    const diffDays = Math.floor(diffMs / 86400000);
                    
                    let timeAgo;
                    if (diffMins < 1) timeAgo = 'Ahora mismo';
                    else if (diffMins < 60) timeAgo = 'Hace ' + diffMins + ' min';
                    else if (diffHours < 24) timeAgo = 'Hace ' + diffHours + ' hora' + (diffHours > 1 ? 's' : '');
                    else if (diffDays < 7) timeAgo = 'Hace ' + diffDays + ' dia' + (diffDays > 1 ? 's' : '');
                    else timeAgo = timestamp.toLocaleDateString('es-HN');
                    
                    return {
                        icon: mapped.icon,
                        iconColor: mapped.color,
                        title: mapped.title,
                        description: row.resource || '',
                        time: timeAgo,
                        status: row.status,
                        timestamp: row.timestamp
                    };
                });
                
                sendResponse(res, 200, {
                    success: true,
                    activities: activities,
                    total: activities.length
                });
                
            } catch (error) {
                log('error', 'Error fetching activity: ' + error.message);
                sendError(res, 500, 'Error al obtener actividad');
            }
            return;
        }

        // ============================================
        // USER SECURITY STATUS ENDPOINT
        // ============================================

        // GET /api/user/security/status - Get unified security status
        if (pathname === '/api/user/security/status' && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const userId = authUser.userId;

            try {
                // Get user security data
                const userResult = await dbPostgres.pool.query(`
                    SELECT totp_enabled, totp_backup_codes, email_verified, password_hash,
                           updated_at as last_password_change
                    FROM users WHERE user_id = $1
                `, [userId]);

                if (userResult.rows.length === 0) {
                    sendError(res, 404, 'Usuario no encontrado');
                    return;
                }

                const user = userResult.rows[0];

                // Count backup codes
                let backupCodesRemaining = 0;
                if (user.totp_backup_codes) {
                    try {
                        const codes = Array.isArray(user.totp_backup_codes)
                            ? user.totp_backup_codes
                            : JSON.parse(user.totp_backup_codes || '[]');
                        backupCodesRemaining = codes.filter(c => !c.used).length;
                    } catch (e) {
                        backupCodesRemaining = 0;
                    }
                }

                // Check if PIN is configured
                const pinResult = await dbPostgres.pool.query(
                    'SELECT id FROM user_transaction_pins WHERE user_id = $1',
                    [userId]
                );
                const pinConfigured = pinResult.rows.length > 0;

                // Count webauthn devices
                const webauthnResult = await dbPostgres.pool.query(
                    'SELECT COUNT(*) as count FROM user_webauthn_credentials WHERE user_id = $1',
                    [userId]
                );
                const webauthnDevices = parseInt(webauthnResult.rows[0].count) || 0;

                // Count whitelist addresses
                const whitelistResult = await dbPostgres.pool.query(
                    'SELECT COUNT(*) as count FROM user_withdrawal_whitelist WHERE user_id = $1',
                    [userId]
                );
                const whitelistAddresses = parseInt(whitelistResult.rows[0].count) || 0;

                // Count active sessions
                const sessionsResult = await dbPostgres.pool.query(
                    'SELECT COUNT(*) as count FROM user_sessions WHERE user_id = $1 AND is_active = true AND expires_at > NOW()',
                    [userId]
                );
                const activeSessions = parseInt(sessionsResult.rows[0].count) || 0;

                sendResponse(res, 200, {
                    success: true,
                    security: {
                        two_factor_enabled: user.totp_enabled || false,
                        backup_codes_remaining: backupCodesRemaining,
                        pin_configured: pinConfigured,
                        webauthn_devices: webauthnDevices,
                        whitelist_addresses: whitelistAddresses,
                        active_sessions: activeSessions,
                        last_password_change: user.last_password_change,
                        email_verified: user.email_verified || false
                    }
                });
                return;

            } catch (error) {
                log('error', 'Error getting security status: ' + error.message);
                sendError(res, 500, 'Error al obtener estado de seguridad');
                return;
            }
        }

        // ============================================
        // USER DEVICES/SESSIONS ENDPOINTS
        // ============================================

        // GET /api/user/devices - List active sessions/devices
        if (pathname === '/api/user/devices' && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const userId = authUser.userId;
            const currentToken = req.headers.authorization?.replace('Bearer ', '');

            try {
                const sessionsResult = await dbPostgres.pool.query(`
                    SELECT id, session_token, ip_address, user_agent, created_at, last_activity, is_active
                    FROM user_sessions
                    WHERE user_id = $1 AND is_active = true AND expires_at > NOW()
                    ORDER BY last_activity DESC
                    LIMIT 20
                `, [userId]);

                // Parse user agent to extract device info
                const parseUserAgent = (ua) => {
                    if (!ua) return { browser: 'Desconocido', os: 'Desconocido', device: 'Desconocido' };

                    let browser = 'Desconocido';
                    let os = 'Desconocido';
                    let device = 'Desktop';

                    // Detect browser
                    if (ua.includes('Chrome') && !ua.includes('Edge')) browser = 'Chrome';
                    else if (ua.includes('Firefox')) browser = 'Firefox';
                    else if (ua.includes('Safari') && !ua.includes('Chrome')) browser = 'Safari';
                    else if (ua.includes('Edge')) browser = 'Edge';
                    else if (ua.includes('Opera')) browser = 'Opera';

                    // Detect OS
                    if (ua.includes('Windows')) os = 'Windows';
                    else if (ua.includes('Mac OS') || ua.includes('Macintosh')) os = 'macOS';
                    else if (ua.includes('Linux') && !ua.includes('Android')) os = 'Linux';
                    else if (ua.includes('Android')) { os = 'Android'; device = 'Mobile'; }
                    else if (ua.includes('iPhone') || ua.includes('iPad')) { os = 'iOS'; device = ua.includes('iPad') ? 'Tablet' : 'Mobile'; }

                    return { browser, os, device };
                };

                const devices = sessionsResult.rows.map(session => {
                    const uaInfo = parseUserAgent(session.user_agent);

                    // Check if this is the current session
                    let isCurrent = false;
                    if (currentToken) {
                        try {
                            const decoded = jwt.verify(currentToken, process.env.JWT_SECRET, { algorithms: ['HS256'] });
                            if (decoded.sessionId === session.id) {
                                isCurrent = true;
                            }
                        } catch (e) {
                            // Token comparison failed, check hash (v3.97.0 - timing-safe)
                            isCurrent = safeCompare(session.session_token, currentToken.substring(0, 64));
                        }
                    }

                    return {
                        id: session.id,
                        device_name: `${uaInfo.browser} en ${uaInfo.os}`,
                        browser: uaInfo.browser,
                        os: uaInfo.os,
                        device_type: uaInfo.device,
                        ip_address: session.ip_address ? session.ip_address.toString() : 'Desconocida',
                        location: 'Honduras',
                        created_at: session.created_at,
                        last_activity: session.last_activity,
                        is_current: isCurrent
                    };
                });

                sendResponse(res, 200, {
                    success: true,
                    devices: devices,
                    total: devices.length
                });
                return;

            } catch (error) {
                log('error', 'Error listing devices: ' + error.message);
                sendError(res, 500, 'Error al listar dispositivos');
                return;
            }
        }

        // DELETE /api/user/devices/:id - Revoke a session
        if (pathname.match(/^\/api\/user\/devices\/[a-f0-9-]+$/) && method === 'DELETE') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const userId = authUser.userId;
            const sessionId = pathname.split('/').pop();

            try {
                // Verify the session belongs to this user
                const sessionCheck = await dbPostgres.pool.query(
                    'SELECT id FROM user_sessions WHERE id = $1 AND user_id = $2',
                    [sessionId, userId]
                );

                if (sessionCheck.rows.length === 0) {
                    sendError(res, 404, 'Sesion no encontrada');
                    return;
                }

                // Revoke the session (soft delete)
                await dbPostgres.pool.query(
                    'UPDATE user_sessions SET is_active = false WHERE id = $1',
                    [sessionId]
                );

                // Log the action
                auditLog('SESSION_REVOKED', { user_id: userId, session_id: sessionId });

                sendResponse(res, 200, {
                    success: true,
                    message: 'Sesion revocada exitosamente'
                });
                return;

            } catch (error) {
                log('error', 'Error revoking session: ' + error.message);
                sendError(res, 500, 'Error al revocar sesion');
                return;
            }
        }

        
        // ============================================
        // USER ACHIEVEMENTS ENDPOINT
        // ============================================
        
        // GET /api/user/achievements - Get user's achievements
        if (pathname === '/api/user/achievements' && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            
            const userId = authUser.userId;
            
            try {
                // Get user data
                const userResult = await dbPostgres.pool.query(`
                    SELECT created_at, verification_level, totp_enabled, email_verified 
                    FROM users WHERE user_id = \$1
                `, [userId]);
                
                if (userResult.rows.length === 0) {
                    sendError(res, 404, 'Usuario no encontrado');
                    return;
                }
                
                const user = userResult.rows[0];
                
                // Get group stats
                const groupsResult = await dbPostgres.pool.query(`
                    SELECT 
                        COUNT(*) as total_groups,
                        COUNT(CASE WHEN role = 'admin' OR role = 'organizer' THEN 1 END) as admin_groups
                    FROM group_members WHERE user_id = \$1 AND status = 'active'
                `, [userId]);
                const groupCount = parseInt(groupsResult.rows[0].total_groups);
                const adminGroupCount = parseInt(groupsResult.rows[0].admin_groups);
                
                // Get contribution stats
                const contributionsResult = await dbPostgres.pool.query(`
                    SELECT 
                        COUNT(*) as total_contributions,
                        COUNT(CASE WHEN status = 'completed' OR status = 'verified' THEN 1 END) as completed,
                        COALESCE(SUM(CASE WHEN status = 'completed' OR status = 'verified' THEN amount ELSE 0 END), 0) as total_amount
                    FROM contributions WHERE user_id = \$1
                `, [userId]);
                const totalContributions = parseInt(contributionsResult.rows[0].total_contributions);
                const completedContributions = parseInt(contributionsResult.rows[0].completed);
                const totalContributionAmount = parseFloat(contributionsResult.rows[0].total_amount);
                
                // Get invitation stats
                const invitationsResult = await dbPostgres.pool.query(`
                    SELECT COUNT(*) as count FROM group_members WHERE invited_by = \$1
                `, [userId]);
                const invitedCount = parseInt(invitationsResult.rows[0].count);
                
                // Get login count
                const loginsResult = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count FROM audit_logs WHERE user_id = \$1 AND action = 'LOGIN_SUCCESS'",
                    [userId]
                );
                const loginCount = parseInt(loginsResult.rows[0].count);
                
                // Calculate account age in days
                const createdAt = new Date(user.created_at);
                const now = new Date();
                const accountAgeDays = Math.floor((now - createdAt) / 86400000);
                
                // Define achievements by category
                const achievements = [
                    // === CUENTA Y SEGURIDAD ===
                    {
                        id: 'new_member',
                        category: 'account',
                        icon: 'fas fa-user-plus',
                        title: 'Nuevo Miembro',
                        description: 'Te uniste a La Tanda',
                        unlocked: true,
                        color: '#22d55e'
                    },
                    {
                        id: 'verified_identity',
                        category: 'account',
                        icon: 'fas fa-id-card',
                        title: 'Identidad Verificada',
                        description: 'Completaste la verificacion KYC',
                        unlocked: user.verification_level !== 'none' && user.verification_level !== 'basic',
                        color: '#3b82f6'
                    },
                    {
                        id: 'security_pro',
                        category: 'account',
                        icon: 'fas fa-shield-alt',
                        title: 'Experto en Seguridad',
                        description: 'Activaste autenticacion 2FA',
                        unlocked: user.totp_enabled === true,
                        color: '#8b5cf6'
                    },
                    {
                        id: 'veteran',
                        category: 'account',
                        icon: 'fas fa-crown',
                        title: 'Veterano',
                        description: 'Mas de 90 dias en La Tanda',
                        unlocked: accountAgeDays >= 90,
                        color: '#ffd700'
                    },
                    
                    // === FINANCIEROS ===
                    {
                        id: 'first_contribution',
                        category: 'financial',
                        icon: 'fas fa-hand-holding-usd',
                        title: 'Primera Aportacion',
                        description: 'Realizaste tu primera contribucion',
                        unlocked: completedContributions >= 1,
                        color: '#22d55e'
                    },
                    {
                        id: 'consistent_payer',
                        category: 'financial',
                        icon: 'fas fa-calendar-check',
                        title: 'Pagador Constante',
                        description: '5 pagos completados a tiempo',
                        unlocked: completedContributions >= 5,
                        color: '#00ffff'
                    },
                    {
                        id: 'big_saver',
                        category: 'financial',
                        icon: 'fas fa-piggy-bank',
                        title: 'Gran Ahorrador',
                        description: 'Contribuciones totales de L. 5,000+',
                        unlocked: totalContributionAmount >= 5000,
                        color: '#f59e0b'
                    },
                    {
                        id: 'tanda_master',
                        category: 'financial',
                        icon: 'fas fa-trophy',
                        title: 'Maestro de Tandas',
                        description: 'Contribuciones totales de L. 25,000+',
                        unlocked: totalContributionAmount >= 25000,
                        color: '#ffd700'
                    },
                    
                    // === SOCIALES ===
                    {
                        id: 'community_member',
                        category: 'social',
                        icon: 'fas fa-users',
                        title: 'Miembro Activo',
                        description: 'Te uniste a tu primer grupo',
                        unlocked: groupCount >= 1,
                        color: '#22d55e'
                    },
                    {
                        id: 'social_butterfly',
                        category: 'social',
                        icon: 'fas fa-user-friends',
                        title: 'Mariposa Social',
                        description: 'Miembro de 3 o mas grupos',
                        unlocked: groupCount >= 3,
                        color: '#ec4899'
                    },
                    {
                        id: 'group_leader',
                        category: 'social',
                        icon: 'fas fa-user-tie',
                        title: 'Lider de Grupo',
                        description: 'Administras u organizas un grupo',
                        unlocked: adminGroupCount >= 1,
                        color: '#8b5cf6'
                    },
                    {
                        id: 'influencer',
                        category: 'social',
                        icon: 'fas fa-bullhorn',
                        title: 'Influencer',
                        description: 'Invitaste a 5 personas a grupos',
                        unlocked: invitedCount >= 5,
                        color: '#f43f5e'
                    }
                ];
                
                // Calculate stats by category
                const categories = {
                    account: { name: 'Cuenta', icon: 'fas fa-user-circle', unlocked: 0, total: 0 },
                    financial: { name: 'Financiero', icon: 'fas fa-coins', unlocked: 0, total: 0 },
                    social: { name: 'Social', icon: 'fas fa-heart', unlocked: 0, total: 0 }
                };
                
                achievements.forEach(a => {
                    if (categories[a.category]) {
                        categories[a.category].total++;
                        if (a.unlocked) categories[a.category].unlocked++;
                    }
                });
                
                const unlockedCount = achievements.filter(a => a.unlocked).length;
                const totalCount = achievements.length;
                const progressPercent = Math.round((unlockedCount / totalCount) * 100);
                
                sendResponse(res, 200, {
                    success: true,
                    achievements: achievements,
                    categories: categories,
                    stats: {
                        unlocked: unlockedCount,
                        total: totalCount,
                        progress: progressPercent,
                        accountAgeDays: accountAgeDays,
                        groupCount: groupCount,
                        contributionCount: completedContributions,
                        totalContributed: totalContributionAmount,
                        invitedCount: invitedCount
                    }
                });
                
            } catch (error) {
                log('error', 'Error fetching achievements: ' + error.message);
                sendError(res, 500, 'Error al obtener logros');
            }
            return;
        }
        // GET dashboard summary (balance, tandas, etc.)
        if (pathname === '/api/dashboard/summary' && (method === 'GET' || method === 'HEAD')) {
            // JWT auth with fallback to query param
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) { sendError(res, 401, 'Autenticacion requerida'); return; }
            const userId = authUser.userId;

            if (!userId) {
                sendError(res, 400, 'user_id es requerido');
                return;
            }

            try {
                // Get user info
                const userResult = await dbPostgres.pool.query('SELECT name, email, created_at, avatar_url FROM users WHERE user_id = $1', [userId]);

                // Get wallet balance including LTD tokens
                let balance = 0;
                let ltdBalance = 0;
                try {
                    const walletResult = await dbPostgres.pool.query(
                        'SELECT balance, crypto_balances FROM user_wallets WHERE user_id = $1 LIMIT 1',
                        [userId]
                    );
                    if (walletResult.rows[0]) {
                        balance = parseFloat(walletResult.rows[0].balance) || 0;
                        ltdBalance = parseFloat(walletResult.rows[0].crypto_balances?.LTD) || 0;
                    }
                } catch (e) {
                }

                // Get active tandas count from group_members and groups tables
                const tandasResult = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as count FROM group_members gm JOIN groups g ON gm.group_id = g.group_id WHERE gm.user_id = $1 AND g.status = 'active'",
                    [userId]
                );

                // Get total savings from contributions
                const savingsResult = await dbPostgres.pool.query(
                    "SELECT COALESCE(SUM(amount), 0) as total, COUNT(*) as completed_count FROM contributions WHERE user_id = $1 AND status = 'completed'",
                    [userId]
                );

                // Get next payment info from contributions
                const nextPaymentResult = await dbPostgres.pool.query(
                    "SELECT g.name, c.amount, c.due_date FROM contributions c JOIN groups g ON c.group_id = g.group_id WHERE c.user_id = $1 AND c.status IN ('pending', 'awaiting_payment') AND c.due_date >= CURRENT_DATE ORDER BY c.due_date ASC LIMIT 1",
                    [userId]
                );

                // Get pending invitations count for sidebar badge
                let pendingInvitations = 0;
                try {
                    const invitationsResult = await dbPostgres.pool.query(
                        "SELECT COUNT(*) as count FROM group_invitations WHERE invitee_user_id = $1 AND status = 'pending'",
                        [userId]
                    );
                    pendingInvitations = parseInt(invitationsResult.rows[0]?.count || 0);
                } catch (e) {
                }

                // Get KYC status for sidebar badge
                let kycStatus = 'pending';
                try {
                    const kycResult = await dbPostgres.pool.query(
                        'SELECT verification_level FROM users WHERE user_id = $1',
                        [userId]
                    );
                    kycStatus = kycResult.rows[0]?.verification_level || 'pending';
                } catch (e) {
                }

                const user = userResult.rows[0] || { name: 'Usuario', email: '' };
                // balance already set above
                const activeTandas = parseInt(tandasResult.rows[0]?.count || 0);
                const totalSavings = parseFloat(savingsResult.rows[0]?.total || 0);
                const nextPayment = nextPaymentResult.rows[0] || null;

                sendResponse(res, 200, {
                    success: true,
                    dashboard: {
                        user: {
                            name: user.name,
                            email: user.email,
                            member_since: user.created_at,
                            avatar_url: user.avatar_url
                        },
                        balance: { amount: ltdBalance, currency: 'LTD' }, // LTD token balance
                        active_tandas: activeTandas,
                        total_savings: totalSavings,
                        completed_contributions: parseInt(savingsResult.rows[0]?.completed_count || 0),
                        next_payment: nextPayment ? {
                            tanda_name: nextPayment.name,
                            amount: nextPayment.amount,
                            due_date: nextPayment.due_date
                        } : null,
                        pending_invitations: pendingInvitations,
                        kyc_status: kycStatus
                    }
                });
                return;
            } catch (error) {
                log('error', 'Error fetching dashboard summary: ' + error.message);
                sendError(res, 500, 'Error al obtener resumen del dashboard');
                return;
            }
        }

        // ============================================
        // HUB INTELIGENTE - UNIFIED COMMAND CENTER
        // Date: 2026-01-23
        // ============================================

        // GET /api/hub/summary - Aggregated summary from all modules
        if (pathname === '/api/hub/summary' && (method === 'GET' || method === 'HEAD')) {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) { sendError(res, 401, 'Autenticacion requerida'); return; }
            const userId = authUser.userId;

            if (!userId) {
                sendError(res, 400, 'user_id es requerido');
                return;
            }

            try {
                // Parallel queries for performance
                const [
                    walletResult,
                    tandasResult,
                    marketplaceResult,
                    lotteryResult,
                    miningResult,
                    alertsResult
                ] = await Promise.all([
                    // Wallet balance
                    dbPostgres.pool.query(
                        'SELECT balance, crypto_balances FROM user_wallets WHERE user_id = $1 LIMIT 1',
                        [userId]
                    ).catch(e => ({ rows: [] })),

                    // Active tandas with next payment
                    dbPostgres.pool.query(
                        `SELECT COUNT(*) as active_count,
                         MIN(CASE WHEN c.status = 'pending' THEN c.due_date END) as next_payment_date,
                         MIN(CASE WHEN c.status = 'pending' THEN c.amount END) as next_payment_amount
                         FROM group_members gm
                         JOIN groups g ON gm.group_id = g.group_id
                         LEFT JOIN contributions c ON c.group_id = g.group_id AND c.user_id = gm.user_id
                         WHERE gm.user_id = $1 AND g.status = 'active'`,
                        [userId]
                    ).catch(e => ({ rows: [{ active_count: 0 }] })),

                    // Marketplace stats
                    dbPostgres.pool.query(
                        `SELECT
                         (SELECT COUNT(*) FROM marketplace_products WHERE seller_id = $1 AND status = 'active') as products,
                         (SELECT COUNT(*) FROM marketplace_orders WHERE seller_id = $1 AND created_at >= CURRENT_DATE) as sales_today,
                         (SELECT COUNT(*) FROM marketplace_orders WHERE seller_id = $1 AND status = 'pending') as pending_orders,
                         (SELECT SUM(views) FROM marketplace_products WHERE seller_id = $1) as total_views`,
                        [userId]
                    ).catch(e => ({ rows: [{ products: 0, sales_today: 0, pending_orders: 0, total_views: 0 }] })),

                    // Lottery stats
                    dbPostgres.pool.query(
                        `SELECT
                         remaining_spins as spins_left,
                         last_spin_date
                         FROM lottery_users WHERE user_id = $1`,
                        [userId]
                    ).catch(e => ({ rows: [{ spins_left: 3 }] })),

                    // Mining status
                    dbPostgres.pool.query(
                        `SELECT
                         tier, current_streak, testnet_ltd_mined, last_claim_date
                         FROM mining_users WHERE user_id = $1`,
                        [userId]
                    ).catch(e => ({ rows: [{ tier: 'bronze', current_streak: 0, testnet_ltd_mined: 0 }] })),

                    // Generate alerts based on conditions
                    dbPostgres.pool.query(
                        `SELECT
                         (SELECT COUNT(*) FROM contributions WHERE user_id = $1 AND status = 'pending' AND due_date <= CURRENT_DATE + INTERVAL '2 days') as urgent_payments,
                         (SELECT COUNT(*) FROM group_invitations WHERE invitee_user_id = $1 AND status = 'pending') as pending_invitations,
                         (SELECT COUNT(*) FROM marketplace_orders WHERE seller_id = $1 AND status = 'pending') as pending_orders`,
                        [userId]
                    ).catch(e => ({ rows: [{ urgent_payments: 0, pending_invitations: 0, pending_orders: 0 }] }))
                ]);

                // Process wallet data
                const wallet = walletResult.rows[0] || {};
                const ltdBalance = parseFloat(wallet.crypto_balances?.LTD) || 0;
                const hnlBalance = parseFloat(wallet.balance) || 0;

                // Process tandas data
                const tandas = tandasResult.rows[0] || { active_count: 0 };

                // Process marketplace data
                const marketplace = marketplaceResult.rows[0] || { products: 0, sales_today: 0, pending_orders: 0, total_views: 0 };

                // Process lottery data
                const lottery = lotteryResult.rows[0] || { spins_left: 3 };

                // Get hot numbers (static for now, could be calculated from history)
                const hotNumbers = [45, 23, 8, 17, 32];

                // Calculate next draw time (La Diaria draws at 9:15 PM HN time)
                const now = new Date();
                const drawHour = 21;
                const drawMinute = 15;
                let nextDraw = new Date(now);
                nextDraw.setHours(drawHour, drawMinute, 0, 0);
                if (now > nextDraw) {
                    nextDraw.setDate(nextDraw.getDate() + 1);
                }

                // Process mining data
                const mining = miningResult.rows[0] || { tier: 'bronze', current_streak: 0, testnet_ltd_mined: 0 };
                const tierRewards = { bronze: 0.5, silver: 1.0, gold: 2.0 };

                // Build alerts array
                const alerts = [];
                const alertsData = alertsResult.rows[0] || {};

                if (alertsData.urgent_payments > 0) {
                    alerts.push({
                        type: 'payment',
                        priority: 'urgent',
                        icon: 'fa-exclamation-circle',
                        message: 'Tienes ' + alertsData.urgent_payments + ' pago(s) proximo(s) a vencer',
                        action_url: 'groups-advanced-system.html',
                        color: '#f87171'
                    });
                }

                if (alertsData.pending_invitations > 0) {
                    alerts.push({
                        type: 'invitation',
                        priority: 'opportunity',
                        icon: 'fa-user-plus',
                        message: alertsData.pending_invitations + ' invitacion(es) pendiente(s)',
                        action_url: 'groups-advanced-system.html#invitations',
                        color: '#fbbf24'
                    });
                }

                if (alertsData.pending_orders > 0) {
                    alerts.push({
                        type: 'marketplace',
                        priority: 'info',
                        icon: 'fa-shopping-bag',
                        message: alertsData.pending_orders + ' orden(es) por procesar',
                        action_url: 'marketplace-social.html#orders',
                        color: '#22d55e'
                    });
                }

                if (lottery.spins_left > 0) {
                    alerts.push({
                        type: 'lottery',
                        priority: 'reward',
                        icon: 'fa-ticket-alt',
                        message: lottery.spins_left + ' giro(s) disponible(s) hoy',
                        action_url: 'loteria.html',
                        color: '#8b5cf6'
                    });
                }

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        wallet: {
                            ltd_balance: ltdBalance,
                            hnl_balance: hnlBalance,
                            currency: 'LTD'
                        },
                        tandas: {
                            active_count: parseInt(tandas.active_count) || 0,
                            next_payment: tandas.next_payment_date ? {
                                date: tandas.next_payment_date,
                                amount: parseFloat(tandas.next_payment_amount) || 0
                            } : null
                        },
                        marketplace: {
                            products: parseInt(marketplace.products) || 0,
                            sales_today: parseInt(marketplace.sales_today) || 0,
                            pending_orders: parseInt(marketplace.pending_orders) || 0,
                            views_today: parseInt(marketplace.total_views) || 0
                        },
                        lottery: {
                            spins_left: parseInt(lottery.spins_left) || 0,
                            hot_numbers: hotNumbers,
                            next_draw: nextDraw.toISOString()
                        },
                        mining: {
                            tier: mining.tier || 'bronze',
                            tier_display: mining.tier === 'gold' ? 'Oro' : mining.tier === 'silver' ? 'Plata' : 'Bronce',
                            streak: mining.current_streak || 0,
                            daily_reward: tierRewards[mining.tier] || 0.5,
                            total_mined: parseFloat(mining.testnet_ltd_mined) || 0
                        },
                        alerts: alerts
                    },
                    timestamp: new Date().toISOString()
                });
                return;
            } catch (error) {
                log('error', 'Error in hub summary: ' + error.message);
                sendError(res, 500, 'Error al obtener resumen del hub');
                return;
            }
        }

        // GET /api/hub/activity - Unified activity feed from all modules
        if (pathname === '/api/hub/activity' && (method === 'GET' || method === 'HEAD')) {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) { sendError(res, 401, 'Autenticacion requerida'); return; }
            const userId = authUser.userId;
            const limit = Math.min(parseInt(query.limit) || 20, 100);
            const offset = parseInt(query.offset) || 0;
            const source = query.source || 'all';

            if (!userId) {
                sendError(res, 400, 'user_id es requerido');
                return;
            }

            try {
                let activities = [];

                // Get tanda contributions
                if (source === 'all' || source === 'tandas') {
                    const tandasActivity = await dbPostgres.pool.query(
                        `SELECT 'tandas' as source, 'contribution' as type,
                         g.name as title, c.amount, c.status, c.created_at as timestamp,
                         CASE WHEN c.status = 'completed' THEN 'fa-check-circle' ELSE 'fa-clock' END as icon
                         FROM contributions c
                         JOIN groups g ON c.group_id = g.group_id
                         WHERE c.user_id = $1
                         ORDER BY c.created_at DESC LIMIT 10`,
                        [userId]
                    ).catch(e => ({ rows: [] }));
                    activities = activities.concat(tandasActivity.rows);
                }

                // Get marketplace orders (as seller)
                if (source === 'all' || source === 'marketplace') {
                    const marketActivity = await dbPostgres.pool.query(
                        `SELECT 'marketplace' as source, 'sale' as type,
                         p.title, o.total_amount as amount, o.status, o.created_at as timestamp,
                         'fa-shopping-bag' as icon
                         FROM marketplace_orders o
                         JOIN marketplace_products p ON o.product_id = p.product_id
                         WHERE o.seller_id = $1
                         ORDER BY o.created_at DESC LIMIT 10`,
                        [userId]
                    ).catch(e => ({ rows: [] }));
                    activities = activities.concat(marketActivity.rows);
                }

                // Get lottery wins
                if (source === 'all' || source === 'lottery') {
                    const lotteryActivity = await dbPostgres.pool.query(
                        `SELECT 'lottery' as source, 'spin' as type,
                         prize_name as title, prize_value as amount, 'won' as status,
                         spin_date as timestamp, 'fa-ticket-alt' as icon
                         FROM lottery_spins
                         WHERE user_id = $1 AND prize_value > 0
                         ORDER BY spin_date DESC LIMIT 10`,
                        [userId]
                    ).catch(e => ({ rows: [] }));
                    activities = activities.concat(lotteryActivity.rows);
                }

                // Get mining claims
                if (source === 'all' || source === 'mining') {
                    const miningActivity = await dbPostgres.pool.query(
                        `SELECT 'mining' as source, 'claim' as type,
                         'Recompensa mineria' as title, reward_amount as amount, 'claimed' as status,
                         claim_date as timestamp, 'fa-hammer' as icon
                         FROM mining_claims
                         WHERE user_id = $1
                         ORDER BY claim_date DESC LIMIT 10`,
                        [userId]
                    ).catch(e => ({ rows: [] }));
                    activities = activities.concat(miningActivity.rows);
                }

                // Sort by timestamp and paginate
                activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                const paginated = activities.slice(offset, offset + limit);

                // Format activities for frontend
                const formatted = paginated.map(a => ({
                    source: a.source,
                    type: a.type,
                    title: a.title,
                    amount: parseFloat(a.amount) || 0,
                    status: a.status,
                    timestamp: a.timestamp,
                    icon: a.icon,
                    formatted_amount: (a.source === 'mining' || a.source === 'lottery')
                        ? '+' + (parseFloat(a.amount) || 0).toFixed(2) + ' LTD'
                        : 'L. ' + (parseFloat(a.amount) || 0).toLocaleString('es-HN', { minimumFractionDigits: 2 })
                }));

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        activities: formatted,
                        pagination: {
                            total: activities.length,
                            limit: limit,
                            offset: offset,
                            has_more: offset + limit < activities.length
                        }
                    }
                });
                return;
            } catch (error) {
                log('error', 'Error in hub activity: ' + error.message);
                sendError(res, 500, 'Error al obtener actividad');
                return;
            }
        }

        // GET /api/hub/insights - AI-generated insights based on user data
        if (pathname === '/api/hub/insights' && (method === 'GET' || method === 'HEAD')) {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) { sendError(res, 401, 'Autenticacion requerida'); return; }
            const userId = authUser.userId;

            if (!userId) {
                sendError(res, 400, 'user_id es requerido');
                return;
            }

            try {
                const insights = [];

                // Get user data for insight generation
                const [walletData, salesData, tandaData, miningData] = await Promise.all([
                    dbPostgres.pool.query(
                        'SELECT balance, crypto_balances FROM user_wallets WHERE user_id = $1',
                        [userId]
                    ).catch(e => ({ rows: [] })),
                    dbPostgres.pool.query(
                        `SELECT SUM(total_amount) as total_sales
                         FROM marketplace_orders
                         WHERE seller_id = $1 AND status = 'completed' AND created_at >= CURRENT_DATE - INTERVAL '7 days'`,
                        [userId]
                    ).catch(e => ({ rows: [{ total_sales: 0 }] })),
                    dbPostgres.pool.query(
                        `SELECT COUNT(*) as active_tandas FROM group_members gm
                         JOIN groups g ON gm.group_id = g.group_id
                         WHERE gm.user_id = $1 AND g.status = 'active'`,
                        [userId]
                    ).catch(e => ({ rows: [{ active_tandas: 0 }] })),
                    dbPostgres.pool.query(
                        'SELECT tier, current_streak FROM mining_users WHERE user_id = $1',
                        [userId]
                    ).catch(e => ({ rows: [{ tier: 'bronze', current_streak: 0 }] }))
                ]);

                const wallet = walletData.rows[0] || {};
                const sales = salesData.rows[0] || { total_sales: 0 };
                const tandas = tandaData.rows[0] || { active_tandas: 0 };
                const mining = miningData.rows[0] || { tier: 'bronze', current_streak: 0 };

                const totalSales = parseFloat(sales.total_sales) || 0;
                const hnlBalance = parseFloat(wallet.balance) || 0;
                const activeTandas = parseInt(tandas.active_tandas) || 0;
                const streak = parseInt(mining.current_streak) || 0;
                const tier = mining.tier || 'bronze';

                // Rule-based insight generation

                // 1. Sales to Tanda suggestion
                if (totalSales > 500 && activeTandas === 0) {
                    insights.push({
                        id: 'sales-to-tanda',
                        icon: 'fa-piggy-bank',
                        text: 'Ganaste L.' + totalSales.toLocaleString() + ' esta semana. Crear una tanda para ahorrar?',
                        action_text: 'Crear Tanda',
                        action_url: 'groups-advanced-system.html?action=create',
                        priority: 1,
                        color: '#00FFFF'
                    });
                }

                // 2. Balance to investment
                if (hnlBalance > 1000) {
                    insights.push({
                        id: 'balance-invest',
                        icon: 'fa-chart-line',
                        text: 'Tienes L.' + hnlBalance.toLocaleString() + ' disponibles. Considera invertir en staking.',
                        action_text: 'Ver Staking',
                        action_url: 'web3-dashboard.html#staking',
                        priority: 2,
                        color: '#22d55e'
                    });
                }

                // 3. Mining streak bonus
                if (streak >= 5) {
                    insights.push({
                        id: 'streak-bonus',
                        icon: 'fa-fire',
                        text: streak + ' dias de racha! Manten tu bonus de mineria activo.',
                        action_text: 'Minar Ahora',
                        action_url: '#mining-section',
                        priority: 3,
                        color: '#ff6b6b'
                    });
                }

                // 4. Tier upgrade suggestion
                if (tier === 'bronze' && streak >= 7) {
                    insights.push({
                        id: 'tier-upgrade',
                        icon: 'fa-arrow-up',
                        text: 'Estas cerca de subir a Tier Plata. Sigue minando!',
                        action_text: 'Ver Progreso',
                        action_url: '#mining-section',
                        priority: 2,
                        color: '#c0c0c0'
                    });
                }

                // 5. Lottery reminder
                insights.push({
                    id: 'lottery-reminder',
                    icon: 'fa-ticket-alt',
                    text: 'Numeros calientes hoy: 45, 23, 8. Prueba tu suerte!',
                    action_text: 'Jugar Loteria',
                    action_url: 'loteria.html',
                    priority: 4,
                    color: '#8b5cf6'
                });

                // 6. No tandas suggestion
                if (activeTandas === 0) {
                    insights.push({
                        id: 'join-tanda',
                        icon: 'fa-users',
                        text: 'Unete a una tanda y empieza a ahorrar con tu comunidad.',
                        action_text: 'Explorar Tandas',
                        action_url: 'groups-advanced-system.html',
                        priority: 1,
                        color: '#fbbf24'
                    });
                }

                // Sort by priority and limit to 4
                insights.sort((a, b) => a.priority - b.priority);
                const topInsights = insights.slice(0, 4);

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        insights: topInsights,
                        generated_at: new Date().toISOString()
                    }
                });
                return;
            } catch (error) {
                log('error', 'Error in hub insights: ' + error.message);
                sendError(res, 500, 'Error al generar insights');
                return;
            }
        }

// ============================================
        // GET /api/feed/social - Public social feed
        // Added: 2026-01-24 | Enhanced: 2026-01-25 with actor data | 2026-02-03 hashtag filter
        // ============================================
        if (pathname === "/api/feed/social" && (method === "GET" || method === "HEAD")) {
            try {
                const limit = Math.min(parseInt(query.limit) || 20, 50);
                const offset = parseInt(query.offset) || 0;
                const types = query.types ? query.types.split(",").map(t => t.trim()) : null;
                const hashtag = query.hashtag ? query.hashtag.toLowerCase().replace(/^#/, '') : null;
                const searchTerm = query.search ? String(query.search).trim().substring(0, 100) : null;

                // Enhanced query with JOIN to users table for actor data
                let queryText = `
                    SELECT 
                        sf.id, sf.event_type, sf.actor_id, sf.actor_name, sf.title, 
                        sf.description, sf.image_url, sf.action_url, sf.metadata, sf.created_at,
                        sf.view_count, sf.likes_count, sf.comments_count, sf.shares_count,
                        sf.hashtags_detected, sf.mentions_detected,
                        u.name as user_name,
                        u.avatar_url as user_avatar,
                        u.verification_level,
                        UPPER(COALESCE(
                            SUBSTRING(COALESCE(u.name, sf.actor_name) FROM 1 FOR 1) ||
                            COALESCE(SUBSTRING(COALESCE(u.name, sf.actor_name) FROM POSITION(' ' IN COALESCE(u.name, sf.actor_name)) + 1 FOR 1), ''),
                            '??'
                        )) as actor_initials
                    FROM social_feed sf
                    LEFT JOIN users u ON sf.actor_id = u.user_id
                `;
                const params = [];
                const whereClauses = [];

                // Filter by types if provided
                if (types && types.length > 0) {
                    params.push(types);
                    whereClauses.push(`sf.event_type = ANY($${params.length})`);
                }

                // Filter by hashtag if provided
                if (hashtag) {
                    params.push(hashtag);
                    whereClauses.push(`sf.hashtags_detected ? $${params.length}`);
                }

                // Filter by search term if provided
                if (searchTerm) {
                    params.push('%' + searchTerm + '%');
                    whereClauses.push(`(sf.title ILIKE $${params.length} OR sf.description ILIKE $${params.length} OR sf.actor_name ILIKE $${params.length} OR u.name ILIKE $${params.length})`);
                }

                if (whereClauses.length > 0) {
                    queryText += ` WHERE ` + whereClauses.join(' AND ');
                }

                queryText += ` ORDER BY sf.created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
                params.push(limit, offset);

                // Get total count with same filters
                let countQuery = `SELECT COUNT(*) as total FROM social_feed sf` + (searchTerm ? ` LEFT JOIN users u ON sf.actor_id = u.user_id` : ``);
                const countWhereClauses = [];
                const countParams = [];

                if (types && types.length > 0) {
                    countParams.push(types);
                    countWhereClauses.push(`sf.event_type = ANY($${countParams.length})`);
                }
                if (hashtag) {
                    countParams.push(hashtag);
                    countWhereClauses.push(`sf.hashtags_detected ? $${countParams.length}`);
                }
                if (searchTerm) {
                    countParams.push('%' + searchTerm + '%');
                    countWhereClauses.push(`(sf.title ILIKE $${countParams.length} OR sf.description ILIKE $${countParams.length} OR sf.actor_name ILIKE $${countParams.length} OR u.name ILIKE $${countParams.length})`);
                }

                if (countWhereClauses.length > 0) {
                    countQuery += ` WHERE ` + countWhereClauses.join(' AND ');
                }

                const [eventsResult, countResult] = await Promise.all([
                    dbPostgres.pool.query(queryText, params),
                    dbPostgres.pool.query(countQuery, countParams)
                ]);

                const events = eventsResult.rows.map(e => ({
                    id: e.id,
                    event_type: e.event_type,
                    title: e.title,
                    description: e.description,
                    image_url: e.image_url,
                    action_url: e.action_url,
                    metadata: e.metadata || {},
                    hashtags: e.hashtags_detected || [],
                    mentions: e.mentions_detected || [],
                    created_at: e.created_at,
                    time_ago: formatTimeAgo(e.created_at),
                    // Enhanced actor object
                    actor: {
                        id: e.actor_id,
                        name: e.user_name || e.actor_name || "Usuario",
                        avatar_url: e.user_avatar || null,
                        initials: e.actor_initials || "??",
                        verified: e.verification_level && e.verification_level >= 2
                    },
                    // Engagement counters
                    engagement: {
                        likes: e.likes_count || 0,
                        comments: e.comments_count || 0,
                        views: e.view_count || 0,
                        shares: e.shares_count || 0
                    }
                }));

                const total = parseInt(countResult.rows[0]?.total) || 0;
                const feedAuthUser = getAuthenticatedUser(req, query);
                if (feedAuthUser) {
                    const pollEventIds = events.filter(ev => ev.metadata && ev.metadata.poll).map(ev => ev.id);
                    if (pollEventIds.length > 0) {
                        try {
                            const userVotes = await dbPostgres.pool.query(
                                'SELECT event_id, option_index FROM poll_votes WHERE user_id = $1 AND event_id = ANY($2)',
                                [feedAuthUser.userId, pollEventIds]
                            );
                            const voteMap = {};
                            userVotes.rows.forEach(v => { voteMap[v.event_id] = v.option_index; });
                            events.forEach(ev => {
                                if (ev.metadata && ev.metadata.poll && voteMap[ev.id] !== undefined) {
                                    ev.metadata.poll.user_vote = voteMap[ev.id];
                                }
                            });
                        } catch (pvErr) {
                            log('warn', '[SOCIAL] Poll vote check error: ' + pvErr.message);
                        }
                    }
                }



                // Enrich with user likes/bookmarks state
                if (feedAuthUser) {
                    const eventIds = events.map(ev => ev.id);
                    if (eventIds.length > 0) {
                        try {
                            const [userLikes, userBookmarks] = await Promise.all([
                                dbPostgres.pool.query(
                                    'SELECT event_id FROM social_likes WHERE user_id = $1 AND event_id = ANY($2)',
                                    [feedAuthUser.userId, eventIds]
                                ),
                                dbPostgres.pool.query(
                                    'SELECT event_id FROM social_bookmarks WHERE user_id = $1 AND event_id = ANY($2)',
                                    [feedAuthUser.userId, eventIds]
                                )
                            ]);
                            const likedSet = new Set(userLikes.rows.map(r => r.event_id));
                            const bookmarkedSet = new Set(userBookmarks.rows.map(r => r.event_id));
                            events.forEach(ev => {
                                ev.is_liked = likedSet.has(ev.id);
                                ev.is_bookmarked = bookmarkedSet.has(ev.id);
                            });
                        } catch (lbErr) {
                            log('warn', '[SOCIAL] Like/bookmark check error: ' + lbErr.message);
                        }
                    }
                }

                // Mask actor info for anonymous posts
                const feedAuthUserId = feedAuthUser ? feedAuthUser.userId : null;
                events.forEach(ev => {
                    if (ev.metadata && ev.metadata.is_anonymous) {
                        const realActorId = ev.actor.id;
                        if (feedAuthUserId && realActorId === feedAuthUserId) {
                            ev.metadata.real_actor_id = realActorId;
                        }
                        ev.actor = { id: null, name: "Anonimo", avatar_url: null, initials: "??", verified: false };
                    }
                });
                sendResponse(res, 200, {
                    success: true,
                    data: {
                        events: events,
                        pagination: {
                            total: total,
                            limit: limit,
                            offset: offset,
                            has_more: offset + limit < total
                        },
                        filter: hashtag ? { hashtag: hashtag } : null
                    }
                });
                return;
            } catch (error) {
                log("error", "[SOCIAL_FEED] Error fetching feed: " + error.message);
                sendError(res, 500, "Error al obtener feed social");
                return;
            }
        }


        // ============================================

        // ============================================
        // POST /api/feed/social - Create new post
        // Added: 2026-02-01 | Enhanced: 2026-02-03 with @mentions and #hashtags
        // ============================================
        if (pathname === '/api/feed/social' && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida para publicar');
                return;
            }

            const userId = authUser.userId;

            try {
                const content = (body.content || '').trim();
                // v4.1.0: Validate image_url protocol
                let imageUrl = null;
                if (body.image_url) {
                    const imgStr = String(body.image_url).trim();
                    if (imgStr.startsWith('/uploads/') || imgStr.startsWith('https://')) {
                        imageUrl = imgStr.substring(0, 500);
                    }
                }

                if (!content) {
                    sendError(res, 400, 'El contenido no puede estar vacio');
                    return;
                }
                if (content.length > 500) {
                    sendError(res, 400, 'El contenido no puede exceder 500 caracteres');
                    return;
                }

                const userResult = await dbPostgres.pool.query(
                    'SELECT name, avatar_url, verification_level FROM users WHERE user_id = $1',
                    [userId]
                );
                const userInfo = userResult.rows[0] || {};
                const userName = userInfo.name || 'Usuario';

                // ========== Extract @mentions ==========
                const mentionRegex = /@([\w\-\.]+)/g;
                const mentionMatches = content.matchAll(mentionRegex);
                const mentionsDetected = [];
                const mentionedUserIds = [];

                for (const match of mentionMatches) {
                    const handle = match[1].toLowerCase();
                    
                    // Look up user by handle
                    const mentionedUserResult = await dbPostgres.pool.query(
                        `SELECT user_id, name FROM users 
                         WHERE LOWER(handle) = $1
                         LIMIT 1`,
                        [handle]
                    );

                    if (mentionedUserResult.rows.length > 0) {
                        const mentionedUser = mentionedUserResult.rows[0];
                        mentionsDetected.push({
                            handle: handle,
                            user_id: mentionedUser.user_id,
                            name: mentionedUser.name
                        });
                        // Track for notifications (avoid duplicates)
                        if (!mentionedUserIds.includes(mentionedUser.user_id)) {
                            mentionedUserIds.push(mentionedUser.user_id);
                        }
                    }
                }

                // ========== Extract #hashtags ==========
                const hashtagRegex = /#([\wáéíóúñÁÉÍÓÚÑ]+)/g;
                const hashtagMatches = content.matchAll(hashtagRegex);
                const hashtagsDetected = [];

                for (const match of hashtagMatches) {
                    const tag = match[1].toLowerCase();
                    if (!hashtagsDetected.includes(tag)) {
                        hashtagsDetected.push(tag);
                    }
                }

                // ========== Build metadata (with optional poll) ==========
                const postMetadata = { type: 'user_post' };
                if (body.poll && Array.isArray(body.poll.options) && body.poll.options.length >= 2) {
                    const pollOptions = body.poll.options.slice(0, 4).map(o => String(o).trim()).filter(o => o.length > 0);
                    if (pollOptions.length >= 2) {
                        const durationHours = Math.min(parseInt(body.poll.duration_hours) || 72, 168);
                        const expiresAt = new Date(Date.now() + durationHours * 60 * 60 * 1000);
                        postMetadata.poll = {
                            options: pollOptions,
                            votes: pollOptions.map(() => 0),
                            total_votes: 0,
                            expires_at: expiresAt.toISOString(),
                            duration_hours: durationHours
                        };
                    }
                }
                if (body.media_type === 'gif') {
                    postMetadata.media_type = 'gif';
                }
                if (body.media_type === 'video') {
                    postMetadata.media_type = 'video';
                }
                if (body.location && typeof body.location === 'string') {
                    postMetadata.location = body.location.trim().substring(0, 100);
                }
                if (body.is_anonymous === true) {
                    postMetadata.is_anonymous = true;
                }
                if (body.link_preview && typeof body.link_preview === "object" && body.link_preview.url) {
                    postMetadata.link_preview = {
                        url: String(body.link_preview.url).substring(0, 500),
                        title: body.link_preview.title ? String(body.link_preview.title).substring(0, 200) : null,
                        description: body.link_preview.description ? String(body.link_preview.description).substring(0, 300) : null,
                        image: body.link_preview.image ? String(body.link_preview.image).substring(0, 500) : null,
                        site_name: body.link_preview.site_name ? String(body.link_preview.site_name).substring(0, 100) : null,
                        domain: body.link_preview.domain ? String(body.link_preview.domain).substring(0, 100) : null
                    };
                }

                // ========== Insert post with mentions and hashtags ==========
                const insertResult = await dbPostgres.pool.query(
                    `INSERT INTO social_feed 
                     (event_type, actor_id, actor_name, title, description, image_url, action_url, metadata, mentions_detected, hashtags_detected) 
                     VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) 
                     RETURNING id, created_at`,
                    [
                        'user_post', 
                        userId, 
                        userName, 
                        content.substring(0, 100), 
                        content, 
                        imageUrl, 
                        null, 
                        JSON.stringify(postMetadata),
                        JSON.stringify(mentionsDetected),
                        JSON.stringify(hashtagsDetected)
                    ]
                );

                const postId = insertResult.rows[0].id;

                // ========== Send notifications to mentioned users ==========
                for (const mentionedUserId of mentionedUserIds) {
                    // Skip self-mentions
                    if (mentionedUserId === userId) continue;

                    try {
                        await dbPostgres.pool.query(
                            `INSERT INTO notifications (user_id, subject, body, notification_type, action_url, created_at)
                             VALUES ($1, $2, $3, 'mention', $4, NOW())`,
                            [
                                mentionedUserId,
                                'Te mencionaron en una publicacion',
                                '@' + userName + ' te menciono en una publicacion',
                                '/home-dashboard.html?event=' + postId
                            ]
                        );
                    } catch (notifError) {
                        log('warn', '[SOCIAL] Failed to create mention notification: ' + notifError.message);
                    }
                }

                const post = {
                    id: postId,
                    event_type: 'user_post',
                    title: content.substring(0, 100),
                    description: content,
                    image_url: imageUrl,
                    metadata: postMetadata,
                    hashtags: hashtagsDetected,
                    mentions: mentionsDetected,
                    created_at: insertResult.rows[0].created_at,
                    time_ago: 'ahora',
                    actor: {
                        id: userId,
                        name: userName,
                        avatar_url: userInfo.avatar_url || null,
                        initials: userName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase(),
                        verified: userInfo.verification_level && parseInt(userInfo.verification_level) >= 2
                    },
                    engagement: { likes: 0, comments: 0, views: 0, shares: 0 }
                };

                log('info', '[SOCIAL] User ' + userId + ' created post with ' + mentionsDetected.length + ' mentions and ' + hashtagsDetected.length + ' hashtags');

                // If anonymous, mask actor in response but keep real_actor_id for edit/delete
                if (postMetadata.is_anonymous) {
                    post.metadata.real_actor_id = userId;
                    post.actor = { id: null, name: "Anonimo", avatar_url: null, initials: "??", verified: false };
                }
                sendResponse(res, 201, { success: true, data: { post: post } });
            } catch (error) {
                log('error', '[SOCIAL] Create post error: ' + error.message);
                sendError(res, 500, 'Error al crear publicacion');
            }
            return;
        }


        // ============================================

        // ============================================
        // DELETE /api/feed/social/:id - Delete post
        // Added: 2026-02-02
        // Only owner can delete their own posts
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/[\w-]+$/) && method === "DELETE") {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticacion requerida");
                return;
            }

            const postId = pathname.split("/")[4];
            const userId = authUser.userId;

            try {
                // Check if post exists and belongs to user
                const postResult = await dbPostgres.pool.query(
                    "SELECT id, actor_id, event_type FROM social_feed WHERE id = $1",
                    [postId]
                );

                if (postResult.rows.length === 0) {
                    sendError(res, 404, "Publicacion no encontrada");
                    return;
                }

                const post = postResult.rows[0];

                // Only allow deletion of user_post type and only by owner
                if (post.event_type !== "user_post") {
                    sendError(res, 403, "Solo puedes eliminar tus propias publicaciones");
                    return;
                }

                if (post.actor_id !== userId) {
                    sendError(res, 403, "Solo puedes eliminar tus propias publicaciones");
                    return;
                }

                // Delete the post
                await dbPostgres.pool.query(
                    "DELETE FROM social_feed WHERE id = $1",
                    [postId]
                );

                // Also delete related likes, bookmarks, comments
                await dbPostgres.pool.query("DELETE FROM social_likes WHERE event_id = $1", [postId]);
                await dbPostgres.pool.query("DELETE FROM social_bookmarks WHERE event_id = $1", [postId]);
                await dbPostgres.pool.query("DELETE FROM social_comments WHERE event_id = $1", [postId]);

                log("info", "[SOCIAL] User " + userId + " deleted post " + postId);
                sendResponse(res, 200, { success: true, message: "Publicacion eliminada" });
            } catch (error) {
                log("error", "[SOCIAL] Delete post error: " + error.message);
                sendError(res, 500, "Error al eliminar publicacion");
            }
            return;
        }

        // ============================================
        // PUT /api/feed/social/:id - Edit post
        // Added: 2026-02-02
        // Only owner can edit their own posts
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/[\w-]+$/) && method === "PUT") {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticacion requerida");
                return;
            }

            const postId = pathname.split("/")[4];
            const userId = authUser.userId;

            try {
                const content = (body.content || "").trim();

                if (!content) {
                    sendError(res, 400, "El contenido no puede estar vacio");
                    return;
                }

                if (content.length > 500) {
                    sendError(res, 400, "El contenido no puede exceder 500 caracteres");
                    return;
                }

                // Check if post exists and belongs to user
                const postResult = await dbPostgres.pool.query(
                    "SELECT id, actor_id, event_type FROM social_feed WHERE id = $1",
                    [postId]
                );

                if (postResult.rows.length === 0) {
                    sendError(res, 404, "Publicacion no encontrada");
                    return;
                }

                const post = postResult.rows[0];

                // Only allow editing of user_post type and only by owner
                if (post.event_type !== "user_post") {
                    sendError(res, 403, "Solo puedes editar tus propias publicaciones");
                    return;
                }

                if (post.actor_id !== userId) {
                    sendError(res, 403, "Solo puedes editar tus propias publicaciones");
                    return;
                }

                // Update the post
                const updateResult = await dbPostgres.pool.query(
                    "UPDATE social_feed SET title = $1, description = $2, updated_at = NOW() WHERE id = $3 RETURNING updated_at",
                    [content.substring(0, 100), content, postId]
                );

                log("info", "[SOCIAL] User " + userId + " edited post " + postId);
                sendResponse(res, 200, { 
                    success: true, 
                    data: { 
                        content: content,
                        updated_at: updateResult.rows[0].updated_at 
                    },
                    message: "Publicacion actualizada" 
                });
            } catch (error) {
                log("error", "[SOCIAL] Edit post error: " + error.message);
                sendError(res, 500, "Error al editar publicacion");
            }
            return;
        }



        // ============================================
        // POST /api/feed/social/:id/like - Toggle like
        // Added: 2026-01-25
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/[\w-]+\/like$/) && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }

            const eventId = pathname.split('/')[4];
            const userId = authUser.userId;

            try {
                // Check existing like
                const existing = await dbPostgres.pool.query(
                    'SELECT id FROM social_likes WHERE user_id = $1 AND event_id = $2',
                    [userId, eventId]
                );

                let liked;
                if (existing.rows.length > 0) {
                    // Unlike
                    await dbPostgres.pool.query(
                        'DELETE FROM social_likes WHERE user_id = $1 AND event_id = $2',
                        [userId, eventId]
                    );
                    await dbPostgres.pool.query(
                        'UPDATE social_feed SET likes_count = GREATEST(0, likes_count - 1) WHERE id = $1',
                        [eventId]
                    );
                    liked = false;
                log('info', `[SOCIAL] User ${userId} unliked event ${eventId}`);
                } else {
                    // Like
                    await dbPostgres.pool.query(
                        'INSERT INTO social_likes (user_id, event_id) VALUES ($1, $2)',
                        [userId, eventId]
                    );
                    await dbPostgres.pool.query(
                        'UPDATE social_feed SET likes_count = likes_count + 1 WHERE id = $1',
                        [eventId]
                    );
                    liked = true;
                log('info', `[SOCIAL] User ${userId} liked event ${eventId}`);
                }

                // Get updated count
                const countResult = await dbPostgres.pool.query(
                    'SELECT likes_count FROM social_feed WHERE id = $1',
                    [eventId]
                );

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        liked: liked,
                        likes_count: countResult.rows[0]?.likes_count || 0
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] Like error: ' + error.message);
                sendError(res, 500, 'Error al procesar like');
                return;
            }
        }

        // ============================================
        // POST /api/feed/social/:id/bookmark - Toggle bookmark
        // Added: 2026-01-25
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/[\w-]+\/bookmark$/) && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }

            const eventId = pathname.split('/')[4];
            const userId = authUser.userId;

            try {
                // Check existing bookmark
                const existing = await dbPostgres.pool.query(
                    'SELECT id FROM social_bookmarks WHERE user_id = $1 AND event_id = $2',
                    [userId, eventId]
                );

                let bookmarked;
                if (existing.rows.length > 0) {
                    // Remove bookmark
                    await dbPostgres.pool.query(
                        'DELETE FROM social_bookmarks WHERE user_id = $1 AND event_id = $2',
                        [userId, eventId]
                    );
                    bookmarked = false;
                log('info', `[SOCIAL] User ${userId} unbookmarked event ${eventId}`);
                } else {
                    // Add bookmark
                    await dbPostgres.pool.query(
                        'INSERT INTO social_bookmarks (user_id, event_id) VALUES ($1, $2)',
                        [userId, eventId]
                    );
                    bookmarked = true;
                log('info', `[SOCIAL] User ${userId} bookmarked event ${eventId}`);
                }

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        bookmarked: bookmarked
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] Bookmark error: ' + error.message);
                sendError(res, 500, 'Error al procesar bookmark');
                return;
            }
        }

        // ============================================
        // POST /api/feed/social/track-views - Batch increment view counts
        // Added: 2026-02-26
        // ============================================
        if (pathname === '/api/feed/social/track-views' && method === 'POST') {
            try {
                const eventIds = body.event_ids;

                if (!Array.isArray(eventIds) || eventIds.length === 0) {
                    sendError(res, 400, 'event_ids debe ser un array no vacio');
                    return;
                }

                if (eventIds.length > 50) {
                    sendError(res, 400, 'Maximo 50 eventos por solicitud');
                    return;
                }

                // Validate each ID is a non-empty string
                const validIds = eventIds.filter(id => typeof id === 'string' && id.trim().length > 0);
                if (validIds.length === 0) {
                    sendError(res, 400, 'event_ids contiene valores invalidos');
                    return;
                }

                const result = await dbPostgres.pool.query(
                    'UPDATE social_feed SET view_count = view_count + 1 WHERE id = ANY($1::uuid[])',
                    [validIds]
                );

                sendResponse(res, 200, {
                    success: true,
                    tracked: result.rowCount
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] Track views error: ' + error.message);
                sendError(res, 500, 'Error al registrar vistas');
                return;
            }
        }

        // ============================================
        // GET /api/feed/social/bookmarks - Get user's bookmarked events
        // Added: 2026-01-25
        // ============================================
        if (pathname === '/api/feed/social/bookmarks' && (method === 'GET' || method === 'HEAD')) {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }

            const userId = authUser.userId;
            const limit = Math.min(parseInt(query.limit) || 20, 50);
            const offset = parseInt(query.offset) || 0;

            try {
                const result = await dbPostgres.pool.query(`
                    SELECT
                        sf.id, sf.event_type, sf.actor_id, sf.actor_name, sf.title,
                        sf.description, sf.image_url, sf.action_url, sf.metadata, sf.created_at,
                        sf.view_count, sf.likes_count, sf.comments_count, sf.shares_count,
                        u.name as user_name,
                        u.avatar_url as user_avatar,
                        u.verification_level,
                        sb.created_at as bookmarked_at
                    FROM social_bookmarks sb
                    JOIN social_feed sf ON sb.event_id = sf.id
                    LEFT JOIN users u ON sf.actor_id = u.user_id
                    WHERE sb.user_id = $1
                    ORDER BY sb.created_at DESC
                    LIMIT $2 OFFSET $3
                `, [userId, limit, offset]);

                const countResult = await dbPostgres.pool.query(
                    'SELECT COUNT(*) as total FROM social_bookmarks WHERE user_id = $1',
                    [userId]
                );

                const events = result.rows.map(e => ({
                    id: e.id,
                    event_type: e.event_type,
                    title: e.title,
                    description: e.description,
                    image_url: e.image_url,
                    action_url: e.action_url,
                    metadata: e.metadata || {},
                    created_at: e.created_at,
                    time_ago: formatTimeAgo(e.created_at),
                    bookmarked_at: e.bookmarked_at,
                    actor: {
                        id: e.actor_id,
                        name: e.user_name || e.actor_name || "Usuario",
                        avatar_url: e.user_avatar || null,
                        verified: e.verification_level && e.verification_level >= 2
                    },
                    engagement: {
                        likes: e.likes_count || 0,
                        comments: e.comments_count || 0,
                        views: e.view_count || 0
                    }
                }));

                const total = parseInt(countResult.rows[0]?.total) || 0;

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        events: events,
                        pagination: {
                            total: total,
                            limit: limit,
                            offset: offset,
                            has_more: offset + limit < total
                        }
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] Bookmarks fetch error: ' + error.message);
                sendError(res, 500, 'Error al obtener guardados');
                return;
            }
        }



        // ============================================
        // GET /api/feed/social/:id/comments - Get comments for event
        // Added: 2026-01-25
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/[\w-]+\/comments$/) && (method === 'GET' || method === 'HEAD')) {
            const eventId = pathname.split('/')[4];
            const limit = Math.min(parseInt(query.limit) || 50, 100);
            const offset = parseInt(query.offset) || 0;

            try {
                // Get comments with user info (including nested replies)
                const result = await dbPostgres.pool.query(`
                    SELECT
                        c.id,
                        c.event_id,
                        c.user_id,
                        c.parent_id,
                        c.content,
                        c.created_at,
                        u.name as user_name,
                        u.avatar_url as user_avatar,
                        u.verification_level,
                        UPPER(COALESCE(
                            SUBSTRING(u.name FROM 1 FOR 1) ||
                            COALESCE(SUBSTRING(u.name FROM POSITION(' ' IN u.name) + 1 FOR 1), ''),
                            '??'
                        )) as user_initials
                    FROM social_comments c
                    LEFT JOIN users u ON c.user_id = u.user_id
                    WHERE c.event_id = $1
                    ORDER BY c.created_at ASC
                    LIMIT $2 OFFSET $3
                `, [eventId, limit, offset]);

                const countResult = await dbPostgres.pool.query(
                    'SELECT COUNT(*) as total FROM social_comments WHERE event_id = $1',
                    [eventId]
                );

                // Build nested comment structure
                const commentsMap = new Map();
                const rootComments = [];

                result.rows.forEach(row => {
                    const comment = {
                        id: row.id,
                        event_id: row.event_id,
                        parent_id: row.parent_id,
                        content: row.content,
                        created_at: row.created_at,
                        time_ago: formatTimeAgo(row.created_at),
                        user: {
                            id: row.user_id,
                            name: row.user_name || 'Usuario',
                            avatar_url: row.user_avatar || null,
                            initials: row.user_initials || '??',
                            verified: row.verification_level && parseInt(row.verification_level) >= 2
                        },
                        replies: []
                    };
                    commentsMap.set(row.id, comment);
                });

                // Organize into tree structure
                commentsMap.forEach(comment => {
                    if (comment.parent_id && commentsMap.has(comment.parent_id)) {
                        commentsMap.get(comment.parent_id).replies.push(comment);
                    } else {
                        rootComments.push(comment);
                    }
                });

                const total = parseInt(countResult.rows[0]?.total) || 0;

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        comments: rootComments,
                        total: total,
                        pagination: {
                            limit: limit,
                            offset: offset,
                            has_more: offset + limit < total
                        }
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] Comments fetch error: ' + error.message);
                sendError(res, 500, 'Error al obtener comentarios');
                return;
            }
        }

        // ============================================
        // POST /api/feed/social/:id/comments - Add comment
        // Added: 2026-01-25
        // Fixed: 2026-02-01 - Use pre-parsed body instead of req.on('data')
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/[\w-]+\/comments$/) && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }

            const eventId = pathname.split('/')[4];
            const userId = authUser.userId;

            try {
                // body is already parsed by global parseBody() at line ~2916
                const content = (body.content || '').trim();
                const parentId = body.parent_id || null;

                // Validate content
                if (!content) {
                    sendError(res, 400, 'El comentario no puede estar vacio');
                    return;
                }
                if (content.length > 500) {
                    sendError(res, 400, 'El comentario no puede exceder 500 caracteres');
                    return;
                }

                // Verify event exists
                const eventCheck = await dbPostgres.pool.query(
                    'SELECT id FROM social_feed WHERE id = $1',
                    [eventId]
                );
                if (eventCheck.rows.length === 0) {
                    sendError(res, 404, 'Publicacion no encontrada');
                    return;
                }

                // If replying, verify parent exists
                if (parentId) {
                    const parentCheck = await dbPostgres.pool.query(
                        'SELECT id FROM social_comments WHERE id = $1 AND event_id = $2',
                        [parentId, eventId]
                    );
                    if (parentCheck.rows.length === 0) {
                        sendError(res, 404, 'Comentario padre no encontrado');
                        return;
                    }
                }

                // Insert comment
                const insertResult = await dbPostgres.pool.query(`
                    INSERT INTO social_comments (event_id, user_id, parent_id, content)
                    VALUES ($1, $2, $3, $4)
                    RETURNING id, created_at
                `, [eventId, userId, parentId, content]);

                // Update comments_count on social_feed
                await dbPostgres.pool.query(
                    'UPDATE social_feed SET comments_count = comments_count + 1 WHERE id = $1',
                    [eventId]
                );

                // Get user info for response
                const userResult = await dbPostgres.pool.query(
                    'SELECT name, avatar_url, verification_level FROM users WHERE user_id = $1',
                    [userId]
                );
                const userInfo = userResult.rows[0] || {};

                const comment = {
                    id: insertResult.rows[0].id,
                    event_id: eventId,
                    parent_id: parentId,
                    content: content,
                    created_at: insertResult.rows[0].created_at,
                    time_ago: 'ahora',
                    user: {
                        id: userId,
                        name: userInfo.name || 'Usuario',
                        avatar_url: userInfo.avatar_url || null,
                        verified: userInfo.verification_level && parseInt(userInfo.verification_level) >= 2
                    },
                    replies: []
                };

                log('info', `[SOCIAL] User ${userId} commented on event ${eventId}`);

                sendResponse(res, 201, {
                    success: true,
                    data: {
                        comment: comment
                    }
                });
            } catch (error) {
                log('error', '[SOCIAL] Comment create error: ' + error.message);
                sendError(res, 500, 'Error al publicar comentario');
            }
            return;
        }

        // ============================================
        // DELETE /api/feed/social/comments/:id - Delete comment
        // Added: 2026-01-25
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/comments\/[\w-]+$/) && method === 'DELETE') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }

            const commentId = pathname.split('/')[5];
            const userId = authUser.userId;

            try {
                // Verify ownership
                const commentCheck = await dbPostgres.pool.query(
                    'SELECT id, event_id, user_id FROM social_comments WHERE id = $1',
                    [commentId]
                );

                if (commentCheck.rows.length === 0) {
                    sendError(res, 404, 'Comentario no encontrado');
                    return;
                }

                const comment = commentCheck.rows[0];
                if (comment.user_id !== userId) {
                    sendError(res, 403, 'No tienes permiso para eliminar este comentario');
                    return;
                }

                // Count replies that will be deleted
                const replyCount = await dbPostgres.pool.query(
                    'SELECT COUNT(*) as count FROM social_comments WHERE parent_id = $1',
                    [commentId]
                );
                const totalToDelete = 1 + parseInt(replyCount.rows[0]?.count || 0);

                // Delete comment (cascades to replies)
                await dbPostgres.pool.query(
                    'DELETE FROM social_comments WHERE id = $1',
                    [commentId]
                );

                // Update comments_count
                await dbPostgres.pool.query(
                    'UPDATE social_feed SET comments_count = GREATEST(0, comments_count - $1) WHERE id = $2',
                    [totalToDelete, comment.event_id]
                );

                log('info', `[SOCIAL] User ${userId} deleted comment ${commentId}`);

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        deleted: true,
                        deleted_count: totalToDelete
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] Comment delete error: ' + error.message);
                sendError(res, 500, 'Error al eliminar comentario');
                return;
            }
        }



        // ============================================
        // POST /api/feed/social/follow/:userId - Follow user
        // Added: 2026-01-25
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/follow\/[\w-]+$/) && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }

            const followingId = pathname.split('/')[5];
            const followerId = authUser.userId;

            // Can't follow yourself
            if (followerId === followingId) {
                sendError(res, 400, 'No puedes seguirte a ti mismo');
                return;
            }

            try {
                // Check if already following
                const existing = await dbPostgres.pool.query(
                    'SELECT id FROM social_follows WHERE follower_id = $1 AND following_id = $2',
                    [followerId, followingId]
                );

                if (existing.rows.length > 0) {
                    sendResponse(res, 200, {
                        success: true,
                        data: { following: true, message: 'Ya sigues a este usuario' }
                    });
                    return;
                }

                // Verify target user exists
                const userCheck = await dbPostgres.pool.query(
                    'SELECT user_id, name FROM users WHERE user_id = $1',
                    [followingId]
                );

                if (userCheck.rows.length === 0) {
                    sendError(res, 404, 'Usuario no encontrado');
                    return;
                }

                // Create follow
                await dbPostgres.pool.query(
                    'INSERT INTO social_follows (follower_id, following_id) VALUES ($1, $2)',
                    [followerId, followingId]
                );

                log('info', `[SOCIAL] User ${followerId} followed ${followingId}`);

                sendResponse(res, 201, {
                    success: true,
                    data: {
                        following: true,
                        user: {
                            id: userCheck.rows[0].user_id,
                            name: userCheck.rows[0].name
                        }
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] Follow error: ' + error.message);
                sendError(res, 500, 'Error al seguir usuario');
                return;
            }
        }

        // ============================================
        // DELETE /api/feed/social/follow/:userId - Unfollow user
        // Added: 2026-01-25
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/follow\/[\w-]+$/) && method === 'DELETE') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }

            const followingId = pathname.split('/')[5];
            const followerId = authUser.userId;

            try {
                const result = await dbPostgres.pool.query(
                    'DELETE FROM social_follows WHERE follower_id = $1 AND following_id = $2 RETURNING id',
                    [followerId, followingId]
                );

                if (result.rows.length === 0) {
                    sendResponse(res, 200, {
                        success: true,
                        data: { following: false, message: 'No seguias a este usuario' }
                    });
                    return;
                }

                log('info', `[SOCIAL] User ${followerId} unfollowed ${followingId}`);

                sendResponse(res, 200, {
                    success: true,
                    data: { following: false }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] Unfollow error: ' + error.message);
                sendError(res, 500, 'Error al dejar de seguir');
                return;
            }
        }

        // ============================================
        // GET /api/feed/social/following - Feed from followed users
        // Added: 2026-01-25
        // ============================================
        if (pathname === '/api/feed/social/following' && (method === 'GET' || method === 'HEAD')) {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }

            const userId = authUser.userId;
            const limit = Math.min(parseInt(query.limit) || 20, 50);
            const offset = parseInt(query.offset) || 0;

            try {
                // Get events from followed users
                const result = await dbPostgres.pool.query(`
                    SELECT
                        sf.id, sf.event_type, sf.actor_id, sf.actor_name, sf.title,
                        sf.description, sf.image_url, sf.action_url, sf.metadata, sf.created_at,
                        sf.view_count, sf.likes_count, sf.comments_count, sf.shares_count,
                        u.name as user_name,
                        u.avatar_url as user_avatar,
                        u.verification_level,
                        UPPER(COALESCE(
                            SUBSTRING(COALESCE(u.name, sf.actor_name) FROM 1 FOR 1) ||
                            COALESCE(SUBSTRING(COALESCE(u.name, sf.actor_name) FROM POSITION(' ' IN COALESCE(u.name, sf.actor_name)) + 1 FOR 1), ''),
                            '??'
                        )) as actor_initials
                    FROM social_feed sf
                    JOIN social_follows f ON sf.actor_id = f.following_id
                    LEFT JOIN users u ON sf.actor_id = u.user_id
                    WHERE f.follower_id = $1
                    ORDER BY sf.created_at DESC
                    LIMIT $2 OFFSET $3
                `, [userId, limit, offset]);

                // Get total count
                const countResult = await dbPostgres.pool.query(`
                    SELECT COUNT(*) as total
                    FROM social_feed sf
                    JOIN social_follows f ON sf.actor_id = f.following_id
                    WHERE f.follower_id = $1
                `, [userId]);

                const events = result.rows.map(e => ({
                    id: e.id,
                    event_type: e.event_type,
                    title: e.title,
                    description: e.description,
                    image_url: e.image_url,
                    action_url: e.action_url,
                    metadata: e.metadata || {},
                    created_at: e.created_at,
                    time_ago: formatTimeAgo(e.created_at),
                    actor: {
                        id: e.actor_id,
                        name: e.user_name || e.actor_name || "Usuario",
                        avatar_url: e.user_avatar || null,
                        initials: e.actor_initials || "??",
                        verified: e.verification_level && parseInt(e.verification_level) >= 2
                    },
                    engagement: {
                        likes: e.likes_count || 0,
                        comments: e.comments_count || 0,
                        views: e.view_count || 0,
                        shares: e.shares_count || 0
                    }
                }));

                const total = parseInt(countResult.rows[0]?.total) || 0;

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        events: events,
                        pagination: {
                            total: total,
                            limit: limit,
                            offset: offset,
                            has_more: offset + limit < total
                        }
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] Following feed error: ' + error.message);
                sendError(res, 500, 'Error al obtener feed personalizado');
                return;
            }
        }

        // ============================================
        // GET /api/feed/social/user/:userId/profile - Get user mini profile
        // Added: 2026-01-25
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/user\/[\w-]+\/profile$/) && (method === 'GET' || method === 'HEAD')) {
            const targetUserId = pathname.split('/')[5];
            const authUser = getAuthenticatedUser(req, query);
            const currentUserId = authUser?.userId || null;

            try {
                // Get user info
                const userResult = await dbPostgres.pool.query(`
                    SELECT user_id, name, avatar_url, bio, verification_level, created_at
                    FROM users WHERE user_id = $1
                `, [targetUserId]);

                if (userResult.rows.length === 0) {
                    sendError(res, 404, 'Usuario no encontrado');
                    return;
                }

                const user = userResult.rows[0];

                // Get follower/following counts
                const [followersCount, followingCount, postsCount] = await Promise.all([
                    dbPostgres.pool.query(
                        'SELECT COUNT(*) as count FROM social_follows WHERE following_id = $1',
                        [targetUserId]
                    ),
                    dbPostgres.pool.query(
                        'SELECT COUNT(*) as count FROM social_follows WHERE follower_id = $1',
                        [targetUserId]
                    ),
                    dbPostgres.pool.query(
                        'SELECT COUNT(*) as count FROM social_feed WHERE actor_id = $1',
                        [targetUserId]
                    )
                ]);

                // Check if current user follows this user
                let isFollowing = false;
                if (currentUserId && currentUserId !== targetUserId) {
                    const followCheck = await dbPostgres.pool.query(
                        'SELECT id FROM social_follows WHERE follower_id = $1 AND following_id = $2',
                        [currentUserId, targetUserId]
                    );
                    isFollowing = followCheck.rows.length > 0;
                }

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        user: {
                            id: user.user_id,
                            name: user.name,
                            avatar_url: user.avatar_url,
                            bio: user.bio,
                            verified: user.verification_level && parseInt(user.verification_level) >= 2,
                            member_since: user.created_at,
                            avatar_url: user.avatar_url
                        },
                        stats: {
                            followers: parseInt(followersCount.rows[0]?.count) || 0,
                            following: parseInt(followingCount.rows[0]?.count) || 0,
                            posts: parseInt(postsCount.rows[0]?.count) || 0
                        },
                        is_following: isFollowing,
                        is_self: currentUserId === targetUserId
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] User profile error: ' + error.message);
                sendError(res, 500, 'Error al obtener perfil');
                return;
            }
        }



        // ============================================
        // GET /api/feed/social/user/:userId/posts - Get user posts
        // Added: 2026-02-09
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/user\/[\w-]+\/posts$/) && (method === 'GET' || method === 'HEAD')) {
            const targetUserId = pathname.split('/')[5];
            const authUser = getAuthenticatedUser(req, query);
            const currentUserId = authUser?.userId || null;
            const limit = Math.min(parseInt(query.limit) || 20, 50);
            const offset = parseInt(query.offset) || 0;

            try {
                // Exclude anonymous posts unless requester is the author
                let anonymousFilter = '';
                const params = [targetUserId, limit, offset];
                if (currentUserId !== targetUserId) {
                    anonymousFilter = `AND (sf.metadata->>'is_anonymous' IS NULL OR sf.metadata->>'is_anonymous' != 'true')`;
                }

                const result = await dbPostgres.pool.query(`
                    SELECT sf.id, sf.event_type, sf.actor_id, sf.actor_name, sf.title,
                        sf.description, sf.image_url, sf.metadata, sf.created_at,
                        sf.likes_count, sf.comments_count, sf.shares_count,
                        u.name as user_name, u.avatar_url as user_avatar, u.verification_level
                    FROM social_feed sf
                    LEFT JOIN users u ON sf.actor_id = u.user_id
                    WHERE sf.actor_id = $1 ${anonymousFilter}
                    ORDER BY sf.created_at DESC
                    LIMIT $2 OFFSET $3
                `, params);

                const countResult = await dbPostgres.pool.query(`
                    SELECT COUNT(*) as total FROM social_feed sf
                    WHERE actor_id = $1 ${anonymousFilter}
                `, [targetUserId]);

                const total = parseInt(countResult.rows[0]?.total) || 0;

                const posts = result.rows.map(e => ({
                    id: e.id,
                    event_type: e.event_type,
                    title: e.title,
                    description: e.description,
                    image_url: e.image_url,
                    metadata: e.metadata || {},
                    created_at: e.created_at,
                    time_ago: formatTimeAgo(e.created_at),
                    actor: {
                        id: e.actor_id,
                        name: e.user_name || e.actor_name || 'Usuario',
                        avatar_url: e.user_avatar || null,
                        verified: e.verification_level && parseInt(e.verification_level) >= 2
                    },
                    engagement: {
                        likes: e.likes_count || 0,
                        comments: e.comments_count || 0,
                        shares: e.shares_count || 0
                    }
                }));


                // Enrich with user likes/bookmarks state
                if (currentUserId) {
                    const upEventIds = posts.map(p => p.id);
                    if (upEventIds.length > 0) {
                        try {
                            const [upLikes, upBookmarks] = await Promise.all([
                                dbPostgres.pool.query(
                                    'SELECT event_id FROM social_likes WHERE user_id = $1 AND event_id = ANY($2)',
                                    [currentUserId, upEventIds]
                                ),
                                dbPostgres.pool.query(
                                    'SELECT event_id FROM social_bookmarks WHERE user_id = $1 AND event_id = ANY($2)',
                                    [currentUserId, upEventIds]
                                )
                            ]);
                            const upLikedSet = new Set(upLikes.rows.map(r => r.event_id));
                            const upBookmarkedSet = new Set(upBookmarks.rows.map(r => r.event_id));
                            posts.forEach(p => {
                                p.is_liked = upLikedSet.has(p.id);
                                p.is_bookmarked = upBookmarkedSet.has(p.id);
                            });
                        } catch (uplbErr) {
                            log('warn', '[SOCIAL] User posts like/bookmark check error: ' + uplbErr.message);
                        }
                    }
                }

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        posts,
                        pagination: { total, limit, offset, has_more: offset + limit < total }
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] User posts error: ' + error.message);
                sendError(res, 500, 'Error al obtener publicaciones');
                return;
            }
        }

        // ============================================
        // GET /api/feed/social/user/:userId/followers - Get user followers
        // Added: 2026-02-09
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/user\/[\w-]+\/followers$/) && (method === 'GET' || method === 'HEAD')) {
            const targetUserId = pathname.split('/')[5];
            const authUser = getAuthenticatedUser(req, query);
            const currentUserId = authUser?.userId || null;
            const limit = Math.min(parseInt(query.limit) || 20, 50);
            const offset = parseInt(query.offset) || 0;

            try {
                const result = await dbPostgres.pool.query(`
                    SELECT u.user_id, u.name, u.handle, u.avatar_url, u.bio, u.verification_level
                    FROM social_follows f
                    JOIN users u ON f.follower_id = u.user_id
                    WHERE f.following_id = $1
                    ORDER BY f.created_at DESC
                    LIMIT $2 OFFSET $3
                `, [targetUserId, limit, offset]);

                const countResult = await dbPostgres.pool.query(
                    'SELECT COUNT(*) as total FROM social_follows WHERE following_id = $1',
                    [targetUserId]
                );

                const total = parseInt(countResult.rows[0]?.total) || 0;

                // Batch is_following check
                let followingSet = new Set();
                if (currentUserId && result.rows.length > 0) {
                    const userIds = result.rows.map(r => r.user_id);
                    const followCheck = await dbPostgres.pool.query(
                        'SELECT following_id FROM social_follows WHERE follower_id = $1 AND following_id = ANY($2)',
                        [currentUserId, userIds]
                    );
                    followingSet = new Set(followCheck.rows.map(r => r.following_id));
                }

                const users = result.rows.map(u => ({
                    id: u.user_id,
                    name: u.name,
                    handle: u.handle || null,
                    avatar_url: u.avatar_url || null,
                    bio: u.bio || null,
                    verified: u.verification_level && parseInt(u.verification_level) >= 2,
                    is_following: followingSet.has(u.user_id),
                    is_self: u.user_id === currentUserId
                }));

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        users,
                        pagination: { total, limit, offset, has_more: offset + limit < total }
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] User followers error: ' + error.message);
                sendError(res, 500, 'Error al obtener seguidores');
                return;
            }
        }

        // ============================================
        // GET /api/feed/social/user/:userId/following - Get user following
        // Added: 2026-02-09
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/user\/[\w-]+\/following$/) && (method === 'GET' || method === 'HEAD')) {
            const targetUserId = pathname.split('/')[5];
            const authUser = getAuthenticatedUser(req, query);
            const currentUserId = authUser?.userId || null;
            const limit = Math.min(parseInt(query.limit) || 20, 50);
            const offset = parseInt(query.offset) || 0;

            try {
                const result = await dbPostgres.pool.query(`
                    SELECT u.user_id, u.name, u.handle, u.avatar_url, u.bio, u.verification_level
                    FROM social_follows f
                    JOIN users u ON f.following_id = u.user_id
                    WHERE f.follower_id = $1
                    ORDER BY f.created_at DESC
                    LIMIT $2 OFFSET $3
                `, [targetUserId, limit, offset]);

                const countResult = await dbPostgres.pool.query(
                    'SELECT COUNT(*) as total FROM social_follows WHERE follower_id = $1',
                    [targetUserId]
                );

                const total = parseInt(countResult.rows[0]?.total) || 0;

                // Batch is_following check
                let followingSet = new Set();
                if (currentUserId && result.rows.length > 0) {
                    const userIds = result.rows.map(r => r.user_id);
                    const followCheck = await dbPostgres.pool.query(
                        'SELECT following_id FROM social_follows WHERE follower_id = $1 AND following_id = ANY($2)',
                        [currentUserId, userIds]
                    );
                    followingSet = new Set(followCheck.rows.map(r => r.following_id));
                }

                const users = result.rows.map(u => ({
                    id: u.user_id,
                    name: u.name,
                    handle: u.handle || null,
                    avatar_url: u.avatar_url || null,
                    bio: u.bio || null,
                    verified: u.verification_level && parseInt(u.verification_level) >= 2,
                    is_following: followingSet.has(u.user_id),
                    is_self: u.user_id === currentUserId
                }));

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        users,
                        pagination: { total, limit, offset, has_more: offset + limit < total }
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] User following error: ' + error.message);
                sendError(res, 500, 'Error al obtener seguidos');
                return;
            }
        }
        // ============================================
        // GET /api/feed/social/trending - Get trending posts (24h)
        // Added: 2026-01-25
        // ============================================
        if (pathname === '/api/feed/social/trending' && (method === 'GET' || method === 'HEAD')) {
            const limit = Math.min(parseInt(query.limit) || 20, 50);
            const offset = parseInt(query.offset) || 0;

            try {
                // Get posts with highest engagement in last 24 hours
                const result = await dbPostgres.pool.query(`
                    SELECT
                        sf.id, sf.event_type, sf.actor_id, sf.actor_name, sf.title,
                        sf.description, sf.image_url, sf.action_url, sf.metadata, sf.created_at,
                        sf.view_count, sf.likes_count, sf.comments_count, sf.shares_count,
                        u.name as user_name,
                        u.avatar_url as user_avatar,
                        u.verification_level,
                        UPPER(COALESCE(
                            SUBSTRING(COALESCE(u.name, sf.actor_name) FROM 1 FOR 1) ||
                            COALESCE(SUBSTRING(COALESCE(u.name, sf.actor_name) FROM POSITION(' ' IN COALESCE(u.name, sf.actor_name)) + 1 FOR 1), ''),
                            '??'
                        )) as actor_initials,
                        (COALESCE(sf.likes_count, 0) * 3 + COALESCE(sf.comments_count, 0) * 5 + COALESCE(sf.view_count, 0)) as engagement_score
                    FROM social_feed sf
                    LEFT JOIN users u ON sf.actor_id = u.user_id
                    WHERE sf.created_at > NOW() - INTERVAL '24 hours'
                    ORDER BY engagement_score DESC, sf.created_at DESC
                    LIMIT $1 OFFSET $2
                `, [limit, offset]);

                const countResult = await dbPostgres.pool.query(`
                    SELECT COUNT(*) as total
                    FROM social_feed
                    WHERE created_at > NOW() - INTERVAL '24 hours'
                `);

                const events = result.rows.map(e => ({
                    id: e.id,
                    event_type: e.event_type,
                    title: e.title,
                    description: e.description,
                    image_url: e.image_url,
                    action_url: e.action_url,
                    metadata: e.metadata || {},
                    created_at: e.created_at,
                    time_ago: formatTimeAgo(e.created_at),
                    actor: {
                        id: e.actor_id,
                        name: e.user_name || e.actor_name || "Usuario",
                        avatar_url: e.user_avatar || null,
                        initials: e.actor_initials || "??",
                        verified: e.verification_level && parseInt(e.verification_level) >= 2
                    },
                    engagement: {
                        likes: e.likes_count || 0,
                        comments: e.comments_count || 0,
                        views: e.view_count || 0,
                        shares: e.shares_count || 0,
                        score: e.engagement_score || 0
                    }
                }));

                const total = parseInt(countResult.rows[0]?.total) || 0;

                // Trending topics by event type (all time)
                const topicsResult = await dbPostgres.pool.query(`
                    SELECT event_type, COUNT(*) as count
                    FROM social_feed
                    GROUP BY event_type
                    ORDER BY count DESC
                `);
                const typeLabels = {
                    prediction_shared: { category: "Predicciones", topic: "#Predictor", tab: "loteria" },
                    user_post: { category: "General", topic: "#LaTanda", tab: "todos" },
                    group_created: { category: "Finanzas", topic: "#Tandas", tab: "grupos" },
                    product_posted: { category: "Mercado", topic: "#VentasHN", tab: "mercado" },
                    lottery_result: { category: "Entretenimiento", topic: "#LoteriaTanda", tab: "loteria" },
                    milestone: { category: "Logros", topic: "#Logros", tab: "logros" }
                };
                const topics = topicsResult.rows.map(r => ({
                    category: (typeLabels[r.event_type] || { category: "General" }).category,
                    topic: (typeLabels[r.event_type] || { topic: "#" + r.event_type }).topic,
                    count: parseInt(r.count) || 0,
                    tab: (typeLabels[r.event_type] || { tab: "todos" }).tab
                }));


                // Enrich with user likes/bookmarks state
                const trendAuthUser = getAuthenticatedUser(req, query);
                if (trendAuthUser) {
                    const trendEventIds = events.map(ev => ev.id);
                    if (trendEventIds.length > 0) {
                        try {
                            const [trendLikes, trendBookmarks] = await Promise.all([
                                dbPostgres.pool.query(
                                    'SELECT event_id FROM social_likes WHERE user_id = $1 AND event_id = ANY($2)',
                                    [trendAuthUser.userId, trendEventIds]
                                ),
                                dbPostgres.pool.query(
                                    'SELECT event_id FROM social_bookmarks WHERE user_id = $1 AND event_id = ANY($2)',
                                    [trendAuthUser.userId, trendEventIds]
                                )
                            ]);
                            const tLikedSet = new Set(trendLikes.rows.map(r => r.event_id));
                            const tBookmarkedSet = new Set(trendBookmarks.rows.map(r => r.event_id));
                            events.forEach(ev => {
                                ev.is_liked = tLikedSet.has(ev.id);
                                ev.is_bookmarked = tBookmarkedSet.has(ev.id);
                            });
                        } catch (tlbErr) {
                            log('warn', '[SOCIAL] Trending like/bookmark check error: ' + tlbErr.message);
                        }
                    }
                }

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        events: events,
                        period: '24h',
                        topics: topics,
                        pagination: {
                            total: total,
                            limit: limit,
                            offset: offset,
                            has_more: offset + limit < total
                        }
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] Trending error: ' + error.message);
                sendError(res, 500, 'Error al obtener trending');
                return;
            }
        }



        // ============================================
        // GET /api/feed/social/suggestions - Get users to follow
        // Added: 2026-01-26
        // ============================================
        if (pathname === '/api/feed/social/suggestions' && (method === 'GET' || method === 'HEAD')) {
            const limit = Math.min(parseInt(query.limit) || 5, 20);

            // Get current user if authenticated
            const authUser = getAuthenticatedUser(req, query);
            const currentUserId = authUser?.userId || null;

            try {
                let result;

                if (currentUserId) {
                    // Get users that the current user is NOT following
                    result = await dbPostgres.pool.query(`
                        SELECT
                            u.user_id as id,
                            u.name,
                            u.email,
                            u.handle,
                            u.avatar_url,
                            u.verification_level,
                            u.created_at,
                            UPPER(COALESCE(
                                SUBSTRING(u.name FROM 1 FOR 1) ||
                                COALESCE(SUBSTRING(u.name FROM POSITION(' ' IN u.name) + 1 FOR 1), ''),
                                '??'
                            )) as initials,
                            (SELECT COUNT(*) FROM social_follows WHERE following_id = u.user_id) as followers_count,
                            (SELECT COUNT(*) FROM social_feed WHERE actor_id = u.user_id) as posts_count
                        FROM users u
                        WHERE u.user_id != $1
                        AND u.user_id NOT IN (
                            SELECT following_id FROM social_follows WHERE follower_id = $1
                        )
                        AND u.name IS NOT NULL
                        AND u.name != ''
                        ORDER BY
                            (SELECT COUNT(*) FROM social_feed WHERE actor_id = u.user_id) DESC,
                            u.created_at DESC
                        LIMIT $2
                    `, [currentUserId, limit]);
                } else {
                    // For non-authenticated users, just get active users
                    result = await dbPostgres.pool.query(`
                        SELECT
                            u.user_id as id,
                            u.name,
                            u.email,
                            u.avatar_url,
                            u.verification_level,
                            u.created_at,
                            UPPER(COALESCE(
                                SUBSTRING(u.name FROM 1 FOR 1) ||
                                COALESCE(SUBSTRING(u.name FROM POSITION(' ' IN u.name) + 1 FOR 1), ''),
                                '??'
                            )) as initials,
                            (SELECT COUNT(*) FROM social_follows WHERE following_id = u.user_id) as followers_count,
                            (SELECT COUNT(*) FROM social_feed WHERE actor_id = u.user_id) as posts_count
                        FROM users u
                        WHERE u.name IS NOT NULL
                        AND u.name != ''
                        ORDER BY
                            (SELECT COUNT(*) FROM social_feed WHERE actor_id = u.user_id) DESC,
                            u.created_at DESC
                        LIMIT $1
                    `, [limit]);
                }

                const suggestions = result.rows.map(u => ({
                    id: u.id,
                    name: u.name,
                    handle: '@' + (u.handle || (u.email ? u.email.split('@')[0] : u.name.toLowerCase().replace(/\s+/g, ''))),
                    avatar_url: u.avatar_url || null,
                    initials: u.initials || '??',
                    verified: u.verification_level && parseInt(u.verification_level) >= 2,
                    followers_count: parseInt(u.followers_count) || 0,
                    posts_count: parseInt(u.posts_count) || 0
                }));

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        suggestions: suggestions
                    }
                });
                return;
            } catch (error) {
                log('error', '[SOCIAL] Suggestions error: ' + error.message);
                sendError(res, 500, 'Error al obtener sugerencias');
                return;
            }
        }


        // ============================================
        // POST /api/feed/social/:id/vote - Vote on poll
        // Added: 2026-02-05
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/[\w-]+\/vote$/) && method === 'POST') {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida para votar');
                return;
            }

            const eventId = pathname.split('/')[4];
            const userId = authUser.userId;
            const optionIndex = parseInt(body.option_index);

            if (isNaN(optionIndex) || optionIndex < 0) {
                sendError(res, 400, 'Opcion invalida');
                return;
            }

            try {
                // Get the post and verify it has a poll
                const postResult = await dbPostgres.pool.query(
                    'SELECT id, metadata FROM social_feed WHERE id = $1',
                    [eventId]
                );

                if (postResult.rows.length === 0) {
                    sendError(res, 404, 'Publicacion no encontrada');
                    return;
                }

                const metadata = postResult.rows[0].metadata || {};
                if (!metadata.poll) {
                    sendError(res, 400, 'Esta publicacion no tiene encuesta');
                    return;
                }

                const poll = metadata.poll;
                if (optionIndex >= poll.options.length) {
                    sendError(res, 400, 'Opcion fuera de rango');
                    return;
                }

                // Check if poll has expired
                if (poll.expires_at && new Date(poll.expires_at) < new Date()) {
                    sendError(res, 400, 'Esta encuesta ha finalizado');
                    return;
                }

                // Try to insert vote (unique constraint prevents double voting)
                try {
                    await dbPostgres.pool.query(
                        'INSERT INTO poll_votes (event_id, user_id, option_index) VALUES ($1, $2, $3)',
                        [eventId, userId, optionIndex]
                    );
                } catch (dupError) {
                    if (dupError.code === '23505') {
                        sendError(res, 409, 'Ya votaste en esta encuesta');
                        return;
                    }
                    throw dupError;
                }

                // Update vote counts in metadata
                if (!poll.votes) poll.votes = poll.options.map(() => 0);
                poll.votes[optionIndex] = (poll.votes[optionIndex] || 0) + 1;
                poll.total_votes = poll.votes.reduce((a, b) => a + b, 0);
                poll.user_vote = optionIndex;

                metadata.poll = poll;

                await dbPostgres.pool.query(
                    'UPDATE social_feed SET metadata = $1 WHERE id = $2',
                    [JSON.stringify(metadata), eventId]
                );

                log('info', '[SOCIAL] User ' + userId + ' voted option ' + optionIndex + ' on poll ' + eventId);
                sendResponse(res, 200, { success: true, data: { poll: poll } });
            } catch (error) {
                log('error', '[SOCIAL] Vote error: ' + error.message);
                sendError(res, 500, 'Error al votar');
            }
            return;
        }

        // ============================================
        // GET /api/feed/social/:id/poll - Get poll results
        // Added: 2026-02-05
        // ============================================
        if (pathname.match(/^\/api\/feed\/social\/[\w-]+\/poll$/) && (method === 'GET' || method === 'HEAD')) {
            const eventId = pathname.split('/')[4];

            try {
                const postResult = await dbPostgres.pool.query(
                    'SELECT metadata FROM social_feed WHERE id = $1',
                    [eventId]
                );

                if (postResult.rows.length === 0) {
                    sendError(res, 404, 'Publicacion no encontrada');
                    return;
                }

                const metadata = postResult.rows[0].metadata || {};
                if (!metadata.poll) {
                    sendError(res, 400, 'Esta publicacion no tiene encuesta');
                    return;
                }

                // Check if current user has voted
                const authUser = getAuthenticatedUser(req, query);
                if (authUser) {
                    const voteResult = await dbPostgres.pool.query(
                        'SELECT option_index FROM poll_votes WHERE event_id = $1 AND user_id = $2',
                        [eventId, authUser.userId]
                    );
                    if (voteResult.rows.length > 0) {
                        metadata.poll.user_vote = voteResult.rows[0].option_index;
                    }
                }

                sendResponse(res, 200, { success: true, data: { poll: metadata.poll } });
            } catch (error) {
                log('error', '[SOCIAL] Poll results error: ' + error.message);
                sendError(res, 500, 'Error al obtener resultados');
            }
            return;
        }

        // Safe GIF URL validator (v3.98.0 - validates external API URLs)
        function safeGifUrl(url) {
            if (!url || typeof url !== 'string') return '';
            try {
                const parsed = new URL(url);
                if (parsed.protocol !== 'https:') return '';
                return url;
            } catch (e) {
                return '';
            }
        }

        // ============================================
        // GET /api/gifs/search - Search GIFs via Klipy proxy
        // Added: 2026-02-05
        // ============================================
        if (pathname === '/api/gifs/search' && (method === 'GET' || method === 'HEAD')) {
            const searchQuery = query.q || '';
            const limit = Math.min(parseInt(query.limit) || 20, 50);

            if (!searchQuery) {
                sendError(res, 400, 'Se requiere parametro de busqueda q');
                return;
            }

            try {
                const klipyKey = process.env.KLIPY_API_KEY;
                if (!klipyKey) {
                    sendError(res, 500, 'GIF API no configurada');
                    return;
                }

                const klipyUrl = 'https://api.klipy.com/api/v1/' + klipyKey + '/gifs/search?q=' + encodeURIComponent(searchQuery) + '&limit=' + limit;
                const klipyResponse = await fetch(klipyUrl);
                const klipyData = await klipyResponse.json();

                const rawGifs = klipyData.data?.data || klipyData.data || [];
                const gifs = (Array.isArray(rawGifs) ? rawGifs : []).slice(0, limit).map(g => ({
                    id: String(g.id || ''),
                    url: safeGifUrl(g.file?.hd?.gif?.url || g.file?.md?.gif?.url || g.url || ''),
                    preview: safeGifUrl(g.file?.md?.webp?.url || g.file?.md?.gif?.url || g.file?.hd?.webp?.url || g.url || '')
                })).filter(g => g.url);

                sendResponse(res, 200, { success: true, data: gifs });
            } catch (error) {
                log('error', '[GIF] Search error: ' + error.message);
                sendError(res, 500, 'Error al buscar GIFs');
            }
            return;
        }

        // ============================================
        // GET /api/gifs/trending - Trending GIFs via Klipy proxy
        // Added: 2026-02-05
        // ============================================
        if (pathname === '/api/gifs/trending' && (method === 'GET' || method === 'HEAD')) {
            const limit = Math.min(parseInt(query.limit) || 20, 50);

            try {
                const klipyKey = process.env.KLIPY_API_KEY;
                if (!klipyKey) {
                    sendError(res, 500, 'GIF API no configurada');
                    return;
                }

                const klipyUrl = 'https://api.klipy.com/api/v1/' + klipyKey + '/gifs/trending?limit=' + limit;
                const klipyResponse = await fetch(klipyUrl);
                const klipyData = await klipyResponse.json();

                const rawGifs = klipyData.data?.data || klipyData.data || [];
                const gifs = (Array.isArray(rawGifs) ? rawGifs : []).slice(0, limit).map(g => ({
                    id: String(g.id || ''),
                    url: safeGifUrl(g.file?.hd?.gif?.url || g.file?.md?.gif?.url || g.url || ''),
                    preview: safeGifUrl(g.file?.md?.webp?.url || g.file?.md?.gif?.url || g.file?.hd?.webp?.url || g.url || '')
                })).filter(g => g.url);

                sendResponse(res, 200, { success: true, data: gifs });
            } catch (error) {
                log('error', '[GIF] Trending error: ' + error.message);
                sendError(res, 500, 'Error al obtener GIFs trending');
            }
            return;
        }


        // Business analytics
        if (pathname === '/api/business/analytics/revenue' && method === 'POST') {
            // SECURITY: Require JWT + admin role (v4.0.0)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            if (authUser.role !== 'admin') {
                sendError(res, 403, 'Solo administradores pueden ver analiticas de negocio');
                return;
            }
            const totalRevenue = database.groups.reduce((sum, g) => sum + g.total_amount_collected, 0);
            const totalCommission = totalRevenue * 0.05;
            
            sendSuccess(res, {
                total_revenue: totalRevenue,
                commission_earned: totalCommission,
                growth_rate: 18.5,
                active_groups: database.groups.filter(g => g.status === 'active').length,
                total_users: database.users.length,
                breakdown: {
                    payments: totalRevenue * 0.92,
                    fees: totalRevenue * 0.08
                }
            });
            return;
        }

        if (pathname === '/api/business/performance/dashboard' && (method === 'GET' || method === 'HEAD')) {

            // SECURITY: Require JWT + admin role (v4.0.0)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            if (authUser.role !== 'admin') {
                sendError(res, 403, 'Solo administradores pueden ver metricas de rendimiento');
                return;
            }
            sendSuccess(res, {
                kpis: {
                    total_revenue: 285000.00,
                    monthly_growth: 18.5,
                    active_users: database.users.filter(u => u.status === 'active').length,
                    active_groups: database.groups.filter(g => g.status === 'active').length
                },
                system_health: {
                    api_uptime: 99.9,
                    response_time: 65,
                    error_rate: 0.1,
                    mobile_app_health: 'excellent'
                },
                mobile_metrics: {
                    app_downloads: 1250,
                    daily_active_users: 890,
                    session_duration_avg: 420, // seconds
                    push_notification_rate: 0.78
                }
            });
            return;
        }

        // Notifications
        if (pathname === '/api/notifications/send' && method === 'POST') {
            // SECURITY FIX: Require admin session (2025-12-31)
            const adminSession = requireAdminSession(req, res);
            if (!adminSession) return;
            const { user_id, type, title, message } = body;
            const notificationId = generateId('notif');
            const notification = {
                id: notificationId,
                user_id,
                type,
                title,
                message,
                sent_at: new Date().toISOString(),
                status: 'sent',
                channels: ['push', 'in_app'],
                push_delivered: true
            };
            database.notifications.push(notification);
            sendSuccess(res, {
                notification_id: notificationId,
                message: 'Notificación enviada exitosamente',
                delivery_status: 'sent'
            });
            return;
        }

        // Default 404 handler

        // ===== TANDAS ENDPOINTS (Rotative Turn-based System) =====

        // Create new tanda
        if (pathname === "/api/tandas/create" && method === "POST") {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const {
                name,
                contribution_amount,
                participants,
                frequency,
                turns_order,
                coordinator_id,
                group_id
            } = body;

            log("info", `Creating tanda: ${name} by ${coordinator_id}`);

            // Validations
            if (!name || !contribution_amount || !participants || !coordinator_id) {
                sendError(res, 400, "Campos requeridos: name, contribution_amount, participants, coordinator_id");
                return;
            }

            if (participants < 2) {
                sendError(res, 400, "Se requieren al menos 2 participantes");
                return;
            }

            if (!turns_order || turns_order.length !== participants) {
                sendError(res, 400, "turns_order debe contener exactamente " + participants + " IDs de usuarios");
                return;
            }

            // Generate tanda
            const tandaId = generateId("tanda");
            const tanda = {
                id: tandaId,
                name: name,
                contribution_amount: parseFloat(contribution_amount),
                total_per_turn: parseFloat(contribution_amount) * participants,
                frequency: frequency || "weekly",
                coordinator_id: coordinator_id,
                group_id: group_id || null,
                status: "active",
                created_at: new Date().toISOString(),

                // Turns management
                current_turn: 1,
                total_turns: participants,
                turns_order: turns_order, // Array of user_ids

                // Turn history
                turn_history: [],

                // Current turn payments
                current_turn_payments: {
                    turn_number: 1,
                    recipient_user_id: turns_order[0],
                    paid_by: [], // Array of user_ids who paid
                    pending_from: turns_order.slice(1) // All except recipient initially
                }
            };

            // Store tanda
            if (!database.tandas) {
                database.tandas = [];
            }
            database.tandas.push(tanda);
            saveDatabase();

            log("info", `Tanda created: ${tandaId} - ${name}`);
            const tandaCI = getClientInfo(req); auditLog("TANDA_CREATED", { userId: tanda.coordinator_id, resource: "tandas", resourceId: tandaId, ip: tandaCI.ip, userAgent: tandaCI.userAgent, extra: { name: name } });

            sendSuccess(res, {
                message: "Tanda creada exitosamente",
                tanda_id: tandaId,
                tanda: tanda
            });
            return;
        }

        // List tandas - MODIFIED to support JWT auth and groups with is_tanda
        // NEW PostgreSQL-based endpoint for my-tandas

        // POST /api/tandas/start - Start a tanda (coordinator only)
        if (pathname === "/api/tandas/start" && method === "POST") {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            
            try {
                
                const tandaId = body.tanda_id;
                const userId = authUser.userId;
                if (!userId) { sendError(res, 400, "user_id requerido"); return; }
                
                // Get tanda to verify coordinator
                const tanda = await dbPostgres.pool.query(
                    "SELECT tanda_id, name, contribution_amount, total_per_turn, frequency, coordinator_id, group_id, status, current_turn, total_turns, turns_order, created_at, updated_at, completed_at, is_demo, scheduled_start_at, lottery_scheduled_at, lottery_executed_at, lottery_countdown_seconds, previous_status FROM tandas WHERE tanda_id = $1",
                    [tandaId]
                );
                
                if (!tanda.rows || tanda.rows.length === 0) {
                    sendError(res, 404, "Tanda no encontrada");
                    return;
                }
                
                const tandaData = tanda.rows[0];
                
                // Verify user is coordinator
                if (tandaData.coordinator_id !== userId) {
                    sendError(res, 403, "Solo el coordinador puede iniciar la tanda");
                    return;
                }
                
                // Verify tanda is in recruiting status
                if (tandaData.status !== "recruiting" && tandaData.status !== "pending") {
                    sendError(res, 400, `La tanda ya está en estado: ${tandaData.status}`);
                    return;
                }
                
                // Verify minimum members (at least 2)
                const turnsOrder = tandaData.turns_order || [];
                if (turnsOrder.length < 2) {
                    sendError(res, 400, "Se necesitan al menos 2 miembros para iniciar la tanda");
                    return;
                }
                
                // Start the tanda
                const updateResult = await dbPostgres.pool.query(
                    `UPDATE tandas SET 
                        status = 'active', 
                        current_turn = 1, 
                        total_turns = $1,
                        updated_at = NOW() 
                    WHERE tanda_id = $2
                    RETURNING tanda_id, status, current_turn, total_turns`,
                    [turnsOrder.length, tandaId]
                );
                
                log("info", `✅ Tanda iniciada: ${tandaId} por coordinador ${userId} con ${turnsOrder.length} miembros`);
                
                sendSuccess(res, { 
                    message: "Tanda iniciada exitosamente",
                    tanda_id: tandaId,
                    status: "active",
                    current_turn: 1,
                    total_members: turnsOrder.length,
                    first_collector: turnsOrder[0]
                });
            } catch (error) {
                log("error", `Error starting tanda: ${error.message}`);
                sendError(res, 500, "Error al iniciar la tanda");
            }
            return;
        }

        if (pathname === "/api/tandas/my-tandas" && method === "GET") {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, "Autenticación requerida");
                return;
            }

            const userId = String(authUser.userId);
            try {
                const userTandas = await dbPostgres.getTandasByUser(userId);
                
                // Pre-load user names for collecting_member display
                const allMemberIds = new Set();
                const allGroupIds = new Set();
                userTandas.forEach(t => {
                    if (t.group_id) allGroupIds.add(t.group_id);
                    (t.turns_order || []).forEach(function(uid) {
                        var parsed = uid;
                        if (typeof uid === "string") { try { parsed = JSON.parse(uid); } catch(e) {} }
                        var memberId = typeof parsed === "object" && parsed !== null ? parsed.user_id : uid;
                        if (memberId) allMemberIds.add(memberId);
                    });
                });
                const userNamesLookup = {};
                if (allMemberIds.size > 0) {
                    try {
                        const idsArr = Array.from(allMemberIds);
                        const ph = idsArr.map((_, i) => "$" + (i + 1)).join(", ");
                        const namesRes = await dbPostgres.pool.query("SELECT user_id, name FROM users WHERE user_id IN (" + ph + ")", idsArr);
                        namesRes.rows.forEach(r => userNamesLookup[r.user_id] = r.name);
                    } catch (e) { log("error", "User names lookup failed", { error: e.message }); }
                }
                
                // Batch-query real contribution counts per group for this user
                const contributionsByGroup = {};
                if (allGroupIds.size > 0) {
                    try {
                        const gidsArr = Array.from(allGroupIds);
                        const gph = gidsArr.map((_, i) => "$" + (i + 2)).join(", ");
                        const contribRes = await dbPostgres.pool.query(
                            "SELECT group_id, COUNT(*) as paid_count FROM contributions WHERE user_id = $1 AND group_id IN (" + gph + ") AND status IN ('completed','coordinator_approved','archived') GROUP BY group_id",
                            [userId].concat(gidsArr)
                        );
                        contribRes.rows.forEach(r => contributionsByGroup[r.group_id] = parseInt(r.paid_count));
                    } catch (e) { log("error", "Contributions lookup failed", { error: e.message }); }
                }
                
                // Batch-query num_positions per group for this user
                const positionsByGroup = {};
                if (allGroupIds.size > 0) {
                    try {
                        const gidsArr2 = Array.from(allGroupIds);
                        const gph2 = gidsArr2.map((_, i) => "$" + (i + 2)).join(", ");
                        const posRes = await dbPostgres.pool.query(
                            "SELECT group_id, COALESCE(num_positions, 1) as num_positions FROM group_members WHERE user_id = $1 AND group_id IN (" + gph2 + ") AND status IN ('active','suspended')",
                            [userId].concat(gidsArr2)
                        );
                        posRes.rows.forEach(r => positionsByGroup[r.group_id] = parseInt(r.num_positions));
                    } catch (e) { log("error", "Positions lookup failed", { error: e.message }); }
                }
                
                const enrichedTandas = userTandas.map(t => {
                    const rawTurnsOrder = t.turns_order || [];
                    const turnsOrder = rawTurnsOrder.map(function(item) {
                        if (typeof item === "object" && item !== null) return item.user_id || item;
                        if (typeof item === "string") { try { var p = JSON.parse(item); return p.user_id || item; } catch(e) { return item; } }
                        return item;
                    });
                    const myTurnPosition = turnsOrder.indexOf(userId) + 1 || 1;
                    const currentTurn = t.current_turn || 0;
                    const totalTurns = t.total_turns || turnsOrder.length || 1;
                    const maxMembers = t.max_members || totalTurns;
                    const currentCycle = t.current_cycle || currentTurn;
                    const commissionRate = t.commission_rate !== null && t.commission_rate !== undefined ? parseFloat(t.commission_rate) : null;
                    const numPositions = positionsByGroup[t.group_id] || 1;
                    let status = t.status || "active";
                    const isCoordinator = t.coordinator_id === userId;
                    const hasTurnAssigned = turnsOrder.includes(userId) || isCoordinator;
                    
                    // Real contribution count from DB
                    const myContributionsPaid = contributionsByGroup[t.group_id] || 0;
                    
                    // Pool uses max_members (personas), not total_turns (posiciones)
                    const poolAmount = t.max_members ? (parseFloat(t.contribution_amount) * maxMembers) : (parseFloat(t.total_per_turn) || (parseFloat(t.contribution_amount) * totalTurns));
                    
                    // For recruiting/pending tandas - no payment dates yet
                    if (status === "recruiting" || status === "pending" || status === "scheduled" || status === "paused") {
                        return {
                            tanda_id: t.id || t.tanda_id,
                            group_id: t.group_id,
                            group_name: t.name,
                            status: status,
                            contribution_amount: parseFloat(t.contribution_amount) || 0,
                            total_per_turn: poolAmount,
                            frequency: t.group_frequency || t.frequency,
                            total_participants: totalTurns,
                            max_members: maxMembers,
                            current_turn: 0,
                            current_cycle: 0,
                            my_turn_position: myTurnPosition,
                            next_payment_date: null,
                            next_payment_amount: parseFloat(t.contribution_amount),
                            collecting_member: null,
                            cycle_start_date: null,
                            progress_percentage: 0,
                            my_contributions_paid: 0,
                            my_contributions_total: maxMembers,
                            commission_rate: commissionRate,
                            payment_status: null,
                            advance_threshold: t.advance_threshold || 80,
                            is_demo: t.is_demo,
                            is_coordinator: isCoordinator,
                            coordinator_name: t.coordinator_name || null,
                            members_joined: t.group_member_count || turnsOrder.length,
                            turns_assigned: turnsOrder.length,
                            expanded_order: [],
                            members_needed: totalTurns,
                            has_turn_assigned: hasTurnAssigned,
                            lottery_scheduled_at: t.lottery_scheduled_at || null,
                            lottery_executed_at: t.lottery_executed_at || null,
                            lottery_executed: t.lottery_executed || false,
                            is_my_turn: false,
                            num_positions: numPositions
                        };
                    }
                    
                    // Active tanda logic
                    if (status === "active" && currentTurn === myTurnPosition) status = "collecting";
                    
                    const cycleStart = t.start_date ? new Date(t.start_date) : new Date(t.created_at);
                    const freq = (t.group_frequency || t.frequency || "monthly").toLowerCase();
                    
                    // Next payment date from centralized helper (15/ultimo for biweekly)
                    const userNextCycle = myContributionsPaid + 1;
                    const gracePeriod = parseInt(t.grace_period) || 5;
                    const dueDateInfo = getPaymentDueDate(freq, cycleStart, userNextCycle, gracePeriod);
                    let nextPaymentDate = dueDateInfo.dueDate ? new Date(dueDateInfo.dueDate + "T12:00:00") : new Date();
                    const nextPaymentGraceDeadline = dueDateInfo.graceDeadline || null;
                    
                    // Payment status based on real data + grace period + date check
                    var paymentStatus = "up_to_date";
                    if (myContributionsPaid < currentCycle * numPositions) {
                        var now = new Date();
                        var graceDate = nextPaymentGraceDeadline ? new Date(nextPaymentGraceDeadline + "T23:59:59") : nextPaymentDate;
                        if (now > graceDate) {
                            paymentStatus = "late";
                        } else if (now > nextPaymentDate) {
                            // Past due date but within grace period
                            paymentStatus = "pending";
                        }
                        // else: payment needed but due date hasn't arrived yet -> up_to_date
                    }
                    
                    const collectingMemberId = currentTurn > 0 ? (turnsOrder[currentTurn - 1] || null) : (turnsOrder[0] || null);
                    const collectingMember = collectingMemberId ? (userNamesLookup[collectingMemberId] || collectingMemberId) : "\u2014";
                    
                    // Progress: current_cycle / total_turns (how far through all rounds)
                    const progressPercent = Math.round(((currentCycle > 0 ? currentCycle - 1 : 0) / totalTurns) * 100) || 0;
                    
                    return {
                        tanda_id: t.id || t.tanda_id,
                        group_id: t.group_id,
                        group_name: t.name,
                        status: status,
                        contribution_amount: parseFloat(t.contribution_amount) || 0,
                        total_per_turn: poolAmount,
                        frequency: t.group_frequency || t.frequency,
                        total_participants: totalTurns,
                        max_members: maxMembers,
                        current_turn: currentTurn,
                        current_cycle: currentCycle,
                        my_turn_position: myTurnPosition,
                        next_payment_date: dueDateInfo.dueDate || nextPaymentDate.toISOString().split("T")[0],
                        next_payment_grace_deadline: nextPaymentGraceDeadline,
                        next_payment_amount: parseFloat(t.contribution_amount),
                        collecting_member: collectingMember,
                        cycle_start_date: cycleStart.toISOString(),
                        progress_percentage: progressPercent,
                        my_contributions_paid: myContributionsPaid,
                        my_contributions_total: maxMembers,
                        commission_rate: commissionRate,
                        payment_status: paymentStatus,
                        advance_threshold: t.advance_threshold || 80,
                        is_demo: t.is_demo,
                        is_coordinator: isCoordinator,
                        coordinator_name: t.coordinator_name || null,
                        has_turn_assigned: hasTurnAssigned,
                        lottery_scheduled_at: t.lottery_scheduled_at || null,
                        lottery_executed_at: t.lottery_executed_at || null,
                        lottery_executed: t.lottery_executed || false,
                        is_my_turn: currentTurn > 0 && currentTurn === myTurnPosition,
                        num_positions: numPositions
                    };
                });
                log("info", `Returning ${enrichedTandas.length} tandas for ${userId} from PostgreSQL`);
                sendSuccess(res, { tandas: enrichedTandas, total: enrichedTandas.length, source: "postgresql" });
            } catch (error) {
                log("error", `PostgreSQL my-tandas error: ${error.message}`);
                sendError(res, 500, "Error fetching tandas");
            }
            return;
        }
        if (pathname === "/api/tandas" && method === "GET") {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const coordinatorId = query.coordinator_id;

            if (!coordinatorId) {
                sendError(res, 400, "coordinator_id requerido");
                return;
            }

            const userTandas = (database.tandas || []).filter(
                t => t.coordinator_id === coordinatorId
            );

            // Enrich with member info
            const enrichedTandas = userTandas.map(t => {
                const currentRecipient = database.users?.find(
                    u => u.id === t.current_turn_payments.recipient_user_id
                );

                return {
                    ...t,
                    current_recipient_name: currentRecipient?.name || "Unknown",
                    progress: `${t.current_turn}/${t.total_turns}`,
                    completion_percentage: Math.round((t.current_turn / t.total_turns) * 100)
                };
            });

            log("info", `Listed ${enrichedTandas.length} tandas for coordinator ${coordinatorId}`);

            sendSuccess(res, {
                tandas: enrichedTandas,
                total: enrichedTandas.length
            });
            return;
        }

        // Get tanda details
        // v4.10.3: Require auth (was fully unauthenticated — exposed participant PII)
        if (pathname.startsWith("/api/tandas/") && method === "GET" &&
            !pathname.includes("/record-payment") &&
            !pathname.includes("/advance-turn") &&
            !pathname.includes("/complete")) {

            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const tandaId = pathname.split("/")[3];

            log("info", `Fetching tanda details: ${tandaId}`);

            const tanda = database.tandas?.find(t => t.id === tandaId);
            if (!tanda) {
                sendError(res, 404, "Tanda no encontrada");
                return;
            }

            // Enrich with participant details
            const participants = tanda.turns_order.map((userId, index) => {
                const user = database.users?.find(u => u.id === userId);
                const hasPaidCurrentTurn = tanda.current_turn_payments.paid_by.includes(userId);
                const isCurrentRecipient = tanda.current_turn_payments.recipient_user_id === userId;

                return {
                    id: userId,  // Changed from user_id to id
                    name: user?.name || "Unknown",
                    email: user?.email || "",
                    turn_number: index + 1,
                    is_current_recipient: isCurrentRecipient,
                    paid_current_turn: hasPaidCurrentTurn,
                    status: isCurrentRecipient ? "receiving" : (hasPaidCurrentTurn ? "paid" : "pending")
                };
            });

            sendSuccess(res, {
                tanda: {
                    ...tanda,
                    participants: participants
                }
            });
            return;
        }

        // Record payment in tanda
        if (pathname.includes("/record-payment") && method === "POST") {
            const tandaId = pathname.split("/")[3];
            const { user_id, amount, coordinator_id } = body;

            log("info", `Recording payment in tanda ${tandaId} by user ${user_id}`);

            const tanda = database.tandas?.find(t => t.id === tandaId);
            if (!tanda) {
                sendError(res, 404, "Tanda no encontrada");
                return;
            }

            // Verify coordinator
            if (tanda.coordinator_id !== coordinator_id) {
                sendError(res, 403, "Solo el coordinador puede registrar pagos");
                return;
            }

            // Verify user is in tanda
            if (!tanda.turns_order.includes(user_id)) {
                sendError(res, 400, "Usuario no es parte de esta tanda");
                return;
            }

            // Verify user hasn't already paid
            if (tanda.current_turn_payments.paid_by.includes(user_id)) {
                sendError(res, 400, "Este usuario ya pagó en este turno");
                return;
            }

            // Add to paid list
            tanda.current_turn_payments.paid_by.push(user_id);

            // Remove from pending
            tanda.current_turn_payments.pending_from =
                tanda.current_turn_payments.pending_from.filter(id => id !== user_id);

            saveDatabase();

            log("info", `Payment recorded in tanda ${tandaId} by user ${user_id}`);

            sendSuccess(res, {
                message: "Pago registrado",
                tanda_id: tandaId,
                paid_count: tanda.current_turn_payments.paid_by.length,
                pending_count: tanda.current_turn_payments.pending_from.length,
                all_paid: tanda.current_turn_payments.pending_from.length === 0
            });
            return;
        }

        // Advance turn
        if (pathname.includes("/advance-turn") && method === "POST") {
            const tandaId = pathname.split("/")[3];
            const { coordinator_id } = body;

            log("info", `Advancing turn for tanda ${tandaId}`);

            const tanda = database.tandas?.find(t => t.id === tandaId);
            if (!tanda) {
                sendError(res, 404, "Tanda no encontrada");
                return;
            }

            // Verify coordinator
            if (tanda.coordinator_id !== coordinator_id) {
                sendError(res, 403, "Solo el coordinador puede avanzar turnos");
                return;
            }

            // Verify all paid
            const allPaid = tanda.current_turn_payments.pending_from.length === 0;
            if (!allPaid) {
                sendError(res, 400, `Aún hay ${tanda.current_turn_payments.pending_from.length} pagos pendientes. No se puede avanzar el turno.`);
                return;
            }

            // Save current turn to history
            tanda.turn_history.push({
                turn_number: tanda.current_turn,
                recipient_user_id: tanda.current_turn_payments.recipient_user_id,
                completed_at: new Date().toISOString(),
                paid_by: [...tanda.current_turn_payments.paid_by],
                total_collected: tanda.total_per_turn
            });

            // Advance turn
            tanda.current_turn++;

            // Check if tanda completed
            if (tanda.current_turn > tanda.total_turns) {
                tanda.status = "completed";
                tanda.completed_at = new Date().toISOString();

                saveDatabase();

                log("info", `Tanda ${tandaId} completed after ${tanda.total_turns} turns`);

                sendSuccess(res, {
                    message: "¡Tanda completada exitosamente!",
                    tanda_id: tandaId,
                    status: "completed",
                    total_turns: tanda.total_turns
                });
                return;
            }

            // Setup next turn
            tanda.current_turn_payments = {
                turn_number: tanda.current_turn,
                recipient_user_id: tanda.turns_order[tanda.current_turn - 1],
                paid_by: [],
                pending_from: [...tanda.turns_order] // All participants need to pay
            };

            saveDatabase();

            const nextRecipient = database.users?.find(
                u => u.id === tanda.current_turn_payments.recipient_user_id
            );

            log("info", `Tanda ${tandaId} advanced to turn ${tanda.current_turn}`);

            sendSuccess(res, {
                message: `Turno avanzado a #${tanda.current_turn}`,
                tanda_id: tandaId,
                current_turn: tanda.current_turn,
                total_turns: tanda.total_turns,
                next_recipient_name: nextRecipient?.name || "Unknown",
                next_recipient_id: tanda.current_turn_payments.recipient_user_id
            });
            return;
        }

        // Complete tanda manually
        if (pathname.includes("/complete") && method === "POST") {
            const tandaId = pathname.split("/")[3];
            const { coordinator_id } = body;

            log("info", `Manually completing tanda ${tandaId}`);

            const tanda = database.tandas?.find(t => t.id === tandaId);
            if (!tanda) {
                sendError(res, 404, "Tanda no encontrada");
                return;
            }

            // Verify coordinator
            if (tanda.coordinator_id !== coordinator_id) {
                sendError(res, 403, "Solo el coordinador puede completar la tanda");
                return;
            }

            tanda.status = "completed";
            tanda.completed_at = new Date().toISOString();

            saveDatabase();

            log("info", `Tanda ${tandaId} marked as completed manually`);

            sendSuccess(res, {
                message: "Tanda completada",
                tanda_id: tandaId,
                status: "completed"
            });
            return;
        }

        // ===== ANALYTICS ENDPOINTS =====

        // Get analytics dashboard for coordinator
        if (pathname.startsWith("/api/analytics/") && method === "GET" && !pathname.includes("/chart/")) {
            // v3.99.0: Require auth - was exposing financial data to unauthenticated users
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            const userId = pathname.split("/")[3];
            // Only allow viewing own analytics or admin
            if (authUser.userId !== userId && authUser.role !== 'admin') {
                sendError(res, 403, 'No autorizado para ver estas analiticas');
                return;
            }
            const timeRange = query.range || "30days";

            log("info", `Fetching analytics for user ${userId}, range: ${timeRange}`);

            // Calculate date range
            const now = new Date();
            let startDate;
            switch(timeRange) {
                case "7days":
                    startDate = new Date(now - 7 * 24 * 60 * 60 * 1000);
                    break;
                case "30days":
                    startDate = new Date(now - 30 * 24 * 60 * 60 * 1000);
                    break;
                case "90days":
                    startDate = new Date(now - 90 * 24 * 60 * 60 * 1000);
                    break;
                case "year":
                    startDate = new Date(now.getFullYear(), 0, 1);
                    break;
                default:
                    startDate = new Date(0); // All time
            }

            // Get coordinator's groups
            const coordinatorGroups = (database.groups || []).filter(
                g => g.admin_id === userId
            );

            if (coordinatorGroups.length === 0) {
                sendSuccess(res, {
                    members: { total: 0, percentChange: 0, growth: [] },
                    revenue: { total: 0, percentChange: 0, history: [] },
                    payments: { rate: 0, paid: 0, pending: 0, rejected: 0 },
                    groups: { active: 0, total: 0, byRevenue: [] },
                    topMembers: []
                });
                return;
            }

            // Calculate total members
            let totalMembers = 0;
            const membersByDate = {};

            coordinatorGroups.forEach(g => {
                const members = (database.groupMembers || []).filter(
                    m => m.group_id === g.id
                );
                totalMembers += members.length;

                // Track member growth
                members.forEach(m => {
                    if (m.joined_at && new Date(m.joined_at) >= startDate) {
                        const date = new Date(m.joined_at).toISOString().split('T')[0];
                        membersByDate[date] = (membersByDate[date] || 0) + 1;
                    }
                });
            });

            // Calculate total collected
            let totalCollected = 0;
            const revenueByDate = {};

            coordinatorGroups.forEach(g => {
                totalCollected += (g.total_amount_collected || 0);

                // Get transactions for this group
                const groupTransactions = (database.transactions || []).filter(
                    t => t.group_id === g.id &&
                         t.status === "completed" &&
                         new Date(t.created_at) >= startDate
                );

                groupTransactions.forEach(t => {
                    const date = new Date(t.created_at).toISOString().split('T')[0];
                    revenueByDate[date] = (revenueByDate[date] || 0) + (t.amount || 0);
                });
            });

            // Calculate payment rate
            const allPayments = [];
            coordinatorGroups.forEach(g => {
                const groupPayments = (database.transactions || []).filter(
                    t => t.group_id === g.id &&
                         new Date(t.created_at) >= startDate
                );
                allPayments.push(...groupPayments);
            });

            const paidPayments = allPayments.filter(t => t.status === "completed");
            const pendingPayments = allPayments.filter(t => t.status === "pending" || t.status === "pending_verification" || t.status === "processing");
            const rejectedPayments = allPayments.filter(t => t.status === "rejected");

            const paymentRate = allPayments.length > 0
                ? Math.round((paidPayments.length / allPayments.length) * 100)
                : 0;

            // Active vs total groups
            const activeGroups = coordinatorGroups.filter(g => g.status === "active" || !g.status).length;

            // Revenue history for chart
            const revenueHistory = Object.entries(revenueByDate)
                .map(([date, amount]) => ({ date, amount }))
                .sort((a, b) => new Date(a.date) - new Date(b.date));

            // Member growth for chart
            const memberGrowth = Object.entries(membersByDate)
                .map(([date, count]) => ({ date, count }))
                .sort((a, b) => new Date(a.date) - new Date(b.date));

            // Top groups by revenue
            const topGroups = coordinatorGroups
                .map(g => {
                    const members = (database.groupMembers || []).filter(m => m.group_id === g.id);
                    const groupPayments = (database.transactions || []).filter(
                        t => t.group_id === g.id && t.status === "completed"
                    );
                    const totalPaid = groupPayments.filter(t => t.status === "completed").length;
                    const totalDue = members.length;
                    const paymentRate = totalDue > 0 ? Math.round((totalPaid / totalDue) * 100) : 0;

                    return {
                        id: g.id,
                        name: g.name,
                        revenue: g.total_amount_collected || 0,
                        members: members.length,
                        payment_rate: paymentRate
                    };
                })
                .sort((a, b) => b.revenue - a.revenue)
                .slice(0, 5);

            // Top members (most punctual)
            const memberStats = {};
            coordinatorGroups.forEach(g => {
                const members = (database.groupMembers || []).filter(m => m.group_id === g.id);
                members.forEach(m => {
                    if (!memberStats[m.user_id]) {
                        memberStats[m.user_id] = {
                            user_id: m.user_id,
                            name: m.user_name || "Unknown",
                            groups: 0,
                            total_payments: 0,
                            on_time_payments: 0
                        };
                    }
                    memberStats[m.user_id].groups++;

                    // Count payments
                    const userPayments = (database.transactions || []).filter(
                        t => t.user_id === m.user_id && t.status === "completed"
                    );
                    memberStats[m.user_id].total_payments += userPayments.length;

                    // Approximate on-time payments (completed payments)
                    memberStats[m.user_id].on_time_payments += userPayments.length;
                });
            });

            const topMembers = Object.values(memberStats)
                .map(m => ({
                    ...m,
                    on_time_rate: m.total_payments > 0
                        ? Math.round((m.on_time_payments / m.total_payments) * 100)
                        : 0
                }))
                .sort((a, b) => b.on_time_rate - a.on_time_rate)
                .slice(0, 10);

            // Calculate percent changes (simplified - comparing to all-time average)
            const membersPercentChange = 0; // TODO: Implement proper comparison
            const revenuePercentChange = 0; // TODO: Implement proper comparison

            log("info", `Analytics generated for user ${userId}: ${totalMembers} members, L.${totalCollected} revenue`);

            sendSuccess(res, {
                members: {
                    total: totalMembers,
                    percentChange: membersPercentChange,
                    growth: memberGrowth
                },
                revenue: {
                    total: totalCollected,
                    percentChange: revenuePercentChange,
                    history: revenueHistory
                },
                payments: {
                    rate: paymentRate,
                    paid: paidPayments.length,
                    pending: pendingPayments.length,
                    rejected: rejectedPayments.length
                },
                groups: {
                    active: activeGroups,
                    total: coordinatorGroups.length,
                    byRevenue: topGroups
                },
                topMembers: topMembers
            });
            return;
        }

        // Get specific chart data
        if (pathname.includes("/chart/") && method === "GET") {
            const parts = pathname.split("/");
            const userId = parts[3];
            const chartType = parts[5];
            const timeRange = query.range || "30days";
            const groupBy = query.groupBy || "day";

            log("info", `Fetching chart data: ${chartType} for user ${userId}`);

            // Calculate date range
            const now = new Date();
            let startDate;
            switch(timeRange) {
                case "7days":
                    startDate = new Date(now - 7 * 24 * 60 * 60 * 1000);
                    break;
                case "30days":
                    startDate = new Date(now - 30 * 24 * 60 * 60 * 1000);
                    break;
                case "90days":
                    startDate = new Date(now - 90 * 24 * 60 * 60 * 1000);
                    break;
                case "year":
                    startDate = new Date(now.getFullYear(), 0, 1);
                    break;
                default:
                    startDate = new Date(0);
            }

            const coordinatorGroups = (database.groups || []).filter(
                g => g.admin_id === userId
            );

            let chartData = {};

            switch(chartType) {
                case "revenue":
                    // Revenue over time
                    const revenueByPeriod = {};
                    coordinatorGroups.forEach(g => {
                        const transactions = (database.transactions || []).filter(
                            t => t.group_id === g.id &&
                                 t.status === "completed" &&
                                 new Date(t.created_at) >= startDate
                        );
                        transactions.forEach(t => {
                            const date = new Date(t.created_at).toISOString().split('T')[0];
                            revenueByPeriod[date] = (revenueByPeriod[date] || 0) + (t.amount || 0);
                        });
                    });
                    chartData = {
                        labels: Object.keys(revenueByPeriod).sort(),
                        data: Object.keys(revenueByPeriod).sort().map(date => revenueByPeriod[date])
                    };
                    break;

                case "members":
                    // Member growth over time
                    const membersByPeriod = {};
                    coordinatorGroups.forEach(g => {
                        const members = (database.groupMembers || []).filter(
                            m => m.group_id === g.id &&
                                 m.joined_at &&
                                 new Date(m.joined_at) >= startDate
                        );
                        members.forEach(m => {
                            const date = new Date(m.joined_at).toISOString().split('T')[0];
                            membersByPeriod[date] = (membersByPeriod[date] || 0) + 1;
                        });
                    });
                    chartData = {
                        labels: Object.keys(membersByPeriod).sort(),
                        data: Object.keys(membersByPeriod).sort().map(date => membersByPeriod[date])
                    };
                    break;

                case "payments":
                    // Payment status distribution
                    let paid = 0, pending = 0, rejected = 0;
                    coordinatorGroups.forEach(g => {
                        const transactions = (database.transactions || []).filter(
                            t => t.group_id === g.id &&
                                 new Date(t.created_at) >= startDate
                        );
                        paid += transactions.filter(t => t.status === "completed").length;
                        pending += transactions.filter(t =>
                            t.status === "pending" || t.status === "pending_verification" || t.status === "processing"
                        ).length;
                        rejected += transactions.filter(t => t.status === "rejected").length;
                    });
                    chartData = {
                        labels: ["Pagados", "Pendientes", "Rechazados"],
                        data: [paid, pending, rejected]
                    };
                    break;

                case "groups":
                    // Payments per group
                    const groupData = coordinatorGroups.map(g => {
                        const transactions = (database.transactions || []).filter(
                            t => t.group_id === g.id && t.status === "completed"
                        );
                        return {
                            name: g.name,
                            payments: transactions.length
                        };
                    }).sort((a, b) => b.payments - a.payments).slice(0, 10);

                    chartData = {
                        labels: groupData.map(g => g.name),
                        data: groupData.map(g => g.payments)
                    };
                    break;

                default:
                    sendError(res, 400, "Tipo de gráfico no soportado");
                    return;
            }

            log("info", `Chart data generated: ${chartType}`);

            sendSuccess(res, {
                chartType: chartType,
                timeRange: timeRange,
                groupBy: groupBy,
                data: chartData
            });
            return;
        }

        // ===== MATCHING ALGORITHM ENDPOINTS =====

        // Save/update user matching preferences
        if (pathname === "/api/matching/preferences" && method === "POST") {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticación requerida');
                return;
            }
            const {
                location,
                age_range,
                contribution_range,
                experience_level,
                preferred_frequency
            } = body;
            // v3.99.0: Use authUser.userId instead of body.user_id (IDOR fix)
            const user_id = authUser.userId;

            // Find or create preferences
            if (!database.matchingPreferences) {
                database.matchingPreferences = [];
            }

            const existingIndex = database.matchingPreferences.findIndex(
                p => p.user_id === user_id
            );

            const preferences = {
                user_id: user_id,
                location: location || null,
                age_range: age_range || { min: 18, max: 65 },
                contribution_range: contribution_range || { min: 0, max: 10000 },
                experience_level: experience_level || "any", // beginner, intermediate, advanced, any
                preferred_frequency: preferred_frequency || "weekly",
                updated_at: new Date().toISOString()
            };

            if (existingIndex >= 0) {
                database.matchingPreferences[existingIndex] = preferences;
            } else {
                database.matchingPreferences.push(preferences);
            }

            saveDatabase();

            log("info", `Preferences saved for user ${user_id}`);

            sendSuccess(res, {
                message: "Preferencias guardadas exitosamente",
                preferences: preferences
            });
            return;
        }

        // Get matching preferences for a user
        if (pathname.startsWith("/api/matching/preferences/") && method === "GET") {
            // v3.99.0: Require auth
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            const userId = authUser.userId;

            const preferences = (database.matchingPreferences || []).find(
                p => p.user_id === userId
            );

            if (!preferences) {
                sendSuccess(res, {
                    preferences: null,
                    message: "No se encontraron preferencias guardadas"
                });
                return;
            }

            sendSuccess(res, {
                preferences: preferences
            });
            return;
        }

        // Get available users for matching (with scoring)
        if (pathname.startsWith("/api/users/available-for-matching") && method === "GET") {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) { sendError(res, 401, 'Autenticacion requerida'); return; }
            const userId = String(authUser.userId);
            const groupId = query.group_id;

            log("info", `Finding matches for user ${userId} in group ${groupId}`);

            if (!userId) {
                sendError(res, 400, "user_id requerido");
                return;
            }

            // Get group details
            const group = (database.groups || []).find(g => g.id === groupId);
            if (!group && groupId) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }

            // Get current members of the group (to exclude them)
            const currentMembers = (database.groupMembers || [])
                .filter(m => m.group_id === groupId)
                .map(m => m.user_id);

            // Get user's matching preferences
            const userPreferences = (database.matchingPreferences || []).find(
                p => p.user_id === userId
            );

            // Get requesting user's data
            const requestingUser = (database.users || []).find(u => u.id === userId);

            // Get all available users (not in current group)
            const availableUsers = (database.users || []).filter(u =>
                u.id !== userId &&
                (!groupId || !currentMembers.includes(u.id)) &&
                u.status !== "suspended" &&
                u.verification_level !== "none"
            );

            // Calculate matching score for each user
            const scoredUsers = availableUsers.map(user => {
                let score = 0;
                const breakdown = {};

                // 1. LOCATION SCORE (30%)
                if (userPreferences && userPreferences.location && user.location) {
                    const locationMatch = userPreferences.location.toLowerCase() === user.location.toLowerCase();
                    const locationScore = locationMatch ? 30 : 0;
                    score += locationScore;
                    breakdown.location = locationScore;
                } else {
                    breakdown.location = 15; // Neutral score if no preference
                    score += 15;
                }

                // 2. AGE SCORE (20%)
                if (userPreferences && userPreferences.age_range && user.age) {
                    const ageInRange = user.age >= userPreferences.age_range.min &&
                                      user.age <= userPreferences.age_range.max;
                    const ageScore = ageInRange ? 20 : 0;
                    score += ageScore;
                    breakdown.age = ageScore;
                } else {
                    breakdown.age = 10; // Neutral score
                    score += 10;
                }

                // 3. EXPERIENCE SCORE (25%)
                const userTandas = (database.tandas || []).filter(t =>
                    t.turns_order && t.turns_order.includes(user.id)
                );
                const userGroups = (database.groupMembers || []).filter(m =>
                    m.user_id === user.id
                );

                const totalExperience = userTandas.length + userGroups.length;
                let experienceScore = 0;

                if (userPreferences && userPreferences.experience_level !== "any") {
                    if (userPreferences.experience_level === "beginner" && totalExperience <= 2) {
                        experienceScore = 25;
                    } else if (userPreferences.experience_level === "intermediate" && totalExperience >= 3 && totalExperience <= 10) {
                        experienceScore = 25;
                    } else if (userPreferences.experience_level === "advanced" && totalExperience > 10) {
                        experienceScore = 25;
                    } else {
                        experienceScore = 10; // Partial match
                    }
                } else {
                    // No preference, score based on experience level
                    if (totalExperience === 0) experienceScore = 10;
                    else if (totalExperience <= 5) experienceScore = 20;
                    else experienceScore = 25;
                }

                score += experienceScore;
                breakdown.experience = experienceScore;

                // 4. TRUST SCORE (15%)
                const trustScore = (user.trust_score || 50) / 100 * 15;
                score += trustScore;
                breakdown.trust = Math.round(trustScore);

                // 5. CONTRIBUTION MATCH (10%)
                let contributionScore = 0;
                if (group && group.contribution_amount && user.avg_contribution) {
                    const diff = Math.abs(group.contribution_amount - user.avg_contribution);
                    const percentDiff = diff / group.contribution_amount;

                    if (percentDiff <= 0.1) contributionScore = 10; // Within 10%
                    else if (percentDiff <= 0.25) contributionScore = 7; // Within 25%
                    else if (percentDiff <= 0.5) contributionScore = 4; // Within 50%
                    else contributionScore = 1;
                } else {
                    contributionScore = 5; // Neutral
                }

                score += contributionScore;
                breakdown.contribution = contributionScore;

                // Round final score
                const finalScore = Math.round(score);

                return {
                    user_id: user.id,
                    name: user.name,
                    email: user.email,
                    location: user.location || "No especificada",
                    age: user.age || null,
                    avatar_url: user.avatar_url || null,
                    verification_level: user.verification_level,
                    trust_score: user.trust_score || 50,
                    total_groups: userGroups.length,
                    total_tandas: userTandas.length,
                    total_experience: totalExperience,
                    avg_contribution: user.avg_contribution || null,
                    match_score: finalScore,
                    score_breakdown: breakdown
                };
            });

            // Sort by match score (highest first)
            scoredUsers.sort((a, b) => b.match_score - a.match_score);

            // Limit to top 20
            const topMatches = scoredUsers.slice(0, 20);

            log("info", `Found ${topMatches.length} matches for user ${userId}`);

            sendSuccess(res, {
                matches: topMatches,
                total: topMatches.length,
                user_preferences: userPreferences || null
            });
            return;
        }

        // Invite user to group
        if (pathname.includes("/invite-user") && method === "POST") {
            const groupId = pathname.split("/")[3];
            const { user_id, invited_by, message } = body;

            log("info", `Inviting user ${user_id} to group ${groupId}`);

            // Validations
            const group = (database.groups || []).find(g => g.id === groupId);
            if (!group) {
                sendError(res, 404, "Grupo no encontrado");
                return;
            }

            const invitedUser = (database.users || []).find(u => u.id === user_id);
            if (!invitedUser) {
                sendError(res, 401, "Credenciales inválidas"); // SECURITY: Generic error to prevent user enumeration
                return;
            }

            // Check if user is already a member
            const existingMember = (database.groupMembers || []).find(
                m => m.group_id === groupId && m.user_id === user_id
            );
            if (existingMember) {
                sendError(res, 400, "El usuario ya es miembro de este grupo");
                return;
            }

            // Check if invitation already exists
            if (!database.groupInvitations) {
                database.groupInvitations = [];
            }

            const existingInvitation = database.groupInvitations.find(
                inv => inv.group_id === groupId && inv.user_id === user_id && inv.status === "pending"
            );

            if (existingInvitation) {
                sendError(res, 400, "Ya existe una invitación pendiente para este usuario");
                return;
            }

            // Create invitation
            const invitationId = generateId("invitation");
            const invitation = {
                id: invitationId,
                group_id: groupId,
                group_name: group.name,
                user_id: user_id,
                invited_by: invited_by,
                message: message || null,
                status: "pending", // pending, accepted, rejected
                created_at: new Date().toISOString(),
                expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() // 7 days
            };

            database.groupInvitations.push(invitation);
            saveDatabase();

            log("info", `Invitation ${invitationId} created for user ${user_id} to group ${groupId}`);

            sendSuccess(res, {
                message: "Invitación enviada exitosamente",
                invitation_id: invitationId,
                invitation: invitation
            });
            return;
        }


        // GET /api/invitations/sent/:userId - Get invitations sent BY a user (PostgreSQL)
        // v4.10.3: Require auth + use JWT userId (was IDOR — anyone could query any user's invitations)
        if (pathname.match(/^\/api\/invitations\/sent\/[^\/]+$/) && method === "GET") {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            // Use JWT userId instead of URL param to prevent IDOR
            const userId = authUser.userId;

            log("info", `Fetching sent invitations for user ${userId}`);

            try {
                const invResult = await dbPostgres.pool.query(`
                    SELECT 
                        gi.id,
                        gi.group_id,
                        gi.invitee_email,
                        gi.invitee_phone,
                        gi.invitee_name,
                        gi.message,
                        gi.status,
                        gi.token,
                        gi.created_at,
                        gi.expires_at,
                        gi.responded_at,
                        gi.reminder_count,
                        gi.last_reminded_at,
                        g.name as group_name,
                        g.description as group_description,
                        g.contribution_amount,
                        g.frequency
                    FROM group_invitations gi
                    JOIN groups g ON gi.group_id = g.group_id
                    WHERE gi.inviter_id = $1
                    ORDER BY gi.created_at DESC
                `, [userId]);

                sendSuccess(res, {
                    invitations: invResult.rows,
                    total: invResult.rows.length
                });
            } catch (error) {
                log("error", "Error fetching sent invitations", { userId, error: error.message });
                sendError(res, 500, "Error al obtener invitaciones enviadas");
            }
            return;
        }
        // Get invitations for a user
        if (pathname.startsWith("/api/invitations/") && !pathname.includes("/token/") && method === "GET") {
            // v3.99.0: Require auth
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) {
                sendError(res, 401, 'Autenticacion requerida');
                return;
            }
            const userId = authUser.userId;

            log("info", `Fetching invitations for user ${userId}`);

            const userInvitations = (database.groupInvitations || []).filter(
                inv => inv.user_id === userId
            );

            // Enrich with group details
            const enrichedInvitations = userInvitations.map(inv => {
                const group = (database.groups || []).find(g => g.id === inv.group_id);
                const inviter = (database.users || []).find(u => u.id === inv.invited_by);

                return {
                    ...inv,
                    group_details: group ? {
                        name: group.name,
                        description: group.description,
                        contribution_amount: group.contribution_amount,
                        frequency: group.frequency,
                        members_count: (database.groupMembers || []).filter(m => m.group_id === group.id).length
                    } : null,
                    inviter_name: inviter ? inviter.name : "Desconocido"
                };
            });

            sendSuccess(res, {
                invitations: enrichedInvitations,
                total: enrichedInvitations.length
            });
            return;
        }

        // GET invitation by token (for accepting from link)
        if (pathname.match(/^\/api\/invitations\/token\/[a-f0-9]+$/) && method === "GET") {
            const token = pathname.split("/").pop();
            
            log("info", "Get invitation by token", { token: token.substring(0, 10) + '...' });
            
            try {
                // Get invitation from PostgreSQL
                const invResult = await dbPostgres.pool.query(
                    `SELECT 
                        gi.*,
                        g.name as group_name,
                        g.description as group_description,
                        g.contribution_amount,
                        g.frequency,
                        g.member_count,
                        g.max_members,
                        u.name as inviter_name,
                        u.email as inviter_email
                    FROM group_invitations gi
                    JOIN groups g ON gi.group_id = g.group_id
                    LEFT JOIN users u ON gi.inviter_id = u.user_id
                    WHERE gi.token = \$1`,
                    [token]
                );
                
                if (invResult.rows.length === 0) {
                    sendError(res, 404, "Invitacion no encontrada o token invalido");
                    return;
                }
                
                const invitation = invResult.rows[0];
                
                // Check if expired
                if (new Date(invitation.expires_at) < new Date()) {
                    sendError(res, 400, "Esta invitacion ha expirado");
                    return;
                }
                
                // Check if already used
                if (invitation.status !== 'pending') {
                    sendError(res, 400, "Esta invitacion ya fue " + (invitation.status === 'accepted' ? 'aceptada' : 'rechazada'), 400);
                    return;
                }
                
                sendSuccess(res, {
                    invitation_id: invitation.id,
                    group_id: invitation.group_id,
                    group_name: invitation.group_name,
                    group_description: invitation.group_description,
                    contribution_amount: invitation.contribution_amount,
                    frequency: invitation.frequency,
                    member_count: invitation.member_count,
                    max_members: invitation.max_members,
                    inviter_name: invitation.inviter_name || 'Un miembro',
                    invitee_name: invitation.invitee_name,
                    message: invitation.message,
                    expires_at: invitation.expires_at,
                    status: invitation.status
                });
                return;
                
            } catch (error) {
                log("error", "Error getting invitation by token", { error: error.message });
                sendError(res, 500, "Error al obtener invitacion");
                return;
            }
        }

        // POST - Decline invitation by token
        if (pathname.match(/^\/api\/invitations\/token\/[a-f0-9]+\/decline$/) && method === "POST") {
            const token = pathname.split("/")[4];
            
            log("info", "Decline invitation by token", { token: token.substring(0, 10) + "..." });
            
            try {
                const invResult = await dbPostgres.pool.query(
                    "SELECT id, group_id, inviter_id, invitee_email, invitee_phone, invitee_name, message, status, token, created_at, responded_at, expires_at, is_reusable, max_uses, use_count, reminder_count, last_reminded_at, invitee_user_id FROM group_invitations WHERE token = $1",
                    [token]
                );
                
                if (invResult.rows.length === 0) {
                    sendError(res, 404, "Invitacion no encontrada");
                    return;
                }
                
                const invitation = invResult.rows[0];
                
                if (invitation.status !== "pending") {
                    sendError(res, 400, "Esta invitacion ya fue procesada");
                    return;
                }
                
                await dbPostgres.pool.query(
                    "UPDATE group_invitations SET status = 'rejected', responded_at = NOW() WHERE id = $1",
                    [invitation.id]
                );
                
                log("info", "Invitation rejected", { invitation_id: invitation.id });
                
                sendSuccess(res, {
                    message: "Invitacion rechazada",
                    invitation_id: invitation.id
                });
                return;
            } catch (error) {
                log("error", "DECLINE ERROR:", error); log("error", "Error declining invitation", { error: error.message });
                sendError(res, 500, "Error al rechazar invitacion");
                return;
            }
        }

        // Accept invitation by token (POST)
        if (pathname.match(/^\/api\/invitations\/token\/[a-f0-9]+\/accept$/) && method === "POST") {
            const parts = pathname.split("/");
            const token = parts[4];
            const { user_id } = body;
            
            log("info", "Accept invitation by token", { token: token.substring(0, 10) + '...', user_id });
        if (pathname.match(/^\/api\/invitations\/token\/[a-f0-9]+\/accept$/) && method === "POST") {
            const parts = pathname.split("/");
            const token = parts[4];
            const { user_id } = body;
            
            log("info", "Accept invitation by token", { token: token.substring(0, 10) + '...', user_id });
            
            try {
                // Get invitation
                const invResult = await dbPostgres.pool.query(
                    "SELECT id, group_id, inviter_id, invitee_email, invitee_phone, invitee_name, message, status, token, created_at, responded_at, expires_at, is_reusable, max_uses, use_count, reminder_count, last_reminded_at, invitee_user_id FROM group_invitations WHERE token = \$1",
                    [token]
                );
                
                if (invResult.rows.length === 0) {
                    sendError(res, 404, "Invitacion no encontrada");
                    return;
                }
                
                const invitation = invResult.rows[0];
                
                // Validations
                if (new Date(invitation.expires_at) < new Date()) {
                    sendError(res, 400, "Esta invitacion ha expirado");
                    return;
                }
                
                // Check if invitation can still be used
                if (invitation.is_reusable) {
                    // Reusable invitation - check max_uses
                    if (invitation.max_uses !== null && invitation.use_count >= invitation.max_uses) {
                        sendError(res, 400, "Esta invitacion ha alcanzado el limite de usos");
                        return;
                    }
                } else {
                    // Single-use invitation - check status
                    if (invitation.status !== 'pending') {
                        sendError(res, 400, "Esta invitacion ya fue procesada");
                        return;
                    }
                }
                
                // Check if user is already a member
                const existingMember = await dbPostgres.pool.query(
                    "SELECT id FROM group_members WHERE group_id = \$1 AND user_id = \$2 AND status = 'active'",
                    [invitation.group_id, user_id]
                );
                
                if (existingMember.rows.length > 0) {
                    sendError(res, 400, "Ya eres miembro de este grupo");
                    return;
                }
                
                // Check group max_members limit
                const groupCheck = await dbPostgres.pool.query(
                    "SELECT member_count, max_members FROM groups WHERE group_id = \$1",
                    [invitation.group_id]
                );
                
                if (groupCheck.rows.length > 0) {
                    const group = groupCheck.rows[0];
                    if (group.max_members && group.member_count >= group.max_members) {
                        sendError(res, 400, "El grupo ha alcanzado el limite de miembros");
                        return;
                    }
                }
                
                // Add user to group
                await dbPostgres.pool.query(
                    "INSERT INTO group_members (group_id, user_id, role, status, invited_by) VALUES (\$1, \$2, 'member', 'active', \$3)",
                    [invitation.group_id, user_id, invitation.inviter_id]
                );
                
                
                // Update invitation based on type
                if (invitation.is_reusable) {
                    // Increment use_count for reusable invitations
                    await dbPostgres.pool.query(
                        "UPDATE group_invitations SET use_count = use_count + 1 WHERE id = \$1",
                        [invitation.id]
                    );
                    log("info", "Reusable invitation used", { invitation_id: invitation.id, use_count: invitation.use_count + 1 });
                } else {
                    // Mark as accepted for single-use invitations
                    await dbPostgres.pool.query(
                        "UPDATE group_invitations SET status = 'accepted', responded_at = NOW() WHERE id = \$1",
                        [invitation.id]
                    );
                }
                
                // Get group info for response
                const groupResult = await dbPostgres.pool.query(
                    "SELECT name FROM groups WHERE group_id = \$1",
                    [invitation.group_id]
                );
                
                log("info", "User joined group via invitation", { user_id, group_id: invitation.group_id, is_reusable: invitation.is_reusable });
                
                sendSuccess(res, {
                    message: "Te has unido al grupo exitosamente",
                    group_id: invitation.group_id,
                    group_name: groupResult.rows[0]?.name || 'Grupo'
                });
                return;
                
            } catch (error) {
                log("error", "Error accepting invitation", { error: error.message });
                
                // Log to failed_group_joins for tracking
                try {
                    await dbPostgres.pool.query(
                        "INSERT INTO failed_group_joins (user_id, user_email, group_id, invitation_id, error_type, error_message) VALUES ($1, $2, $3, $4, $5, $6)",
                        [user_id, null, invitation?.group_id, invitation?.id, 'DB_ERROR', error.message]
                    );
                    
                    // Notify group admin
                    if (invitation?.group_id) {
                        const groupInfo = await dbPostgres.pool.query(
                            "SELECT admin_id, name FROM groups WHERE group_id = $1",
                            [invitation.group_id]
                        );
                        if (groupInfo.rows.length > 0) {
                            const admin = groupInfo.rows[0];
                            await dbPostgres.pool.query(
                                "INSERT INTO notifications (user_id, type, title, message, data, created_at) VALUES ($1, $2, $3, $4, $5, NOW())",
                                [
                                    admin.admin_id,
                                    'join_error',
                                    'Error en unión a grupo',
                                    'Un usuario tuvo problemas al unirse a ' + admin.name,
                                    JSON.stringify({ group_id: invitation.group_id, user_id: user_id, error: error.message })
                                ]
                            );
                        }
                    }
                } catch (logErr) {
                    log("error", "Failed to log join error", { error: logErr.message });
                }
                
                log("error", "Error al aceptar invitacion", { error: error.message }); sendError(res, 500, "Error interno del servidor");
                return;
            }
        }

            log("info", `User ${user_id} responding to invitation ${invitationId} with action: ${action}`);

            const invitation = (database.groupInvitations || []).find(
                inv => inv.id === invitationId
            );

            if (!invitation) {
                sendError(res, 404, "Invitación no encontrada");
                return;
            }

            if (invitation.user_id !== user_id) {
                sendError(res, 403, "No tienes permiso para responder a esta invitación");
                return;
            }

            if (invitation.status !== "pending") {
                sendError(res, 400, `La invitación ya fue ${invitation.status === "accepted" ? "aceptada" : "rechazada"}`);
                return;
            }

            // Check if expired
            if (new Date(invitation.expires_at) < new Date()) {
                invitation.status = "expired";
                saveDatabase();
                sendError(res, 400, "La invitación ha expirado");
                return;
            }

            if (action === "accept") {
                // Add user to group
                const memberId = generateId("member");
                const member = {
                    id: memberId,
                    group_id: invitation.group_id,
                    user_id: user_id,
                    user_name: (database.users || []).find(u => u.id === user_id)?.name || "Unknown",
                    role: "member",
                    joined_at: new Date().toISOString(),
                    payment_status: "pending",
                    total_paid: 0
                };

                if (!database.groupMembers) {
                    database.groupMembers = [];
                }
                database.groupMembers.push(member);

                invitation.status = "accepted";
                invitation.responded_at = new Date().toISOString();

                saveDatabase();

                log("info", `User ${user_id} accepted invitation and joined group ${invitation.group_id}`);

                sendSuccess(res, {
                    message: "Invitación aceptada. ¡Bienvenido al grupo!",
                    member_id: memberId,
                    group_id: invitation.group_id
                });
            } else if (action === "reject") {
                invitation.status = "rejected";
                invitation.responded_at = new Date().toISOString();
                saveDatabase();

                log("info", `User ${user_id} rejected invitation ${invitationId}`);

                sendSuccess(res, {
                    message: "Invitación rechazada"
                });
            } else {
                sendError(res, 400, "Acción inválida. Usa 'accept' o 'reject'");
                return;
            }
            return;
        }

        // =====================================================================
        // POSITION SELECTION & ASSIGNMENT SYSTEM - 10 ENDPOINTS
        // =====================================================================

        // Para Participantes (Tab Tandas)
        if (pathname === '/api/tandas/available-positions' && method === 'GET') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            handleGetAvailablePositions(req, res, query, database);
            return;
        }

        if (pathname === '/api/tandas/request-position' && method === 'POST') {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            // Pass authUser to handler for secure user identification
            handleRequestPosition(req, res, body, database, authUser);
            return;
        }

        if (pathname === '/api/tandas/change-position-request' && (method === 'PUT' || method === 'PATCH')) {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            handleChangePositionRequest(req, res, body, database, authUser);
            return;
        }

        if (pathname === '/api/tandas/my-position-status' && method === 'GET') {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            handleGetMyPositionStatus(req, res, query, database, authUser);
            return;
        }

        // Para Coordinadores (Tab My Groups)
        if (pathname === '/api/groups/position-requests' && method === 'GET') {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            handleGetPositionRequests(req, res, query, database, authUser);
            return;
        }

        if (pathname === '/api/groups/approve-position-request' && method === 'POST') {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            handleApprovePositionRequest(req, res, body, database, authUser);
            return;
        }

        if (pathname === '/api/groups/reject-position-request' && method === 'POST') {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            handleRejectPositionRequest(req, res, body, database, authUser);
            return;
        }

        if (pathname === '/api/groups/assign-position-manually' && method === 'POST') {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            handleAssignPositionManually(req, res, body, database, authUser);
            return;
        }

        if (pathname === '/api/groups/auto-assign-positions' && method === 'POST') {
            // SECURITY FIX: Require JWT auth (2025-12-31)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            handleAutoAssignPositions(req, res, body, database, authUser);
            return;
        }

        if (pathname === '/api/groups/activate-tanda' && method === 'POST') {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            handleActivateTanda(req, res, body, database, authUser);
            return;
        }

        // GET /api/groups/:id/start-summary - Get summary for starting a tanda
        const startSummaryMatch = pathname.match(/^\/api\/groups\/([^\/]+)\/start-summary$/);
        if (startSummaryMatch && method === "GET") {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) { sendError(res, 401, "Autenticación requerida"); return; }
            const groupId = startSummaryMatch[1];
            
            try {
                const groupResult = await dbPostgres.pool.query(
                    "SELECT g.group_id, g.name, g.contribution_amount, g.frequency, g.member_count, g.max_members, g.total_amount_collected, g.admin_id, g.status, g.created_at, g.location, g.description, g.image_url, g.category, g.meeting_schedule, g.updated_at, g.is_demo, g.start_date, g.grace_period, g.penalty_amount, g.current_cycle, g.lottery_executed, g.lottery_executed_at, g.lottery_scheduled_at, g.deleted_at, g.deleted_by, g.approval_settings, g.last_recruitment_notification_at, COUNT(gm.id) as member_count FROM groups g LEFT JOIN group_members gm ON g.group_id = gm.group_id AND gm.status = 'active' WHERE g.group_id = $1 GROUP BY g.group_id",
                    [groupId]
                );
                
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }
                
                const group = groupResult.rows[0];
                
                // Get turns_order from tandas table (source of truth)
                const tandaResult = await dbPostgres.pool.query(
                    "SELECT turns_order FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1",
                    [groupId]
                );
                const turnsOrder = tandaResult.rows[0] && tandaResult.rows[0].turns_order ? tandaResult.rows[0].turns_order : [];

                // Build position map from turns_order
                const positionMap = {};
                turnsOrder.forEach(function(userId, index) {
                    positionMap[userId] = index + 1;
                });

                const membersResult = await dbPostgres.pool.query(
                    "SELECT gm.user_id, gm.role, u.name FROM group_members gm JOIN users u ON gm.user_id = u.user_id WHERE gm.group_id = $1 AND gm.status = 'active'",
                    [groupId]
                );

                // Sort members by turns_order position
                const sortedMembers = membersResult.rows.map(m => ({
                    ...m,
                    turn_position: positionMap[m.user_id] || null
                })).sort((a, b) => {
                    if (a.turn_position === null) return 1;
                    if (b.turn_position === null) return -1;
                    return a.turn_position - b.turn_position;
                });

                const lotteryExecuted = turnsOrder.length > 0;
                
                sendResponse(res, 200, {
                    success: true,
                    data: {
                        group_id: group.group_id,
                        group_name: group.name,
                        member_count: parseInt(group.member_count) || 0,
                        max_members: group.max_members || 10,
                        contribution_amount: parseFloat(group.contribution_amount) || 0,
                        frequency: group.frequency || "semanal",
                        total_duration: group.max_members ? (group.max_members + " semanas") : "N/A",
                        lottery_executed: lotteryExecuted,
                        members_with_positions: sortedMembers.map(m => ({
                            user_id: m.user_id,
                            name: m.name,
                            position: m.turn_position,
                            role: m.role
                        }))
                    }
                });
                return;
            } catch (error) {
                log("error", "Error getting start summary: " + error.message);
                sendError(res, 500, "Error al obtener resumen");
                return;
            }
        }

        // POST /api/tandas/:id/schedule-start - Schedule tanda start
        const scheduleStartMatch = pathname.match(/^\/api\/tandas\/([^\/]+)\/schedule-start$/);
        if (scheduleStartMatch && method === "POST") {
            const authUser = getAuthenticatedUser(req, query);
            if (!authUser) { sendError(res, 401, "Autenticación requerida"); return; }
            const tandaId = scheduleStartMatch[1];
            const { start_at } = body;
            
            if (!start_at) {
                sendError(res, 400, "start_at es requerido");
                return;
            }
            
            try {
                const tandaResult = await dbPostgres.pool.query(
                    "SELECT t.tanda_id, t.status, t.group_id, t.coordinator_id, g.name as group_name, g.admin_id FROM tandas t JOIN groups g ON t.group_id = g.group_id WHERE t.tanda_id = $1",
                    [tandaId]
                );
                
                if (tandaResult.rows.length === 0) {
                    sendError(res, 404, "Tanda no encontrada");
                    return;
                }
                
                const tanda = tandaResult.rows[0];
                
                if (tanda.admin_id !== authUser.userId && tanda.coordinator_id !== authUser.userId) {
                    sendError(res, 403, "Solo el coordinador puede programar la tanda");
                    return;
                }
                
                await dbPostgres.pool.query(
                    "UPDATE tandas SET scheduled_start_at = $1, status = 'scheduled', updated_at = NOW() WHERE tanda_id = $2",
                    [start_at, tandaId]
                );
                
                sendResponse(res, 200, {
                    success: true,
                    message: "Tanda programada exitosamente",
                    scheduled_at: start_at
                });
                return;
            } catch (error) {
                log("error", "Error scheduling tanda: " + error.message);
                sendError(res, 500, "Error al programar tanda");
                return;
            }
        }

        // POST /api/groups/:id/lottery-assign - Execute tombola to randomize turn order

        

        // POST /api/groups/:id/toggle-pause - Pause or resume a tanda
        const togglePauseMatch = pathname.match(/^\/api\/groups\/([^\/]+)\/toggle-pause$/);
        if (togglePauseMatch && method === "POST") {
            const groupId = togglePauseMatch[1];
            
            // Require authentication
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                // Check permission (creator or coordinator only)
                // v4.10.3: Allow suspended creators/coordinators (group suspension suspends all members)
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status IN ('active', 'suspended')
                `, [groupId, authUser.userId]);

                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para pausar/reanudar esta tanda');
                    return;
                }

                // Get current tanda status
                const tandaResult = await dbPostgres.pool.query(
                    "SELECT tanda_id, status FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1",
                    [groupId]
                );

                if (tandaResult.rows.length === 0) {
                    sendError(res, 404, 'No se encontró la tanda');
                    return;
                }

                const tanda = tandaResult.rows[0];
                const currentStatus = tanda.status;
                let newStatus;
                let message;

                // Toggle between paused and previous status
                if (currentStatus === 'paused') {
                    // Resume - set to active (or recruiting if it was recruiting before)
                    newStatus = body.previous_status || 'active';
                    message = 'Tanda reanudada';
                } else {
                    // Pause
                    newStatus = 'paused';
                    message = 'Tanda pausada';
                }

                // Update tanda status
                await dbPostgres.pool.query(
                    "UPDATE tandas SET status = $1, previous_status = $2, updated_at = NOW() WHERE tanda_id = $3",
                    [newStatus, currentStatus, tanda.tanda_id]
                );

                // When resuming: reactivate all suspended members (they were suspended when group was paused)
                let membersReactivated = 0;
                if (currentStatus === 'paused' && newStatus !== 'paused') {
                    const reactivateResult = await dbPostgres.pool.query(
                        "UPDATE group_members SET status = 'active', updated_at = NOW() WHERE group_id = $1 AND status = 'suspended'",
                        [groupId]
                    );
                    membersReactivated = reactivateResult.rowCount;
                    if (membersReactivated > 0) {
                        log("info", "Reactivated suspended members on resume", { groupId, count: membersReactivated });
                    }
                }

                log("info", "Tanda status toggled", { groupId, oldStatus: currentStatus, newStatus, by: authUser.userId });

                sendSuccess(res, {
                    message: message,
                    previous_status: currentStatus,
                    new_status: newStatus,
                    tanda_id: tanda.tanda_id,
                    members_reactivated: membersReactivated
                });
            } catch (error) {
                log("error", "Error toggling tanda pause", { error: error.message, groupId });
                sendError(res, 500, "Error al pausar/reanudar la tanda");
            }
            return;
        }


        // POST /api/groups/:id/lottery-live - Execute tombola with LIVE WebSocket broadcast
        const lotteryLiveMatch = pathname.match(/^\/api\/groups\/([^\/]+)\/lottery-live$/);
        if (lotteryLiveMatch && method === "POST") {
            const groupId = lotteryLiveMatch[1];
            
            // Require authentication
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {

                // ============================================
                // SECURITY: Verify user has permission to execute lottery (Added 2025-12-31)
                // v4.10.3: Allow suspended creators/coordinators to manage
                // ============================================
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status IN ('active', 'suspended')
                `, [groupId, authUser.userId]);

                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para ejecutar la tómbola');
                    return;
                }

                // ============================================
                // VALIDATION: Check if lottery was already executed (Added 2025-12-31)
                // ============================================
                const executedCheck = await dbPostgres.pool.query(`
                    SELECT lottery_executed_at FROM tandas
                    WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
                `, [groupId]);

                if (executedCheck.rows.length > 0 && executedCheck.rows[0].lottery_executed_at) {
                    sendError(res, 400, 'La tómbola ya fue ejecutada para esta tanda');
                    return;
                }

                const { countdown_seconds = 10 } = body;

                // Verify group exists and get name
                const groupResult = await dbPostgres.pool.query(
                    "SELECT g.group_id, g.name FROM groups g WHERE g.group_id = $1",
                    [groupId]
                );

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                const groupName = groupResult.rows[0].name;

                // Get all active members WITH lock status and num_positions
                const membersResult = await dbPostgres.pool.query(
                    "SELECT gm.user_id, u.name, gm.turn_locked, gm.turn_position, COALESCE(gm.num_positions, 1) as num_positions FROM group_members gm JOIN users u ON gm.user_id = u.user_id WHERE gm.group_id = $1 AND gm.status = 'active'",
                    [groupId]
                );

                if (membersResult.rows.length < 2) {
                    sendError(res, 400, "Se necesitan al menos 2 miembros para ejecutar la tombola");
                    return;
                }

                // Check WebSocket room status
                const roomStats = wsLottery.getRoomStats(groupId);

                // Calculate total positions (sum of all num_positions)
                const totalPositions = membersResult.rows.reduce((sum, m) => sum + parseInt(m.num_positions || 1), 0);
                
                // Expand members into individual position entries
                const allEntries = [];
                const lockedEntries = []; // {index: position-1, entry: memberEntry}
                
                for (const member of membersResult.rows) {
                    const numPos = parseInt(member.num_positions) || 1;
                    
                    for (let i = 0; i < numPos; i++) {
                        const entry = {
                            user_id: member.user_id,
                            name: member.name,
                            position_number: i + 1,
                            total_positions: numPos
                        };
                        
                        // First position can be locked if turn_locked is true
                        if (i === 0 && member.turn_locked && member.turn_position) {
                            lockedEntries.push({
                                index: member.turn_position - 1,
                                entry: entry
                            });
                        } else {
                            allEntries.push(entry);
                        }
                    }
                }
                
                log("info", "Live lottery starting", { 
                    groupId, 
                    uniqueMembers: membersResult.rows.length,
                    totalPositions, 
                    locked: lockedEntries.length, 
                    toShuffle: allEntries.length,
                    wsConnected: roomStats.connected 
                });

                // Shuffle non-locked entries (Fisher-Yates)
                for (let i = allEntries.length - 1; i > 0; i--) {
                    const j = crypto.randomInt(0, i + 1);
                    [allEntries[i], allEntries[j]] = [allEntries[j], allEntries[i]];
                }

                // Build final array respecting locked positions
                const members = new Array(totalPositions).fill(null);
                
                // Place locked entries first
                for (const locked of lockedEntries) {
                    if (locked.index >= 0 && locked.index < totalPositions && !members[locked.index]) {
                        members[locked.index] = locked.entry;
                    }
                }
                
                // Fill remaining positions with shuffled entries
                let shuffleIndex = 0;
                for (let i = 0; i < totalPositions; i++) {
                    if (!members[i] && shuffleIndex < allEntries.length) {
                        members[i] = allEntries[shuffleIndex++];
                    }
                }

                // Send immediate response - lottery will execute async via WebSocket
                sendResponse(res, 200, {
                    success: true,
                    message: "Tombola en vivo iniciada",
                    data: {
                        groupId: groupId,
                        groupName: groupName,
                        countdown_seconds: countdown_seconds,
                        members_count: members.length,
                        ws_connected: roomStats.connected,
                        ws_endpoint: "/ws/lottery?groupId=" + groupId
                    }
                });

                // Execute live lottery asynchronously via WebSocket
                (async () => {
                    try {
                        // Execute with WebSocket broadcast
                        await wsLottery.executeLiveLottery(
                            groupId, 
                            groupName, 
                            members, 
                            countdown_seconds,
                            800 // 800ms delay between each assignment
                        );

                        // Save results to database
                        const turnsOrder = members.map((m, i) => ({user_id: m.user_id, slot: (m.position_number || 1) - 1}));

                        // Update or create tanda
                        const tandaResult = await dbPostgres.pool.query(
                            "SELECT tanda_id FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1",
                            [groupId]
                        );

                        if (tandaResult.rows.length > 0) {
                            await dbPostgres.pool.query(
                                "UPDATE tandas SET turns_order = $1, lottery_executed_at = NOW(), updated_at = NOW() WHERE tanda_id = $2",
                                [turnsOrder, tandaResult.rows[0].tanda_id]
                            );
                        } else {
                            const tandaId = "tanda_" + Date.now();
                            await dbPostgres.pool.query(
                                "INSERT INTO tandas (tanda_id, group_id, name, status, turns_order, lottery_executed_at, created_at, updated_at) VALUES ($1, $2, $3, 'recruiting', $4, NOW(), NOW(), NOW())",
                                [tandaId, groupId, "Tanda - " + groupName, turnsOrder]
                            );
                        }

                        // Update group_members turn positions (only first position per user)
                        const updatedUsers = new Set();
                        for (let i = 0; i < turnsOrder.length; i++) {
                            const userId = turnsOrder[i].user_id || turnsOrder[i];
                            if (!updatedUsers.has(userId)) {
                                await dbPostgres.pool.query(
                                    "UPDATE group_members SET turn_position = $1 WHERE group_id = $2 AND user_id = $3",
                                    [i + 1, groupId, userId]
                                );
                                updatedUsers.add(userId);
                            }
                        }

                        // Create notifications for all members
                        for (let i = 0; i < members.length; i++) {
                            const member = members[i];
                            const position = i + 1;
                            try {
                                await createNotification(
                                    member.user_id,
                                    "lottery_executed",
                                    "Tombola Ejecutada",
                                    `La tombola de "${groupName}" se ha ejecutado. Tu turno asignado es #${position} de ${members.length}.`,
                                    { group_id: groupId, position: position, total_positions: members.length }
                                );
                            } catch (notifErr) {
                                log("warn", "Could not notify member: " + notifErr.message);
                            }
                        }

                        log("info", "Live lottery completed and saved", { groupId, positions: turnsOrder.length });

                    } catch (asyncError) {
                        log("error", "Error in async lottery execution: " + asyncError.message);
                        // Broadcast error to connected clients
                        wsLottery.broadcastToGroup(groupId, {
                            type: "lottery_error",
                            message: "Error al ejecutar tombola: " + asyncError.message,
                            timestamp: Date.now()
                        });
                    }
                })();

                return;

            } catch (error) {
                log("error", "Error starting live lottery: " + error.message);
                sendError(res, 500, "Error al iniciar tombola en vivo");
                return;
            }
        }


        // =============================================
        // LOTTERY/TOMBOLA SCHEDULING SYSTEM
        // =============================================

        // POST /api/groups/:id/lottery-schedule - Schedule tombola for a specific time
        const lotteryScheduleMatch = pathname.match(/^\/api\/groups\/([^\/]+)\/lottery-schedule$/);
        if (lotteryScheduleMatch && method === "POST") {
            const groupId = lotteryScheduleMatch[1];
            
            // Require authentication
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                const { scheduled_at, countdown_seconds = 10 } = body;

                // ============================================
                // SECURITY: Verify user has permission to schedule lottery (Added 2025-12-31)
                // ============================================
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status = 'active'
                `, [groupId, authUser.userId]);

                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para programar la tómbola');
                    return;
                }

                // ============================================
                // VALIDATION: Check if lottery was already executed (Added 2025-12-31)
                // ============================================
                const executedCheck = await dbPostgres.pool.query(`
                    SELECT lottery_executed_at FROM tandas
                    WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
                `, [groupId]);

                if (executedCheck.rows.length > 0 && executedCheck.rows[0].lottery_executed_at) {
                    sendError(res, 400, 'La tómbola ya fue ejecutada para esta tanda');
                    return;
                }


                if (!scheduled_at) {
                    sendError(res, 400, "Se requiere fecha/hora programada (scheduled_at)");
                    return;
                }

                const scheduledDate = new Date(scheduled_at);
                if (scheduledDate <= new Date()) {
                    sendError(res, 400, "La fecha programada debe ser en el futuro");
                    return;
                }

                // Get tanda for this group
                const tandaResult = await dbPostgres.pool.query(
                    "SELECT tanda_id, name FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1",
                    [groupId]
                );

                if (tandaResult.rows.length === 0) {
                    sendError(res, 404, "No se encontro tanda para este grupo");
                    return;
                }

                const tanda = tandaResult.rows[0];

                // Update tanda with scheduled lottery
                await dbPostgres.pool.query(
                    "UPDATE tandas SET lottery_scheduled_at = $1, lottery_countdown_seconds = $2, updated_at = NOW() WHERE tanda_id = $3",
                    [scheduledDate, countdown_seconds, tanda.tanda_id]
                );

                // Get all group members to notify
                const membersResult = await dbPostgres.pool.query(
                    "SELECT gm.user_id, u.name FROM group_members gm JOIN users u ON gm.user_id = u.user_id WHERE gm.group_id = $1 AND gm.status = 'active'",
                    [groupId]
                );

                // Get group name
                const groupResult = await dbPostgres.pool.query(
                    "SELECT name FROM groups WHERE group_id = $1",
                    [groupId]
                );
                const groupName = groupResult.rows[0]?.name || "Grupo";

                // Notify all members about scheduled lottery
                const formattedDate = scheduledDate.toLocaleString('es-HN', { 
                    dateStyle: 'medium', 
                    timeStyle: 'short',
                    timeZone: 'America/Tegucigalpa'
                });

                for (const member of membersResult.rows) {
                    await createNotification(
                        member.user_id,
                        'lottery_scheduled',
                        'Tombola Programada',
                        `La tombola de "${groupName}" se ejecutara el ${formattedDate}. ¡No te la pierdas!`,
                        { group_id: groupId, tanda_id: tanda.tanda_id, scheduled_at: scheduled_at }
                    );
                }

                log("info", "Lottery scheduled", { groupId, tandaId: tanda.tanda_id, scheduledAt: scheduled_at, notified: membersResult.rows.length });

                sendResponse(res, 200, {
                    success: true,
                    message: "Tombola programada exitosamente",
                    data: {
                        scheduled_at: scheduledDate,
                        countdown_seconds: countdown_seconds,
                        members_notified: membersResult.rows.length
                    }
                });
                return;
            } catch (error) {
                log("error", "Error scheduling lottery: " + error.message);
                sendError(res, 500, "Error al programar tombola");
                return;
            }
        }

        // POST /api/groups/:id/lottery-cancel - Cancel scheduled tombola
        const lotteryCancelMatch = pathname.match(/^\/api\/groups\/([^\/]+)\/lottery-cancel$/);
        if (lotteryCancelMatch && method === "POST") {
            const groupId = lotteryCancelMatch[1];

            // Require authentication
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                // Verify user has permission
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status = 'active'
                `, [groupId, authUser.userId]);

                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para cancelar la tómbola');
                    return;
                }

                // Check if there's a scheduled lottery to cancel
                const tandaResult = await dbPostgres.pool.query(`
                    SELECT tanda_id, lottery_scheduled_at, lottery_executed_at
                    FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
                `, [groupId]);

                if (tandaResult.rows.length === 0) {
                    sendError(res, 404, "No se encontró tanda para este grupo");
                    return;
                }

                const tanda = tandaResult.rows[0];

                if (tanda.lottery_executed_at) {
                    sendError(res, 400, "La tómbola ya fue ejecutada, no se puede cancelar");
                    return;
                }

                if (!tanda.lottery_scheduled_at) {
                    sendError(res, 400, "No hay tómbola programada para cancelar");
                    return;
                }

                // Clear the scheduled lottery
                await dbPostgres.pool.query(`
                    UPDATE tandas
                    SET lottery_scheduled_at = NULL, lottery_countdown_seconds = NULL, updated_at = NOW()
                    WHERE tanda_id = $1
                `, [tanda.tanda_id]);

                // Get group name for notifications
                const groupResult = await dbPostgres.pool.query(
                    "SELECT name FROM groups WHERE group_id = $1",
                    [groupId]
                );
                const groupName = groupResult.rows[0]?.name || "Grupo";

                // Notify all members about cancellation
                const membersResult = await dbPostgres.pool.query(
                    "SELECT user_id FROM group_members WHERE group_id = $1 AND status = 'active'",
                    [groupId]
                );

                for (const member of membersResult.rows) {
                    await createNotification(
                        member.user_id,
                        'lottery_cancelled',
                        'Tómbola Cancelada',
                        `La tómbola programada de "${groupName}" ha sido cancelada.`,
                        { group_id: groupId, tanda_id: tanda.tanda_id }
                    );
                }

                log("info", "Lottery cancelled", { groupId, tandaId: tanda.tanda_id, cancelledBy: authUser.userId });

                sendResponse(res, 200, {
                    success: true,
                    message: "Tómbola cancelada exitosamente",
                    data: {
                        group_id: groupId,
                        members_notified: membersResult.rows.length
                    }
                });
                return;
            } catch (error) {
                log("error", "Error cancelling lottery: " + error.message);
                sendError(res, 500, "Error al cancelar tómbola");
                return;
            }
        }

        // POST /api/groups/:id/lottery-reset - Reset tombola to allow re-execution
        const lotteryResetMatch = pathname.match(/^\/api\/groups\/([^\/]+)\/lottery-reset$/);
        if (lotteryResetMatch && method === "POST") {
            const groupId = lotteryResetMatch[1];

            // Require authentication
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                // Only creator can reset tombola (more restrictive)
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status = 'active'
                `, [groupId, authUser.userId]);

                if (permCheck.rows.length === 0 || permCheck.rows[0].role !== 'creator') {
                    sendError(res, 403, 'Solo el creador del grupo puede resetear la tómbola');
                    return;
                }

                // Get tanda
                const tandaResult = await dbPostgres.pool.query(`
                    SELECT tanda_id, lottery_executed_at
                    FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
                `, [groupId]);

                if (tandaResult.rows.length === 0) {
                    sendError(res, 404, "No se encontró tanda para este grupo");
                    return;
                }

                const tanda = tandaResult.rows[0];

                if (!tanda.lottery_executed_at) {
                    sendError(res, 400, "La tómbola aún no ha sido ejecutada");
                    return;
                }

                // Reset tombola - clear execution data
                await dbPostgres.pool.query(`
                    UPDATE tandas
                    SET lottery_executed_at = NULL,
                        lottery_scheduled_at = NULL,
                        lottery_countdown_seconds = NULL,
                        turns_order = NULL,
                        updated_at = NOW()
                    WHERE tanda_id = $1
                `, [tanda.tanda_id]);

                // Reset member turn positions
                await dbPostgres.pool.query(`
                    UPDATE group_members
                    SET turn_position = NULL
                    WHERE group_id = $1
                `, [groupId]);

                // Get group name for notifications
                const groupResult = await dbPostgres.pool.query(
                    "SELECT name FROM groups WHERE group_id = $1",
                    [groupId]
                );
                const groupName = groupResult.rows[0]?.name || "Grupo";

                // Notify all members
                const membersResult = await dbPostgres.pool.query(
                    "SELECT user_id FROM group_members WHERE group_id = $1 AND status = 'active'",
                    [groupId]
                );

                for (const member of membersResult.rows) {
                    await createNotification(
                        member.user_id,
                        'lottery_reset',
                        'Tómbola Reseteada',
                        `La tómbola de "${groupName}" ha sido reseteada. Se ejecutará una nueva tómbola próximamente.`,
                        { group_id: groupId, tanda_id: tanda.tanda_id }
                    );
                }

                log("info", "Lottery reset", { groupId, tandaId: tanda.tanda_id, resetBy: authUser.userId });

                sendResponse(res, 200, {
                    success: true,
                    message: "Tómbola reseteada exitosamente. Ahora puede ejecutar una nueva.",
                    data: {
                        group_id: groupId,
                        members_notified: membersResult.rows.length
                    }
                });
                return;
            } catch (error) {
                log("error", "Error resetting lottery: " + error.message);
                sendError(res, 500, "Error al resetear tómbola");
                return;
            }
        }

        // GET /api/groups/:id/lottery-status - Get lottery status for a group
        const lotteryStatusMatch = pathname.match(/^\/api\/groups\/([^\/]+)\/lottery-status$/);
        if (lotteryStatusMatch && method === "GET") {
            const groupId = lotteryStatusMatch[1];

            try {
                const tandaResult = await dbPostgres.pool.query(
                    `SELECT t.tanda_id, t.name, t.lottery_scheduled_at, t.lottery_executed_at, 
                            t.lottery_countdown_seconds, t.turns_order, t.status
                     FROM tandas t 
                     WHERE t.group_id = $1 
                     ORDER BY t.created_at DESC LIMIT 1`,
                    [groupId]
                );

                if (tandaResult.rows.length === 0) {
                    sendResponse(res, 200, {
                        success: true,
                        data: { status: 'no_tanda', message: 'No hay tanda asociada a este grupo' }
                    });
                    return;
                }

                const tanda = tandaResult.rows[0];
                const now = new Date();
                const scheduledAt = tanda.lottery_scheduled_at ? new Date(tanda.lottery_scheduled_at) : null;
                const executedAt = tanda.lottery_executed_at ? new Date(tanda.lottery_executed_at) : null;

                let status = 'not_scheduled';
                let timeRemaining = null;

                if (executedAt) {
                    status = 'executed';
                } else if (scheduledAt) {
                    if (scheduledAt > now) {
                        status = 'scheduled';
                        timeRemaining = Math.floor((scheduledAt - now) / 1000); // seconds
                    } else {
                        status = 'ready_to_execute';
                    }
                }

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        status: status,
                        tanda_id: tanda.tanda_id,
                        tanda_name: tanda.name,
                        scheduled_at: tanda.lottery_scheduled_at,
                        executed_at: tanda.lottery_executed_at,
                        countdown_seconds: tanda.lottery_countdown_seconds || 10,
                        time_remaining_seconds: timeRemaining,
                        lottery_executed: !!executedAt || (tanda.turns_order && tanda.turns_order.length > 0)
                    }
                });
                return;
            } catch (error) {
                log("error", "Error getting lottery status: " + error.message);
                sendError(res, 500, "Error al obtener estado de tombola");
                return;
            }
        }

        // GET /api/groups/:id/lottery-results - Get lottery results after execution
        const lotteryResultsMatch = pathname.match(/^\/api\/groups\/([^\/]+)\/lottery-results$/);
        if (lotteryResultsMatch && method === "GET") {
            const groupId = lotteryResultsMatch[1];

            try {
                // Get tanda with turns_order
                const tandaResult = await dbPostgres.pool.query(
                    `SELECT t.tanda_id, t.name, t.turns_order, t.lottery_executed_at
                     FROM tandas t 
                     WHERE t.group_id = $1 
                     ORDER BY t.created_at DESC LIMIT 1`,
                    [groupId]
                );

                if (tandaResult.rows.length === 0 || !tandaResult.rows[0].turns_order || tandaResult.rows[0].turns_order.length === 0) {
                    sendResponse(res, 200, {
                        success: true,
                        data: { 
                            executed: false, 
                            message: 'La tombola aun no ha sido ejecutada' 
                        }
                    });
                    return;
                }

                const tanda = tandaResult.rows[0];
                const turnsOrder = tanda.turns_order;

                // Get member details for each position
                const membersResult = await dbPostgres.pool.query(
                    `SELECT u.user_id, u.name, u.email
                     FROM users u 
                     WHERE u.user_id = ANY($1)`,
                    [turnsOrder]
                );

                const membersMap = {};
                membersResult.rows.forEach(m => { membersMap[m.user_id] = m; });

                const results = turnsOrder.map((userId, idx) => ({
                    position: idx + 1,
                    user_id: userId,
                    name: membersMap[userId]?.name || 'Usuario',
                    member_id: userId // for frontend compatibility
                }));

                sendResponse(res, 200, {
                    success: true,
                    data: {
                        executed: true,
                        executed_at: tanda.lottery_executed_at,
                        tanda_id: tanda.tanda_id,
                        tanda_name: tanda.name,
                        results: results,
                        total_positions: results.length
                    }
                });
                return;
            } catch (error) {
                log("error", "Error getting lottery results: " + error.message);
                sendError(res, 500, "Error al obtener resultados de tombola");
                return;
            }
        }

        const lotteryAssignMatch = pathname.match(/^\/api\/groups\/([^\/]+)\/lottery-assign$/);
        if (lotteryAssignMatch && method === "POST") {
            const groupId = lotteryAssignMatch[1];

            // ============================================
            // SECURITY: Require JWT authentication (Added 2025-12-31)
            // ============================================
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                // ============================================
                // SECURITY: Verify user has permission to execute lottery (Added 2025-12-31)
                // v4.10.3: Allow suspended creators/coordinators to manage
                // ============================================
                const permCheck = await dbPostgres.pool.query(`
                    SELECT gm.role FROM group_members gm
                    WHERE gm.group_id = $1 AND gm.user_id = $2 AND gm.status IN ('active', 'suspended')
                `, [groupId, authUser.userId]);

                if (permCheck.rows.length === 0 || !['creator', 'coordinator', 'admin'].includes(permCheck.rows[0].role)) {
                    sendError(res, 403, 'No tienes permisos para ejecutar la tómbola');
                    return;
                }

                // ============================================
                // VALIDATION: Check if lottery was already executed (Added 2025-12-31)
                // ============================================
                const executedCheck = await dbPostgres.pool.query(`
                    SELECT lottery_executed_at FROM tandas
                    WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1
                `, [groupId]);

                if (executedCheck.rows.length > 0 && executedCheck.rows[0].lottery_executed_at) {
                    sendError(res, 400, 'La tómbola ya fue ejecutada para esta tanda');
                    return;
                }

                // Verify group exists
                const groupResult = await dbPostgres.pool.query(
                    "SELECT g.group_id, g.name FROM groups g WHERE g.group_id = $1",
                    [groupId]
                );

                if (groupResult.rows.length === 0) {
                    sendError(res, 404, "Grupo no encontrado");
                    return;
                }

                // Get all active members WITH lock status and num_positions
                const membersResult = await dbPostgres.pool.query(
                    "SELECT gm.user_id, u.name, gm.turn_locked, gm.turn_position, COALESCE(gm.num_positions, 1) as num_positions FROM group_members gm JOIN users u ON gm.user_id = u.user_id WHERE gm.group_id = $1 AND gm.status = 'active'",
                    [groupId]
                );

                if (membersResult.rows.length < 2) {
                    sendError(res, 400, "Se necesitan al menos 2 miembros para ejecutar la tombola");
                    return;
                }

                // Calculate total positions (sum of all num_positions)
                const totalPositions = membersResult.rows.reduce((sum, m) => sum + parseInt(m.num_positions || 1), 0);
                
                // Expand members into individual position entries
                const allEntries = [];
                const lockedEntries = [];
                
                for (const member of membersResult.rows) {
                    const numPos = parseInt(member.num_positions) || 1;
                    
                    for (let i = 0; i < numPos; i++) {
                        const entry = {
                            user_id: member.user_id,
                            name: member.name,
                            position_number: i + 1,
                            total_positions: numPos
                        };
                        
                        if (i === 0 && member.turn_locked && member.turn_position) {
                            lockedEntries.push({
                                index: member.turn_position - 1,
                                entry: entry
                            });
                        } else {
                            allEntries.push(entry);
                        }
                    }
                }
                
                log("info", "Lottery-assign executing", { 
                    groupId, 
                    uniqueMembers: membersResult.rows.length,
                    totalPositions, 
                    locked: lockedEntries.length, 
                    toShuffle: allEntries.length 
                });

                // Shuffle non-locked entries (Fisher-Yates)
                for (let i = allEntries.length - 1; i > 0; i--) {
                    const j = crypto.randomInt(0, i + 1);
                    [allEntries[i], allEntries[j]] = [allEntries[j], allEntries[i]];
                }

                // Build final array respecting locked positions
                const members = new Array(totalPositions).fill(null);
                
                for (const locked of lockedEntries) {
                    if (locked.index >= 0 && locked.index < totalPositions && !members[locked.index]) {
                        members[locked.index] = locked.entry;
                    }
                }
                
                let shuffleIndex = 0;
                for (let i = 0; i < totalPositions; i++) {
                    if (!members[i] && shuffleIndex < allEntries.length) {
                        members[i] = allEntries[shuffleIndex++];
                    }
                }

                // Create turns_order array from final member order
                const turnsOrder = members.map(m => m.user_id);

                // Check if tanda exists for this group
                const tandaResult = await dbPostgres.pool.query(
                    "SELECT tanda_id FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1",
                    [groupId]
                );

                if (tandaResult.rows.length > 0) {
                    // Update existing tanda
                    await dbPostgres.pool.query(
                        "UPDATE tandas SET turns_order = $1, updated_at = NOW() WHERE tanda_id = $2",
                        [turnsOrder, tandaResult.rows[0].tanda_id]
                    );
                } else {
                    // Create new tanda with turns_order
                    const tandaId = "tanda_" + crypto.randomBytes(12).toString("hex");
                    const group = groupResult.rows[0];

                    await dbPostgres.pool.query(
                        "INSERT INTO tandas (tanda_id, group_id, name, status, turns_order, created_at, updated_at) VALUES ($1, $2, $3, 'recruiting', $4, NOW(), NOW())",
                        [tandaId, groupId, group.name, turnsOrder]
                    );
                }

                // Also update group_members.turn_position for backwards compatibility
                for (let i = 0; i < turnsOrder.length; i++) {
                    await dbPostgres.pool.query(
                        "UPDATE group_members SET turn_position = $1 WHERE group_id = $2 AND user_id = $3",
                        [i + 1, groupId, turnsOrder[i]]
                    );
                }

                log("info", "Tombola executed for group " + groupId);

                // Update lottery_executed_at timestamp
                try {
                    const tandaForUpdate = await dbPostgres.pool.query(
                        "SELECT tanda_id FROM tandas WHERE group_id = $1 ORDER BY created_at DESC LIMIT 1",
                        [groupId]
                    );
                    if (tandaForUpdate.rows.length > 0) {
                        await dbPostgres.pool.query(
                            "UPDATE tandas SET lottery_executed_at = NOW(), updated_at = NOW() WHERE tanda_id = $1",
                            [tandaForUpdate.rows[0].tanda_id]
                        );
                    }
                } catch (updateErr) {
                    log("warn", "Could not update lottery_executed_at: " + updateErr.message);
                }

                // Notify all members about their turn assignment
                const groupNameResult = await dbPostgres.pool.query(
                    "SELECT name FROM groups WHERE group_id = $1",
                    [groupId]
                );
                const groupName = groupNameResult.rows[0]?.name || "Grupo";

                for (let i = 0; i < members.length; i++) {
                    const member = members[i];
                    const position = i + 1;
                    try {
                        await createNotification(
                            member.user_id,
                            "lottery_executed",
                            "Tombola Ejecutada",
                            `La tombola de "${groupName}" se ha ejecutado. Tu turno asignado es #${position} de ${members.length}.`,
                            { group_id: groupId, position: position, total_positions: members.length }
                        );
                    } catch (notifErr) {
                        log("warn", "Could not notify member: " + notifErr.message);
                    }
                }
                log("info", "Notified " + members.length + " members about lottery results");

                sendResponse(res, 200, {
                    success: true,
                    message: "Tombola ejecutada exitosamente",
                    data: {
                        turns_order: members.map((m, idx) => ({
                            position: idx + 1,
                            user_id: m.user_id,
                            name: m.name
                        }))
                    }
                });
                return;
            } catch (error) {
                log("error", "Error executing lottery: " + error.message);
                sendError(res, 500, "Error al ejecutar tombola");
                return;
            }
        }



        // POST /api/tandas/pay - Registrar pago de tanda (PostgreSQL)
        if (pathname === "/api/tandas/pay" && method === "POST") {
            // SECURITY: Require JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                const { tanda_id, amount, payment_method = "wallet" } = body;

                if (!tanda_id || !amount) {
                    sendError(res, 400, "Faltan datos requeridos (tanda_id, amount)");
                    return;
                }

                // v4.1.0: Validate payment_method whitelist
                const validPaymentMethods = ['wallet', 'bank_transfer', 'tigo_money', 'crypto'];
                if (!validPaymentMethods.includes(payment_method)) {
                    sendError(res, 400, 'Método de pago inválido');
                    return;
                }

                const userId = authUser.userId;

                // Buscar la tanda en PostgreSQL
                const tandaResult = await dbPostgres.pool.query(
                    "SELECT tanda_id, name, contribution_amount, total_per_turn, frequency, coordinator_id, group_id, status, current_turn, total_turns, turns_order, created_at, updated_at, completed_at, is_demo, scheduled_start_at, lottery_scheduled_at, lottery_executed_at, lottery_countdown_seconds, previous_status FROM tandas WHERE tanda_id = $1",
                    [tanda_id]
                );

                if (tandaResult.rows.length === 0) {
                    sendError(res, 404, "Tanda no encontrada");
                    return;
                }

                const tanda = tandaResult.rows[0];

                // Verificar que la tanda esté activa
                if (tanda.status === "recruiting" || tanda.status === "pending") {
                    sendError(res, 400, "La tanda aún no ha iniciado. Está en estado: " + tanda.status);
                    return;
                }

                // Verificar monto
                const expectedAmount = parseFloat(tanda.contribution_amount);
                if (Math.abs(parseFloat(amount) - expectedAmount) > 0.01) {
                    sendError(res, 400, "El monto debe ser L." + expectedAmount.toFixed(2));
                    return;
                }

                // Si es pago con wallet, verificar saldo y descontar atomicamente
                if (payment_method === "wallet") {
                    const client = await dbPostgres.pool.connect();
                    try {
                        await client.query('BEGIN');
                        // Lock the wallet row to prevent concurrent double-spend
                        const walletResult = await client.query(
                            "SELECT balance FROM user_wallets WHERE user_id = $1 FOR UPDATE",
                            [userId]
                        );
                
                        const walletBalance = walletResult.rows.length > 0
                            ? parseFloat(walletResult.rows[0].balance)
                            : 0;
                
                        if (walletBalance < expectedAmount) {
                            await client.query('ROLLBACK');
                            sendError(res, 400, "Saldo insuficiente", {
                                balance: walletBalance,
                                required: expectedAmount
                            });
                            return;
                        }
                
                        // Descontar del saldo (atomic within transaction)
                        await client.query(
                            "UPDATE user_wallets SET balance = balance - $1, updated_at = NOW() WHERE user_id = $2",
                            [expectedAmount, userId]
                        );
                
                        // Crear el pago dentro de la misma transaccion
                        const paymentResult = await client.query(
                            "INSERT INTO contributions (user_id, group_id, amount, payment_method, status, cycle_number, paid_date) VALUES ($1, $2, $3, $4, 'completed', $5, NOW()) RETURNING id, amount, payment_method, status, paid_date",
                            [userId, tanda.group_id || tanda_id, expectedAmount, payment_method, tanda.current_turn || 1]
                        );
                
                        await client.query('COMMIT');
                        var payment = paymentResult.rows[0];
                    } catch (txError) {
                        await client.query('ROLLBACK');
                        throw txError;
                    } finally {
                        client.release();
                    }
                } else {
                    // v4.1.0: Non-wallet payment — duplicate check to prevent unlimited contributions
                    const existingPayment = await dbPostgres.pool.query(
                        "SELECT id FROM contributions WHERE user_id = $1 AND group_id = $2 AND cycle_number = $3 AND status = 'completed'",
                        [userId, tanda.group_id || tanda_id, tanda.current_turn || 1]
                    );
                    if (existingPayment.rows.length > 0) {
                        sendError(res, 400, 'Ya registraste tu pago para este turno');
                        return;
                    }
                    const paymentResult = await dbPostgres.pool.query(
                        "INSERT INTO contributions (user_id, group_id, amount, payment_method, status, cycle_number, paid_date) VALUES ($1, $2, $3, $4, 'completed', $5, NOW()) RETURNING id, amount, payment_method, status, paid_date",
                        [userId, tanda.group_id || tanda_id, expectedAmount, payment_method, tanda.current_turn || 1]
                    );
                    var payment = paymentResult.rows[0];
                }
                
                // Obtener nuevo saldo si pagó con wallet
                let newBalance = null;
                if (payment_method === "wallet") {
                    const newBalanceResult = await dbPostgres.pool.query(
                        "SELECT balance FROM user_wallets WHERE user_id = $1",
                        [userId]
                    );
                    newBalance = newBalanceResult.rows.length > 0 
                        ? parseFloat(newBalanceResult.rows[0].balance) 
                        : 0;
                }

                sendSuccess(res, { 
                    message: "¡Pago registrado exitosamente!",
                    payment: {
                        id: payment.id,
                        amount: parseFloat(payment.amount),
                        payment_method: payment.payment_method,
                        status: payment.status,
                        paid_date: payment.paid_date
                    },
                    new_balance: newBalance
                });
                return;

            } catch (error) {
                log("error", "Error processing payment:", error);
                log("error", "Error al procesar pago", { error: error.message }); sendError(res, 500, "Error interno del servidor");
                return;
            }
        }
        // GET /api/payments/history - Historial personal de pagos y cobros (PostgreSQL)
        if (pathname === "/api/payments/history" && method === "GET") {
            // ============================================
            // SECURITY FIX: Require JWT auth (2025-12-31)
            // ============================================
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                const urlParams = new URL(req.url, "http://localhost").searchParams;
                const userId = authUser.userId; // SECURITY: Always use authenticated user
                const type = urlParams.get("type") || "all";

                let payments = [];

                // Obtener pagos enviados desde contributions
                if (type === "sent" || type === "all") {
                    const sentResult = await dbPostgres.pool.query(
                        "SELECT c.id, c.amount, c.payment_method, c.status, c.paid_date as date, c.created_at, t.name as tanda_name, t.tanda_id FROM contributions c LEFT JOIN tandas t ON c.group_id = t.group_id OR c.group_id = t.tanda_id WHERE c.user_id = $1 ORDER BY COALESCE(c.paid_date, c.created_at) DESC LIMIT 50",
                        [userId]
                    );
                    
                    sentResult.rows.forEach(row => {
                        payments.push({
                            id: row.id,
                            amount: parseFloat(row.amount || 0),
                            payment_method: row.payment_method || "wallet",
                            status: row.status || "completed",
                            date: row.date || row.created_at,
                            tanda_name: row.tanda_name || "Tanda",
                            tanda_id: row.tanda_id,
                            direction: "sent",
                            user_id: userId
                        });
                    });
                }

                // Obtener cobros recibidos desde cycle_distributions (distribuciones donde el usuario es beneficiario)
                if (type === "received" || type === "all") {
                    const receivedResult = await dbPostgres.pool.query(
                        "SELECT cd.id, cd.net_amount, cd.cycle_number, cd.status, cd.distributed_at as date, cd.group_id, g.name as group_name FROM cycle_distributions cd LEFT JOIN groups g ON cd.group_id = g.group_id WHERE cd.beneficiary_user_id = $1 AND cd.status = 'completed' ORDER BY cd.distributed_at DESC LIMIT 50",
                        [userId]
                    );

                    receivedResult.rows.forEach(row => {
                        payments.push({
                            id: row.id,
                            amount: parseFloat(row.net_amount || 0),
                            payment_method: "distribucion",
                            status: row.status || "completed",
                            date: row.date,
                            tanda_name: row.group_name || "Tanda",
                            group_name: row.group_name,
                            cycle_number: row.cycle_number,
                            direction: "received"
                        });
                    });
                }

                payments.sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0));

                const totalSent = payments.filter(p => p.direction === "sent").reduce((sum, p) => sum + p.amount, 0);
                const totalReceived = payments.filter(p => p.direction === "received").reduce((sum, p) => sum + p.amount, 0);

                sendSuccess(res, {
                    payments: payments,
                    count: payments.length,
                    totals: { sent: totalSent, received: totalReceived, net: totalReceived - totalSent }
                });
                return;

            } catch (error) {
                log("error", "Error loading history:", error);
                log("error", "Error al cargar historial", { error: error.message }); sendError(res, 500, "Error interno del servidor");
                return;
            }
        }
        
        // ========== ADMIN: All pending contributions ==========
        if (pathname === '/api/admin/contributions/pending' && (method === 'GET' || method === 'HEAD')) {
            // Verify admin authentication
            const authHeader = req.headers.authorization;
            if (!authHeader || !authHeader.startsWith('Bearer ')) {
                sendError(res, 401, 'Token de autenticación requerido');
                return;
            }
            
            const token = authHeader.split(' ')[1];
            const session = database.admin_sessions?.[token];
            
            if (!session) {
                sendError(res, 401, 'Sesión inválida');
                return;
            }
            
            if (new Date() > new Date(session.expires_at)) {
                delete database.admin_sessions[token];
                saveDatabase();
                sendError(res, 401, 'Sesión expirada');
                return;
            }

            try {
                const result = await dbPostgres.pool.query(`
                    SELECT
                        c.id,
                        c.user_id,
                        c.group_id,
                        c.amount,
                        c.payment_method,
                        c.status,
                        c.reference_code,
                        c.proof_url,
                        c.created_at,
                        c.verified_at,
                        c.verified_by,
                        u.name as user_name,
                        u.email as user_email,
                        g.name as group_name
                    FROM contributions c
                    LEFT JOIN users u ON c.user_id = u.user_id
                    LEFT JOIN groups g ON c.group_id = g.group_id
                    WHERE c.status IN ('pending_verification', 'awaiting_payment')
                    ORDER BY c.created_at DESC
                    LIMIT 100
                `);

                // Map to frontend expected format
                const pendingDeposits = result.rows.map(c => ({
                    id: c.id,
                    user_id: c.user_name || c.user_id,
                    user_account_number: c.user_email,
                    amount: parseFloat(c.amount),
                    net_amount: parseFloat(c.amount),
                    bank_name: c.payment_method === "bank_transfer" ? "Transferencia Bancaria" :
                               c.payment_method === "mobile_money" ? "Dinero Móvil" :
                               c.payment_method === "crypto" ? "Crypto" :
                               c.payment_method === "cash" ? "Efectivo" : c.payment_method,
                    reference_number: c.reference_code || "N/A",
                    status: c.status,
                    status_description: c.status === "pending_verification" ? "Pendiente Verificación" :
                                       c.status === "awaiting_payment" ? "Esperando Pago" : c.status,
                    created_at: c.created_at,
                    time_remaining: 24,
                    receipt: c.proof_url ? { filename: c.proof_url } : null,
                    group_name: c.group_name,
                    currency: c.payment_method === "crypto" ? "USDT" : "HNL"
                }));

                // Calculate multi-currency totals
                const currencyTotals = pendingDeposits.reduce((totals, d) => {
                    totals[d.currency] = (totals[d.currency] || 0) + d.amount;
                    return totals;
                }, {});

                const totalAmountDisplay = Object.entries(currencyTotals)
                    .map(([currency, amount]) => {
                        if (currency === "HNL") return "L " + amount.toLocaleString("es-HN", {minimumFractionDigits: 2});
                        return "$" + amount.toLocaleString("en-US", {minimumFractionDigits: 2}) + " " + currency;
                    })
                    .join(" + ") || "L 0.00";

                sendSuccess(res, {
                    pending_deposits: pendingDeposits,
                    total_pending: pendingDeposits.length,
                    total_amount: pendingDeposits.reduce((sum, d) => sum + d.amount, 0),
                    total_amount_display: totalAmountDisplay,
                    banks_summary: {}
                });
            } catch (error) {
                log("error", 'Error fetching admin pending contributions:', error);
                sendError(res, 500, 'Error al obtener contribuciones pendientes');
            }
            return;
        }

        // Admin: Dashboard stats (SECURED - requires admin auth)
        if (pathname === '/api/admin/dashboard/stats' && (method === 'GET' || method === 'HEAD')) {
            // Check admin authentication
            const authUser = requireAuth(req, res);
            if (!authUser) return; // requireAuth already sent error response
            if (authUser.role !== 'admin') { sendError(res, 403, 'Solo administradores'); return; }
            
            
            try {
                const stats = await dbPostgres.pool.query(`
                    SELECT
                        (SELECT COUNT(*) FROM users) as total_users,
                        (SELECT COUNT(*) FROM groups WHERE status = 'active') as active_groups,
                        (SELECT COUNT(*) FROM contributions WHERE status = 'pending_verification') as pending_verifications,
                        (SELECT COALESCE(SUM(amount), 0) FROM contributions WHERE status = 'completed') as total_processed,
                        (SELECT COUNT(*) FROM cycle_distributions) as total_distributions
                `);

                sendSuccess(res, {
                    overview: stats.rows[0]
                });
            } catch (error) {
                log("error", 'Error fetching admin dashboard stats:', error);
                sendError(res, 500, 'Error al obtener estadisticas');
            }
            return;
        }
        // ========== ADMIN: All pending withdrawals ==========
        if (pathname === "/api/admin/withdrawals/pending" && (method === "GET" || method === "HEAD")) {

            // SECURITY: Require admin JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            // Verify admin authentication
            const authHeader = req.headers.authorization;
            if (!authHeader || !authHeader.startsWith("Bearer ")) {
                sendError(res, 401, "Token de autenticación requerido");
                return;
            }
            
            const token = authHeader.split(" ")[1];
            const session = database.admin_sessions?.[token];
            
            if (!session) {
                sendError(res, 401, "Sesión inválida");
                return;
            }
            
            if (new Date() > new Date(session.expires_at)) {
                delete database.admin_sessions[token];
                saveDatabase();
                sendError(res, 401, "Sesión expirada");
                return;
            }
            
            try {
                const result = await dbPostgres.pool.query(`
                    SELECT
                        w.id,
                        w.user_id,
                        w.amount,
                        w.method,
                        w.status,
                        w.bank_name,
                        w.account_number,
                        w.account_holder_name,
                        w.provider,
                        w.phone_number,
                        w.network,
                        w.wallet_address,
                        w.notes,
                        w.created_at,
                        w.updated_at,
                        u.name as user_name,
                        u.email as user_email,
                        u.phone as user_phone
                    FROM withdrawals w
                    LEFT JOIN users u ON w.user_id = u.user_id
                    WHERE w.status = 'pending'
                    ORDER BY w.created_at ASC
                    LIMIT 100
                `);
                
                const withdrawals = result.rows.map(w => ({
                    id: w.id,
                    user_id: w.user_id,
                    user_name: w.user_name || "Usuario",
                    user_email: w.user_email,
                    user_phone: w.user_phone,
                    amount: parseFloat(w.amount),
                    method: w.method,
                    status: w.status,
                    bank_name: w.bank_name,
                    account_number: w.account_number,
                    account_holder: w.account_holder_name,
                    provider: w.provider,
                    phone_number: w.phone_number,
                    network: w.network,
                    wallet_address: w.wallet_address,
                    notes: w.notes,
                    created_at: w.created_at,
                    updated_at: w.updated_at
                }));
                
                sendSuccess(res, {
                    withdrawals: withdrawals,
                    summary: {
                        total: withdrawals.length,
                        total_amount: withdrawals.reduce((sum, w) => sum + w.amount, 0),
                        by_method: withdrawals.reduce((acc, w) => {
                            acc[w.method] = (acc[w.method] || 0) + 1;
                            return acc;
                        }, {})
                    }
                });
            } catch (error) {
                log("error", "Error fetching admin pending withdrawals:", error);
                sendError(res, 500, "Error al obtener retiros pendientes");
            }
            return;
        }

        // ========== END ADMIN ENDPOINTS ==========
// Admin: View Audit Logs (SECURED - requires admin auth)
        if (pathname === "/api/admin/audit-logs" && (method === "GET" || method === "HEAD")) {

            // SECURITY: Require admin JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            // Verify admin session authentication
            const authHeader = req.headers.authorization;
            if (!authHeader || !authHeader.startsWith("Bearer ")) {
                sendError(res, 401, "Token de autenticacion requerido");
                return;
            }
            
            const token = authHeader.split(" ")[1];
            const session = database.admin_sessions?.[token];
            
            if (!session) {
                sendError(res, 401, "Sesion invalida o expirada");
                return;
            }
            
            if (new Date() > new Date(session.expires_at)) {
                delete database.admin_sessions[token];
                sendError(res, 401, "Sesion expirada");
                return;
            }

            
            try {
                const urlParams = new URL(req.url, "http://localhost").searchParams;
                const page = parseInt(urlParams.get("page")) || 1;
                const limit = Math.min(parseInt(urlParams.get("limit")) || 50, 100);
                const offset = (page - 1) * limit;
                const action = urlParams.get("action");
                const userId = urlParams.get("user_id");
                const startDate = urlParams.get("start_date");
                const endDate = urlParams.get("end_date");
                const status = urlParams.get("status");
                
                let whereConditions = [];
                let params = [];
                let paramIndex = 1;
                
                if (action) {
                    whereConditions.push(`action = $${paramIndex++}`);
                    params.push(action);
                }
                if (userId) {
                    whereConditions.push(`user_id = $${paramIndex++}`);
                    params.push(userId);
                }
                if (startDate) {
                    whereConditions.push(`timestamp >= $${paramIndex++}`);
                    params.push(startDate);
                }
                if (endDate) {
                    whereConditions.push(`timestamp <= $${paramIndex++}`);
                    params.push(endDate);
                }
                if (status) {
                    whereConditions.push(`status = $${paramIndex++}`);
                    params.push(status);
                }
                
                const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(" AND ")}` : "";
                
                // Get total count
                const countQuery = `SELECT COUNT(*) FROM audit_logs ${whereClause}`;
                const countResult = await dbPostgres.pool.query(countQuery, params);
                const totalCount = parseInt(countResult.rows[0].count);
                
                // Get paginated results
                const dataQuery = `
                    SELECT id, timestamp, user_id, user_email, action, resource, resource_id, 
                           details, ip_address, status, error_message
                    FROM audit_logs 
                    ${whereClause}
                    ORDER BY timestamp DESC
                    LIMIT $${paramIndex++} OFFSET $${paramIndex}
                `;
                params.push(limit, offset);
                
                const result = await dbPostgres.pool.query(dataQuery, params);
                
                // Get action summary
                const summaryQuery = `
                    SELECT action, COUNT(*) as count 
                    FROM audit_logs 
                    ${whereClause}
                    GROUP BY action 
                    ORDER BY count DESC
                `;
                const summaryResult = await dbPostgres.pool.query(summaryQuery, params.slice(0, -2));
                
                sendSuccess(res, {
                    logs: result.rows,
                    pagination: {
                        page,
                        limit,
                        total: totalCount,
                        totalPages: Math.ceil(totalCount / limit)
                    },
                    summary: summaryResult.rows,
                    filters: { action, userId, startDate, endDate, status }
                });
            } catch (error) {
                log("error", "Error fetching audit logs:", error);
                sendError(res, 500, "Error al obtener logs de auditoria");
            }
            return;
        }


        // Admin: Metrics Dashboard (SECURED - requires admin auth)
        if (pathname === "/api/admin/metrics" && (method === "GET" || method === "HEAD")) {

            // SECURITY: Require admin JWT authentication (added 2025-12-14)
            const authUser = requireAuth(req, res);
            if (!authUser) return;
            const authHeader = req.headers.authorization;
            if (!authHeader || !authHeader.startsWith("Bearer ")) {
                sendError(res, 401, "Token de autenticacion requerido");
                return;
            }
            
            const token = authHeader.split(" ")[1];
            const session = database.admin_sessions?.[token];
            
            if (!session) {
                sendError(res, 401, "Sesion invalida o expirada");
                return;
            }
            
            if (new Date() > new Date(session.expires_at)) {
                delete database.admin_sessions[token];
                sendError(res, 401, "Sesion expirada");
                return;
            }
            
            sendSuccess(res, metricsModule.getMetrics());
            return;
        }


        // ============================================
        // FAILED GROUP JOINS MANAGEMENT
        // ============================================

        // GET /api/admin/failed-joins - List failed join attempts
        if (pathname === '/api/admin/failed-joins' && (method === 'GET' || method === 'HEAD')) {
            // SECURITY FIX: Require admin session (2025-12-31)
            const adminSession = requireAdminSession(req, res);
            if (!adminSession) return;

            try {
                const { resolved, error_type, limit = 50, offset = 0 } = query;
                
                let whereClause = 'WHERE 1=1';
                const params = [];
                let paramCount = 0;

                if (resolved !== undefined) {
                    paramCount++;
                    whereClause += ` AND fgj.resolved = $${paramCount}`;
                    params.push(resolved === 'true');
                }

                if (error_type) {
                    paramCount++;
                    whereClause += ` AND fgj.error_type = $${paramCount}`;
                    params.push(error_type);
                }

                paramCount++;
                const limitParam = paramCount;
                paramCount++;
                const offsetParam = paramCount;
                params.push(parseInt(limit), parseInt(offset));

                const result = await dbPostgres.pool.query(`
                    SELECT 
                        fgj.*,
                        u.name as user_name,
                        u.email as user_email_from_users,
                        g.name as group_name,
                        gi.token as invitation_token
                    FROM failed_group_joins fgj
                    LEFT JOIN users u ON fgj.user_id = u.user_id
                    LEFT JOIN groups g ON fgj.group_id = g.group_id
                    LEFT JOIN group_invitations gi ON fgj.invitation_id = gi.id
                    ${whereClause}
                    ORDER BY fgj.created_at DESC
                    LIMIT $${limitParam} OFFSET $${offsetParam}
                `, params);

                // Get total count
                const countResult = await dbPostgres.pool.query(`
                    SELECT COUNT(*) as total FROM failed_group_joins fgj ${whereClause.replace(/LIMIT.*/, '')}
                `, params.slice(0, -2));

                sendSuccess(res, {
                    failed_joins: result.rows,
                    total: parseInt(countResult.rows[0].total),
                    limit: parseInt(limit),
                    offset: parseInt(offset)
                });
            } catch (error) {
                log('error', 'Error fetching failed joins', { error: error.message });
                sendError(res, 500, 'Error al obtener errores de unión');
            }
            return;
        }

        // GET /api/admin/failed-joins/stats - Get statistics
        if (pathname === '/api/admin/failed-joins/stats' && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                const result = await dbPostgres.pool.query(`
                    SELECT 
                        COUNT(*) FILTER (WHERE resolved = false) as unresolved,
                        COUNT(*) FILTER (WHERE resolved = true) as resolved,
                        COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as last_24h,
                        COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '7 days') as last_7d,
                        COUNT(DISTINCT error_type) as error_types,
                        COUNT(DISTINCT user_id) as affected_users,
                        COUNT(DISTINCT group_id) as affected_groups
                    FROM failed_group_joins
                `);

                const byType = await dbPostgres.pool.query(`
                    SELECT error_type, COUNT(*) as count, 
                           COUNT(*) FILTER (WHERE resolved = false) as unresolved
                    FROM failed_group_joins
                    GROUP BY error_type
                    ORDER BY count DESC
                `);

                sendSuccess(res, {
                    summary: result.rows[0],
                    by_error_type: byType.rows
                });
            } catch (error) {
                log('error', 'Error fetching failed joins stats', { error: error.message });
                sendError(res, 500, 'Error al obtener estadísticas');
            }
            return;
        }

        // PUT /api/admin/failed-joins/:id/resolve - Mark as resolved
        if (pathname.match(/^\/api\/admin\/failed-joins\/[^\/]+\/resolve$/) && (method === 'PUT' || method === 'PATCH')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const failedJoinId = pathname.split('/')[4];
            const { resolution_type = 'manual', notes } = body;

            try {
                const result = await dbPostgres.pool.query(`
                    UPDATE failed_group_joins
                    SET resolved = true,
                        resolved_at = NOW(),
                        resolved_by = $1,
                        resolution_type = $2,
                        error_details = COALESCE(error_details, '{}'::jsonb) || jsonb_build_object('resolution_notes', $3)
                    WHERE id = $4
                    RETURNING id, user_id, group_id, resolved, resolved_at, resolved_by, resolution_type, error_details
                `, [authUser.userId, resolution_type, notes || '', failedJoinId]);

                if (result.rows.length === 0) {
                    sendError(res, 404, 'Error no encontrado');
                    return;
                }

                log('info', 'Failed join marked as resolved', { id: failedJoinId, by: authUser.userId });
                sendSuccess(res, { 
                    message: 'Marcado como resuelto',
                    failed_join: result.rows[0]
                });
            } catch (error) {
                log('error', 'Error resolving failed join', { error: error.message });
                sendError(res, 500, 'Error al resolver');
            }
            return;
        }

        // POST /api/admin/failed-joins/:id/retry - Retry adding user to group
        if (pathname.match(/^\/api\/admin\/failed-joins\/[^\/]+\/retry$/) && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const failedJoinId = pathname.split('/')[4];

            try {
                // Get the failed join record
                const fjResult = await dbPostgres.pool.query(
                    'SELECT id, user_id, user_email, group_id, invitation_id, error_type, error_message, error_details, retry_count, max_retries, resolved, resolved_at, resolved_by, resolution_type, created_at, updated_at FROM failed_group_joins WHERE id = $1',
                    [failedJoinId]
                );

                if (fjResult.rows.length === 0) {
                    sendError(res, 404, 'Error no encontrado');
                    return;
                }

                const fj = fjResult.rows[0];

                if (fj.resolved) {
                    sendError(res, 400, 'Este error ya fue resuelto');
                    return;
                }

                if (fj.retry_count >= fj.max_retries) {
                    sendError(res, 400, 'Se alcanzó el máximo de reintentos');
                    return;
                }

                // Check if user exists
                if (!fj.user_id) {
                    sendError(res, 400, 'No hay usuario asociado para reintentar');
                    return;
                }

                // Check if already a member
                const memberCheck = await dbPostgres.pool.query(
                    'SELECT id FROM group_members WHERE group_id = $1 AND user_id = $2 AND status = \'active\'',
                    [fj.group_id, fj.user_id]
                );

                if (memberCheck.rows.length > 0) {
                    // Already a member, mark as resolved
                    await dbPostgres.pool.query(`
                        UPDATE failed_group_joins
                        SET resolved = true, resolved_at = NOW(), resolved_by = $1, resolution_type = 'auto_already_member'
                        WHERE id = $2
                    `, [authUser.userId, failedJoinId]);

                    sendSuccess(res, { message: 'El usuario ya es miembro del grupo. Marcado como resuelto.' });
                    return;
                }

                // Try to add user to group
                await dbPostgres.pool.query(`
                    INSERT INTO group_members (group_id, user_id, role, status, invited_by, notes)
                    VALUES ($1, $2, 'member', 'active', $3, 'Added via retry from failed_group_joins')
                `, [fj.group_id, fj.user_id, authUser.userId]);

                // Mark as resolved
                await dbPostgres.pool.query(`
                    UPDATE failed_group_joins
                    SET resolved = true, 
                        resolved_at = NOW(), 
                        resolved_by = $1, 
                        resolution_type = 'retry_success',
                        retry_count = retry_count + 1
                    WHERE id = $2
                `, [authUser.userId, failedJoinId]);

                log('info', 'Failed join retry successful', { id: failedJoinId, user: fj.user_id, group: fj.group_id });
                sendSuccess(res, { 
                    message: 'Usuario agregado al grupo exitosamente',
                    user_id: fj.user_id,
                    group_id: fj.group_id
                });

            } catch (error) {
                // Update retry count
                await dbPostgres.pool.query(`
                    UPDATE failed_group_joins
                    SET retry_count = retry_count + 1,
                        error_details = COALESCE(error_details, '{}'::jsonb) || jsonb_build_object('retry_error', $1)
                    WHERE id = $2
                `, [error.message, failedJoinId]);

                log('error', 'Failed join retry failed', { error: error.message });
                log('info', 'error', 'Error al reintentar', { error: error.message }); sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // POST /api/admin/failed-joins/:id/add-manually - Add user manually with custom data
        if (pathname.match(/^\/api\/admin\/failed-joins\/[^\/]+\/add-manually$/) && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const failedJoinId = pathname.split('/')[4];
            const { user_id, group_id } = body;

            if (!user_id || !group_id) {
                sendError(res, 400, 'user_id y group_id son requeridos');
                return;
            }

            try {
                // Check if already a member
                const memberCheck = await dbPostgres.pool.query(
                    'SELECT id FROM group_members WHERE group_id = $1 AND user_id = $2',
                    [group_id, user_id]
                );

                if (memberCheck.rows.length > 0) {
                    sendError(res, 400, 'El usuario ya es miembro de este grupo');
                    return;
                }

                // Add to group
                await dbPostgres.pool.query(`
                    INSERT INTO group_members (group_id, user_id, role, status, invited_by, notes)
                    VALUES ($1, $2, 'member', 'active', $3, 'Added manually by admin from failed_group_joins')
                `, [group_id, user_id, authUser.userId]);

                // Mark failed join as resolved if exists
                if (failedJoinId !== 'new') {
                    await dbPostgres.pool.query(`
                        UPDATE failed_group_joins
                        SET resolved = true, resolved_at = NOW(), resolved_by = $1, resolution_type = 'manual_add'
                        WHERE id = $2
                    `, [authUser.userId, failedJoinId]);
                }

                log('info', 'User added manually to group', { user_id, group_id, by: authUser.userId });
                sendSuccess(res, { 
                    message: 'Usuario agregado al grupo manualmente',
                    user_id,
                    group_id
                });

            } catch (error) {
                log('error', 'Error adding user manually', { error: error.message });
                log('info', 'error', 'Error al agregar usuario', { error: error.message }); sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }
        // ============================================================
        // ONBOARDING REWARDS API
        // ============================================================

        // POST /api/rewards/onboarding/claim - Claim onboarding task reward
        if (pathname === '/api/rewards/onboarding/claim' && method === 'POST') {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            const { task_id } = body;

            // Valid onboarding tasks and their rewards
            const ONBOARDING_REWARDS = {
                'account_created': { reward: 10, description: 'Crear cuenta' },
                'email_verified': { reward: 5, description: 'Verificar email' },
                'profile_completed': { reward: 15, description: 'Completar perfil' },
                'first_deposit': { reward: 20, description: 'Primer depósito' },
                'first_tanda': { reward: 25, description: 'Unirse a una tanda' },
                'kyc_completed': { reward: 50, description: 'Verificar identidad' }
            };

            if (!task_id || !ONBOARDING_REWARDS[task_id]) {
                sendError(res, 400, 'Tarea de onboarding inválida', {
                    valid_tasks: Object.keys(ONBOARDING_REWARDS)
                });
                return;
            }

            try {
                // Check if reward was already claimed
                const existingClaim = await dbPostgres.pool.query(`
                    SELECT id FROM audit_logs
                    WHERE user_id = $1
                    AND action = 'ONBOARDING_REWARD_CLAIMED'
                    AND details->>'task_id' = $2
                `, [authUser.userId, task_id]);

                if (existingClaim.rows.length > 0) {
                    sendError(res, 400, 'Esta recompensa ya fue reclamada', {
                        task_id,
                        already_claimed: true
                    });
                    return;
                }

                // Verify task completion based on task type
                let taskCompleted = false;

                switch (task_id) {
                    case 'account_created':
                        taskCompleted = true; // Always true if authenticated
                        break;

                    case 'email_verified':
                        const userCheck = await dbPostgres.pool.query(
                            'SELECT email_verified FROM users WHERE user_id = $1',
                            [authUser.userId]
                        );
                        taskCompleted = userCheck.rows[0]?.email_verified === true;
                        break;

                    case 'profile_completed':
                        const profileCheck = await dbPostgres.pool.query(
                            'SELECT avatar_url, phone FROM users WHERE user_id = $1',
                            [authUser.userId]
                        );
                        const profile = profileCheck.rows[0];
                        taskCompleted = !!(profile?.avatar_url && profile?.avatar_url !== 'default.jpg' && profile?.phone);
                        break;

                    case 'first_deposit':
                        const depositCheck = await dbPostgres.pool.query(`
                            SELECT id FROM transactions
                            WHERE user_id = $1 AND type = 'deposit' AND status = 'completed'
                            LIMIT 1
                        `, [authUser.userId]);
                        taskCompleted = depositCheck.rows.length > 0;
                        break;

                    case 'first_tanda':
                        const tandaCheck = await dbPostgres.pool.query(`
                            SELECT id FROM group_members
                            WHERE user_id = $1 AND status = 'active'
                            LIMIT 1
                        `, [authUser.userId]);
                        taskCompleted = tandaCheck.rows.length > 0;
                        break;

                    case 'kyc_completed':
                        const kycCheck = await dbPostgres.pool.query(
                            "SELECT verification_level FROM users WHERE user_id = $1",
                            [authUser.userId]
                        );
                        taskCompleted = kycCheck.rows[0]?.verification_level === 'full';
                        break;
                }

                if (!taskCompleted) {
                    sendError(res, 400, 'Debes completar la tarea antes de reclamar la recompensa', {
                        task_id,
                        task_description: ONBOARDING_REWARDS[task_id].description,
                        completed: false
                    });
                    return;
                }

                // v4.0.0: Wrap credit in transaction to prevent double-claim race
                const rewardAmount = ONBOARDING_REWARDS[task_id].reward;
                const rewardClient = await dbPostgres.pool.connect();
                try {
                    await rewardClient.query('BEGIN');
                    // Re-check claim inside transaction to prevent race condition
                    const recheck = await rewardClient.query(
                        "SELECT id FROM audit_logs WHERE user_id = $1 AND action = 'ONBOARDING_REWARD_CLAIMED' AND details->>'task_id' = $2",
                        [authUser.userId, task_id]
                    );
                    if (recheck.rows.length > 0) {
                        await rewardClient.query('ROLLBACK');
                        rewardClient.release();
                        sendError(res, 400, 'Esta recompensa ya fue reclamada', { task_id, already_claimed: true });
                        return;
                    }
                    await creditLTDTokens(authUser.userId, rewardAmount, 'ONBOARDING_' + task_id.toUpperCase(), rewardClient);
                    await rewardClient.query('COMMIT');
                } catch (txErr) {
                    await rewardClient.query('ROLLBACK').catch(() => {});
                    throw txErr;
                } finally {
                    rewardClient.release();
                }

                // Log the claim (outside transaction, non-critical)
                await auditLog('ONBOARDING_REWARD_CLAIMED', {
                    userId: authUser.userId,
                    extra: {
                        task_id,
                        reward_amount: rewardAmount,
                        description: ONBOARDING_REWARDS[task_id].description
                    }
                });

                // Get updated balance
                const walletResult = await dbPostgres.pool.query(
                    'SELECT crypto_balances FROM user_wallets WHERE user_id = $1',
                    [authUser.userId]
                );
                const newBalance = walletResult.rows[0]?.crypto_balances?.LTD || rewardAmount;

                log('info', 'Onboarding reward claimed', {
                    userId: authUser.userId,
                    task_id,
                    reward: rewardAmount
                });

                sendSuccess(res, {
                    message: '¡Recompensa reclamada exitosamente!',
                    task_id,
                    reward_claimed: rewardAmount,
                    new_ltd_balance: newBalance,
                    task_description: ONBOARDING_REWARDS[task_id].description
                });

            } catch (error) {
                log('error', 'Error claiming onboarding reward', {
                    error: error.message,
                    userId: authUser.userId,
                    task_id
                });
                log('info', 'error', 'Error al reclamar recompensa', { error: error.message }); sendError(res, 500, 'Error interno del servidor');
            }
            return;
        }

        // GET /api/rewards/onboarding/status - Get onboarding rewards status
        if (pathname === '/api/rewards/onboarding/status' && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res);
            if (!authUser) return;

            try {
                // Get all claimed rewards
                const claimedResult = await dbPostgres.pool.query(`
                    SELECT details->>'task_id' as task_id,
                           details->>'reward_amount' as reward_amount,
                           timestamp as claimed_at
                    FROM audit_logs
                    WHERE user_id = $1
                    AND action = 'ONBOARDING_REWARD_CLAIMED'
                    ORDER BY timestamp
                `, [authUser.userId]);

                const claimedTasks = {};
                let totalClaimed = 0;
                claimedResult.rows.forEach(row => {
                    claimedTasks[row.task_id] = {
                        claimed: true,
                        reward: parseInt(row.reward_amount),
                        claimed_at: row.claimed_at
                    };
                    totalClaimed += parseInt(row.reward_amount);
                });

                // Build status for all tasks
                const ONBOARDING_REWARDS = {
                    'account_created': { reward: 10, description: 'Crear cuenta' },
                    'email_verified': { reward: 5, description: 'Verificar email' },
                    'profile_completed': { reward: 15, description: 'Completar perfil' },
                    'first_deposit': { reward: 20, description: 'Primer depósito' },
                    'first_tanda': { reward: 25, description: 'Unirse a una tanda' },
                    'kyc_completed': { reward: 50, description: 'Verificar identidad' }
                };

                const tasks = {};
                let totalPossible = 0;
                for (const [taskId, taskInfo] of Object.entries(ONBOARDING_REWARDS)) {
                    totalPossible += taskInfo.reward;
                    tasks[taskId] = {
                        description: taskInfo.description,
                        reward: taskInfo.reward,
                        claimed: !!claimedTasks[taskId],
                        claimed_at: claimedTasks[taskId]?.claimed_at || null
                    };
                }

                const completedCount = Object.keys(claimedTasks).length;
                const allComplete = completedCount === Object.keys(ONBOARDING_REWARDS).length;

                sendSuccess(res, {
                    tasks,
                    summary: {
                        total_tasks: Object.keys(ONBOARDING_REWARDS).length,
                        completed_tasks: completedCount,
                        total_possible_rewards: totalPossible,
                        total_claimed: totalClaimed,
                        pending_rewards: totalPossible - totalClaimed,
                        onboarding_complete: allComplete,
                        progress_percentage: Math.round((completedCount / Object.keys(ONBOARDING_REWARDS).length) * 100)
                    }
                });

            } catch (error) {
                log('error', 'Error fetching onboarding status', {
                    error: error.message,
                    userId: authUser.userId
                });
                sendError(res, 500, 'Error al obtener estado de onboarding');
            }
            return;
        }



        // =============================================
        // v4.11.0: MARK MEMBER AS MORA (Manual by coordinator)
        // POST /api/groups/:id/members/:userId/mark-mora
        // =============================================
        if (pathname.match(/^\/api\/groups\/[^\/]+\/members\/[^\/]+\/mark-mora$/) && method === 'POST') {
            const authUser = requireAuth(req, res, query);
            if (!authUser) return;

            const parts = pathname.split('/');
            const groupId = decodeURIComponent(parts[3]);
            const targetUserId = decodeURIComponent(parts[5]);

            try {
                // Check requester is creator/coordinator/admin
                const requesterMember = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, authUser.userId]
                );
                const isAdmin = authUser.role === 'admin';
                const requesterRole = requesterMember.rows[0]?.role;
                if (!isAdmin && requesterRole !== 'creator' && requesterRole !== 'coordinator') {
                    sendError(res, 403, 'Solo el coordinador o creador puede marcar mora');
                    return;
                }

                // Get group info
                const groupResult = await dbPostgres.pool.query(
                    "SELECT current_cycle, contribution_amount FROM groups WHERE group_id = $1 AND status = 'active'",
                    [groupId]
                );
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                const cycleNumber = body.cycle_number ? parseInt(body.cycle_number) : (groupResult.rows[0].current_cycle || 1);
                const contributionAmount = parseFloat(groupResult.rows[0].contribution_amount);

                // Validate target is active/suspended member
                const targetMember = await dbPostgres.pool.query(
                    "SELECT user_id, COALESCE(num_positions, 1) as num_positions FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, targetUserId]
                );
                if (targetMember.rows.length === 0) {
                    sendError(res, 404, 'Miembro no encontrado en el grupo');
                    return;
                }

                const positions = parseInt(targetMember.rows[0].num_positions);

                // Check if already paid for this cycle
                const paidCheck = await dbPostgres.pool.query(
                    "SELECT COUNT(*) as cnt FROM contributions WHERE group_id = $1 AND user_id = $2 AND cycle_number = $3 AND status IN ('completed', 'coordinator_approved', 'archived')",
                    [groupId, targetUserId, cycleNumber]
                );
                if (parseInt(paidCheck.rows[0].cnt) >= positions) {
                    sendError(res, 400, 'El miembro ya completo sus pagos para este ciclo');
                    return;
                }

                // Insert mora record
                const moraResult = await dbPostgres.pool.query(`
                    INSERT INTO payment_deferrals (group_id, user_id, cycle_number, type, status, mora_applied_by, mora_applied_at, mora_method, positions_count, amount_owed, created_at, updated_at)
                    VALUES ($1, $2, $3, 'mora', 'active', $4, NOW(), 'manual_coordinator', $5, $6, NOW(), NOW())
                    ON CONFLICT (group_id, user_id, cycle_number, type) DO NOTHING
                    RETURNING id
                `, [groupId, targetUserId, cycleNumber, authUser.userId, positions, contributionAmount * positions]);

                if (moraResult.rows.length === 0) {
                    sendError(res, 409, 'Ya existe un registro de mora para este miembro y ciclo');
                    return;
                }

                // Notify member
                await notificationsUtils.createNotification(dbPostgres.pool, targetUserId, 'mora_applied',
                    'Pago en Mora',
                    'Tu coordinador ha marcado tu pago como mora.',
                    { group_id: groupId, cycle_number: cycleNumber }
                );

                log("info", "Mora marked manually", { groupId, targetUserId, cycleNumber, by: authUser.userId });
                sendSuccess(res, { message: 'Mora registrada', deferral_id: moraResult.rows[0].id });
            } catch (error) {
                log('error', 'Error marking mora', { error: error.message });
                sendError(res, 500, 'Error al registrar mora');
            }
            return;
        }


        // =============================================
        // v4.11.0: REQUEST EXTENSION (Member requests prórroga)
        // POST /api/groups/:id/extensions/request
        // =============================================
        if (pathname.match(/^\/api\/groups\/[^\/]+\/extensions\/request$/) && method === 'POST') {
            const authUser = requireAuth(req, res, query);
            if (!authUser) return;

            const parts = pathname.split('/');
            const groupId = decodeURIComponent(parts[3]);

            try {
                // Check requester is active member
                const memberCheck = await dbPostgres.pool.query(
                    "SELECT user_id, COALESCE(num_positions, 1) as num_positions FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, authUser.userId]
                );
                if (memberCheck.rows.length === 0) {
                    sendError(res, 403, 'No eres miembro activo de este grupo');
                    return;
                }

                // Get group info
                const groupResult = await dbPostgres.pool.query(
                    "SELECT current_cycle, contribution_amount, name, admin_id FROM groups WHERE group_id = $1 AND status = 'active'",
                    [groupId]
                );
                if (groupResult.rows.length === 0) {
                    sendError(res, 404, 'Grupo no encontrado');
                    return;
                }

                const currentCycle = groupResult.rows[0].current_cycle || 1;
                const contributionAmount = parseFloat(groupResult.rows[0].contribution_amount);
                const positions = parseInt(memberCheck.rows[0].num_positions);

                // Validate reason
                const reason = typeof body.reason === 'string' ? body.reason.trim() : '';
                if (reason.length < 1 || reason.length > 500) {
                    sendError(res, 400, 'El motivo es requerido (1-500 caracteres)');
                    return;
                }

                // Calculate proposed date
                let proposedDate = null;
                if (body.next_quincena) {
                    const now = new Date();
                    const day = now.getDate();
                    const month = now.getMonth();
                    const year = now.getFullYear();
                    if (day < 15) {
                        proposedDate = new Date(year, month, 15);
                    } else {
                        // Last day of current month or 15th of next month
                        proposedDate = new Date(year, month + 1, 15);
                    }
                } else if (body.proposed_date) {
                    proposedDate = new Date(body.proposed_date);
                    if (isNaN(proposedDate.getTime())) {
                        sendError(res, 400, 'Fecha propuesta invalida');
                        return;
                    }
                    // Don't allow dates more than 60 days in the future
                    const maxDate = new Date();
                    maxDate.setDate(maxDate.getDate() + 60);
                    if (proposedDate > maxDate) {
                        sendError(res, 400, 'La fecha propuesta no puede ser mayor a 60 dias');
                        return;
                    }
                }

                // Check no existing active extension for this cycle
                const existingCheck = await dbPostgres.pool.query(
                    "SELECT id FROM payment_deferrals WHERE group_id = $1 AND user_id = $2 AND cycle_number = $3 AND type = 'extension' AND status IN ('active', 'approved')",
                    [groupId, authUser.userId, currentCycle]
                );
                if (existingCheck.rows.length > 0) {
                    sendError(res, 409, 'Ya tienes una prorroga activa para este ciclo');
                    return;
                }

                // Insert extension request
                const extResult = await dbPostgres.pool.query(`
                    INSERT INTO payment_deferrals (group_id, user_id, cycle_number, type, status, requested_at, proposed_date, reason, positions_count, amount_owed, created_at, updated_at)
                    VALUES ($1, $2, $3, 'extension', 'active', NOW(), $4, $5, $6, $7, NOW(), NOW())
                    RETURNING id, proposed_date, created_at
                `, [groupId, authUser.userId, currentCycle, proposedDate, reason, positions, contributionAmount * positions]);

                // Notify group creator
                const creatorId = groupResult.rows[0].admin_id;
                if (creatorId && creatorId !== authUser.userId) {
                    await notificationsUtils.createNotification(dbPostgres.pool, creatorId, 'extension_requested',
                        'Solicitud de Prorroga',
                        'Un miembro ha solicitado una prorroga para su pago.',
                        { group_id: groupId, deferral_id: extResult.rows[0].id, cycle_number: currentCycle }
                    );
                }

                log("info", "Extension requested", { groupId, userId: authUser.userId, cycle: currentCycle });
                sendSuccess(res, {
                    message: 'Solicitud de prorroga enviada',
                    extension: {
                        id: extResult.rows[0].id,
                        proposed_date: extResult.rows[0].proposed_date,
                        created_at: extResult.rows[0].created_at
                    }
                });
            } catch (error) {
                log('error', 'Error requesting extension', { error: error.message });
                sendError(res, 500, 'Error al solicitar prorroga');
            }
            return;
        }


        // =============================================
        // v4.11.0: GET EXTENSIONS/MORAS for a group
        // GET /api/groups/:id/extensions
        // =============================================
        if (pathname.match(/^\/api\/groups\/[^\/]+\/extensions$/) && (method === 'GET' || method === 'HEAD')) {
            const authUser = requireAuth(req, res, query);
            if (!authUser) return;

            const parts = pathname.split('/');
            const groupId = decodeURIComponent(parts[3]);

            try {
                // Check membership
                const memberCheck = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, authUser.userId]
                );
                const isAdmin = authUser.role === 'admin';
                if (!isAdmin && memberCheck.rows.length === 0) {
                    sendError(res, 403, 'No tienes acceso a este grupo');
                    return;
                }

                const isCoordinator = isAdmin || memberCheck.rows[0]?.role === 'creator' || memberCheck.rows[0]?.role === 'coordinator';

                // Build query with filters
                const statusFilter = query.status || 'all';
                const typeFilter = query.type || 'all';
                const cycleFilter = query.cycle ? parseInt(query.cycle) : null;

                let whereClauses = ['pd.group_id = $1'];
                let params = [groupId];
                let paramIdx = 2;

                // Members can only see their own
                if (!isCoordinator) {
                    whereClauses.push('pd.user_id = $' + paramIdx);
                    params.push(authUser.userId);
                    paramIdx++;
                }

                if (statusFilter !== 'all') {
                    whereClauses.push('pd.status = $' + paramIdx);
                    params.push(statusFilter);
                    paramIdx++;
                }

                if (typeFilter !== 'all') {
                    whereClauses.push('pd.type = $' + paramIdx);
                    params.push(typeFilter);
                    paramIdx++;
                }

                if (cycleFilter) {
                    whereClauses.push('pd.cycle_number = $' + paramIdx);
                    params.push(cycleFilter);
                    paramIdx++;
                }

                const result = await dbPostgres.pool.query(`
                    SELECT pd.id, pd.group_id, pd.user_id, pd.cycle_number, pd.type, pd.status,
                        pd.mora_applied_by, pd.mora_applied_at, pd.mora_method,
                        pd.requested_at, pd.proposed_date, pd.reason,
                        pd.responded_by, pd.responded_at, pd.response_notes,
                        pd.positions_count, pd.amount_owed, pd.resolved_at,
                        pd.created_at, pd.updated_at,
                        u.name as user_name, u.avatar_url as user_avatar
                    FROM payment_deferrals pd
                    LEFT JOIN users u ON pd.user_id = u.user_id
                    WHERE ${whereClauses.join(' AND ')}
                    ORDER BY pd.created_at DESC
                    LIMIT 100
                `, params);

                // Summary counts
                const summaryResult = await dbPostgres.pool.query(`
                    SELECT
                        COUNT(*) FILTER (WHERE type = 'mora' AND status = 'active') as active_moras,
                        COUNT(*) FILTER (WHERE type = 'extension' AND status = 'active') as pending_extensions,
                        COUNT(*) FILTER (WHERE type = 'extension' AND status = 'approved') as approved_extensions,
                        COUNT(*) FILTER (WHERE status = 'resolved') as resolved
                    FROM payment_deferrals WHERE group_id = $1
                `, [groupId]);

                sendSuccess(res, {
                    deferrals: result.rows,
                    summary: summaryResult.rows[0]
                });
            } catch (error) {
                log('error', 'Error fetching extensions', { error: error.message });
                sendError(res, 500, 'Error al obtener prorrogas');
            }
            return;
        }


        // =============================================
        // v4.11.0: APPROVE/REJECT EXTENSION
        // PATCH /api/groups/:id/extensions/:extensionId
        // =============================================
        if (pathname.match(/^\/api\/groups\/[^\/]+\/extensions\/[0-9a-f-]+$/) && (method === 'PATCH' || method === 'PUT')) {
            const authUser = requireAuth(req, res, query);
            if (!authUser) return;

            const parts = pathname.split('/');
            const groupId = decodeURIComponent(parts[3]);
            const extensionId = decodeURIComponent(parts[5]);

            try {
                // Check requester is creator/coordinator/admin
                const requesterMember = await dbPostgres.pool.query(
                    "SELECT role FROM group_members WHERE group_id = $1 AND user_id = $2 AND status IN ('active', 'suspended')",
                    [groupId, authUser.userId]
                );
                const isAdmin = authUser.role === 'admin';
                const requesterRole = requesterMember.rows[0]?.role;
                if (!isAdmin && requesterRole !== 'creator' && requesterRole !== 'coordinator') {
                    sendError(res, 403, 'Solo el coordinador o creador puede gestionar prorrogas');
                    return;
                }

                const action = body.action;
                if (action !== 'approve' && action !== 'reject') {
                    sendError(res, 400, 'Accion invalida. Use approve o reject');
                    return;
                }

                // Get the deferral
                const deferral = await dbPostgres.pool.query(
                    "SELECT id, user_id, type, status FROM payment_deferrals WHERE id = $1 AND group_id = $2",
                    [extensionId, groupId]
                );
                if (deferral.rows.length === 0) {
                    sendError(res, 404, 'Prorroga no encontrada');
                    return;
                }

                if (deferral.rows[0].type !== 'extension') {
                    sendError(res, 400, 'Solo se pueden aprobar/rechazar prorrogas, no moras');
                    return;
                }

                if (deferral.rows[0].status !== 'active') {
                    sendError(res, 400, 'Esta prorroga ya fue procesada');
                    return;
                }

                const newStatus = action === 'approve' ? 'approved' : 'rejected';
                const responseNotes = typeof body.response_notes === 'string' ? body.response_notes.trim().slice(0, 500) : null;

                await dbPostgres.pool.query(`
                    UPDATE payment_deferrals
                    SET status = $1, responded_by = $2, responded_at = NOW(), response_notes = $3, updated_at = NOW()
                    WHERE id = $4
                `, [newStatus, authUser.userId, responseNotes, extensionId]);

                // Notify the member
                const targetUserId = deferral.rows[0].user_id;
                const notifType = action === 'approve' ? 'extension_approved' : 'extension_rejected';
                const notifTitle = action === 'approve' ? 'Prorroga Aprobada' : 'Prorroga Rechazada';
                const notifMessage = action === 'approve'
                    ? 'Tu solicitud de prorroga ha sido aprobada por el coordinador.'
                    : 'Tu solicitud de prorroga ha sido rechazada por el coordinador.';

                await notificationsUtils.createNotification(dbPostgres.pool, targetUserId, notifType,
                    notifTitle, notifMessage,
                    { group_id: groupId, deferral_id: extensionId }
                );

                log("info", `Extension ${action}d`, { groupId, extensionId, by: authUser.userId });
                sendSuccess(res, { message: action === 'approve' ? 'Prorroga aprobada' : 'Prorroga rechazada', status: newStatus });
            } catch (error) {
                log('error', 'Error updating extension', { error: error.message });
                sendError(res, 500, 'Error al procesar prorroga');
            }
            return;
        }

        sendError(res, 404, 'Endpoint not found', {
            requested_path: pathname,
            method: method,
            available_docs: '/docs',
            total_endpoints: 140
        });

    } catch (error) {
        log("error", 'Server error:', error);
        log('error', 'Server error', { error: error.message, pathname, method });
        sendError(res, 500, 'Error interno del servidor');
    }
});

// Helper functions for MIA
function generateMiaResponse(message, context) {
    const responses = {
        'grupos': 'Te puedo ayudar a encontrar el grupo perfecto para ti. ¿Cuánto puedes ahorrar semanalmente?',
        'pagos': 'Tenemos varios métodos de pago disponibles: Tigo Money, Claro Money, transferencia bancaria y efectivo. ¿Cuál prefieres?',
        'ayuda': 'Estoy aquí para ayudarte con todo lo relacionado a La Tanda. ¿Qué necesitas saber?',
        'verificacion': 'Para completar tu verificación necesitas subir tu cédula y una selfie. ¿Ya tienes los documentos listos?'
    };
    
    const lowerMessage = message.toLowerCase();
    for (const key in responses) {
        if (lowerMessage.includes(key)) {
            return responses[key];
        }
    }
    
    return 'Entiendo tu consulta. Te puedo ayudar con información sobre grupos, pagos, verificación y más. ¿Podrías ser más específico?';
}

function getSuggestedActions(message) {
    const lowerMessage = message.toLowerCase();
    if (lowerMessage.includes('grupo')) {
        return ['Ver grupos disponibles', 'Crear nuevo grupo', 'Unirse a grupo'];
    }
    if (lowerMessage.includes('pago')) {
        return ['Ver métodos de pago', 'Realizar pago', 'Historial de pagos'];
    }
    return ['Ver perfil', 'Contactar soporte', 'Ver ayuda'];
}

// Email notification system
const sendDepositNotification = async (data) => {
    try {
        const { type, deposit, user_id } = data;
        const amount = parseFloat(deposit.amount || 0);
        const netAmount = parseFloat(deposit.net_amount || 0);

        const adminEmails = ['admin@latanda.online', 'finance@latanda.online'];
        let subject, htmlContent;

        switch (type) {
            case 'new_deposit':
                subject = `Nuevo Depósito - L.${amount.toFixed(2)} - ${deposit.reference_number || ''}`;
                htmlContent = `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                        <div style="background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); color: white; padding: 20px; border-radius: 10px;">
                            <h2 style="color: #00FFFF; margin-bottom: 10px;">Nuevo Depósito Pendiente</h2>
                            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px;">
                                <p><strong>Usuario:</strong> ${user_id}</p>
                                <p><strong>Monto:</strong> L.${amount.toFixed(2)}</p>
                                <p><strong>Neto:</strong> L.${netAmount.toFixed(2)}</p>
                                <p><strong>Referencia:</strong> ${deposit.reference_number || 'N/A'}</p>
                                <p><strong>Banco:</strong> ${deposit.bank_name || 'N/A'}</p>
                                <p><strong>Fecha:</strong> ${new Date(deposit.created_at || Date.now()).toLocaleString('es-ES')}</p>
                            </div>
                            <div style="margin-top: 20px; text-align: center;">
                                <a href="https://latanda.online/admin-panel.html"
                                   style="background: #00FFFF; color: #0f172a; padding: 12px 24px;
                                          text-decoration: none; border-radius: 6px; font-weight: bold;">
                                    Ver Panel de Administración
                                </a>
                            </div>
                        </div>
                    </div>`;
                break;
            case 'deposit_confirmed':
                subject = `Depósito Confirmado - L.${amount.toFixed(2)} - ${deposit.reference_number || ''}`;
                htmlContent = `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                        <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 20px; border-radius: 10px;">
                            <h2 style="margin-bottom: 10px;">Depósito Confirmado</h2>
                            <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                                <p><strong>Usuario:</strong> ${user_id}</p>
                                <p><strong>Monto:</strong> L.${amount.toFixed(2)}</p>
                                <p><strong>Referencia:</strong> ${deposit.reference_number || 'N/A'}</p>
                                <p><strong>Confirmado por:</strong> ${data.admin_id || 'admin'}</p>
                                <p><strong>Fecha:</strong> ${new Date().toLocaleString('es-ES')}</p>
                            </div>
                        </div>
                    </div>`;
                break;
            case 'deposit_rejected':
                subject = `Depósito Rechazado - L.${amount.toFixed(2)} - ${deposit.reference_number || ''}`;
                htmlContent = `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                        <div style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; padding: 20px; border-radius: 10px;">
                            <h2 style="margin-bottom: 10px;">Depósito Rechazado</h2>
                            <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                                <p><strong>Usuario:</strong> ${user_id}</p>
                                <p><strong>Monto:</strong> L.${amount.toFixed(2)}</p>
                                <p><strong>Referencia:</strong> ${deposit.reference_number || 'N/A'}</p>
                                <p><strong>Rechazado por:</strong> ${data.admin_id || 'admin'}</p>
                                <p><strong>Razón:</strong> ${data.rejection_reason || 'No especificada'}</p>
                            </div>
                        </div>
                    </div>`;
                break;
            case 'receipt_uploaded':
                subject = `Comprobante Subido - ${deposit.reference_number || deposit.id}`;
                htmlContent = `<p>Comprobante subido para depósito ${deposit.id}. Requiere revisión.</p>`;
                break;
        }

        log('info', 'Deposit notification', { type, subject, recipients: adminEmails, deposit_id: deposit.id });
    } catch (error) {
        log('error', 'Failed to send deposit notification', { error: error.message });
    }
};

// Load existing database on startup
loadDatabase();

// Start server
// Initialize token blacklist for logout support
(async () => {
    try {
        const initialized = await securityMiddleware.initTokenBlacklist();
        if (initialized) log("info", "[Security] Token blacklist ready");
    } catch (err) {
    }
})();

server.listen(port, hostname, () => {
    log('info', 'Server started', { port, hostname });
    log('info', '🚀 LA TANDA COMPLETE MOBILE API - 140+ ENDPOINTS DEPLOYED');
    log('info', `✅ Server running at http://${hostname}:${port}/`);
    // Signal PM2 that the app is ready (prevents EADDRINUSE during reloads)
    if (process.send) process.send("ready");
    
    // Initialize WebSocket server for live lottery
    wsLottery.initWebSocketServer(server);
    log('info', '🔌 WebSocket server initialized on /ws/lottery');
    log('info', '📱 Mobile-optimized with complete integration');
    log('info', '📊 Total Endpoints: 140+');
    log('info', '📝 Documentation: /docs');
    log('info', '🔒 Authentication: Bearer token');
    log('info', '🎯 Complete mobile ecosystem ready!');
    // Initialize Marketplace API with database pool
    marketplaceApi.initMarketplaceAPI(dbPostgres.pool);
    log('info', '📋 Endpoint Categories:');
    log('info', '   • Core System: 4 endpoints');
    log('info', '   • User Journey: 3 endpoints');
    log('info', '   • Registration: 9 endpoints');
    log('info', '   • Payments: 9 endpoints');
    log('info', '   • Verification: 8 endpoints');
    log('info', '   • Notifications: 6 endpoints');
    log('info', '   • Business Intelligence: 8 endpoints');
    log('info', '   • Mobile App Specific: 6 endpoints');
    log('info', '   • User Authentication: 4 endpoints');
    log('info', '   • Push Notifications: 2 endpoints');
    log('info', '   • Offline Sync: 3 endpoints');
    log('info', '   • MIA Assistant: 5 endpoints');
    log('info', '   • Documentation: 1 endpoint');
    log('info', '   ✅ Mobile-optimized user flows');
});


    // Crash safety: log and exit on unhandled errors
    process.on('uncaughtException', (err) => {
        log('fatal', 'Uncaught exception', { error: err.message, stack: err.stack });
        process.exit(1);
    });
    process.on('unhandledRejection', (reason) => {
        log('fatal', 'Unhandled rejection', { error: reason?.message || String(reason) });
        process.exit(1);
    });

    process.on('SIGTERM', () => {
    log('info', 'SIGTERM received');
    saveDatabase();
    server.close(async () => { try { await dbPostgres.pool.end(); } catch(e) {} process.exit(0); });
});

process.on('SIGINT', () => {
    log('info', 'SIGINT received');
    saveDatabase();
    server.close(async () => { try { await dbPostgres.pool.end(); } catch(e) {} process.exit(0); });
});