/**
 * LA TANDA - PostgreSQL Database Module
 * Replaces fs.readFileSync/writeFileSync with PostgreSQL queries
 * Version: 1.0.0
 * Date: 2025-11-14
 */

const { Pool } = require('pg');
const fs = require('fs');
const path = require('path');

// PostgreSQL connection pool
const pool = new Pool({
    host: 'localhost',
    port: 5432,
    database: 'latanda_production',
    password: 'latanda123',
    user: 'postgres',
    max: 20, // Maximum number of clients in the pool
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
});

// Logging
const logsDir = path.join(__dirname, 'logs');
if (!fs.existsSync(logsDir)) {
    fs.mkdirSync(logsDir, { recursive: true });
}

const log = (level, message, data = {}) => {
    const timestamp = new Date().toISOString();
    const logEntry = { timestamp, level, message, ...data };
    console.log(`[${timestamp}] ${level.toUpperCase()}: ${message}`);
    
    const logFile = path.join(logsDir, 'db-postgres.log');
    fs.appendFileSync(logFile, JSON.stringify(logEntry) + '\n');
};

// Test connection on startup
pool.query('SELECT NOW()', (err, res) => {
    if (err) {
        log('error', 'PostgreSQL connection failed', { error: err.message });
    } else {
        log('info', 'PostgreSQL connected successfully', { time: res.rows[0].now });
    }
});

// ============================================
// USER OPERATIONS
// ============================================

const getUsers = async () => {
    try {
        const result = await pool.query(`
            SELECT 
                user_id as id,
                telegram_id,
                name,
                email,
                phone,
                verification_level,
                registration_date,
                status,
                total_contributions,
                avatar_url,
                push_token,
                app_version,
                device_type,
                last_app_access,
                notification_preferences,
                app_settings
            FROM users
            ORDER BY created_at DESC
        `);
        
        // Parse JSONB fields back to objects
        return result.rows.map(row => ({
            ...row,
            notification_preferences: row.notification_preferences || {},
            app_settings: row.app_settings || {}
        }));
    } catch (error) {
        log('error', 'getUsers failed', { error: error.message });
        throw error;
    }
};

const getUserById = async (userId) => {
    try {
        const result = await pool.query(`
            SELECT 
                user_id as id,
                telegram_id,
                name,
                email,
                phone,
                verification_level,
                registration_date,
                status,
                total_contributions,
                avatar_url,
                push_token,
                app_version,
                device_type,
                last_app_access,
                notification_preferences,
                app_settings
            FROM users
            WHERE user_id = $1
        `, [userId]);
        
        if (result.rows.length === 0) return null;
        
        const user = result.rows[0];
        return {
            ...user,
            notification_preferences: user.notification_preferences || {},
            app_settings: user.app_settings || {}
        };
    } catch (error) {
        log('error', 'getUserById failed', { userId, error: error.message });
        throw error;
    }
};

const createUser = async (userData) => {
    try {
        const result = await pool.query(`
            INSERT INTO users (
                user_id, telegram_id, name, email, phone,
                verification_level, registration_date, status,
                total_contributions, avatar_url, push_token,
                app_version, device_type, last_app_access,
                notification_preferences, app_settings, password_hash
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
            RETURNING user_id as id
        `, [
            userData.id,
            userData.telegram_id || null,
            userData.name,
            userData.email || null,
            userData.phone || null,
            userData.verification_level || 'basic',
            userData.registration_date || new Date().toISOString(),
            userData.status || 'active',
            userData.total_contributions || 0,
            userData.avatar_url || null,
            userData.push_token || null,
            userData.app_version || null,
            userData.device_type || null,
            userData.last_app_access || null,
            JSON.stringify(userData.notification_preferences || {}),
            JSON.stringify(userData.app_settings || {}),
            userData.password_hash || null
        ]);
        
        log('info', 'User created', { userId: result.rows[0].id });
        return result.rows[0].id;
    } catch (error) {
        log('error', 'createUser failed', { userData, error: error.message });
        throw error;
    }
};

const updateUser = async (userId, updates) => {
    try {
        const setClauses = [];
        const values = [];
        let paramIndex = 1;
        
        // Build dynamic UPDATE query
        Object.keys(updates).forEach(key => {
            if (key === 'id') return; // Don't update primary key
            
            const dbKey = key === 'id' ? 'user_id' : key;
            setClauses.push(`${dbKey} = $${paramIndex}`);
            
            // Handle JSONB fields
            if (key === 'notification_preferences' || key === 'app_settings') {
                values.push(JSON.stringify(updates[key]));
            } else {
                values.push(updates[key]);
            }
            paramIndex++;
        });
        
        values.push(userId);
        
        const query = `
            UPDATE users 
            SET ${setClauses.join(', ')}, updated_at = CURRENT_TIMESTAMP
            WHERE user_id = $${paramIndex}
            RETURNING user_id
        `;
        
        await pool.query(query, values);
        log('info', 'User updated', { userId });
    } catch (error) {
        log('error', 'updateUser failed', { userId, error: error.message });
        throw error;
    }
};

// ============================================
// GROUP OPERATIONS

// ============================================
// USER AUTHENTICATION OPERATIONS
// ============================================

const getUserByEmail = async (email) => {
    try {
        const result = await pool.query(
            'SELECT user_id as id, name, email, phone, password_hash, verification_level, status, avatar_url, notification_preferences, app_settings FROM users WHERE email = $1',
            [email]
        );
        return result.rows[0] || null;
    } catch (error) {
        log('error', 'getUserByEmail failed', { email, error: error.message });
        throw error;
    }
};

const updateUserPassword = async (userId, passwordHash) => {
    try {
        await pool.query(
            'UPDATE users SET password_hash = $1, password_reset_token = NULL, password_reset_expires = NULL, updated_at = CURRENT_TIMESTAMP WHERE user_id = $2',
            [passwordHash, userId]
        );
        log('info', 'User password updated', { userId });
    } catch (error) {
        log('error', 'updateUserPassword failed', { userId, error: error.message });
        throw error;
    }
};

const setPasswordResetToken = async (userId, token, expiresAt) => {
    try {
        await pool.query(
            'UPDATE users SET password_reset_token = $1, password_reset_expires = $2, updated_at = CURRENT_TIMESTAMP WHERE user_id = $3',
            [token, expiresAt, userId]
        );
        log('info', 'Password reset token set', { userId });
    } catch (error) {
        log('error', 'setPasswordResetToken failed', { userId, error: error.message });
        throw error;
    }
};

const getUserByResetToken = async (token) => {
    try {
        const result = await pool.query(
            "SELECT user_id as id, email, password_reset_expires FROM users WHERE password_reset_token = $1",
            [token]
        );
        return result.rows[0] || null;
    } catch (error) {
        log("error", "getUserByResetToken failed", { error: error.message });
        throw error;
    }
};

const getPasswordResetToken = async (userId) => {
    try {
        const result = await pool.query(
            "SELECT password_reset_token as token, password_reset_expires as expires_at FROM users WHERE user_id = $1",
            [userId]
        );
        return result.rows[0] || null;
    } catch (error) {
        log("error", "getPasswordResetToken failed", { userId, error: error.message });
        throw error;
    }
};

// ============================================

const getGroups = async () => {
    try {
        const result = await pool.query(`
            SELECT 
                group_id as id,
                name,
                contribution_amount,
                frequency,
                member_count,
                max_members,
                total_amount_collected,
                admin_id,
                status,
                created_at,
                location,
                description,
                image_url,
                category,
                meeting_schedule,
                is_demo
            FROM groups
            ORDER BY created_at DESC
        `);
        
        return result.rows;
    } catch (error) {
        log('error', 'getGroups failed', { error: error.message });
        throw error;
    }
};

const getGroupById = async (groupId) => {
    try {
        const result = await pool.query(`
            SELECT 
                group_id as id,
                name,
                contribution_amount,
                frequency,
                member_count,
                max_members,
                total_amount_collected,
                admin_id,
                status,
                created_at,
                location,
                description,
                image_url,
                category,
                meeting_schedule,
                is_demo
            FROM groups
            WHERE group_id = $1
        `, [groupId]);
        
        return result.rows.length > 0 ? result.rows[0] : null;
    } catch (error) {
        log('error', 'getGroupById failed', { groupId, error: error.message });
        throw error;
    }
};

const createGroup = async (groupData) => {
    try {
        const result = await pool.query(`
            INSERT INTO groups (
                group_id, name, contribution_amount, frequency,
                member_count, max_members, total_amount_collected,
                admin_id, status, created_at, location, description,
                image_url, category, meeting_schedule,
                is_demo, start_date, grace_period, penalty_amount
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
            RETURNING group_id as id
        `, [
            groupData.id,
            groupData.name,
            groupData.contribution_amount,
            groupData.frequency,
            groupData.member_count || 0,
            groupData.max_members || 12,
            groupData.total_amount_collected || 0,
            groupData.admin_id,
            groupData.status || 'active',
            groupData.created_at || new Date().toISOString(),
            groupData.location || null,
            groupData.description || null,
            groupData.image_url || null,
            groupData.category || null,
            groupData.meeting_schedule || null,
            groupData.is_demo || false,
            groupData.start_date || null,
            groupData.grace_period || 3,
            groupData.penalty_amount || 50
        ]);
        
        log('info', 'Group created', { groupId: result.rows[0].id });
        return result.rows[0].id;
    } catch (error) {
        log('error', 'createGroup failed', { groupData, error: error.message });
        throw error;
    }
};

const updateGroup = async (groupId, updates) => {
    try {
        const setClauses = [];
        const values = [];
        let paramIndex = 1;
        
        Object.keys(updates).forEach(key => {
            if (key === "id" || key === "updated_at") return;
            setClauses.push(key + " = $" + paramIndex);
            values.push(updates[key]);
            paramIndex++;
        });
        
        if (setClauses.length === 0) {
            log("warn", "No fields to update", { groupId });
            return null;
        }
        
        values.push(groupId);
        
        const query = "UPDATE groups SET " + setClauses.join(", ") + ", updated_at = CURRENT_TIMESTAMP WHERE group_id = $" + paramIndex + " RETURNING *";
        
        const result = await pool.query(query, values);
        
        if (result.rows.length === 0) {
            log("warn", "Group not found for update", { groupId });
            return null;
        }
        
        log("info", "Group updated", { groupId });
        return result.rows[0];
    } catch (error) {
        log("error", "updateGroup failed", { groupId, error: error.message });
        throw error;
    }
};


// ============================================
// GROUP MEMBERS OPERATIONS
// ============================================

const getGroupMembers = async (groupId) => {
    try {
        const result = await pool.query(`
            SELECT 
                gm.id,
                gm.group_id,
                gm.user_id,
                gm.role,
                gm.status,
                gm.joined_at,
                gm.left_at,
                gm.invited_by,
                gm.notes,
                COALESCE(u.name, 'Usuario') as name,
                u.email,
                u.phone,
                u.telegram_id,
                u.avatar_url
            FROM group_members gm
            LEFT JOIN users u ON gm.user_id = u.user_id
            WHERE gm.group_id = $1 AND gm.status = 'active'
            ORDER BY 
                CASE gm.role 
                    WHEN 'creator' THEN 1 
                    WHEN 'coordinator' THEN 2 
                    ELSE 3 
                END,
                gm.joined_at ASC
        `, [groupId]);
        
        log('info', 'Group members fetched', { groupId, count: result.rows.length });
        return result.rows;
    } catch (error) {
        log('error', 'getGroupMembers failed', { groupId, error: error.message });
        throw error;
    }
};

const addGroupMember = async (memberData) => {
    try {
        const { group_id, user_id, role = 'member', invited_by, notes } = memberData;
        
        const result = await pool.query(`
            INSERT INTO group_members (group_id, user_id, role, status, invited_by, notes)
            VALUES ($1, $2, $3, 'active', $4, $5)
            ON CONFLICT (group_id, user_id) DO UPDATE SET
                status = 'active',
                role = EXCLUDED.role,
                joined_at = CURRENT_TIMESTAMP
            RETURNING *
        `, [group_id, user_id, role, invited_by, notes]);
        
        log('info', 'Group member added', { group_id, user_id, role });
        return result.rows[0];
    } catch (error) {
        log('error', 'addGroupMember failed', { memberData, error: error.message });
        throw error;
    }
};

const updateGroupMember = async (groupId, userId, updates) => {
    try {
        const setClauses = [];
        const values = [];
        let paramIndex = 1;
        
        Object.keys(updates).forEach(key => {
            setClauses.push(`${key} = $${paramIndex}`);
            values.push(updates[key]);
            paramIndex++;
        });
        
        values.push(groupId, userId);
        
        const result = await pool.query(`
            UPDATE group_members 
            SET ${setClauses.join(', ')}
            WHERE group_id = $${paramIndex} AND user_id = $${paramIndex + 1}
            RETURNING *
        `, values);
        
        log('info', 'Group member updated', { groupId, userId });
        return result.rows[0];
    } catch (error) {
        log('error', 'updateGroupMember failed', { groupId, userId, error: error.message });
        throw error;
    }
};

const removeGroupMember = async (groupId, userId) => {
    try {
        const result = await pool.query(`
            UPDATE group_members 
            SET status = 'left', left_at = CURRENT_TIMESTAMP
            WHERE group_id = $1 AND user_id = $2
            RETURNING *
        `, [groupId, userId]);
        
        log('info', 'Group member removed', { groupId, userId });
        return result.rows[0];
    } catch (error) {
        log('error', 'removeGroupMember failed', { groupId, userId, error: error.message });
        throw error;
    }
};


// ============================================
// CONTRIBUTIONS/PAYMENTS OPERATIONS
// ============================================

const getGroupContributions = async (groupId, options = {}) => {
    try {
        const { status, limit = 50, offset = 0 } = options;
        let query = `
            SELECT 
                c.id,
                c.user_id,
                c.group_id,
                c.amount,
                c.payment_method,
                c.status,
                c.transaction_id,
                c.confirmation_code,
                c.notes,
                c.due_date,
                c.paid_date,
                c.cycle_number,
                c.created_at,
                COALESCE(u.name, 'Usuario') as user_name,
                u.email as user_email,
                u.avatar_url as user_avatar
            FROM contributions c
            LEFT JOIN users u ON c.user_id = u.user_id
            WHERE c.group_id = $1
        `;
        
        const params = [groupId];
        let paramIndex = 2;
        
        if (status) {
            query += ` AND c.status = $${paramIndex}`;
            params.push(status);
            paramIndex++;
        }
        
        query += ` ORDER BY c.created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
        params.push(limit, offset);
        
        const result = await pool.query(query, params);
        
        // Get totals
        const totalsQuery = `
            SELECT 
                COUNT(*) as total_count,
                COALESCE(SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END), 0) as total_completed,
                COALESCE(SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END), 0) as total_pending,
                COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_count,
                COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_count
            FROM contributions
            WHERE group_id = $1
        `;
        const totalsResult = await pool.query(totalsQuery, [groupId]);
        
        log('info', 'Group contributions fetched', { groupId, count: result.rows.length });
        return {
            contributions: result.rows,
            totals: totalsResult.rows[0]
        };
    } catch (error) {
        log('error', 'getGroupContributions failed', { groupId, error: error.message });
        throw error;
    }
};

const createContribution = async (contributionData) => {
    try {
        const {
            user_id,
            group_id,
            amount,
            payment_method,
            status = 'pending',
            transaction_id,
            confirmation_code,
            notes,
            due_date,
            cycle_number = 1
        } = contributionData;
        
        const result = await pool.query(`
            INSERT INTO contributions (
                user_id, group_id, amount, payment_method, status,
                transaction_id, confirmation_code, notes, due_date, cycle_number
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
            RETURNING *
        `, [user_id, group_id, amount, payment_method, status, transaction_id, confirmation_code, notes, due_date, cycle_number]);
        
        log('info', 'Contribution created', { id: result.rows[0].id, group_id, user_id, amount });
        return result.rows[0];
    } catch (error) {
        log('error', 'createContribution failed', { contributionData, error: error.message });
        throw error;
    }
};

const updateContribution = async (contributionId, updates) => {
    try {
        const setClauses = [];
        const values = [];
        let paramIndex = 1;
        
        Object.keys(updates).forEach(key => {
            if (key === 'id') return;
            setClauses.push(`${key} = $${paramIndex}`);
            values.push(updates[key]);
            paramIndex++;
        });
        
        values.push(contributionId);
        
        const result = await pool.query(`
            UPDATE contributions 
            SET ${setClauses.join(', ')}, updated_at = NOW()
            WHERE id = $${paramIndex}
            RETURNING *
        `, values);
        
        log('info', 'Contribution updated', { contributionId });
        return result.rows[0];
    } catch (error) {
        log('error', 'updateContribution failed', { contributionId, error: error.message });
        throw error;
    }
};


// ============================================
// GROUP INVITATIONS OPERATIONS
// ============================================

const createGroupInvitation = async (invitationData) => {
    try {
        const { group_id, inviter_id, invitee_email, invitee_phone, invitee_name, message } = invitationData;
        
        const result = await pool.query(`
            INSERT INTO group_invitations (group_id, inviter_id, invitee_email, invitee_phone, invitee_name, message)
            VALUES ($1, $2, $3, $4, $5, $6)
            RETURNING *
        `, [group_id, inviter_id, invitee_email, invitee_phone, invitee_name, message]);
        
        log('info', 'Group invitation created', { id: result.rows[0].id, group_id });
        return result.rows[0];
    } catch (error) {
        log('error', 'createGroupInvitation failed', { error: error.message });
        throw error;
    }
};

const getGroupInvitations = async (groupId, status = null) => {
    try {
        let query = `
            SELECT 
                gi.*,
                COALESCE(u.name, 'Usuario') as inviter_name,
                g.name as group_name
            FROM group_invitations gi
            LEFT JOIN users u ON gi.inviter_id = u.user_id
            LEFT JOIN groups g ON gi.group_id = g.group_id
            WHERE gi.group_id = $1
        `;
        const params = [groupId];
        
        if (status) {
            query += ' AND gi.status = $2';
            params.push(status);
        }
        
        query += ' ORDER BY gi.created_at DESC';
        
        const result = await pool.query(query, params);
        log('info', 'Group invitations fetched', { groupId, count: result.rows.length });
        return result.rows;
    } catch (error) {
        log('error', 'getGroupInvitations failed', { groupId, error: error.message });
        throw error;
    }
};

const getInvitationByToken = async (token) => {
    try {
        const result = await pool.query(`
            SELECT 
                gi.*,
                g.name as group_name,
                g.contribution_amount,
                g.frequency,
                COALESCE(u.name, 'Usuario') as inviter_name
            FROM group_invitations gi
            LEFT JOIN groups g ON gi.group_id = g.group_id
            LEFT JOIN users u ON gi.inviter_id = u.user_id
            WHERE gi.token = $1
        `, [token]);
        
        return result.rows[0] || null;
    } catch (error) {
        log('error', 'getInvitationByToken failed', { error: error.message });
        throw error;
    }
};

const updateInvitationStatus = async (invitationId, status) => {
    try {
        const result = await pool.query(`
            UPDATE group_invitations 
            SET status = $1, responded_at = CURRENT_TIMESTAMP
            WHERE id = $2
            RETURNING *
        `, [status, invitationId]);
        
        log('info', 'Invitation status updated', { invitationId, status });
        return result.rows[0];
    } catch (error) {
        log('error', 'updateInvitationStatus failed', { error: error.message });
        throw error;
    }
};


// ============================================
// EXPORT MODULE
// ============================================

// ========== TANDAS FUNCTIONS ==========

const getTandas = async () => {
    try {
        const result = await pool.query(`
            SELECT 
                tanda_id as id,
                name,
                contribution_amount,
                total_per_turn,
                frequency,
                coordinator_id,
                group_id,
                status,
                current_turn,
                total_turns,
                turns_order,
                created_at,
                updated_at,
                completed_at,
                is_demo
            FROM tandas t LEFT JOIN users u ON t.coordinator_id = u.user_id
            ORDER BY created_at DESC
        `);
        return result.rows;
    } catch (error) {
        log('error', 'getTandas failed', { error: error.message });
        throw error;
    }
};

const getTandasByUser = async (userId) => {
    try {
        const result = await pool.query(`
            SELECT
                t.tanda_id as id,
                t.name,
                t.contribution_amount,
                t.total_per_turn,
                t.frequency,
                t.coordinator_id,
                t.group_id,
                t.status,
                t.current_turn,
                t.total_turns,
                t.turns_order,
                t.created_at,
                t.is_demo,
                u.name as coordinator_name,
                g.member_count as group_member_count
            FROM tandas t
            LEFT JOIN users u ON t.coordinator_id = u.user_id
            LEFT JOIN groups g ON t.group_id = g.group_id
            WHERE $1 = ANY(t.turns_order) OR t.coordinator_id = $1 OR (t.status IN ('recruiting', 'pending') AND t.group_id IN (SELECT group_id FROM group_members WHERE user_id = $1))
            ORDER BY t.created_at DESC
        `, [userId]);
        return result.rows;
    } catch (error) {
        log('error', 'getTandasByUser failed', { error: error.message });
        throw error;
    }
};

const getTandaById = async (tandaId) => {
    try {
        const result = await pool.query(`
            SELECT * FROM tandas t LEFT JOIN users u ON t.coordinator_id = u.user_id WHERE tanda_id = $1
        `, [tandaId]);
        return result.rows[0] || null;
    } catch (error) {
        log('error', 'getTandaById failed', { error: error.message });
        throw error;
    }
};

const createTanda = async (tandaData) => {
    try {
        const result = await pool.query(`
            INSERT INTO tandas (
                tanda_id, name, contribution_amount, total_per_turn, frequency,
                coordinator_id, group_id, status, current_turn, total_turns,
                turns_order, is_demo
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
            RETURNING *
        `, [
            tandaData.id || 'tanda_' + Date.now(),
            tandaData.name,
            tandaData.contribution_amount || 100,
            tandaData.total_per_turn || (tandaData.contribution_amount * (tandaData.turns_order?.length || 1)),
            tandaData.frequency || 'monthly',
            tandaData.coordinator_id,
            tandaData.group_id || null,
            tandaData.status || 'active',
            tandaData.current_turn !== undefined ? tandaData.current_turn : 1,
            tandaData.total_turns || tandaData.turns_order?.length || 0,
            tandaData.turns_order || [],
            tandaData.is_demo || false
        ]);
        return result.rows[0];
    } catch (error) {
        log('error', 'createTanda failed', { error: error.message });
        throw error;
    }
};

// ============================================
// EMAIL VERIFICATION FUNCTIONS
// ============================================

const setEmailVerificationCode = async (userId, code, expiresAt) => {
    try {
        await pool.query(
            `UPDATE users SET email_verification_code = $1, email_verification_expires = $2, updated_at = CURRENT_TIMESTAMP WHERE user_id = $3`,
            [code, expiresAt, userId]
        );
        log("info", "Email verification code set", { userId });
    } catch (error) {
        log("error", "setEmailVerificationCode failed", { userId, error: error.message });
        throw error;
    }
};

const verifyEmailCode = async (userId, code) => {
    try {
        const result = await pool.query(
            `SELECT email_verification_code, email_verification_expires FROM users WHERE user_id = $1`,
            [userId]
        );
        
        if (!result.rows[0]) {
            return { valid: false, reason: "Usuario no encontrado" };
        }
        
        const user = result.rows[0];
        
        if (!user.email_verification_code) {
            return { valid: false, reason: "No hay c贸digo de verificaci贸n pendiente" };
        }
        
        if (new Date() > new Date(user.email_verification_expires)) {
            return { valid: false, reason: "El c贸digo ha expirado" };
        }
        
        if (user.email_verification_code !== code) {
            return { valid: false, reason: "C贸digo incorrecto" };
        }
        
        // Mark email as verified
        await pool.query(
            `UPDATE users SET email_verified = TRUE, email_verification_code = NULL, email_verification_expires = NULL, updated_at = CURRENT_TIMESTAMP WHERE user_id = $1`,
            [userId]
        );
        
        log("info", "Email verified successfully", { userId });
        return { valid: true };
    } catch (error) {
        log("error", "verifyEmailCode failed", { userId, error: error.message });
        throw error;
    }
};

module.exports = {
    // Invitation operations
    createGroupInvitation,
    getGroupInvitations,
    getInvitationByToken,
    updateInvitationStatus,

    // Contribution operations
    getGroupContributions,
    createContribution,
    updateContribution,

    // Group members operations
    getGroupMembers,
    addGroupMember,
    updateGroupMember,
    removeGroupMember,

    pool,
    
    // User operations
    getUsers,
    getUserById,
    createUser,
    updateUser,
    getUserByEmail,
    updateUserPassword,
    setPasswordResetToken,
    getPasswordResetToken,
    getUserByResetToken,
    
    // Email verification
    setEmailVerificationCode,
    verifyEmailCode,
    
    // Group operations
    getGroups,
    getGroupById,
    createGroup,
    updateGroup,
    
    // Tanda operations
    getTandas,
    getTandasByUser,
    getTandaById,
    createTanda,
    
    // Utility
    log
};
